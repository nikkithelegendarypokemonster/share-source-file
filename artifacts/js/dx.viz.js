/*!
* DevExtreme (dx.viz.js)
* Version: 24.2.0
* Build date: Fri Aug 30 2024
*
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
*/
"use strict";

/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 41139:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfernoWrapperComponent = exports.InfernoComponent = exports.BaseInfernoComponent = void 0;
var inferno_1 = __webpack_require__(78089);
var effect_host_1 = __webpack_require__(82819);
var areObjectsEqual = function (firstObject, secondObject) {
    var bothAreObjects = firstObject instanceof Object && secondObject instanceof Object;
    if (!bothAreObjects) {
        return firstObject === secondObject;
    }
    var firstObjectKeys = Object.keys(firstObject);
    var secondObjectKeys = Object.keys(secondObject);
    if (firstObjectKeys.length !== secondObjectKeys.length) {
        return false;
    }
    var hasDifferentElement = firstObjectKeys.some(function (key) { return firstObject[key] !== secondObject[key]; });
    return !hasDifferentElement;
};
var BaseInfernoComponent = /** @class */ (function (_super) {
    __extends(BaseInfernoComponent, _super);
    function BaseInfernoComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._pendingContext = _this.context;
        return _this;
    }
    BaseInfernoComponent.prototype.componentWillReceiveProps = function (_, context) {
        this._pendingContext = context !== null && context !== void 0 ? context : {};
    };
    BaseInfernoComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        return (!areObjectsEqual(this.props, nextProps)
            || !areObjectsEqual(this.state, nextState)
            || !areObjectsEqual(this.context, this._pendingContext));
    };
    return BaseInfernoComponent;
}(inferno_1.Component));
exports.BaseInfernoComponent = BaseInfernoComponent;
var InfernoComponent = /** @class */ (function (_super) {
    __extends(InfernoComponent, _super);
    function InfernoComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._effects = [];
        return _this;
    }
    InfernoComponent.prototype.createEffects = function () {
        return [];
    };
    InfernoComponent.prototype.updateEffects = function () { };
    InfernoComponent.prototype.componentWillMount = function () {
        effect_host_1.InfernoEffectHost.lock();
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    InfernoComponent.prototype.componentWillUpdate = function (_nextProps, _nextState, _context) {
        effect_host_1.InfernoEffectHost.lock();
    };
    InfernoComponent.prototype.componentDidMount = function () {
        var _this = this;
        effect_host_1.InfernoEffectHost.callbacks.push(function () { _this._effects = _this.createEffects(); });
        effect_host_1.InfernoEffectHost.callEffects();
    };
    InfernoComponent.prototype.componentDidUpdate = function () {
        var _this = this;
        effect_host_1.InfernoEffectHost.callbacks.push(function () { return _this.updateEffects(); });
        effect_host_1.InfernoEffectHost.callEffects();
    };
    InfernoComponent.prototype.destroyEffects = function () {
        this._effects.forEach(function (e) { return e.dispose(); });
    };
    InfernoComponent.prototype.componentWillUnmount = function () {
        this.destroyEffects();
    };
    return InfernoComponent;
}(BaseInfernoComponent));
exports.InfernoComponent = InfernoComponent;
var InfernoWrapperComponent = /** @class */ (function (_super) {
    __extends(InfernoWrapperComponent, _super);
    function InfernoWrapperComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vDomElement = null;
        return _this;
    }
    InfernoWrapperComponent.prototype.vDomUpdateClasses = function () {
        var el = this.vDomElement;
        var currentClasses = el.className.length
            ? el.className.split(' ')
            : [];
        var addedClasses = currentClasses.filter(function (className) { return el.dxClasses.previous.indexOf(className) < 0; });
        var removedClasses = el.dxClasses.previous.filter(function (className) { return currentClasses.indexOf(className) < 0; });
        addedClasses.forEach(function (value) {
            var indexInRemoved = el.dxClasses.removed.indexOf(value);
            if (indexInRemoved > -1) {
                el.dxClasses.removed.splice(indexInRemoved, 1);
            }
            else if (!el.dxClasses.added.includes(value)) {
                el.dxClasses.added.push(value);
            }
        });
        removedClasses.forEach(function (value) {
            var indexInAdded = el.dxClasses.added.indexOf(value);
            if (indexInAdded > -1) {
                el.dxClasses.added.splice(indexInAdded, 1);
            }
            else if (!el.dxClasses.removed.includes(value)) {
                el.dxClasses.removed.push(value);
            }
        });
    };
    InfernoWrapperComponent.prototype.componentDidMount = function () {
        var el = inferno_1.findDOMfromVNode(this.$LI, true);
        this.vDomElement = el;
        _super.prototype.componentDidMount.call(this);
        el.dxClasses = el.dxClasses || {
            removed: [], added: [], previous: [],
        };
        el.dxClasses.previous = (el === null || el === void 0 ? void 0 : el.className.length)
            ? el.className.split(' ')
            : [];
    };
    InfernoWrapperComponent.prototype.componentDidUpdate = function () {
        _super.prototype.componentDidUpdate.call(this);
        var el = this.vDomElement;
        if (el !== null) {
            el.dxClasses.added.forEach(function (className) { return el.classList.add(className); });
            el.dxClasses.removed.forEach(function (className) { return el.classList.remove(className); });
            el.dxClasses.previous = el.className.length
                ? el.className.split(' ')
                : [];
        }
    };
    InfernoWrapperComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var shouldUpdate = _super.prototype.shouldComponentUpdate.call(this, nextProps, nextState);
        if (shouldUpdate) {
            this.vDomUpdateClasses();
        }
        return shouldUpdate;
    };
    return InfernoWrapperComponent;
}(InfernoComponent));
exports.InfernoWrapperComponent = InfernoWrapperComponent;


/***/ }),

/***/ 16797:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createContext = void 0;
var inferno_1 = __webpack_require__(78089);
var contextId = 0;
var createContext = function (defaultValue) {
    var id = contextId++;
    return {
        id: id,
        defaultValue: defaultValue,
        Provider: /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.getChildContext = function () {
                var _a;
                return __assign(__assign({}, this.context), (_a = {}, _a[id] = this.props.value || defaultValue, _a));
            };
            class_1.prototype.render = function () {
                return this.props.children;
            };
            return class_1;
        }(inferno_1.Component)),
    };
};
exports.createContext = createContext;


/***/ }),

/***/ 84491:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfernoEffect = void 0;
var InfernoEffect = /** @class */ (function () {
    function InfernoEffect(effect, dependency) {
        this.dependency = dependency;
        this.effect = effect;
        this.destroy = effect();
    }
    InfernoEffect.prototype.update = function (dependency) {
        var currentDependency = this.dependency;
        if (dependency) {
            this.dependency = dependency;
        }
        if (!dependency || dependency.some(function (d, i) { return currentDependency[i] !== d; })) {
            this.dispose();
            this.destroy = this.effect();
        }
    };
    InfernoEffect.prototype.dispose = function () {
        if (this.destroy) {
            this.destroy();
        }
    };
    return InfernoEffect;
}());
exports.InfernoEffect = InfernoEffect;


/***/ }),

/***/ 82819:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfernoEffectHost = void 0;
exports.InfernoEffectHost = {
    lockCount: 0,
    lock: function () {
        this.lockCount++;
    },
    callbacks: [],
    callEffects: function () {
        this.lockCount--;
        if (this.lockCount < 0) {
            throw new Error('Unexpected Effect Call');
        }
        if (this.lockCount === 0) {
            var effects = this.callbacks;
            this.callbacks = [];
            effects.forEach(function (callback) { return callback(); });
        }
    },
};


/***/ }),

/***/ 33791:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(41139), exports);
__exportStar(__webpack_require__(16797), exports);
__exportStar(__webpack_require__(84491), exports);
__exportStar(__webpack_require__(82819), exports);
__exportStar(__webpack_require__(74564), exports);
__exportStar(__webpack_require__(28879), exports);
__exportStar(__webpack_require__(12105), exports);
__exportStar(__webpack_require__(3236), exports);
__exportStar(__webpack_require__(1796), exports);
__exportStar(__webpack_require__(56526), exports);


/***/ }),

/***/ 3236:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hydrate = void 0;
var inferno_1 = __webpack_require__(78089);
var shared_1 = __webpack_require__(99489);
function isSameInnerHTML(dom, innerHTML) {
    var tempdom = document.createElement('i');
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
}
function findLastDOMFromVNode(vNode) {
    var flags;
    var children;
    while (vNode) {
        flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            return vNode.dom;
        }
        children = vNode.children;
        if (flags & 8192 /* Fragment */) {
            vNode = vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[children.length - 1];
        }
        else if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        else {
            vNode = children;
        }
    }
    return null;
}
function isSamePropsInnerHTML(dom, props) {
    return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML(dom, props.dangerouslySetInnerHTML.__html));
}
function hydrateComponent(vNode, parentDOM, dom, context, isSVG, isClass, lifecycle) {
    var type = vNode.type;
    var ref = vNode.ref;
    var props = vNode.props || inferno_1.EMPTY_OBJ;
    var currentNode;
    if (isClass) {
        var instance = inferno_1._CI(vNode, type, props, context, isSVG, lifecycle);
        var input = instance.$LI;
        currentNode = hydrateVNode(input, parentDOM, dom, instance.$CX, isSVG, lifecycle);
        inferno_1._MCCC(ref, instance, lifecycle);
    }
    else {
        var input = inferno_1._HI(inferno_1._RFC(vNode, context));
        currentNode = hydrateVNode(input, parentDOM, dom, context, isSVG, lifecycle);
        vNode.children = input;
        inferno_1._MFCC(vNode, lifecycle);
    }
    return currentNode;
}
function hydrateChildren(parentVNode, parentNode, currentNode, context, isSVG, lifecycle) {
    var childFlags = parentVNode.childFlags;
    var children = parentVNode.children;
    var props = parentVNode.props;
    var flags = parentVNode.flags;
    if (childFlags !== 1 /* HasInvalidChildren */) {
        if (childFlags === 2 /* HasVNodeChildren */) {
            if (shared_1.isNull(currentNode)) {
                inferno_1._M(children, parentNode, context, isSVG, null, lifecycle);
            }
            else {
                currentNode = hydrateVNode(children, parentNode, currentNode, context, isSVG, lifecycle);
                currentNode = currentNode ? currentNode.nextSibling : null;
            }
        }
        else if (childFlags === 16 /* HasTextChildren */) {
            if (shared_1.isNull(currentNode)) {
                parentNode.appendChild(document.createTextNode(children));
            }
            else if (parentNode.childNodes.length !== 1 || currentNode.nodeType !== 3) {
                parentNode.textContent = children;
            }
            else if (currentNode.nodeValue !== children) {
                currentNode.nodeValue = children;
            }
            currentNode = null;
        }
        else if (childFlags & 12 /* MultipleChildren */) {
            var prevVNodeIsTextNode = false;
            for (var i = 0, len = children.length; i < len; ++i) {
                var child = children[i];
                if (shared_1.isNull(currentNode) || (prevVNodeIsTextNode && (child.flags & 16 /* Text */) > 0)) {
                    inferno_1._M(child, parentNode, context, isSVG, currentNode, lifecycle);
                }
                else {
                    currentNode = hydrateVNode(child, parentNode, currentNode, context, isSVG, lifecycle);
                    currentNode = currentNode ? currentNode.nextSibling : null;
                }
                prevVNodeIsTextNode = (child.flags & 16 /* Text */) > 0;
            }
        }
        // clear any other DOM nodes, there should be only a single entry for the root
        if ((flags & 8192 /* Fragment */) === 0) {
            var nextSibling = null;
            while (currentNode) {
                nextSibling = currentNode.nextSibling;
                parentNode.removeChild(currentNode);
                currentNode = nextSibling;
            }
        }
    }
    else if (!shared_1.isNull(parentNode.firstChild) && !isSamePropsInnerHTML(parentNode, props)) {
        parentNode.textContent = ''; // dom has content, but VNode has no children remove everything from DOM
        if (flags & 448 /* FormElement */) {
            // If element is form element, we need to clear defaultValue also
            parentNode.defaultValue = '';
        }
    }
}
function hydrateElement(vNode, parentDOM, dom, context, isSVG, lifecycle) {
    var props = vNode.props;
    var className = vNode.className;
    var flags = vNode.flags;
    var ref = vNode.ref;
    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;
    if (dom.nodeType !== 1) {
        inferno_1._ME(vNode, null, context, isSVG, null, lifecycle);
        parentDOM.replaceChild(vNode.dom, dom);
    }
    else {
        vNode.dom = dom;
        hydrateChildren(vNode, dom, dom.firstChild, context, isSVG, lifecycle);
        if (!shared_1.isNull(props)) {
            inferno_1._MP(vNode, flags, props, dom, isSVG);
        }
        if (shared_1.isNullOrUndef(className)) {
            if (dom.className !== '') {
                dom.removeAttribute('class');
            }
        }
        else if (isSVG) {
            dom.setAttribute('class', className);
        }
        else {
            dom.className = className;
        }
        inferno_1._MR(ref, dom, lifecycle);
    }
    return vNode.dom;
}
function hydrateText(vNode, parentDOM, dom) {
    if (dom.nodeType !== 3) {
        parentDOM.replaceChild((vNode.dom = document.createTextNode(vNode.children)), dom);
    }
    else {
        var text = vNode.children;
        if (dom.nodeValue !== text) {
            dom.nodeValue = text;
        }
        vNode.dom = dom;
    }
    return vNode.dom;
}
function hydrateFragment(vNode, parentDOM, dom, context, isSVG, lifecycle) {
    var children = vNode.children;
    if (vNode.childFlags === 2 /* HasVNodeChildren */) {
        hydrateText(children, parentDOM, dom);
        return children.dom;
    }
    hydrateChildren(vNode, parentDOM, dom, context, isSVG, lifecycle);
    return findLastDOMFromVNode(children[children.length - 1]);
}
function hydrateVNode(vNode, parentDOM, currentDom, context, isSVG, lifecycle) {
    var flags = (vNode.flags |= 16384 /* InUse */);
    if (flags & 14 /* Component */) {
        return hydrateComponent(vNode, parentDOM, currentDom, context, isSVG, (flags & 4 /* ComponentClass */) > 0, lifecycle);
    }
    if (flags & 481 /* Element */) {
        return hydrateElement(vNode, parentDOM, currentDom, context, isSVG, lifecycle);
    }
    if (flags & 16 /* Text */) {
        return hydrateText(vNode, parentDOM, currentDom);
    }
    if (flags & 512 /* Void */) {
        return (vNode.dom = currentDom);
    }
    if (flags & 8192 /* Fragment */) {
        return hydrateFragment(vNode, parentDOM, currentDom, context, isSVG, lifecycle);
    }
    shared_1.throwError();
    return null;
}
function hydrate(input, parentDOM, callback) {
    var dom = parentDOM.firstChild;
    if (shared_1.isNull(dom)) {
        inferno_1.render(input, parentDOM, callback);
    }
    else {
        var lifecycle = [];
        if (!shared_1.isInvalid(input)) {
            dom = hydrateVNode(input, parentDOM, dom, {}, false, lifecycle);
        }
        // clear any other DOM nodes, there should be only a single entry for the root
        while (dom && (dom = dom.nextSibling)) {
            parentDOM.removeChild(dom);
        }
        if (lifecycle.length > 0) {
            var listener = void 0;
            while ((listener = lifecycle.shift()) !== undefined) {
                listener();
            }
        }
    }
    parentDOM.$V = input;
    if (shared_1.isFunction(callback)) {
        callback();
    }
}
exports.hydrate = hydrate;


/***/ }),

/***/ 99489:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.throwError = exports.isNull = exports.isFunction = exports.isInvalid = exports.isNullOrUndef = exports.ERROR_MSG = void 0;
exports.ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';
function isNullOrUndef(o) {
    return o === void 0 || o === null;
}
exports.isNullOrUndef = isNullOrUndef;
function isInvalid(o) {
    return o === null || o === false || o === true || o === void 0;
}
exports.isInvalid = isInvalid;
function isFunction(o) {
    return typeof o === 'function';
}
exports.isFunction = isFunction;
function isNull(o) {
    return o === null;
}
exports.isNull = isNull;
function throwError(message) {
    if (!message) {
        message = exports.ERROR_MSG;
    }
    throw new Error("Inferno Error: " + message);
}
exports.throwError = throwError;


/***/ }),

/***/ 56526:
/***/ (function(__unused_webpack_module, exports) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeStyles = void 0;
var NUMBER_STYLES = new Set([
    'animationIterationCount',
    'borderImageOutset',
    'borderImageSlice',
    'border-imageWidth',
    'boxFlex',
    'boxFlexGroup',
    'boxOrdinalGroup',
    'columnCount',
    'fillOpacity',
    'flex',
    'flexGrow',
    'flexNegative',
    'flexOrder',
    'flexPositive',
    'flexShrink',
    'floodOpacity',
    'fontWeight',
    'gridColumn',
    'gridRow',
    'lineClamp',
    'lineHeight',
    'opacity',
    'order',
    'orphans',
    'stopOpacity',
    'strokeDasharray',
    'strokeDashoffset',
    'strokeMiterlimit',
    'strokeOpacity',
    'strokeWidth',
    'tabSize',
    'widows',
    'zIndex',
    'zoom',
]);
var isNumeric = function (value) {
    if (typeof value === 'number')
        return true;
    return !Number.isNaN(Number(value));
};
var getNumberStyleValue = function (style, value) { return (NUMBER_STYLES.has(style) ? value : value + "px"); };
var uppercasePattern = /[A-Z]/g;
var kebabCase = function (str) { return str.replace(uppercasePattern, '-$&').toLowerCase(); };
function normalizeStyles(styles) {
    if (!(styles instanceof Object)) {
        return undefined;
    }
    return Object
        .entries(styles)
        .reduce(function (acc, _a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        acc[kebabCase(key)] = isNumeric(value)
            ? getNumberStyleValue(key, value)
            : value;
        return acc;
    }, {});
}
exports.normalizeStyles = normalizeStyles;


/***/ }),

/***/ 74564:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Portal = void 0;
var inferno_1 = __webpack_require__(78089);
var Portal = function (_a) {
    var container = _a.container, children = _a.children;
    if (container) {
        return inferno_1.createPortal(children, container);
    }
    return null;
};
exports.Portal = Portal;


/***/ }),

/***/ 12105:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReRenderEffect = void 0;
var inferno_1 = __webpack_require__(78089);
var effect_1 = __webpack_require__(84491);
var createReRenderEffect = function () { return new effect_1.InfernoEffect(function () {
    inferno_1.rerender();
}, []); };
exports.createReRenderEffect = createReRenderEffect;


/***/ }),

/***/ 28879:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 1796:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasTemplate = exports.renderTemplate = void 0;
var inferno_1 = __webpack_require__(78089);
var inferno_create_element_1 = __webpack_require__(50477);
var getContainer = function (props) { var _a, _b; return ((_a = props.container) === null || _a === void 0 ? void 0 : _a.get(0)) || ((_b = props.item) === null || _b === void 0 ? void 0 : _b.get(0)); };
function renderTemplate(template, props, _component) {
    setTimeout(function () {
        inferno_1.render(inferno_create_element_1.createElement(template, props), getContainer(props));
    }, 0);
}
exports.renderTemplate = renderTemplate;
var hasTemplate = function (name, properties, _component) {
    var value = properties[name];
    return !!value && typeof value !== 'string';
};
exports.hasTemplate = hasTemplate;


/***/ }),

/***/ 50477:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createElement": function() { return /* binding */ createElement; }
/* harmony export */ });
/* harmony import */ var inferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78089);


function isNullOrUndef(o) {
    return o === void 0 || o === null;
}
function isString(o) {
    return typeof o === 'string';
}
function isUndefined(o) {
    return o === void 0;
}

var componentHooks = {
    onComponentDidMount: 1,
    onComponentDidUpdate: 1,
    onComponentShouldUpdate: 1,
    onComponentWillMount: 1,
    onComponentWillUnmount: 1,
    onComponentWillUpdate: 1
};
function createElement(type, props, _children) {
    var arguments$1 = arguments;
    var children;
    var ref = null;
    var key = null;
    var className = null;
    var flags = 0;
    var newProps;
    var childLen = arguments.length - 2;
    if (childLen === 1) {
        children = _children;
    }
    else if (childLen > 1) {
        children = [];
        while (childLen-- > 0) {
            children[childLen] = arguments$1[childLen + 2];
        }
    }
    if (isString(type)) {
        flags = (0,inferno__WEBPACK_IMPORTED_MODULE_0__.getFlagsForElementVnode)(type);
        if (!isNullOrUndef(props)) {
            newProps = {};
            for (var prop in props) {
                if (prop === 'className' || prop === 'class') {
                    className = props[prop];
                }
                else if (prop === 'key') {
                    key = props.key;
                }
                else if (prop === 'children' && isUndefined(children)) {
                    children = props.children; // always favour children args over props
                }
                else if (prop === 'ref') {
                    ref = props.ref;
                }
                else {
                    if (prop === 'contenteditable') {
                        flags |= 4096 /* ContentEditable */;
                    }
                    newProps[prop] = props[prop];
                }
            }
        }
    }
    else {
        flags = 2 /* ComponentUnknown */;
        if (!isUndefined(children)) {
            if (!props) {
                props = {};
            }
            props.children = children;
        }
        if (!isNullOrUndef(props)) {
            newProps = {};
            for (var prop$1 in props) {
                if (prop$1 === 'key') {
                    key = props.key;
                }
                else if (prop$1 === 'ref') {
                    ref = props.ref;
                }
                else if (componentHooks[prop$1] === 1) {
                    if (!ref) {
                        ref = {};
                    }
                    ref[prop$1] = props[prop$1];
                }
                else {
                    newProps[prop$1] = props[prop$1];
                }
            }
        }
        return (0,inferno__WEBPACK_IMPORTED_MODULE_0__.createComponentVNode)(flags, type, newProps, key, ref);
    }
    if (flags & 8192 /* Fragment */) {
        return (0,inferno__WEBPACK_IMPORTED_MODULE_0__.createFragment)(childLen === 1 ? [children] : children, 0 /* UnknownChildren */, key);
    }
    return (0,inferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(flags, type, className, children, 0 /* UnknownChildren */, newProps, key, ref);
}




/***/ }),

/***/ 78089:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Component": function() { return /* reexport */ Component; },
  "EMPTY_OBJ": function() { return /* reexport */ EMPTY_OBJ; },
  "Fragment": function() { return /* reexport */ Fragment; },
  "_CI": function() { return /* reexport */ createClassComponentInstance; },
  "_HI": function() { return /* reexport */ normalizeRoot; },
  "_M": function() { return /* reexport */ mount; },
  "_MCCC": function() { return /* reexport */ mountClassComponentCallbacks; },
  "_ME": function() { return /* reexport */ mountElement; },
  "_MFCC": function() { return /* reexport */ mountFunctionalComponentCallbacks; },
  "_MP": function() { return /* reexport */ mountProps; },
  "_MR": function() { return /* reexport */ mountRef; },
  "_RFC": function() { return /* reexport */ renderFunctionalComponent; },
  "__render": function() { return /* reexport */ __render; },
  "createComponentVNode": function() { return /* reexport */ createComponentVNode; },
  "createFragment": function() { return /* reexport */ createFragment; },
  "createPortal": function() { return /* reexport */ createPortal; },
  "createRef": function() { return /* reexport */ createRef; },
  "createRenderer": function() { return /* reexport */ createRenderer; },
  "createTextVNode": function() { return /* reexport */ createTextVNode; },
  "createVNode": function() { return /* reexport */ createVNode; },
  "directClone": function() { return /* reexport */ directClone; },
  "findDOMfromVNode": function() { return /* reexport */ findDOMfromVNode; },
  "forwardRef": function() { return /* reexport */ forwardRef; },
  "getFlagsForElementVnode": function() { return /* reexport */ getFlagsForElementVnode; },
  "linkEvent": function() { return /* reexport */ linkEvent; },
  "normalizeProps": function() { return /* reexport */ normalizeProps; },
  "options": function() { return /* reexport */ options; },
  "render": function() { return /* reexport */ render; },
  "rerender": function() { return /* reexport */ rerender; },
  "version": function() { return /* reexport */ version; }
});

;// CONCATENATED MODULE: ../../node_modules/.pnpm/inferno@7.4.11/node_modules/inferno/dist/index.esm.js
var isArray = Array.isArray;
function isStringOrNumber(o) {
    var type = typeof o;
    return type === 'string' || type === 'number';
}
function isNullOrUndef(o) {
    return o === void 0 || o === null;
}
function isInvalid(o) {
    return o === null || o === false || o === true || o === void 0;
}
function isFunction(o) {
    return typeof o === 'function';
}
function isString(o) {
    return typeof o === 'string';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isNull(o) {
    return o === null;
}
function isUndefined(o) {
    return o === void 0;
}
function combineFrom(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}

/**
 * Links given data to event as first parameter
 * @param {*} data data to be linked, it will be available in function as first parameter
 * @param {Function} event Function to be called when event occurs
 * @returns {{data: *, event: Function}}
 */
function linkEvent(data, event) {
    if (isFunction(event)) {
        return { data: data, event: event };
    }
    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers
}
// object.event should always be function, otherwise its badly created object.
function isLinkEventObject(o) {
    return !isNull(o) && typeof o === 'object';
}

// We need EMPTY_OBJ defined in one place.
// Its used for comparison so we cant inline it into shared
var EMPTY_OBJ = {};
var Fragment = '$F';
function normalizeEventName(name) {
    return name.substr(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
    parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
    if (isNull(nextNode)) {
        appendChild(parentDOM, newNode);
    }
    else {
        parentDOM.insertBefore(newNode, nextNode);
    }
}
function documentCreateElement(tag, isSVG) {
    if (isSVG) {
        return document.createElementNS('http://www.w3.org/2000/svg', tag);
    }
    return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
    parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
    parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
    for (var i = 0; i < arrayFn.length; i++) {
        arrayFn[i]();
    }
}
function findChildVNode(vNode, startEdge, flags) {
    var children = vNode.children;
    if (flags & 4 /* ComponentClass */) {
        return children.$LI;
    }
    if (flags & 8192 /* Fragment */) {
        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];
    }
    return children;
}
function findDOMfromVNode(vNode, startEdge) {
    var flags;
    while (vNode) {
        flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            return vNode.dom;
        }
        vNode = findChildVNode(vNode, startEdge, flags);
    }
    return null;
}
function removeVNodeDOM(vNode, parentDOM) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            removeChild(parentDOM, vNode.dom);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    removeVNodeDOM(children[i], parentDOM);
                }
                return;
            }
        }
    } while (vNode);
}
function moveVNodeDOM(vNode, parentDOM, nextNode) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            insertOrAppend(parentDOM, vNode.dom, nextNode);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    moveVNodeDOM(children[i], parentDOM, nextNode);
                }
                return;
            }
        }
    } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
    if (instance.constructor.getDerivedStateFromProps) {
        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
    }
    return state;
}
var renderCheck = {
    v: false
};
var options = {
    componentComparator: null,
    createVNode: null,
    renderComplete: null
};
function setTextContent(dom, children) {
    dom.textContent = children;
}
// Calling this function assumes, nextValue is linkEvent
function isLastValueSameLinkEvent(lastValue, nextValue) {
    return (isLinkEventObject(lastValue) &&
        lastValue.event === nextValue.event &&
        lastValue.data === nextValue.data);
}
function mergeUnsetProperties(to, from) {
    for (var propName in from) {
        if (isUndefined(to[propName])) {
            to[propName] = from[propName];
        }
    }
    return to;
}
function safeCall1(method, arg1) {
    return !!isFunction(method) && (method(arg1), true);
}

var keyPrefix = '$';
function V(childFlags, children, className, flags, key, props, ref, type) {
    this.childFlags = childFlags;
    this.children = children;
    this.className = className;
    this.dom = null;
    this.flags = flags;
    this.key = key === void 0 ? null : key;
    this.props = props === void 0 ? null : props;
    this.ref = ref === void 0 ? null : ref;
    this.type = type;
}
function createVNode(flags, type, className, children, childFlags, props, key, ref) {
    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;
    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);
    if (options.createVNode) {
        options.createVNode(vNode);
    }
    if (childFlag === 0 /* UnknownChildren */) {
        normalizeChildren(vNode, vNode.children);
    }
    return vNode;
}
function mergeDefaultHooks(flags, type, ref) {
    if (flags & 4 /* ComponentClass */) {
        return ref;
    }
    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;
    if (isNullOrUndef(defaultHooks)) {
        return ref;
    }
    if (isNullOrUndef(ref)) {
        return defaultHooks;
    }
    return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type, props) {
    // set default props
    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;
    if (isNullOrUndef(defaultProps)) {
        return props;
    }
    if (isNullOrUndef(props)) {
        return combineFrom(defaultProps, null);
    }
    return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type) {
    if (flags & 12 /* ComponentKnown */) {
        return flags;
    }
    if (type.prototype && type.prototype.render) {
        return 4 /* ComponentClass */;
    }
    if (type.render) {
        return 32776 /* ForwardRefComponent */;
    }
    return 8 /* ComponentFunction */;
}
function createComponentVNode(flags, type, props, key, ref) {
    flags = resolveComponentFlags(flags, type);
    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);
    if (options.createVNode) {
        options.createVNode(vNode);
    }
    return vNode;
}
function createTextVNode(text, key) {
    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);
}
function createFragment(children, childFlags, key) {
    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);
    switch (fragment.childFlags) {
        case 1 /* HasInvalidChildren */:
            fragment.children = createVoidVNode();
            fragment.childFlags = 2 /* HasVNodeChildren */;
            break;
        case 16 /* HasTextChildren */:
            fragment.children = [createTextVNode(children)];
            fragment.childFlags = 4 /* HasNonKeyedChildren */;
            break;
    }
    return fragment;
}
function normalizeProps(vNode) {
    var props = vNode.props;
    if (props) {
        var flags = vNode.flags;
        if (flags & 481 /* Element */) {
            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
                normalizeChildren(vNode, props.children);
            }
            if (props.className !== void 0) {
                if (isNullOrUndef(vNode.className)) {
                    vNode.className = props.className || null;
                }
                props.className = undefined;
            }
        }
        if (props.key !== void 0) {
            vNode.key = props.key;
            props.key = undefined;
        }
        if (props.ref !== void 0) {
            if (flags & 8 /* ComponentFunction */) {
                vNode.ref = combineFrom(vNode.ref, props.ref);
            }
            else {
                vNode.ref = props.ref;
            }
            props.ref = undefined;
        }
    }
    return vNode;
}
/*
 * Fragment is different than normal vNode,
 * because when it needs to be cloned we need to clone its children too
 * But not normalize, because otherwise those possibly get KEY and re-mount
 */
function cloneFragment(vNodeToClone) {
    var oldChildren = vNodeToClone.children;
    var childFlags = vNodeToClone.childFlags;
    return createFragment(childFlags === 2 /* HasVNodeChildren */ ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;
    var props = vNodeToClone.props;
    if (flags & 14 /* Component */) {
        if (!isNull(props)) {
            var propsToClone = props;
            props = {};
            for (var key in propsToClone) {
                props[key] = propsToClone[key];
            }
        }
    }
    if ((flags & 8192 /* Fragment */) === 0) {
        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
    }
    return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
    return createTextVNode('', null);
}
function createPortal(children, container) {
    var normalizedRoot = normalizeRoot(children);
    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);
}
function _normalizeVNodes(nodes, result, index, currentKey) {
    for (var len = nodes.length; index < len; index++) {
        var n = nodes[index];
        if (!isInvalid(n)) {
            var newKey = currentKey + keyPrefix + index;
            if (isArray(n)) {
                _normalizeVNodes(n, result, 0, newKey);
            }
            else {
                if (isStringOrNumber(n)) {
                    n = createTextVNode(n, newKey);
                }
                else {
                    var oldKey = n.key;
                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;
                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {
                        n = directClone(n);
                    }
                    n.flags |= 65536 /* Normalized */;
                    if (!isPrefixedKey) {
                        if (isNull(oldKey)) {
                            n.key = newKey;
                        }
                        else {
                            n.key = currentKey + oldKey;
                        }
                    }
                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {
                        n.key = currentKey + oldKey;
                    }
                }
                result.push(n);
            }
        }
    }
}
function getFlagsForElementVnode(type) {
    switch (type) {
        case 'svg':
            return 32 /* SvgElement */;
        case 'input':
            return 64 /* InputElement */;
        case 'select':
            return 256 /* SelectElement */;
        case 'textarea':
            return 128 /* TextareaElement */;
        case Fragment:
            return 8192 /* Fragment */;
        default:
            return 1 /* HtmlElement */;
    }
}
function normalizeChildren(vNode, children) {
    var newChildren;
    var newChildFlags = 1 /* HasInvalidChildren */;
    // Don't change children to match strict equal (===) true in patching
    if (isInvalid(children)) {
        newChildren = children;
    }
    else if (isStringOrNumber(children)) {
        newChildFlags = 16 /* HasTextChildren */;
        newChildren = children;
    }
    else if (isArray(children)) {
        var len = children.length;
        for (var i = 0; i < len; ++i) {
            var n = children[i];
            if (isInvalid(n) || isArray(n)) {
                newChildren = newChildren || children.slice(0, i);
                _normalizeVNodes(children, newChildren, i, '');
                break;
            }
            else if (isStringOrNumber(n)) {
                newChildren = newChildren || children.slice(0, i);
                newChildren.push(createTextVNode(n, keyPrefix + i));
            }
            else {
                var key = n.key;
                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;
                var isNullKey = isNull(key);
                var isPrefixed = isString(key) && key[0] === keyPrefix;
                if (needsCloning || isNullKey || isPrefixed) {
                    newChildren = newChildren || children.slice(0, i);
                    if (needsCloning || isPrefixed) {
                        n = directClone(n);
                    }
                    if (isNullKey || isPrefixed) {
                        n.key = keyPrefix + i;
                    }
                    newChildren.push(n);
                }
                else if (newChildren) {
                    newChildren.push(n);
                }
                n.flags |= 65536 /* Normalized */;
            }
        }
        newChildren = newChildren || children;
        if (newChildren.length === 0) {
            newChildFlags = 1 /* HasInvalidChildren */;
        }
        else {
            newChildFlags = 8 /* HasKeyedChildren */;
        }
    }
    else {
        newChildren = children;
        newChildren.flags |= 65536 /* Normalized */;
        if (children.flags & 81920 /* InUseOrNormalized */) {
            newChildren = directClone(children);
        }
        newChildFlags = 2 /* HasVNodeChildren */;
    }
    vNode.children = newChildren;
    vNode.childFlags = newChildFlags;
    return vNode;
}
function normalizeRoot(input) {
    if (isInvalid(input) || isStringOrNumber(input)) {
        return createTextVNode(input, null);
    }
    if (isArray(input)) {
        return createFragment(input, 0 /* UnknownChildren */, null);
    }
    return input.flags & 16384 /* InUse */ ? directClone(input) : input;
}

var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var namespaces = {
    'xlink:actuate': xlinkNS,
    'xlink:arcrole': xlinkNS,
    'xlink:href': xlinkNS,
    'xlink:role': xlinkNS,
    'xlink:show': xlinkNS,
    'xlink:title': xlinkNS,
    'xlink:type': xlinkNS,
    'xml:base': xmlNS,
    'xml:lang': xmlNS,
    'xml:space': xmlNS
};

function getDelegatedEventObject(v) {
    return {
        onClick: v,
        onDblClick: v,
        onFocusIn: v,
        onFocusOut: v,
        onKeyDown: v,
        onKeyPress: v,
        onKeyUp: v,
        onMouseDown: v,
        onMouseMove: v,
        onMouseUp: v,
        onTouchEnd: v,
        onTouchMove: v,
        onTouchStart: v
    };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name, dom) {
    var eventsObject = dom.$EV;
    if (!eventsObject) {
        eventsObject = dom.$EV = getDelegatedEventObject(null);
    }
    if (!eventsObject[name]) {
        if (++attachedEventCounts[name] === 1) {
            attachedEvents[name] = attachEventToDocument(name);
        }
    }
    return eventsObject;
}
function unmountSyntheticEvent(name, dom) {
    var eventsObject = dom.$EV;
    if (eventsObject && eventsObject[name]) {
        if (--attachedEventCounts[name] === 0) {
            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);
            attachedEvents[name] = null;
        }
        eventsObject[name] = null;
    }
}
function handleSyntheticEvent(name, lastEvent, nextEvent, dom) {
    if (isFunction(nextEvent)) {
        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;
    }
    else if (isLinkEventObject(nextEvent)) {
        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
            return;
        }
        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;
    }
    else {
        unmountSyntheticEvent(name, dom);
    }
}
// When browsers fully support event.composedPath we could loop it through instead of using parentNode property
function getTargetNode(event) {
    return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name, eventData) {
    var dom = getTargetNode(event);
    do {
        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,
        // because the event listener is on document.body
        // Don't process clicks on disabled elements
        if (isClick && dom.disabled) {
            return;
        }
        var eventsObject = dom.$EV;
        if (eventsObject) {
            var currentEvent = eventsObject[name];
            if (currentEvent) {
                // linkEvent object
                eventData.dom = dom;
                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
                if (event.cancelBubble) {
                    return;
                }
            }
        }
        dom = dom.parentNode;
    } while (!isNull(dom));
}
function stopPropagation() {
    this.cancelBubble = true;
    if (!this.immediatePropagationStopped) {
        this.stopImmediatePropagation();
    }
}
function isDefaultPrevented() {
    return this.defaultPrevented;
}
function isPropagationStopped() {
    return this.cancelBubble;
}
function extendEventProperties(event) {
    // Event data needs to be object to save reference to currentTarget getter
    var eventData = {
        dom: document
    };
    event.isDefaultPrevented = isDefaultPrevented;
    event.isPropagationStopped = isPropagationStopped;
    event.stopPropagation = stopPropagation;
    Object.defineProperty(event, 'currentTarget', {
        configurable: true,
        get: function get() {
            return eventData.dom;
        }
    });
    return eventData;
}
function rootClickEvent(name) {
    return function (event) {
        if (event.button !== 0) {
            // Firefox incorrectly triggers click event for mid/right mouse buttons.
            // This bug has been active for 17 years.
            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051
            event.stopPropagation();
            return;
        }
        dispatchEvents(event, true, name, extendEventProperties(event));
    };
}
function rootEvent(name) {
    return function (event) {
        dispatchEvents(event, false, name, extendEventProperties(event));
    };
}
function attachEventToDocument(name) {
    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);
    document.addEventListener(normalizeEventName(name), attachedEvent);
    return attachedEvent;
}

function isSameInnerHTML(dom, innerHTML) {
    var tempdom = document.createElement('i');
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
}

function triggerEventListener(props, methodName, e) {
    if (props[methodName]) {
        var listener = props[methodName];
        if (listener.event) {
            listener.event(listener.data, e);
        }
        else {
            listener(e);
        }
    }
    else {
        var nativeListenerName = methodName.toLowerCase();
        if (props[nativeListenerName]) {
            props[nativeListenerName](e);
        }
    }
}
function createWrappedFunction(methodName, applyValue) {
    var fnMethod = function (e) {
        var vNode = this.$V;
        // If vNode is gone by the time event fires, no-op
        if (!vNode) {
            return;
        }
        var props = vNode.props || EMPTY_OBJ;
        var dom = vNode.dom;
        if (isString(methodName)) {
            triggerEventListener(props, methodName, e);
        }
        else {
            for (var i = 0; i < methodName.length; ++i) {
                triggerEventListener(props, methodName[i], e);
            }
        }
        if (isFunction(applyValue)) {
            var newVNode = this.$V;
            var newProps = newVNode.props || EMPTY_OBJ;
            applyValue(newProps, dom, false, newVNode);
        }
    };
    Object.defineProperty(fnMethod, 'wrapped', {
        configurable: false,
        enumerable: false,
        value: true,
        writable: false
    });
    return fnMethod;
}

function attachEvent(dom, eventName, handler) {
    var previousKey = "$" + eventName;
    var previousArgs = dom[previousKey];
    if (previousArgs) {
        if (previousArgs[1].wrapped) {
            return;
        }
        dom.removeEventListener(previousArgs[0], previousArgs[1]);
        dom[previousKey] = null;
    }
    if (isFunction(handler)) {
        dom.addEventListener(eventName, handler);
        dom[previousKey] = [eventName, handler];
    }
}

function isCheckedType(type) {
    return type === 'checkbox' || type === 'radio';
}
var onTextInputChange = createWrappedFunction('onInput', applyValueInput);
var wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);
/* tslint:disable-next-line:no-empty */
function emptywrapper(event) {
    event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
    if (isCheckedType(nextPropsOrEmpty.type)) {
        attachEvent(dom, 'change', wrappedOnChange);
        attachEvent(dom, 'click', emptywrapper);
    }
    else {
        attachEvent(dom, 'input', onTextInputChange);
    }
}
function applyValueInput(nextPropsOrEmpty, dom) {
    var type = nextPropsOrEmpty.type;
    var value = nextPropsOrEmpty.value;
    var checked = nextPropsOrEmpty.checked;
    var multiple = nextPropsOrEmpty.multiple;
    var defaultValue = nextPropsOrEmpty.defaultValue;
    var hasValue = !isNullOrUndef(value);
    if (type && type !== dom.type) {
        dom.setAttribute('type', type);
    }
    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    if (!isNullOrUndef(defaultValue) && !hasValue) {
        dom.defaultValue = defaultValue + '';
    }
    if (isCheckedType(type)) {
        if (hasValue) {
            dom.value = value;
        }
        if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
    else {
        if (hasValue && dom.value !== value) {
            dom.defaultValue = value;
            dom.value = value;
        }
        else if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
}

function updateChildOptions(vNode, value) {
    if (vNode.type === 'option') {
        updateChildOption(vNode, value);
    }
    else {
        var children = vNode.children;
        var flags = vNode.flags;
        if (flags & 4 /* ComponentClass */) {
            updateChildOptions(children.$LI, value);
        }
        else if (flags & 8 /* ComponentFunction */) {
            updateChildOptions(children, value);
        }
        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {
            updateChildOptions(children, value);
        }
        else if (vNode.childFlags & 12 /* MultipleChildren */) {
            for (var i = 0, len = children.length; i < len; ++i) {
                updateChildOptions(children[i], value);
            }
        }
    }
}
function updateChildOption(vNode, value) {
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    // we do this as multiple may have changed
    dom.value = props.value;
    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {
        dom.selected = true;
    }
    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {
        dom.selected = props.selected || false;
    }
}
var onSelectChange = createWrappedFunction('onChange', applyValueSelect);
function selectEvents(dom) {
    attachEvent(dom, 'change', onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
        dom.multiple = multiplePropInBoolean;
    }
    var index = nextPropsOrEmpty.selectedIndex;
    if (index === -1) {
        dom.selectedIndex = -1;
    }
    var childFlags = vNode.childFlags;
    if (childFlags !== 1 /* HasInvalidChildren */) {
        var value = nextPropsOrEmpty.value;
        if (isNumber(index) && index > -1 && dom.options[index]) {
            value = dom.options[index].value;
        }
        if (mounting && isNullOrUndef(value)) {
            value = nextPropsOrEmpty.defaultValue;
        }
        updateChildOptions(vNode, value);
    }
}

var onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);
var wrappedOnChange$1 = createWrappedFunction('onChange');
function textAreaEvents(dom, nextPropsOrEmpty) {
    attachEvent(dom, 'input', onTextareaInputChange);
    if (nextPropsOrEmpty.onChange) {
        attachEvent(dom, 'change', wrappedOnChange$1);
    }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
    var value = nextPropsOrEmpty.value;
    var domValue = dom.value;
    if (isNullOrUndef(value)) {
        if (mounting) {
            var defaultValue = nextPropsOrEmpty.defaultValue;
            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
                dom.defaultValue = defaultValue;
                dom.value = defaultValue;
            }
        }
    }
    else if (domValue !== value) {
        /* There is value so keep it controlled */
        dom.defaultValue = value;
        dom.value = value;
    }
}

function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    if (flags & 64 /* InputElement */) {
        applyValueInput(nextPropsOrEmpty, dom);
    }
    else if (flags & 256 /* SelectElement */) {
        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
    }
    else if (flags & 128 /* TextareaElement */) {
        applyValueTextArea(nextPropsOrEmpty, dom, mounting);
    }
    if (isControlled) {
        dom.$V = vNode;
    }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
    if (flags & 64 /* InputElement */) {
        inputEvents(dom, nextPropsOrEmpty);
    }
    else if (flags & 256 /* SelectElement */) {
        selectEvents(dom);
    }
    else if (flags & 128 /* TextareaElement */) {
        textAreaEvents(dom, nextPropsOrEmpty);
    }
}
function isControlledFormElement(nextPropsOrEmpty) {
    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}

function createRef() {
    return {
        current: null
    };
}
function forwardRef(render) {
    // @ts-ignore
    return {
        render: render
    };
}
function unmountRef(ref) {
    if (ref) {
        if (!safeCall1(ref, null) && ref.current) {
            ref.current = null;
        }
    }
}
function mountRef(ref, value, lifecycle) {
    if (ref && (isFunction(ref) || ref.current !== void 0)) {
        lifecycle.push(function () {
            if (!safeCall1(ref, value) && ref.current !== void 0) {
                ref.current = value;
            }
        });
    }
}

function remove(vNode, parentDOM) {
    unmount(vNode);
    removeVNodeDOM(vNode, parentDOM);
}
function unmount(vNode) {
    var flags = vNode.flags;
    var children = vNode.children;
    var ref;
    if (flags & 481 /* Element */) {
        ref = vNode.ref;
        var props = vNode.props;
        unmountRef(ref);
        var childFlags = vNode.childFlags;
        if (!isNull(props)) {
            var keys = Object.keys(props);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                if (syntheticEvents[key]) {
                    unmountSyntheticEvent(key, vNode.dom);
                }
            }
        }
        if (childFlags & 12 /* MultipleChildren */) {
            unmountAllChildren(children);
        }
        else if (childFlags === 2 /* HasVNodeChildren */) {
            unmount(children);
        }
    }
    else if (children) {
        if (flags & 4 /* ComponentClass */) {
            if (isFunction(children.componentWillUnmount)) {
                children.componentWillUnmount();
            }
            unmountRef(vNode.ref);
            children.$UN = true;
            unmount(children.$LI);
        }
        else if (flags & 8 /* ComponentFunction */) {
            ref = vNode.ref;
            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {
                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
            }
            unmount(children);
        }
        else if (flags & 1024 /* Portal */) {
            remove(children, vNode.ref);
        }
        else if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags & 12 /* MultipleChildren */) {
                unmountAllChildren(children);
            }
        }
    }
}
function unmountAllChildren(children) {
    for (var i = 0, len = children.length; i < len; ++i) {
        unmount(children[i]);
    }
}
function clearDOM(dom) {
    // Optimization for clearing dom
    dom.textContent = '';
}
function removeAllChildren(dom, vNode, children) {
    unmountAllChildren(children);
    if (vNode.flags & 8192 /* Fragment */) {
        removeVNodeDOM(vNode, dom);
    }
    else {
        clearDOM(dom);
    }
}

function wrapLinkEvent(nextValue) {
    // This variable makes sure there is no "this" context in callback
    var ev = nextValue.event;
    return function (e) {
        ev(nextValue.data, e);
    };
}
function patchEvent(name, lastValue, nextValue, dom) {
    if (isLinkEventObject(nextValue)) {
        if (isLastValueSameLinkEvent(lastValue, nextValue)) {
            return;
        }
        nextValue = wrapLinkEvent(nextValue);
    }
    attachEvent(dom, normalizeEventName(name), nextValue);
}
// We are assuming here that we come from patchProp routine
// -nextAttrValue cannot be null or undefined
function patchStyle(lastAttrValue, nextAttrValue, dom) {
    if (isNullOrUndef(nextAttrValue)) {
        dom.removeAttribute('style');
        return;
    }
    var domStyle = dom.style;
    var style;
    var value;
    if (isString(nextAttrValue)) {
        domStyle.cssText = nextAttrValue;
        return;
    }
    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {
        for (style in nextAttrValue) {
            // do not add a hasOwnProperty check here, it affects performance
            value = nextAttrValue[style];
            if (value !== lastAttrValue[style]) {
                domStyle.setProperty(style, value);
            }
        }
        for (style in lastAttrValue) {
            if (isNullOrUndef(nextAttrValue[style])) {
                domStyle.removeProperty(style);
            }
        }
    }
    else {
        for (style in nextAttrValue) {
            value = nextAttrValue[style];
            domStyle.setProperty(style, value);
        }
    }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {
    var lastHtml = (lastValue && lastValue.__html) || '';
    var nextHtml = (nextValue && nextValue.__html) || '';
    if (lastHtml !== nextHtml) {
        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
            if (!isNull(lastVNode)) {
                if (lastVNode.childFlags & 12 /* MultipleChildren */) {
                    unmountAllChildren(lastVNode.children);
                }
                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {
                    unmount(lastVNode.children);
                }
                lastVNode.children = null;
                lastVNode.childFlags = 1 /* HasInvalidChildren */;
            }
            dom.innerHTML = nextHtml;
        }
    }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
    switch (prop) {
        case 'children':
        case 'childrenType':
        case 'className':
        case 'defaultValue':
        case 'key':
        case 'multiple':
        case 'ref':
        case 'selectedIndex':
            break;
        case 'autoFocus':
            dom.autofocus = !!nextValue;
            break;
        case 'allowfullscreen':
        case 'autoplay':
        case 'capture':
        case 'checked':
        case 'controls':
        case 'default':
        case 'disabled':
        case 'hidden':
        case 'indeterminate':
        case 'loop':
        case 'muted':
        case 'novalidate':
        case 'open':
        case 'readOnly':
        case 'required':
        case 'reversed':
        case 'scoped':
        case 'seamless':
        case 'selected':
            dom[prop] = !!nextValue;
            break;
        case 'defaultChecked':
        case 'value':
        case 'volume':
            if (hasControlledValue && prop === 'value') {
                break;
            }
            var value = isNullOrUndef(nextValue) ? '' : nextValue;
            if (dom[prop] !== value) {
                dom[prop] = value;
            }
            break;
        case 'style':
            patchStyle(lastValue, nextValue, dom);
            break;
        case 'dangerouslySetInnerHTML':
            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);
            break;
        default:
            if (syntheticEvents[prop]) {
                handleSyntheticEvent(prop, lastValue, nextValue, dom);
            }
            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
                patchEvent(prop, lastValue, nextValue, dom);
            }
            else if (isNullOrUndef(nextValue)) {
                dom.removeAttribute(prop);
            }
            else if (isSVG && namespaces[prop]) {
                // We optimize for isSVG being false
                // If we end up in this path we can read property again
                dom.setAttributeNS(namespaces[prop], prop, nextValue);
            }
            else {
                dom.setAttribute(prop, nextValue);
            }
            break;
    }
}
function mountProps(vNode, flags, props, dom, isSVG) {
    var hasControlledValue = false;
    var isFormElement = (flags & 448 /* FormElement */) > 0;
    if (isFormElement) {
        hasControlledValue = isControlledFormElement(props);
        if (hasControlledValue) {
            addFormElementEventHandlers(flags, dom, props);
        }
    }
    for (var prop in props) {
        // do not add a hasOwnProperty check here, it affects performance
        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
    }
    if (isFormElement) {
        processElement(flags, vNode, dom, props, true, hasControlledValue);
    }
}

function renderNewInput(instance, props, context) {
    var nextInput = normalizeRoot(instance.render(props, instance.state, context));
    var childContext = context;
    if (isFunction(instance.getChildContext)) {
        childContext = combineFrom(context, instance.getChildContext());
    }
    instance.$CX = childContext;
    return nextInput;
}
function createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {
    var instance = new Component(props, context);
    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));
    instance.$SVG = isSVG;
    instance.$L = lifecycle;
    vNode.children = instance;
    instance.$BS = false;
    instance.context = context;
    if (instance.props === EMPTY_OBJ) {
        instance.props = props;
    }
    if (!usesNewAPI) {
        if (isFunction(instance.componentWillMount)) {
            instance.$BR = true;
            instance.componentWillMount();
            var pending = instance.$PS;
            if (!isNull(pending)) {
                var state = instance.state;
                if (isNull(state)) {
                    instance.state = pending;
                }
                else {
                    for (var key in pending) {
                        state[key] = pending[key];
                    }
                }
                instance.$PS = null;
            }
            instance.$BR = false;
        }
    }
    else {
        instance.state = createDerivedState(instance, props, instance.state);
    }
    instance.$LI = renderNewInput(instance, props, context);
    return instance;
}
function renderFunctionalComponent(vNode, context) {
    var props = vNode.props || EMPTY_OBJ;
    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);
}

function mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = (vNode.flags |= 16384 /* InUse */);
    if (flags & 481 /* Element */) {
        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 4 /* ComponentClass */) {
        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 8 /* ComponentFunction */) {
        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
        mountFunctionalComponentCallbacks(vNode, lifecycle);
    }
    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {
        mountText(vNode, parentDOM, nextNode);
    }
    else if (flags & 8192 /* Fragment */) {
        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);
    }
    else if (flags & 1024 /* Portal */) {
        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);
    }
    else ;
}
function mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {
    mount(vNode.children, vNode.ref, context, false, null, lifecycle);
    var placeHolderVNode = createVoidVNode();
    mountText(placeHolderVNode, parentDOM, nextNode);
    vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {
    var children = vNode.children;
    var childFlags = vNode.childFlags;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {
        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;
        children = vNode.children = createVoidVNode();
    }
    if (childFlags === 2 /* HasVNodeChildren */) {
        mount(children, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else {
        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);
    }
}
function mountText(vNode, parentDOM, nextNode) {
    var dom = (vNode.dom = document.createTextNode(vNode.children));
    if (!isNull(parentDOM)) {
        insertOrAppend(parentDOM, dom, nextNode);
    }
}
function mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = vNode.flags;
    var props = vNode.props;
    var className = vNode.className;
    var childFlags = vNode.childFlags;
    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));
    var children = vNode.children;
    if (!isNullOrUndef(className) && className !== '') {
        if (isSVG) {
            dom.setAttribute('class', className);
        }
        else {
            dom.className = className;
        }
    }
    if (childFlags === 16 /* HasTextChildren */) {
        setTextContent(dom, children);
    }
    else if (childFlags !== 1 /* HasInvalidChildren */) {
        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';
        if (childFlags === 2 /* HasVNodeChildren */) {
            if (children.flags & 16384 /* InUse */) {
                vNode.children = children = directClone(children);
            }
            mount(children, dom, context, childrenIsSVG, null, lifecycle);
        }
        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {
            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);
        }
    }
    if (!isNull(parentDOM)) {
        insertOrAppend(parentDOM, dom, nextNode);
    }
    if (!isNull(props)) {
        mountProps(vNode, flags, props, dom, isSVG);
    }
    mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {
    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (child.flags & 16384 /* InUse */) {
            children[i] = child = directClone(child);
        }
        mount(child, dom, context, isSVG, nextNode, lifecycle);
    }
}
function mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);
    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);
}
function mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    mount((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);
}
function createClassMountCallback(instance) {
    return function () {
        instance.componentDidMount();
    };
}
function mountClassComponentCallbacks(ref, instance, lifecycle) {
    mountRef(ref, instance, lifecycle);
    if (isFunction(instance.componentDidMount)) {
        lifecycle.push(createClassMountCallback(instance));
    }
}
function createOnMountCallback(ref, vNode) {
    return function () {
        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
    };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle) {
    var ref = vNode.ref;
    if (!isNullOrUndef(ref)) {
        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
        if (isFunction(ref.onComponentDidMount)) {
            lifecycle.push(createOnMountCallback(ref, vNode));
        }
    }
}

function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    unmount(lastVNode);
    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {
        mount(nextVNode, null, context, isSVG, null, lifecycle);
        // Single DOM operation, when we have dom references available
        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
    }
    else {
        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);
        removeVNodeDOM(lastVNode, parentDOM);
    }
}
function patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);
    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {
        if (lastVNode.flags & 16384 /* InUse */) {
            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
        }
        else {
            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one
            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (nextFlags & 481 /* Element */) {
        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);
    }
    else if (nextFlags & 4 /* ComponentClass */) {
        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 8 /* ComponentFunction */) {
        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 16 /* Text */) {
        patchText(lastVNode, nextVNode);
    }
    else if (nextFlags & 512 /* Void */) {
        nextVNode.dom = lastVNode.dom;
    }
    else if (nextFlags & 8192 /* Fragment */) {
        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
    }
    else {
        patchPortal(lastVNode, nextVNode, context, lifecycle);
    }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
    if (lastChildren !== nextChildren) {
        if (lastChildren !== '') {
            parentDOM.firstChild.nodeValue = nextChildren;
        }
        else {
            setTextContent(parentDOM, nextChildren);
        }
    }
}
function patchContentEditableChildren(dom, nextChildren) {
    if (dom.textContent !== nextChildren) {
        dom.textContent = nextChildren;
    }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    var lastChildren = lastVNode.children;
    var nextChildren = nextVNode.children;
    var lastChildFlags = lastVNode.childFlags;
    var nextChildFlags = nextVNode.childFlags;
    var nextNode = null;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {
        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;
        nextChildren = nextVNode.children = createVoidVNode();
    }
    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;
    if (lastChildFlags & 12 /* MultipleChildren */) {
        var lastLen = lastChildren.length;
        // We need to know Fragment's edge node when
        if (
        // It uses keyed algorithm
        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||
            // It transforms from many to single
            nextIsSingle ||
            // It will append more nodes
            (!nextIsSingle && nextChildren.length > lastLen)) {
            // When fragment has multiple children there is always at least one vNode
            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;
        }
    }
    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal(lastVNode, nextVNode, context, lifecycle) {
    var lastContainer = lastVNode.ref;
    var nextContainer = nextVNode.ref;
    var nextChildren = nextVNode.children;
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);
    nextVNode.dom = lastVNode.dom;
    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
        var node = nextChildren.dom;
        removeChild(lastContainer, node);
        appendChild(nextContainer, node);
    }
}
function patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {
    var dom = (nextVNode.dom = lastVNode.dom);
    var lastProps = lastVNode.props;
    var nextProps = nextVNode.props;
    var isFormElement = false;
    var hasControlledValue = false;
    var nextPropsOrEmpty;
    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;
    // inlined patchProps  -- starts --
    if (lastProps !== nextProps) {
        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
        nextPropsOrEmpty = nextProps || EMPTY_OBJ;
        if (nextPropsOrEmpty !== EMPTY_OBJ) {
            isFormElement = (nextFlags & 448 /* FormElement */) > 0;
            if (isFormElement) {
                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
            }
            for (var prop in nextPropsOrEmpty) {
                var lastValue = lastPropsOrEmpty[prop];
                var nextValue = nextPropsOrEmpty[prop];
                if (lastValue !== nextValue) {
                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
        if (lastPropsOrEmpty !== EMPTY_OBJ) {
            for (var prop$1 in lastPropsOrEmpty) {
                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
    }
    var nextChildren = nextVNode.children;
    var nextClassName = nextVNode.className;
    // inlined patchProps  -- ends --
    if (lastVNode.className !== nextClassName) {
        if (isNullOrUndef(nextClassName)) {
            dom.removeAttribute('class');
        }
        else if (isSVG) {
            dom.setAttribute('class', nextClassName);
        }
        else {
            dom.className = nextClassName;
        }
    }
    if (nextFlags & 4096 /* ContentEditable */) {
        patchContentEditableChildren(dom, nextChildren);
    }
    else {
        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);
    }
    if (isFormElement) {
        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
    }
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    if (lastRef !== nextRef) {
        unmountRef(lastRef);
        mountRef(nextRef, dom, lifecycle);
    }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {
    unmount(lastChildren);
    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);
    removeVNodeDOM(lastChildren, parentDOM);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {
    switch (lastChildFlags) {
        case 2 /* HasVNodeChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    remove(lastChildren, parentDOM);
                    break;
                case 16 /* HasTextChildren */:
                    unmount(lastChildren);
                    setTextContent(parentDOM, nextChildren);
                    break;
                default:
                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);
                    break;
            }
            break;
        case 1 /* HasInvalidChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    break;
                case 16 /* HasTextChildren */:
                    setTextContent(parentDOM, nextChildren);
                    break;
                default:
                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        case 16 /* HasTextChildren */:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);
                    break;
                case 2 /* HasVNodeChildren */:
                    clearDOM(parentDOM);
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    clearDOM(parentDOM);
                    break;
                default:
                    clearDOM(parentDOM);
                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        default:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    unmountAllChildren(lastChildren);
                    setTextContent(parentDOM, nextChildren);
                    break;
                case 2 /* HasVNodeChildren */:
                    removeAllChildren(parentDOM, parentVNode, lastChildren);
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    removeAllChildren(parentDOM, parentVNode, lastChildren);
                    break;
                default:
                    var lastLength = lastChildren.length | 0;
                    var nextLength = nextChildren.length | 0;
                    // Fast path's for both algorithms
                    if (lastLength === 0) {
                        if (nextLength > 0) {
                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                        }
                    }
                    else if (nextLength === 0) {
                        removeAllChildren(parentDOM, parentVNode, lastChildren);
                    }
                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {
                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
                    }
                    else {
                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);
                    }
                    break;
            }
            break;
    }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
    lifecycle.push(function () {
        instance.componentDidUpdate(lastProps, lastState, snapshot);
    });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {
    var lastState = instance.state;
    var lastProps = instance.props;
    var usesNewAPI = Boolean(instance.$N);
    var hasSCU = isFunction(instance.shouldComponentUpdate);
    if (usesNewAPI) {
        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
    }
    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {
        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {
            instance.componentWillUpdate(nextProps, nextState, context);
        }
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
        var snapshot = null;
        var nextInput = renderNewInput(instance, nextProps, context);
        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {
            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
        }
        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
        // Dont update Last input, until patch has been succesfully executed
        instance.$LI = nextInput;
        if (isFunction(instance.componentDidUpdate)) {
            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
        }
    }
    else {
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
    }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = (nextVNode.children = lastVNode.children);
    // If Component has crashed, ignore it to stay functional
    if (isNull(instance)) {
        return;
    }
    instance.$L = lifecycle;
    var nextProps = nextVNode.props || EMPTY_OBJ;
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    var nextState = instance.state;
    if (!instance.$N) {
        if (isFunction(instance.componentWillReceiveProps)) {
            instance.$BR = true;
            instance.componentWillReceiveProps(nextProps, context);
            // If instance component was removed during its own update do nothing.
            if (instance.$UN) {
                return;
            }
            instance.$BR = false;
        }
        if (!isNull(instance.$PS)) {
            nextState = combineFrom(nextState, instance.$PS);
            instance.$PS = null;
        }
    }
    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);
    if (lastRef !== nextRef) {
        unmountRef(lastRef);
        mountRef(nextRef, instance, lifecycle);
    }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var shouldUpdate = true;
    var nextProps = nextVNode.props || EMPTY_OBJ;
    var nextRef = nextVNode.ref;
    var lastProps = lastVNode.props;
    var nextHooksDefined = !isNullOrUndef(nextRef);
    var lastInput = lastVNode.children;
    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {
        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
    }
    if (shouldUpdate !== false) {
        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {
            nextRef.onComponentWillUpdate(lastProps, nextProps);
        }
        var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));
        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);
        nextVNode.children = nextInput;
        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {
            nextRef.onComponentDidUpdate(lastProps, nextProps);
        }
    }
    else {
        nextVNode.children = lastInput;
    }
}
function patchText(lastVNode, nextVNode) {
    var nextText = nextVNode.children;
    var dom = (nextVNode.dom = lastVNode.dom);
    if (nextText !== lastVNode.children) {
        dom.nodeValue = nextText;
    }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
    var i = 0;
    var nextChild;
    var lastChild;
    for (; i < commonLength; ++i) {
        nextChild = nextChildren[i];
        lastChild = lastChildren[i];
        if (nextChild.flags & 16384 /* InUse */) {
            nextChild = nextChildren[i] = directClone(nextChild);
        }
        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);
        lastChildren[i] = nextChild;
    }
    if (lastChildrenLength < nextChildrenLength) {
        for (i = commonLength; i < nextChildrenLength; ++i) {
            nextChild = nextChildren[i];
            if (nextChild.flags & 16384 /* InUse */) {
                nextChild = nextChildren[i] = directClone(nextChild);
            }
            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (lastChildrenLength > nextChildrenLength) {
        for (i = commonLength; i < lastChildrenLength; ++i) {
            remove(lastChildren[i], dom);
        }
    }
}
function patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var j = 0;
    var aNode = a[j];
    var bNode = b[j];
    var nextPos;
    var nextNode;
    // Step 1
    // tslint:disable-next-line
    outer: {
        // Sync nodes with the same key at the beginning.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[j] = bNode;
            ++j;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[j];
            bNode = b[j];
        }
        aNode = a[aEnd];
        bNode = b[bEnd];
        // Sync nodes with the same key at the end.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[bEnd] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[aEnd] = bNode;
            aEnd--;
            bEnd--;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[aEnd];
            bNode = b[bEnd];
        }
    }
    if (j > aEnd) {
        if (j <= bEnd) {
            nextPos = bEnd + 1;
            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;
            while (j <= bEnd) {
                bNode = b[j];
                if (bNode.flags & 16384 /* InUse */) {
                    b[j] = bNode = directClone(bNode);
                }
                ++j;
                mount(bNode, dom, context, isSVG, nextNode, lifecycle);
            }
        }
    }
    else if (j > bEnd) {
        while (j <= aEnd) {
            remove(a[j++], dom);
        }
    }
    else {
        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
    }
}
function patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
    var aNode;
    var bNode;
    var nextPos;
    var i = 0;
    var aStart = j;
    var bStart = j;
    var aLeft = aEnd - j + 1;
    var bLeft = bEnd - j + 1;
    var sources = new Int32Array(bLeft + 1);
    // Keep track if its possible to remove whole DOM using textContent = '';
    var canRemoveWholeContent = aLeft === aLength;
    var moved = false;
    var pos = 0;
    var patched = 0;
    // When sizes are small, just loop them through
    if (bLength < 4 || (aLeft | bLeft) < 32) {
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                for (j = bStart; j <= bEnd; j++) {
                    bNode = b[j];
                    if (aNode.key === bNode.key) {
                        sources[j - bStart] = i + 1;
                        if (canRemoveWholeContent) {
                            canRemoveWholeContent = false;
                            while (aStart < i) {
                                remove(a[aStart++], dom);
                            }
                        }
                        if (pos > j) {
                            moved = true;
                        }
                        else {
                            pos = j;
                        }
                        if (bNode.flags & 16384 /* InUse */) {
                            b[j] = bNode = directClone(bNode);
                        }
                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                        ++patched;
                        break;
                    }
                }
                if (!canRemoveWholeContent && j > bEnd) {
                    remove(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove(aNode, dom);
            }
        }
    }
    else {
        var keyIndex = {};
        // Map keys by their index
        for (i = bStart; i <= bEnd; ++i) {
            keyIndex[b[i].key] = i;
        }
        // Try to patch same keys
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                j = keyIndex[aNode.key];
                if (j !== void 0) {
                    if (canRemoveWholeContent) {
                        canRemoveWholeContent = false;
                        while (i > aStart) {
                            remove(a[aStart++], dom);
                        }
                    }
                    sources[j - bStart] = i + 1;
                    if (pos > j) {
                        moved = true;
                    }
                    else {
                        pos = j;
                    }
                    bNode = b[j];
                    if (bNode.flags & 16384 /* InUse */) {
                        b[j] = bNode = directClone(bNode);
                    }
                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                    ++patched;
                }
                else if (!canRemoveWholeContent) {
                    remove(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove(aNode, dom);
            }
        }
    }
    // fast-path: if nothing patched remove all old and add all new
    if (canRemoveWholeContent) {
        removeAllChildren(dom, parentVNode, a);
        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);
    }
    else if (moved) {
        var seq = lis_algorithm(sources);
        j = seq.length - 1;
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone(bNode);
                }
                nextPos = pos + 1;
                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
            }
            else if (j < 0 || i !== seq[j]) {
                pos = i + bStart;
                bNode = b[pos];
                nextPos = pos + 1;
                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);
            }
            else {
                j--;
            }
        }
    }
    else if (patched !== bLeft) {
        // when patched count doesn't match b length we need to insert those new ones
        // loop backwards so we can use insertBefore
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone(bNode);
                }
                nextPos = pos + 1;
                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
            }
        }
    }
}
var result;
var p;
var maxLen = 0;
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function lis_algorithm(arr) {
    var arrI = 0;
    var i = 0;
    var j = 0;
    var k = 0;
    var u = 0;
    var v = 0;
    var c = 0;
    var len = arr.length;
    if (len > maxLen) {
        maxLen = len;
        result = new Int32Array(len);
        p = new Int32Array(len);
    }
    for (; i < len; ++i) {
        arrI = arr[i];
        if (arrI !== 0) {
            j = result[k];
            if (arr[j] < arrI) {
                p[i] = j;
                result[++k] = i;
                continue;
            }
            u = 0;
            v = k;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = k + 1;
    var seq = new Int32Array(u);
    v = result[u - 1];
    while (u-- > 0) {
        seq[u] = v;
        v = p[v];
        result[u] = 0;
    }
    return seq;
}

var hasDocumentAvailable = typeof document !== 'undefined';
if (hasDocumentAvailable) {
    /*
     * Defining $EV and $V properties on Node.prototype
     * fixes v8 "wrong map" de-optimization
     */
    if (window.Node) {
        Node.prototype.$EV = null;
        Node.prototype.$V = null;
    }
}
function __render(input, parentDOM, callback, context) {
    var lifecycle = [];
    var rootInput = parentDOM.$V;
    renderCheck.v = true;
    if (isNullOrUndef(rootInput)) {
        if (!isNullOrUndef(input)) {
            if (input.flags & 16384 /* InUse */) {
                input = directClone(input);
            }
            mount(input, parentDOM, context, false, null, lifecycle);
            parentDOM.$V = input;
            rootInput = input;
        }
    }
    else {
        if (isNullOrUndef(input)) {
            remove(rootInput, parentDOM);
            parentDOM.$V = null;
        }
        else {
            if (input.flags & 16384 /* InUse */) {
                input = directClone(input);
            }
            patch(rootInput, input, parentDOM, context, false, null, lifecycle);
            rootInput = parentDOM.$V = input;
        }
    }
    callAll(lifecycle);
    renderCheck.v = false;
    if (isFunction(callback)) {
        callback();
    }
    if (isFunction(options.renderComplete)) {
        options.renderComplete(rootInput, parentDOM);
    }
}
function render(input, parentDOM, callback, context) {
    if ( callback === void 0 ) callback = null;
    if ( context === void 0 ) context = EMPTY_OBJ;

    __render(input, parentDOM, callback, context);
}
function createRenderer(parentDOM) {
    return function renderer(lastInput, nextInput, callback, context) {
        if (!parentDOM) {
            parentDOM = lastInput;
        }
        render(nextInput, parentDOM, callback, context);
    };
}

var QUEUE = [];
var nextTick = typeof Promise !== 'undefined'
    ? Promise.resolve().then.bind(Promise.resolve())
    : function (a) {
        window.setTimeout(a, 0);
    };
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
    var pending = component.$PS;
    if (isFunction(newState)) {
        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
    }
    if (isNullOrUndef(pending)) {
        component.$PS = newState;
    }
    else {
        for (var stateKey in newState) {
            pending[stateKey] = newState[stateKey];
        }
    }
    if (!component.$BR) {
        if (!renderCheck.v) {
            if (QUEUE.length === 0) {
                applyState(component, force);
                if (isFunction(callback)) {
                    callback.call(component);
                }
                return;
            }
        }
        if (QUEUE.indexOf(component) === -1) {
            QUEUE.push(component);
        }
        if (force) {
            component.$F = true;
        }
        if (!microTaskPending) {
            microTaskPending = true;
            nextTick(rerender);
        }
        if (isFunction(callback)) {
            var QU = component.$QU;
            if (!QU) {
                QU = component.$QU = [];
            }
            QU.push(callback);
        }
    }
    else if (isFunction(callback)) {
        component.$L.push(callback.bind(component));
    }
}
function callSetStateCallbacks(component) {
    var queue = component.$QU;
    for (var i = 0; i < queue.length; ++i) {
        queue[i].call(component);
    }
    component.$QU = null;
}
function rerender() {
    var component;
    microTaskPending = false;
    while ((component = QUEUE.shift())) {
        if (!component.$UN) {
            var force = component.$F;
            component.$F = false;
            applyState(component, force);
            if (component.$QU) {
                callSetStateCallbacks(component);
            }
        }
    }
}
function applyState(component, force) {
    if (force || !component.$BR) {
        var pendingState = component.$PS;
        component.$PS = null;
        var lifecycle = [];
        renderCheck.v = true;
        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
        callAll(lifecycle);
        renderCheck.v = false;
    }
    else {
        component.state = component.$PS;
        component.$PS = null;
    }
}
var Component = function Component(props, context) {
    // Public
    this.state = null;
    // Internal properties
    this.$BR = false; // BLOCK RENDER
    this.$BS = true; // BLOCK STATE
    this.$PS = null; // PENDING STATE (PARTIAL or FULL)
    this.$LI = null; // LAST INPUT
    this.$UN = false; // UNMOUNTED
    this.$CX = null; // CHILDCONTEXT
    this.$QU = null; // QUEUE
    this.$N = false; // Uses new lifecycle API Flag
    this.$L = null; // Current lifecycle of this component
    this.$SVG = false; // Flag to keep track if component is inside SVG tree
    this.$F = false; // Force update flag
    this.props = props || EMPTY_OBJ;
    this.context = context || EMPTY_OBJ; // context should not be mutable
};
Component.prototype.forceUpdate = function forceUpdate (callback) {
    if (this.$UN) {
        return;
    }
    // Do not allow double render during force update
    queueStateChanges(this, {}, callback, true);
};
Component.prototype.setState = function setState (newState, callback) {
    if (this.$UN) {
        return;
    }
    if (!this.$BS) {
        queueStateChanges(this, newState, callback, false);
    }
};
Component.prototype.render = function render (_nextProps, _nextState, _nextContext) {
    return null;
};

var version = "7.4.11";



;// CONCATENATED MODULE: ../../node_modules/.pnpm/inferno@7.4.11/node_modules/inferno/index.esm.js


if (false) {}


/***/ }),

/***/ 66798:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.registerPattern = exports.registerGradient = exports["default"] = void 0;
var _utils = __webpack_require__(19157);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const graphicObjects = {};
const registerPattern = options => {
  const id = (0, _utils.getNextDefsSvgId)();
  graphicObjects[id] = _extends({
    type: 'pattern'
  }, options);
  return id;
};
exports.registerPattern = registerPattern;
const registerGradient = (type, options) => {
  const id = (0, _utils.getNextDefsSvgId)();
  graphicObjects[id] = _extends({
    type
  }, options);
  return id;
};
exports.registerGradient = registerGradient;
const getGraphicObjects = () => graphicObjects;
var _default = exports["default"] = {
  getGraphicObjects
};

/***/ }),

/***/ 97522:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.base64ToBytes = base64ToBytes;
exports.bytesToHex = bytesToHex;
exports.bytesToWords = bytesToWords;
exports.concatBytes = concatBytes;
exports.hexToBytes = hexToBytes;
exports.leftRotate = leftRotate;
exports.stringToBytes = stringToBytes;
exports.wordsToBytes = wordsToBytes;
exports.wordsToHex = wordsToHex;
/* eslint-disable no-bitwise */
function base64ToBytes(base64) {
  return new Uint8Array(atob(base64).split('').map(s => s.charCodeAt(0)));
}
function hexToBytes(string) {
  var _string$match;
  return new Uint8Array(((_string$match = string.match(/.{1,2}/g)) === null || _string$match === void 0 ? void 0 : _string$match.map(byte => parseInt(byte, 16))) ?? []);
}
function stringToBytes(string) {
  const bytes = new Uint8Array(string.length);
  for (let k = 0; k < string.length; k += 1) {
    bytes[k] = string.charCodeAt(k) & 0xFF;
  }
  return bytes;
}
function wordsToBytes(words) {
  const bytes = new Uint8Array(words.length * 4);
  for (let k = 0; k < bytes.length; k += 1) {
    bytes[k] = words[k >> 2] >>> 8 * (3 - k % 4);
  }
  return bytes;
}
function bytesToWords(bytes) {
  const words = new Uint32Array((bytes.length - 1 >> 2) + 1);
  for (let k = 0; k < bytes.length; k += 1) {
    words[k >> 2] |= bytes[k] << 8 * (3 - k % 4);
  }
  return words;
}
function wordsToHex(words) {
  return [...words].map(w => w.toString(16).padStart(8, '0')).join('');
}
function bytesToHex(bytes) {
  return [...bytes].map(b => b.toString(16).padStart(2, '0')).join('');
}
function leftRotate(x, n) {
  return (x << n | x >>> 32 - n) >>> 0;
}
function concatBytes(a, b) {
  const result = new Uint8Array(a.length + b.length);
  result.set(a, 0);
  result.set(b, a.length);
  return result;
}

/***/ }),

/***/ 41402:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PUBLIC_KEY = exports.INTERNAL_USAGE_ID = void 0;
const PUBLIC_KEY = exports.PUBLIC_KEY = {
  e: 65537,
  n: new Uint8Array([200, 219, 153, 203, 140, 7, 228, 253, 193, 243, 62, 137, 139, 60, 68, 242, 48, 142, 113, 88, 185, 235, 253, 105, 80, 74, 32, 170, 96, 74, 111, 250, 7, 205, 154, 3, 146, 115, 153, 53, 45, 132, 123, 56, 61, 208, 184, 201, 63, 24, 109, 223, 0, 179, 169, 102, 139, 224, 73, 233, 45, 173, 138, 66, 98, 88, 69, 76, 177, 111, 113, 218, 192, 33, 101, 152, 25, 134, 34, 173, 32, 82, 230, 44, 247, 200, 253, 170, 192, 246, 30, 12, 96, 205, 100, 249, 181, 93, 0, 231])
};
const INTERNAL_USAGE_ID = exports.INTERNAL_USAGE_ID = 'i9qS7usDB0eYJ_dN-hixdQ';

/***/ }),

/***/ 77685:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.parseLicenseKey = parseLicenseKey;
exports.peekValidationPerformed = peekValidationPerformed;
exports.setLicenseCheckSkipCondition = setLicenseCheckSkipCondition;
exports.validateLicense = validateLicense;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _version = __webpack_require__(36739);
var _version2 = __webpack_require__(39550);
var _byte_utils = __webpack_require__(97522);
var _key = __webpack_require__(41402);
var _pkcs = __webpack_require__(95373);
var _rsa_bigint = __webpack_require__(25746);
var _sha = __webpack_require__(13082);
var _trial_panel = __webpack_require__(84814);
var _types = __webpack_require__(13004);
const _excluded = ["customerId", "maxVersionAllowed", "format", "internalUsageId"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }
const FORMAT = 1;
const RTM_MIN_PATCH_VERSION = 3;
const KEY_SPLITTER = '.';
const BUY_NOW_LINK = 'https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeJQuery.aspx';
const GENERAL_ERROR = {
  kind: _types.TokenKind.corrupted,
  error: 'general'
};
const VERIFICATION_ERROR = {
  kind: _types.TokenKind.corrupted,
  error: 'verification'
};
const DECODING_ERROR = {
  kind: _types.TokenKind.corrupted,
  error: 'decoding'
};
const DESERIALIZATION_ERROR = {
  kind: _types.TokenKind.corrupted,
  error: 'deserialization'
};
const PAYLOAD_ERROR = {
  kind: _types.TokenKind.corrupted,
  error: 'payload'
};
const VERSION_ERROR = {
  kind: _types.TokenKind.corrupted,
  error: 'version'
};
let validationPerformed = false;
// verifies RSASSA-PKCS1-v1.5 signature
function verifySignature(_ref) {
  let {
    text,
    signature: encodedSignature
  } = _ref;
  return (0, _rsa_bigint.compareSignatures)({
    key: _key.PUBLIC_KEY,
    signature: (0, _byte_utils.base64ToBytes)(encodedSignature),
    actual: (0, _pkcs.pad)((0, _sha.sha1)(text))
  });
}
function parseLicenseKey(encodedKey) {
  if (encodedKey === undefined) {
    return GENERAL_ERROR;
  }
  const parts = encodedKey.split(KEY_SPLITTER);
  if (parts.length !== 2 || parts[0].length === 0 || parts[1].length === 0) {
    return GENERAL_ERROR;
  }
  if (!verifySignature({
    text: parts[0],
    signature: parts[1]
  })) {
    return VERIFICATION_ERROR;
  }
  let decodedPayload = '';
  try {
    decodedPayload = atob(parts[0]);
  } catch {
    return DECODING_ERROR;
  }
  let payload = {};
  try {
    payload = JSON.parse(decodedPayload);
  } catch {
    return DESERIALIZATION_ERROR;
  }
  const {
      customerId,
      maxVersionAllowed,
      format,
      internalUsageId
    } = payload,
    rest = _objectWithoutPropertiesLoose(payload, _excluded);
  if (internalUsageId !== undefined) {
    return {
      kind: _types.TokenKind.internal,
      internalUsageId
    };
  }
  if (customerId === undefined || maxVersionAllowed === undefined || format === undefined) {
    return PAYLOAD_ERROR;
  }
  if (format !== FORMAT) {
    return VERSION_ERROR;
  }
  return {
    kind: _types.TokenKind.verified,
    payload: _extends({
      customerId,
      maxVersionAllowed
    }, rest)
  };
}
function isPreview(patch) {
  return isNaN(patch) || patch < RTM_MIN_PATCH_VERSION;
}
function getLicenseCheckParams(_ref2) {
  let {
    licenseKey,
    version
  } = _ref2;
  let preview = false;
  try {
    preview = isPreview(version.patch);
    const {
      major,
      minor
    } = preview ? (0, _version2.getPreviousMajorVersion)(version) : version;
    if (!licenseKey) {
      return {
        preview,
        error: 'W0019'
      };
    }
    const license = parseLicenseKey(licenseKey);
    if (license.kind === _types.TokenKind.corrupted) {
      return {
        preview,
        error: 'W0021'
      };
    }
    if (license.kind === _types.TokenKind.internal) {
      return {
        preview,
        internal: true,
        error: license.internalUsageId === _key.INTERNAL_USAGE_ID ? undefined : 'W0020'
      };
    }
    if (!(major && minor)) {
      return {
        preview,
        error: 'W0021'
      };
    }
    if (major * 10 + minor > license.payload.maxVersionAllowed) {
      return {
        preview,
        error: 'W0020'
      };
    }
    return {
      preview,
      error: undefined
    };
  } catch {
    return {
      preview,
      error: 'W0021'
    };
  }
}
function validateLicense(licenseKey) {
  let versionStr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _version.fullVersion;
  if (validationPerformed) {
    return;
  }
  validationPerformed = true;
  const version = (0, _version2.parseVersion)(versionStr);
  const versionsCompatible = (0, _version2.assertedVersionsCompatible)(version);
  const {
    internal,
    error
  } = getLicenseCheckParams({
    licenseKey,
    version
  });
  if (!versionsCompatible && internal) {
    return;
  }
  if (error && !internal) {
    (0, _trial_panel.showTrialPanel)((0, _config.default)().buyNowLink ?? BUY_NOW_LINK, _version.fullVersion);
  }
  const preview = isPreview(version.patch);
  if (error) {
    _errors.default.log(preview ? 'W0022' : error);
    return;
  }
  if (preview && !internal) {
    _errors.default.log('W0022');
  }
}
function peekValidationPerformed() {
  return validationPerformed;
}
function setLicenseCheckSkipCondition() {
  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
}
// NOTE: We need this default export
// to allow QUnit mock the validateLicense function
var _default = exports["default"] = {
  validateLicense
};

/***/ }),

/***/ 95373:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.pad = pad;
var _byte_utils = __webpack_require__(97522);
var _key = __webpack_require__(41402);
// see https://datatracker.ietf.org/doc/html/rfc8017#page-47
const ASN1_SHA1 = '3021300906052b0e03021a05000414';
// PKCS #1 v1.5
// 0x00 0x01 P 0x00 A H
// P - padding string (0xff...0xff)
// A - ASN.1 encoding of the hash algorithm used
// H - hash value
function pad(hash) {
  const dataLength = (_key.PUBLIC_KEY.n.length * 8 + 6) / 8;
  const data = (0, _byte_utils.concatBytes)((0, _byte_utils.hexToBytes)(ASN1_SHA1), hash);
  if (data.length + 10 > dataLength) {
    throw Error('Key is too short for SHA1 signing algorithm');
  }
  const padding = new Uint8Array(dataLength - data.length);
  padding.fill(0xff, 0, padding.length - 1);
  padding[0] = 0;
  padding[1] = 1;
  padding[padding.length - 1] = 0;
  return (0, _byte_utils.concatBytes)(padding, data);
}

/***/ }),

/***/ 25746:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.compareSignatures = compareSignatures;
function compareSignatures(args) {
  try {
    const zero = BigInt(0);
    const one = BigInt(1);
    const eight = BigInt(8);
    const modExp = (base, exponent, modulus) => {
      let result = one;
      let b = base;
      let e = exponent;
      while (e) {
        if (e & one) {
          // eslint-disable-line no-bitwise
          result = result * b % modulus;
        }
        b = b * b % modulus;
        e >>= one; // eslint-disable-line no-bitwise
      }
      return result;
    };
    const bigIntFromBytes = bytes => bytes.reduce((acc, cur) => (acc << eight) + BigInt(cur),
    // eslint-disable-line no-bitwise
    zero);
    const actual = bigIntFromBytes(args.actual);
    const signature = bigIntFromBytes(args.signature);
    const exponent = BigInt(args.key.e);
    const modulus = bigIntFromBytes(args.key.n);
    const expected = modExp(signature, exponent, modulus);
    return expected === actual;
  } catch {
    return true;
  }
}

/***/ }),

/***/ 13082:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.preprocess = preprocess;
exports.sha1 = sha1;
var _byte_utils = __webpack_require__(97522);
/* eslint-disable no-bitwise */

function preprocess(text) {
  const bytes = new Uint8Array(text.length + 1);
  bytes.set((0, _byte_utils.stringToBytes)(text));
  bytes[bytes.length - 1] = 0x80;
  const words = (0, _byte_utils.bytesToWords)(new Uint8Array(bytes));
  const result = new Uint32Array(Math.ceil((words.length + 2) / 16) * 16);
  result.set(words, 0);
  result[result.length - 1] = (bytes.length - 1) * 8;
  return result;
}
function sha1(text) {
  const message = preprocess(text);
  const h = new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
  for (let i = 0; i < message.length; i += 16) {
    const w = new Uint32Array(80);
    for (let j = 0; j < 16; j += 1) {
      w[j] = message[i + j];
    }
    for (let j = 16; j < 80; j += 1) {
      const n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
      w[j] = n << 1 | n >>> 31;
    }
    let a = h[0];
    let b = h[1];
    let c = h[2];
    let d = h[3];
    let e = h[4];
    for (let j = 0; j < 80; j += 1) {
      const [f, k] = j < 20 ? [b & c | ~b & d, 0x5A827999] // eslint-disable-line no-nested-ternary, max-len
      : j < 40 ? [b ^ c ^ d, 0x6ED9EBA1] // eslint-disable-line no-nested-ternary, max-len
      : j < 60 ? [b & c | b & d | c & d, 0x8F1BBCDC] // eslint-disable-line no-nested-ternary, max-len
      : [b ^ c ^ d, 0xCA62C1D6];
      const temp = (0, _byte_utils.leftRotate)(a, 5) + f + e + k + w[j];
      e = d;
      d = c;
      c = (0, _byte_utils.leftRotate)(b, 30);
      b = a;
      a = temp;
    }
    h[0] += a;
    h[1] += b;
    h[2] += c;
    h[3] += d;
    h[4] += e;
  }
  return (0, _byte_utils.wordsToBytes)(h);
}

/***/ }),

/***/ 45053:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isClient = exports.BASE_Z_INDEX = void 0;
exports.registerCustomComponents = registerCustomComponents;
exports.renderTrialPanel = renderTrialPanel;
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
/* eslint-disable max-classes-per-file */
/* eslint no-restricted-imports: ["error", { "patterns": ["*"] }] */
const BASE_Z_INDEX = exports.BASE_Z_INDEX = 1500;
const isClient = () => typeof HTMLElement !== 'undefined';
exports.isClient = isClient;
const SafeHTMLElement = isClient() ? HTMLElement
// eslint-disable-next-line max-len
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-extraneous-class
: class {};
const DATA_PERMANENT_ATTRIBUTE = 'data-permanent';
const componentNames = {
  trigger: 'dx-license-trigger',
  panel: 'dx-license'
};
const attributeNames = {
  buyNow: 'buy-now',
  version: 'version'
};
const commonStyles = {
  opacity: '1',
  visibility: 'visible',
  'clip-path': 'none',
  filter: 'none'
};
const contentStyles = _extends({}, commonStyles, {
  width: '100%',
  height: 'auto',
  'line-height': 'normal',
  display: 'block',
  'z-index': `${BASE_Z_INDEX}`,
  position: 'static',
  transform: 'translate(0px, 0px)',
  'background-color': '#FF7200',
  border: 'none',
  margin: 'auto',
  'box-sizing': 'border-box',
  'text-align': 'center'
});
const containerStyles = _extends({}, contentStyles, {
  display: 'flex',
  'align-items': 'center',
  'flex-direction': 'row',
  position: 'relative',
  top: '0px',
  left: '0px',
  padding: '0.5rem'
});
const buttonStyles = {
  width: '1rem',
  cursor: 'pointer',
  height: '1rem'
};
const textStyles = _extends({}, commonStyles, {
  display: 'inline',
  position: 'static',
  padding: '0px',
  margin: '0px',
  color: 'white',
  'font-family': '\'Segoe UI\',\'Open Sans Condensed\',-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,Cantarell,Ubuntu,roboto,noto,arial,sans-serif',
  'font-size': '0.875rem',
  'font-wight': '600'
});
function createImportantStyles(defaultStyles, customStyles) {
  const styles = customStyles ? _extends({}, defaultStyles, customStyles) : defaultStyles;
  return Object.keys(styles).reduce((cssString, currentKey) => `${cssString}${[currentKey, `${styles[currentKey]} !important;`].join(': ')}`, '');
}
class DxLicense extends SafeHTMLElement {
  constructor() {
    var _DxLicense$customStyl, _DxLicense$customStyl2, _DxLicense$customStyl3, _DxLicense$customStyl4, _DxLicense$customStyl5;
    super();
    this._observer = null;
    this._inReassign = false;
    this._hidden = false;
    this._spanStyles = createImportantStyles(textStyles, (_DxLicense$customStyl = DxLicense.customStyles) === null || _DxLicense$customStyl === void 0 ? void 0 : _DxLicense$customStyl.textStyles);
    this._linkStyles = createImportantStyles(textStyles, (_DxLicense$customStyl2 = DxLicense.customStyles) === null || _DxLicense$customStyl2 === void 0 ? void 0 : _DxLicense$customStyl2.linkStyles);
    this._containerStyles = createImportantStyles(containerStyles, (_DxLicense$customStyl3 = DxLicense.customStyles) === null || _DxLicense$customStyl3 === void 0 ? void 0 : _DxLicense$customStyl3.containerStyles);
    this._contentStyles = createImportantStyles(contentStyles, (_DxLicense$customStyl4 = DxLicense.customStyles) === null || _DxLicense$customStyl4 === void 0 ? void 0 : _DxLicense$customStyl4.contentStyles);
    this._buttonStyles = createImportantStyles(buttonStyles, (_DxLicense$customStyl5 = DxLicense.customStyles) === null || _DxLicense$customStyl5 === void 0 ? void 0 : _DxLicense$customStyl5.contentStyles);
  }
  _createSpan(text) {
    const span = document.createElement('span');
    span.innerText = text;
    span.style.cssText = this._spanStyles;
    return span;
  }
  _createLink(text, href) {
    const link = document.createElement('a');
    link.innerText = text;
    link.style.cssText = this._linkStyles;
    link.href = href;
    link.target = '_blank';
    return link;
  }
  _createButton() {
    const button = document.createElement('div');
    button.style.cssText = this._buttonStyles;
    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    polygon.setAttribute('points', '13.4 12.7 8.7 8 13.4 3.4 12.6 2.6 8 7.3 3.4 2.6 2.6 3.4 7.3 8 2.6 12.6 3.4 13.4 8 8.7 12.7 13.4 13.4 12.7');
    polygon.style.cssText = createImportantStyles({
      fill: '#fff',
      opacity: '.5',
      'stroke-width': '0px'
    });
    svg.setAttribute('id', 'Layer_1');
    svg.setAttribute('data-name', 'Layer 1');
    svg.setAttribute('version', '1.1');
    svg.setAttribute('viewBox', '0 0 16 16');
    svg.style.cssText = createImportantStyles({
      'vertical-align': 'baseline'
    });
    svg.appendChild(polygon);
    button.appendChild(svg);
    button.onclick = () => {
      this._hidden = true;
      this.style.cssText = createImportantStyles({
        display: 'none'
      });
    };
    return button;
  }
  _createContentContainer() {
    const contentContainer = document.createElement('div');
    contentContainer.style.cssText = this._contentStyles;
    contentContainer.append(this._createSpan('For evaluation purposes only. Redistribution not authorized. Please '), this._createLink('purchase a license', this.getAttribute(attributeNames.buyNow)), this._createSpan(` to continue use of DevExpress product libraries (v${this.getAttribute(attributeNames.version)}).`));
    return contentContainer;
  }
  _reassignComponent() {
    this.innerHTML = '';
    this.style.cssText = this._containerStyles;
    this.append(this._createContentContainer(), this._createButton());
  }
  connectedCallback() {
    this._reassignComponent();
    if (!this._observer) {
      this._observer = new MutationObserver(() => {
        if (this._hidden) {
          var _this$_observer;
          (_this$_observer = this._observer) === null || _this$_observer === void 0 || _this$_observer.disconnect();
          return;
        }
        if (this._inReassign) {
          this._inReassign = false;
        } else {
          this._inReassign = true;
          this._reassignComponent();
        }
      });
      this._observer.observe(this, {
        childList: true,
        attributes: true,
        // eslint-disable-next-line spellcheck/spell-checker
        subtree: true
      });
    }
  }
  disconnectedCallback() {
    setTimeout(() => {
      const licensePanel = document.getElementsByTagName(componentNames.panel);
      if (!licensePanel.length) {
        document.body.prepend(this);
      }
    }, 100);
  }
}
DxLicense.customStyles = undefined;
class DxLicenseTrigger extends SafeHTMLElement {
  connectedCallback() {
    this.style.cssText = createImportantStyles({
      display: 'none'
    });
    const licensePanel = document.getElementsByTagName(componentNames.panel);
    if (!licensePanel.length) {
      const license = document.createElement(componentNames.panel);
      license.setAttribute(attributeNames.version, this.getAttribute(attributeNames.version));
      license.setAttribute(attributeNames.buyNow, this.getAttribute(attributeNames.buyNow));
      license.setAttribute(DATA_PERMANENT_ATTRIBUTE, 'true');
      document.body.prepend(license);
    }
  }
}
function registerCustomComponents(customStyles) {
  if (!customElements.get(componentNames.trigger)) {
    DxLicense.customStyles = customStyles;
    customElements.define(componentNames.trigger, DxLicenseTrigger);
    customElements.define(componentNames.panel, DxLicense);
  }
}
function renderTrialPanel(buyNowUrl, version, customStyles) {
  registerCustomComponents(customStyles);
  const trialPanelTrigger = document.createElement(componentNames.trigger);
  trialPanelTrigger.setAttribute(attributeNames.buyNow, buyNowUrl);
  trialPanelTrigger.setAttribute(attributeNames.version, version);
  document.body.appendChild(trialPanelTrigger);
}

/***/ }),

/***/ 84814:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.registerTrialPanelComponents = registerTrialPanelComponents;
exports.showTrialPanel = showTrialPanel;
var _trial_panel = __webpack_require__(45053);
function showTrialPanel(buyNowUrl, version, customStyles) {
  if ((0, _trial_panel.isClient)()) {
    (0, _trial_panel.renderTrialPanel)(buyNowUrl, version, customStyles);
  }
}
function registerTrialPanelComponents(customStyles) {
  if ((0, _trial_panel.isClient)()) {
    (0, _trial_panel.registerCustomComponents)(customStyles);
  }
}

/***/ }),

/***/ 13004:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TokenKind = void 0;
var TokenKind;
(function (TokenKind) {
  TokenKind["corrupted"] = "corrupted";
  TokenKind["verified"] = "verified";
  TokenKind["internal"] = "internal";
})(TokenKind || (exports.TokenKind = TokenKind = {}));

/***/ }),

/***/ 24321:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.dateUtilsTs = void 0;
// TODO Vinogradov: Refactor offsets: number[] -> ...offsets: number[]
const addOffsets = (date, offsets) => {
  const newDateMs = offsets.reduce((result, offset) => result + offset, date.getTime());
  return new Date(newDateMs);
};
const dateUtilsTs = exports.dateUtilsTs = {
  addOffsets
};

/***/ }),

/***/ 55634:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Component = void 0;
var _action = _interopRequireDefault(__webpack_require__(62414));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _config = _interopRequireDefault(__webpack_require__(80209));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _events_strategy = __webpack_require__(80566);
var _index = __webpack_require__(95683);
var _utils = __webpack_require__(45434);
var _postponed_operations = __webpack_require__(90889);
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _common = __webpack_require__(20576);
var _data = __webpack_require__(47617);
var _extend = __webpack_require__(13306);
var _public_component = __webpack_require__(9321);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable max-classes-per-file */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable consistent-return */
/* eslint-disable no-param-reassign */
/* eslint-disable @typescript-eslint/init-declarations */
/* eslint-disable no-plusplus */
/* eslint-disable @typescript-eslint/prefer-for-of */
/* eslint-disable @typescript-eslint/no-unused-expressions */
/* eslint-disable default-case */
/* eslint-disable @typescript-eslint/prefer-optional-chain */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/restrict-plus-operands */
/* eslint-disable @typescript-eslint/explicit-function-return-type */

const getEventName = actionName => actionName.charAt(2).toLowerCase() + actionName.substr(3);
const isInnerOption = optionName => optionName.indexOf('_', 0) === 0;
class Component extends _class.default.inherit({}) {
  _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  }
  _getDeprecatedOptions() {
    return this._deprecatedOptions;
  }
  _getDefaultOptions() {
    return {
      onInitialized: null,
      onOptionChanged: null,
      onDisposing: null,
      defaultOptionsRules: null
    };
  }
  _defaultOptionsRules() {
    return [];
  }
  _setOptionsByDevice(rules) {
    this._options.applyRules(rules);
  }
  _convertRulesToOptions(rules) {
    return (0, _utils.convertRulesToOptions)(rules);
  }
  _isInitialOptionValue(name) {
    return this._options.isInitial(name);
  }
  _setOptionsByReference() {
    this._optionsByReference = {};
  }
  _getOptionsByReference() {
    return this._optionsByReference;
  }
  ctor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      _optionChangedCallbacks,
      _disposingCallbacks
    } = options;
    this.NAME = (0, _public_component.name)(this.constructor);
    this._eventsStrategy = _events_strategy.EventsStrategy.create(this, options.eventsStrategy);
    this._updateLockCount = 0;
    this._optionChangedCallbacks = _optionChangedCallbacks || (0, _callbacks.default)();
    this._disposingCallbacks = _disposingCallbacks || (0, _callbacks.default)();
    this.postponedOperations = new _postponed_operations.PostponedOperations();
    this._createOptions(options);
  }
  _createOptions(options) {
    this.beginUpdate();
    try {
      this._setOptionsByReference();
      this._setDeprecatedOptions();
      this._options = new _index.Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
      this._options.onChanging((name, previousValue, value) => this._initialized && this._optionChanging(name, previousValue, value));
      this._options.onDeprecated((option, info) => this._logDeprecatedOptionWarning(option, info));
      this._options.onChanged((name, value, previousValue) => this._notifyOptionChanged(name, value, previousValue));
      this._options.onStartChange(() => this.beginUpdate());
      this._options.onEndChange(() => this.endUpdate());
      this._options.addRules(this._defaultOptionsRules());
      if (options && options.onInitializing) {
        options.onInitializing.apply(this, [options]);
      }
      this._setOptionsByDevice(options.defaultOptionsRules);
      this._initOptions(options);
    } finally {
      this.endUpdate();
    }
  }
  _initOptions(options) {
    this.option(options);
  }
  _init() {
    this._createOptionChangedAction();
    this.on('disposing', args => {
      this._disposingCallbacks.fireWith(this, [args]);
    });
  }
  _logDeprecatedOptionWarning(option, info) {
    const message = info.message || `Use the '${info.alias}' option instead`;
    _errors.default.log('W0001', this.NAME, option, info.since, message);
  }
  _logDeprecatedComponentWarning(since, alias) {
    _errors.default.log('W0000', this.NAME, since, `Use the '${alias}' widget instead`);
  }
  _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption('onOptionChanged', {
      excludeValidators: ['disabled', 'readOnly']
    });
  }
  _createDisposingAction() {
    this._disposingAction = this._createActionByOption('onDisposing', {
      excludeValidators: ['disabled', 'readOnly']
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case 'onDisposing':
      case 'onInitialized':
        break;
      case 'onOptionChanged':
        this._createOptionChangedAction();
        break;
      case 'defaultOptionsRules':
        break;
    }
  }
  _dispose() {
    this._optionChangedCallbacks.empty();
    this._createDisposingAction();
    this._disposingAction();
    this._eventsStrategy.dispose();
    this._options.dispose();
    this._disposed = true;
  }
  _lockUpdate() {
    this._updateLockCount++;
  }
  _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  }
  // TODO: remake as getter after ES6 refactor
  _isUpdateAllowed() {
    return this._updateLockCount === 0;
  }
  // TODO: remake as getter after ES6 refactor
  _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  }
  isInitialized() {
    return this._initialized;
  }
  _commitUpdate() {
    this.postponedOperations.callPostponedOperations();
    this._isInitializingRequired() && this._initializeComponent();
  }
  _initializeComponent() {
    this._initializing = true;
    try {
      this._init();
    } finally {
      this._initializing = false;
      this._lockUpdate();
      this._createActionByOption('onInitialized', {
        excludeValidators: ['disabled', 'readOnly']
      })();
      this._unlockUpdate();
      this._initialized = true;
    }
  }
  instance() {
    return this;
  }
  beginUpdate() {
    this._lockUpdate();
  }
  endUpdate() {
    this._unlockUpdate();
    this._isUpdateAllowed() && this._commitUpdate();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _optionChanging() {}
  _notifyOptionChanged(option, value, previousValue) {
    if (this._initialized) {
      const optionNames = [option].concat(this._options.getAliasesByName(option));
      for (let i = 0; i < optionNames.length; i++) {
        const name = optionNames[i];
        const args = {
          name: (0, _data.getPathParts)(name)[0],
          fullName: name,
          value,
          previousValue
        };
        if (!isInnerOption(name)) {
          this._optionChangedCallbacks.fireWith(this, [(0, _extend.extend)(this._defaultActionArgs(), args)]);
          this._optionChangedAction((0, _extend.extend)({}, args));
        }
        if (!this._disposed && this._cancelOptionChange !== name) {
          this._optionChanged(args);
        }
      }
    }
  }
  initialOption(name) {
    return this._options.initial(name);
  }
  _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  }
  _defaultActionArgs() {
    return {
      component: this
    };
  }
  _createAction(actionSource, config) {
    let action;
    return e => {
      if (!(0, _type.isDefined)(e)) {
        e = {};
      }
      if (!(0, _type.isPlainObject)(e)) {
        e = {
          actionValue: e
        };
      }
      action = action || new _action.default(actionSource, (0, _extend.extend)({}, config, this._defaultActionConfig()));
      return action.execute.call(action, (0, _extend.extend)(e, this._defaultActionArgs()));
    };
  }
  _createActionByOption(optionName, config) {
    var _this = this;
    let action;
    let eventName;
    let actionFunc;
    config = (0, _extend.extend)({}, config);
    const result = function () {
      if (!eventName) {
        config = config || {};
        if (typeof optionName !== 'string') {
          throw _errors.default.Error('E0008');
        }
        if (optionName.startsWith('on')) {
          eventName = getEventName(optionName);
        }
        actionFunc = _this.option(optionName);
      }
      if (!action && !actionFunc && !config.beforeExecute && !config.afterExecute && !_this._eventsStrategy.hasEvent(eventName)) {
        return;
      }
      if (!action) {
        const {
          beforeExecute
        } = config;
        config.beforeExecute = function () {
          for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            props[_key2] = arguments[_key2];
          }
          beforeExecute && beforeExecute.apply(_this, props);
          _this._eventsStrategy.fireEvent(eventName, props[0].args);
        };
        action = _this._createAction(actionFunc, config);
      }
      // @ts-expect-error
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if ((0, _config.default)().wrapActionsBeforeExecute) {
        const beforeActionExecute = _this.option('beforeActionExecute') || _common.noop;
        const wrappedAction = beforeActionExecute(_this, action, config) || action;
        return wrappedAction.apply(_this, args);
      }
      return action.apply(_this, args);
    };
    // @ts-expect-error
    if ((0, _config.default)().wrapActionsBeforeExecute) {
      return result;
    }
    const onActionCreated = this.option('onActionCreated') || _common.noop;
    return onActionCreated(this, result, config) || result;
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
  hasActionSubscription(actionName) {
    return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName));
  }
  isOptionDeprecated(name) {
    return this._options.isDeprecated(name);
  }
  _setOptionWithoutOptionChange(name, value) {
    this._cancelOptionChange = name;
    this.option(name, value);
    this._cancelOptionChange = false;
  }
  _getOptionValue(name, context) {
    const value = this.option(name);
    if ((0, _type.isFunction)(value)) {
      return value.bind(context)();
    }
    return value;
  }
  option() {
    return this._options.option(...arguments);
  }
  resetOption(name) {
    this.beginUpdate();
    this._options.reset(name);
    this.endUpdate();
  }
}
exports.Component = Component;

/***/ }),

/***/ 29783:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _element = __webpack_require__(6415);
var _element_data = __webpack_require__(97906);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _template_manager = __webpack_require__(14192);
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _public_component = __webpack_require__(9321);
var _resize_callbacks = _interopRequireDefault(__webpack_require__(55814));
var _shadow_dom = __webpack_require__(90330);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _short = __webpack_require__(72918);
var _license_validation = _interopRequireWildcard(__webpack_require__(77685));
var _component = __webpack_require__(55634);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable no-plusplus */
/* eslint-disable consistent-return */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable new-cap */
/* eslint-disable no-void */
/* eslint-disable no-return-assign */
/* eslint-disable @typescript-eslint/no-shadow */
/* eslint-disable @typescript-eslint/prefer-optional-chain */
/* eslint-disable @typescript-eslint/no-unused-expressions */
/* eslint-disable no-multi-assign */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-unsafe-return */

// @ts-expect-error

class DOMComponent extends _component.Component {
  static getInstance(element) {
    return (0, _public_component.getInstanceByElement)((0, _renderer.default)(element), this);
  }
  static defaultOptions(rule) {
    this._classCustomRules = Object.hasOwnProperty.bind(this)('_classCustomRules') && this._classCustomRules ? this._classCustomRules : [];
    this._classCustomRules.push(rule);
  }
  _getDefaultOptions() {
    return (0, _extend.extend)(super._getDefaultOptions(), {
      width: undefined,
      height: undefined,
      rtlEnabled: (0, _config.default)().rtlEnabled,
      elementAttr: {},
      disabled: false,
      integrationOptions: {}
      // @ts-expect-error
    }, this._useTemplates() ? _template_manager.TemplateManager.createDefaultOptions() : {});
  }
  // @ts-expect-error
  ctor(element, options) {
    this._customClass = null;
    this._createElement(element);
    (0, _public_component.attachInstanceToElement)(this._$element, this, this._dispose);
    super.ctor(options);
    const validationAlreadyPerformed = (0, _license_validation.peekValidationPerformed)();
    // @ts-expect-error
    _license_validation.default.validateLicense((0, _config.default)().licenseKey);
    if (!validationAlreadyPerformed && (0, _license_validation.peekValidationPerformed)()) {
      (0, _config.default)({
        licenseKey: ''
      });
    }
  }
  _createElement(element) {
    this._$element = (0, _renderer.default)(element);
  }
  _getSynchronizableOptionsForCreateComponent() {
    return ['rtlEnabled', 'disabled', 'templatesRenderAsynchronously'];
  }
  _checkFunctionValueDeprecation(optionNames) {
    if (!this.option('_ignoreFunctionValueDeprecation')) {
      optionNames.forEach(optionName => {
        if ((0, _type.isFunction)(this.option(optionName))) {
          _errors.default.log('W0017', optionName);
        }
      });
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _visibilityChanged(value) {}
  _dimensionChanged() {}
  _init() {
    super._init();
    this._checkFunctionValueDeprecation(['width', 'height', 'maxHeight', 'maxWidth', 'minHeight', 'minWidth', 'popupHeight', 'popupWidth']);
    this._attachWindowResizeCallback();
    this._initTemplateManager();
  }
  _setOptionsByDevice(instanceCustomRules) {
    // @ts-expect-error
    super._setOptionsByDevice([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []));
  }
  _isInitialOptionValue(name) {
    // @ts-expect-error
    const isCustomOption = this.constructor._classCustomRules
    // @ts-expect-error
    && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name);
    return !isCustomOption && super._isInitialOptionValue(name);
  }
  _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      const windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
      _resize_callbacks.default.add(windowResizeCallBack);
    }
  }
  _isDimensionChangeSupported() {
    return this._dimensionChanged !== DOMComponent.prototype._dimensionChanged;
  }
  _renderComponent() {
    (0, _shadow_dom.addShadowDomStyles)(this.$element());
    this._initMarkup();
    (0, _window.hasWindow)() && this._render();
  }
  _initMarkup() {
    const {
      rtlEnabled
    } = this.option() || {};
    this._renderElementAttributes();
    this._toggleRTLDirection(rtlEnabled);
    this._renderVisibilityChange();
    this._renderDimensions();
  }
  _render() {
    this._attachVisibilityChangeHandlers();
  }
  _renderElementAttributes() {
    const {
      elementAttr
    } = this.option() || {};
    const attributes = (0, _extend.extend)({}, elementAttr);
    const classNames = attributes.class;
    delete attributes.class;
    this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames);
    this._customClass = classNames;
  }
  _renderVisibilityChange() {
    if (this._isDimensionChangeSupported()) {
      this._attachDimensionChangeHandlers();
    }
    if (this._isVisibilityChangeSupported()) {
      const $element = this.$element();
      $element.addClass('dx-visibility-change-handler');
    }
  }
  _renderDimensions() {
    const $element = this.$element();
    const element = $element.get(0);
    const width = this._getOptionValue('width', element);
    const height = this._getOptionValue('height', element);
    if (this._isCssUpdateRequired(element, height, width)) {
      $element.css({
        width: width === null ? '' : width,
        height: height === null ? '' : height
      });
    }
  }
  _isCssUpdateRequired(element, height, width) {
    return !!((0, _type.isDefined)(width) || (0, _type.isDefined)(height) || element.style.width || element.style.height);
  }
  _attachDimensionChangeHandlers() {
    const $el = this.$element();
    const namespace = `${this.NAME}VisibilityChange`;
    _short.resize.off($el, {
      namespace
    });
    _short.resize.on($el, () => this._dimensionChanged(), {
      namespace
    });
  }
  _attachVisibilityChangeHandlers() {
    if (this._isVisibilityChangeSupported()) {
      const $el = this.$element();
      const namespace = `${this.NAME}VisibilityChange`;
      this._isHidden = !this._isVisible();
      _short.visibility.off($el, {
        namespace
      });
      _short.visibility.on($el, () => this._checkVisibilityChanged('shown'), () => this._checkVisibilityChanged('hiding'), {
        namespace
      });
    }
  }
  _isVisible() {
    const $element = this.$element();
    return $element.is(':visible');
  }
  _checkVisibilityChanged(action) {
    const isVisible = this._isVisible();
    if (isVisible) {
      if (action === 'hiding' && !this._isHidden) {
        this._visibilityChanged(false);
        this._isHidden = true;
      } else if (action === 'shown' && this._isHidden) {
        this._isHidden = false;
        this._visibilityChanged(true);
      }
    }
  }
  _isVisibilityChangeSupported() {
    return this._visibilityChanged !== DOMComponent.prototype._visibilityChanged && (0, _window.hasWindow)();
  }
  _clean() {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _modelByElement(element) {
    const {
      modelByElement
    } = this.option();
    const $element = this.$element();
    return modelByElement ? modelByElement($element) : undefined;
  }
  _invalidate() {
    if (this._isUpdateAllowed()) {
      throw _errors.default.Error('E0007');
    }
    this._requireRefresh = true;
  }
  _refresh() {
    this._clean();
    this._renderComponent();
  }
  _dispose() {
    this._templateManager && this._templateManager.dispose();
    super._dispose();
    this._clean();
    this._detachWindowResizeCallback();
  }
  _detachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      _resize_callbacks.default.remove(this._windowResizeCallBack);
    }
  }
  _toggleRTLDirection(rtl) {
    const $element = this.$element();
    $element.toggleClass('dx-rtl', rtl);
  }
  _createComponent(element, component) {
    let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const synchronizableOptions = (0, _common.grep)(this._getSynchronizableOptionsForCreateComponent(), value => !(value in config));
    const {
      integrationOptions
    } = this.option();
    let {
      nestedComponentOptions
    } = this.option();
    nestedComponentOptions = nestedComponentOptions || _common.noop;
    const nestedComponentConfig = (0, _extend.extend)({
      integrationOptions
    }, nestedComponentOptions(this));
    synchronizableOptions.forEach(optionName => nestedComponentConfig[optionName] = this.option(optionName));
    this._extendConfig(config, nestedComponentConfig);
    let instance = void 0;
    if ((0, _type.isString)(component)) {
      const $element = (0, _renderer.default)(element)[component](config);
      instance = $element[component]('instance');
    } else if (element) {
      instance = component.getInstance(element);
      if (instance) {
        // @ts-expect-error
        instance.option(config);
      } else {
        instance = new component(element, config);
      }
    }
    if (instance) {
      const optionChangedHandler = _ref => {
        let {
          name,
          value
        } = _ref;
        if (synchronizableOptions.includes(name)) {
          // @ts-expect-error
          instance.option(name, value);
        }
      };
      this.on('optionChanged', optionChangedHandler);
      // @ts-expect-error
      instance.on('disposing', () => this.off('optionChanged', optionChangedHandler));
    }
    return instance;
  }
  _extendConfig(config, extendConfig) {
    (0, _iterator.each)(extendConfig, (key, value) => {
      !Object.prototype.hasOwnProperty.call(config, key) && (config[key] = value);
    });
  }
  _defaultActionConfig() {
    const $element = this.$element();
    const context = this._modelByElement($element);
    return (0, _extend.extend)(super._defaultActionConfig(), {
      context
    });
  }
  _defaultActionArgs() {
    const $element = this.$element();
    const model = this._modelByElement($element);
    const element = this.element();
    return (0, _extend.extend)(super._defaultActionArgs(), {
      element,
      model
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case 'width':
      case 'height':
        this._renderDimensions();
        break;
      case 'rtlEnabled':
        this._invalidate();
        break;
      case 'elementAttr':
        this._renderElementAttributes();
        break;
      case 'disabled':
      case 'integrationOptions':
        break;
      default:
        super._optionChanged(args);
        break;
    }
  }
  _removeAttributes(element) {
    const attrs = element.attributes;
    for (let i = attrs.length - 1; i >= 0; i--) {
      const attr = attrs[i];
      if (attr) {
        const {
          name
        } = attr;
        if (!name.indexOf('aria-') || name.indexOf('dx-') !== -1 || name === 'role' || name === 'style' || name === 'tabindex') {
          element.removeAttribute(name);
        }
      }
    }
  }
  _removeClasses(element) {
    element.className = element.className.split(' ').filter(cssClass => cssClass.lastIndexOf('dx-', 0) !== 0).join(' ');
  }
  _updateDOMComponent(renderRequired) {
    if (renderRequired) {
      this._renderComponent();
    } else if (this._requireRefresh) {
      this._requireRefresh = false;
      this._refresh();
    }
  }
  endUpdate() {
    const renderRequired = this._isInitializingRequired();
    super.endUpdate();
    this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
  }
  $element() {
    return this._$element;
  }
  element() {
    const $element = this.$element();
    return (0, _element.getPublicElement)($element);
  }
  dispose() {
    const element = this.$element().get(0);
    (0, _element_data.cleanDataRecursive)(element, true);
    element.textContent = '';
    this._removeAttributes(element);
    this._removeClasses(element);
  }
  resetOption(optionName) {
    super.resetOption(optionName);
    if (optionName === 'width' || optionName === 'height') {
      const initialOption = this.initialOption(optionName);
      !(0, _type.isDefined)(initialOption) && this.$element().css(optionName, '');
    }
  }
  _getAnonymousTemplateName() {
    return void 0;
  }
  _initTemplateManager() {
    if (this._templateManager || !this._useTemplates()) return void 0;
    const {
      integrationOptions = {}
    } = this.option();
    const {
      createTemplate
    } = integrationOptions;
    this._templateManager = new _template_manager.TemplateManager(
    // @ts-expect-error
    createTemplate, this._getAnonymousTemplateName());
    this._initTemplates();
    return undefined;
  }
  _initTemplates() {
    const {
      templates,
      anonymousTemplateMeta
    } = this._templateManager.extractTemplates(this.$element());
    const anonymousTemplate = this.option(`integrationOptions.templates.${anonymousTemplateMeta.name}`);
    templates.forEach(_ref2 => {
      let {
        name,
        template
      } = _ref2;
      this._options.silent(`integrationOptions.templates.${name}`, template);
    });
    if (anonymousTemplateMeta.name && !anonymousTemplate) {
      this._options.silent(`integrationOptions.templates.${anonymousTemplateMeta.name}`, anonymousTemplateMeta.template);
      this._options.silent('_hasAnonymousTemplateContent', true);
    }
  }
  _getTemplateByOption(optionName) {
    return this._getTemplate(this.option(optionName));
  }
  _getTemplate(templateSource) {
    const templates = this.option('integrationOptions.templates');
    const isAsyncTemplate = this.option('templatesRenderAsynchronously');
    const skipTemplates = this.option('integrationOptions.skipTemplates');
    return this._templateManager.getTemplate(templateSource, templates, {
      isAsyncTemplate,
      skipTemplates
    }, this);
  }
  _saveTemplate(name, template) {
    this._setOptionWithoutOptionChange(`integrationOptions.templates.${name}`, this._templateManager._createTemplate(template));
  }
  _useTemplates() {
    return true;
  }
}
var _default = exports["default"] = DOMComponent;

/***/ }),

/***/ 94700:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(95429);
__webpack_require__(91633);
__webpack_require__(24028);
var _action = _interopRequireDefault(__webpack_require__(62414));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _version = __webpack_require__(58020);
var _short = __webpack_require__(72918);
var _selectors = __webpack_require__(31421);
var _dom_component = _interopRequireDefault(__webpack_require__(29783));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable consistent-return */
/* eslint-disable @typescript-eslint/no-invalid-this */
/* eslint-disable no-void */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/prefer-optional-chain */
/* eslint-disable @typescript-eslint/no-unused-expressions */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable no-param-reassign */
/* eslint-disable @typescript-eslint/explicit-function-return-type */

function setAttribute(name, value, target) {
  name = name === 'role' || name === 'id' ? name : `aria-${name}`;
  value = (0, _type.isDefined)(value) ? value.toString() : null;
  target.attr(name, value);
}
class Widget extends _dom_component.default {
  constructor() {
    super(...arguments);
    this._feedbackHideTimeout = 400;
    this._feedbackShowTimeout = 30;
  }
  static getOptionsFromContainer(_ref) {
    let {
      name,
      fullName,
      value
    } = _ref;
    let options = {};
    if (name === fullName) {
      options = value;
    } else {
      const option = fullName.split('.').pop();
      options[option] = value;
    }
    return options;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _supportedKeys(event) {
    return {};
  }
  _getDefaultOptions() {
    return (0, _extend.extend)(super._getDefaultOptions(), {
      hoveredElement: null,
      isActive: false,
      disabled: false,
      visible: true,
      hint: undefined,
      activeStateEnabled: false,
      onContentReady: null,
      hoverStateEnabled: false,
      focusStateEnabled: false,
      tabIndex: 0,
      accessKey: undefined,
      onFocusIn: null,
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: false,
      useResizeObserver: true
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const device = _devices.default.real();
        const {
          platform
        } = device;
        const {
          version
        } = device;
        return platform === 'ios' && (0, _version.compare)(version, '13.3') <= 0;
      },
      options: {
        useResizeObserver: false
      }
    }]);
  }
  _init() {
    super._init();
    this._initContentReadyAction();
  }
  _innerWidgetOptionChanged(innerWidget, args) {
    const options = Widget.getOptionsFromContainer(args);
    innerWidget && innerWidget.option(options);
    this._options.cache(args.name, options);
  }
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const syncOptions = () => this._options.silent(optionsContainer, (0, _extend.extend)({}, innerWidget.option()));
    syncOptions();
    innerWidget.on('optionChanged', syncOptions);
  }
  _getAriaTarget() {
    return this._focusTarget();
  }
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption('onContentReady', {
      excludeValidators: ['disabled', 'readOnly']
    });
  }
  _initMarkup() {
    const {
      disabled,
      visible
    } = this.option();
    this.$element().addClass('dx-widget');
    this._toggleDisabledState(disabled);
    this._toggleVisibility(visible);
    this._renderHint();
    this._isFocusable() && this._renderFocusTarget();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderContent();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
    this._toggleIndependentState();
  }
  _renderHint() {
    const {
      hint
    } = this.option();
    this.$element().attr('title', hint || null);
  }
  _renderContent() {
    (0, _common.deferRender)(() => !this._disposed ? this._renderContentImpl() : void 0)
    // @ts-expect-error
    .done(() => !this._disposed ? this._fireContentReadyAction() : void 0);
  }
  _renderContentImpl() {}
  _fireContentReadyAction() {
    return (0, _common.deferRender)(() => this._contentReadyAction());
  }
  _dispose() {
    this._contentReadyAction = null;
    this._detachKeyboardEvents();
    super._dispose();
  }
  _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), false);
  }
  _clean() {
    this._cleanFocusState();
    this._resetActiveState();
    super._clean();
    this.$element().empty();
  }
  _toggleVisibility(visible) {
    this.$element().toggleClass('dx-state-invisible', !visible);
  }
  _renderFocusState() {
    this._attachKeyboardEvents();
    if (this._isFocusable()) {
      this._renderFocusTarget();
      this._attachFocusEvents();
      this._renderAccessKey();
    }
  }
  _renderAccessKey() {
    const $el = this._focusTarget();
    const {
      accessKey
    } = this.option();
    $el.attr('accesskey', accessKey);
  }
  _isFocusable() {
    const {
      focusStateEnabled,
      disabled
    } = this.option();
    return focusStateEnabled && !disabled;
  }
  _eventBindingTarget() {
    return this.$element();
  }
  _focusTarget() {
    return this._getActiveElement();
  }
  _isFocusTarget(element) {
    const focusTargets = (0, _renderer.default)(this._focusTarget()).toArray();
    return focusTargets.includes(element);
  }
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit).not('.dx-state-disabled');
  }
  _getActiveElement() {
    const activeElement = this._eventBindingTarget();
    if (this._activeStateUnit) {
      return this._findActiveTarget(activeElement);
    }
    return activeElement;
  }
  _renderFocusTarget() {
    const {
      tabIndex
    } = this.option();
    this._focusTarget().attr('tabIndex', tabIndex);
  }
  _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  }
  _refreshFocusEvent() {
    this._detachFocusEvents();
    this._attachFocusEvents();
  }
  _focusEventTarget() {
    return this._focusTarget();
  }
  _focusInHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption('onFocusIn', {
        beforeExecute: () => this._updateFocusState(event, true),
        excludeValidators: ['readOnly']
      })({
        event
      });
    }
  }
  _focusOutHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption('onFocusOut', {
        beforeExecute: () => this._updateFocusState(event, false),
        excludeValidators: ['readOnly', 'disabled']
      })({
        event
      });
    }
  }
  _updateFocusState(_ref2, isFocused) {
    let {
      target
    } = _ref2;
    if (this._isFocusTarget(target)) {
      this._toggleFocusClass(isFocused, (0, _renderer.default)(target));
    }
  }
  _toggleFocusClass(isFocused, $element) {
    const $focusTarget = $element && $element.length ? $element : this._focusTarget();
    $focusTarget.toggleClass('dx-state-focused', isFocused);
  }
  _hasFocusClass(element) {
    const $focusTarget = (0, _renderer.default)(element || this._focusTarget());
    return $focusTarget.hasClass('dx-state-focused');
  }
  _isFocused() {
    return this._hasFocusClass();
  }
  _getKeyboardListeners() {
    return [];
  }
  _attachKeyboardEvents() {
    this._detachKeyboardEvents();
    const {
      focusStateEnabled,
      onKeyboardHandled
    } = this.option();
    const hasChildListeners = this._getKeyboardListeners().length;
    const hasKeyboardEventHandler = !!onKeyboardHandled;
    const shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
    if (shouldAttach) {
      this._keyboardListenerId = _short.keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), opts => this._keyboardHandler(opts));
    }
  }
  _keyboardHandler(options, onlyChildProcessing) {
    if (!onlyChildProcessing) {
      const {
        originalEvent,
        keyName,
        which
      } = options;
      const keys = this._supportedKeys(originalEvent);
      const func = keys[keyName] || keys[which];
      if (func !== undefined) {
        const handler = func.bind(this);
        const result = handler(originalEvent, options);
        if (!result) {
          return false;
        }
      }
    }
    const keyboardListeners = this._getKeyboardListeners();
    const {
      onKeyboardHandled
    } = this.option();
    keyboardListeners.forEach(listener => listener && listener._keyboardHandler(options));
    onKeyboardHandled && onKeyboardHandled(options);
    return true;
  }
  _refreshFocusState() {
    this._cleanFocusState();
    this._renderFocusState();
  }
  _cleanFocusState() {
    const $element = this._focusTarget();
    $element.removeAttr('tabIndex');
    this._toggleFocusClass(false);
    this._detachFocusEvents();
    this._detachKeyboardEvents();
  }
  _detachKeyboardEvents() {
    _short.keyboard.off(this._keyboardListenerId);
    this._keyboardListenerId = null;
  }
  _attachHoverEvents() {
    const {
      hoverStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const namespace = 'UIFeedback';
    const $el = this._eventBindingTarget();
    _short.hover.off($el, {
      selector,
      namespace
    });
    if (hoverStateEnabled) {
      _short.hover.on($el, new _action.default(_ref3 => {
        let {
          event,
          element
        } = _ref3;
        this._hoverStartHandler(event);
        this.option('hoveredElement', (0, _renderer.default)(element));
      }, {
        excludeValidators: ['readOnly']
      }), event => {
        this.option('hoveredElement', null);
        this._hoverEndHandler(event);
      }, {
        selector,
        namespace
      });
    }
  }
  _attachFeedbackEvents() {
    const {
      activeStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const namespace = 'UIFeedback';
    const $el = this._eventBindingTarget();
    _short.active.off($el, {
      namespace,
      selector
    });
    if (activeStateEnabled) {
      _short.active.on($el, new _action.default(_ref4 => {
        let {
          event,
          element
        } = _ref4;
        return this._toggleActiveState((0, _renderer.default)(element), true, event);
      }), new _action.default(_ref5 => {
        let {
          event,
          element
        } = _ref5;
        return this._toggleActiveState((0, _renderer.default)(element), false, event);
      }, {
        excludeValidators: ['disabled', 'readOnly']
      }), {
        showTimeout: this._feedbackShowTimeout,
        hideTimeout: this._feedbackHideTimeout,
        selector,
        namespace
      });
    }
  }
  _detachFocusEvents() {
    const $el = this._focusEventTarget();
    _short.focus.off($el, {
      namespace: `${this.NAME}Focus`
    });
  }
  _attachFocusEvents() {
    const $el = this._focusEventTarget();
    _short.focus.on($el, e => this._focusInHandler(e), e => this._focusOutHandler(e), {
      namespace: `${this.NAME}Focus`,
      // @ts-expect-error
      isFocusable: (index, el) => (0, _renderer.default)(el).is(_selectors.focusable)
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _hoverStartHandler(event) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _hoverEndHandler(event) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _toggleActiveState($element, value, event) {
    this.option('isActive', value);
    $element.toggleClass('dx-state-active', value);
  }
  _updatedHover() {
    const hoveredElement = this._options.silent('hoveredElement');
    this._hover(hoveredElement, hoveredElement);
  }
  _findHoverTarget($el) {
    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
  }
  _hover($el, $previous) {
    const {
      hoverStateEnabled,
      disabled,
      isActive
    } = this.option();
    $previous = this._findHoverTarget($previous);
    $previous && $previous.toggleClass('dx-state-hover', false);
    if ($el && hoverStateEnabled && !disabled && !isActive) {
      const newHoveredElement = this._findHoverTarget($el);
      newHoveredElement && newHoveredElement.toggleClass('dx-state-hover', true);
    }
  }
  _toggleDisabledState(value) {
    this.$element().toggleClass('dx-state-disabled', Boolean(value));
    this.setAria('disabled', value || undefined);
  }
  _toggleIndependentState() {
    this.$element().toggleClass('dx-state-independent', this.option('ignoreParentReadOnly'));
  }
  _setWidgetOption(widgetName, args) {
    if (!this[widgetName]) {
      return;
    }
    if ((0, _type.isPlainObject)(args[0])) {
      (0, _iterator.each)(args[0], (option, value) => this._setWidgetOption(widgetName, [option, value]));
      return;
    }
    const optionName = args[0];
    let value = args[1];
    if (args.length === 1) {
      value = this.option(optionName);
    }
    const widgetOptionMap = this[`${widgetName}OptionMap`];
    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value);
  }
  _optionChanged(args) {
    const {
      name,
      value,
      previousValue
    } = args;
    switch (name) {
      case 'disabled':
        this._toggleDisabledState(value);
        this._updatedHover();
        this._refreshFocusState();
        break;
      case 'hint':
        this._renderHint();
        break;
      case 'ignoreParentReadOnly':
        this._toggleIndependentState();
        break;
      case 'activeStateEnabled':
        this._attachFeedbackEvents();
        break;
      case 'hoverStateEnabled':
        this._attachHoverEvents();
        this._updatedHover();
        break;
      case 'tabIndex':
      case 'focusStateEnabled':
        this._refreshFocusState();
        break;
      case 'onFocusIn':
      case 'onFocusOut':
      case 'useResizeObserver':
        break;
      case 'accessKey':
        this._renderAccessKey();
        break;
      case 'hoveredElement':
        this._hover(value, previousValue);
        break;
      case 'isActive':
        this._updatedHover();
        break;
      case 'visible':
        this._toggleVisibility(value);
        if (this._isVisibilityChangeSupported()) {
          // TODO hiding works wrong
          this._checkVisibilityChanged(value ? 'shown' : 'hiding');
        }
        break;
      case 'onKeyboardHandled':
        this._attachKeyboardEvents();
        break;
      case 'onContentReady':
        this._initContentReadyAction();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _isVisible() {
    const {
      visible
    } = this.option();
    return super._isVisible() && visible;
  }
  beginUpdate() {
    this._ready(false);
    super.beginUpdate();
  }
  endUpdate() {
    super.endUpdate();
    if (this._initialized) {
      this._ready(true);
    }
  }
  _ready(value) {
    if (arguments.length === 0) {
      return this._isReady;
    }
    this._isReady = value;
  }
  setAria() {
    if (!(0, _type.isPlainObject)(arguments.length <= 0 ? undefined : arguments[0])) {
      setAttribute(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], (arguments.length <= 2 ? undefined : arguments[2]) || this._getAriaTarget());
    } else {
      const target = (arguments.length <= 1 ? undefined : arguments[1]) || this._getAriaTarget();
      (0, _iterator.each)(arguments.length <= 0 ? undefined : arguments[0], (name, value) => setAttribute(name, value, target));
    }
  }
  isReady() {
    return this._ready();
  }
  repaint() {
    this._refresh();
  }
  focus() {
    _short.focus.trigger(this._focusTarget());
  }
  registerKeyHandler(key, handler) {
    const currentKeys = this._supportedKeys();
    this._supportedKeys = () => (0, _extend.extend)(currentKeys, {
      [key]: handler
    });
  }
}
var _default = exports["default"] = Widget;

/***/ }),

/***/ 77881:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DataSource = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _events_strategy = __webpack_require__(80566);
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _queue = __webpack_require__(59504);
var _type = __webpack_require__(35922);
var _array_utils = __webpack_require__(60637);
var _custom_store = _interopRequireDefault(__webpack_require__(88036));
var _operation_manager = _interopRequireDefault(__webpack_require__(88665));
var _utils = __webpack_require__(9234);
var _errors = __webpack_require__(18438);
var _utils2 = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } // @ts-expect-error
// @ts-expect-error
// @ts-expect-error
const DataSource = exports.DataSource = _class.default.inherit({
  ctor(options) {
    // @ts-expect-error
    options = (0, _utils.normalizeDataSourceOptions)(options);
    this._eventsStrategy = new _events_strategy.EventsStrategy(this, {
      syncStrategy: true
    });
    this._store = options.store;
    this._changedTime = 0;
    const needThrottling = options.pushAggregationTimeout !== 0;
    if (needThrottling) {
      const throttlingTimeout = options.pushAggregationTimeout === undefined ? () => this._changedTime * 5 : options.pushAggregationTimeout;
      let pushDeferred;
      let lastPushWaiters;
      const throttlingPushHandler = (0, _utils2.throttleChanges)(changes => {
        pushDeferred.resolve();
        const storePushPending = (0, _deferred.when)(...lastPushWaiters);
        storePushPending.done(() => this._onPush(changes));
        lastPushWaiters = undefined;
        pushDeferred = undefined;
      }, throttlingTimeout);
      this._onPushHandler = args => {
        this._aggregationTimeoutId = throttlingPushHandler(args.changes);
        if (!pushDeferred) {
          // @ts-expect-error
          pushDeferred = new _deferred.Deferred();
        }
        lastPushWaiters = args.waitFor;
        args.waitFor.push(pushDeferred.promise());
      };
      this._store.on('beforePushAggregation', this._onPushHandler);
    } else {
      this._onPushHandler = changes => this._onPush(changes);
      this._store.on('push', this._onPushHandler);
    }
    this._storeLoadOptions = this._extractLoadOptions(options);
    this._mapFunc = options.map;
    this._postProcessFunc = options.postProcess;
    this._pageIndex = options.pageIndex !== undefined ? options.pageIndex : 0;
    this._pageSize = options.pageSize !== undefined ? options.pageSize : 20;
    this._loadingCount = 0;
    this._loadQueue = this._createLoadQueue();
    this._searchValue = 'searchValue' in options ? options.searchValue : null;
    this._searchOperation = options.searchOperation || 'contains';
    this._searchExpr = options.searchExpr;
    this._paginate = options.paginate;
    this._reshapeOnPush = options.reshapeOnPush ?? false;
    (0, _iterator.each)(['onChanged', 'onLoadError', 'onLoadingChanged', 'onCustomizeLoadResult', 'onCustomizeStoreLoadOptions'], (_, optionName) => {
      if (optionName in options) {
        this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName]);
      }
    });
    this._operationManager = new _operation_manager.default();
    this._init();
  },
  _init() {
    this._items = [];
    this._userData = {};
    this._totalCount = -1;
    this._isLoaded = false;
    if (!(0, _type.isDefined)(this._paginate)) {
      this._paginate = !this.group();
    }
    this._isLastPage = !this._paginate;
  },
  dispose() {
    var _this$_delayedLoadTas;
    this._store.off('beforePushAggregation', this._onPushHandler);
    this._store.off('push', this._onPushHandler);
    this._eventsStrategy.dispose();
    clearTimeout(this._aggregationTimeoutId);
    (_this$_delayedLoadTas = this._delayedLoadTask) === null || _this$_delayedLoadTas === void 0 || _this$_delayedLoadTas.abort();
    this._operationManager.cancelAll();
    delete this._store;
    delete this._items;
    delete this._delayedLoadTask;
    this._disposed = true;
  },
  _extractLoadOptions(options) {
    const result = {};
    let names = ['sort', 'filter', 'langParams', 'select', 'group', 'requireTotalCount'];
    const customNames = this._store._customLoadOptions();
    if (customNames) {
      names = names.concat(customNames);
    }
    (0, _iterator.each)(names, function () {
      result[this] = options[this];
    });
    return result;
  },
  loadOptions() {
    return this._storeLoadOptions;
  },
  items() {
    return this._items;
  },
  pageIndex(newIndex) {
    if (!(0, _type.isNumeric)(newIndex)) {
      return this._pageIndex;
    }
    this._pageIndex = newIndex;
    this._isLastPage = !this._paginate;
  },
  paginate(value) {
    if (!(0, _type.isBoolean)(value)) {
      return this._paginate;
    }
    if (this._paginate !== value) {
      this._paginate = value;
      this.pageIndex(0);
    }
  },
  pageSize(value) {
    if (!(0, _type.isNumeric)(value)) {
      return this._pageSize;
    }
    this._pageSize = value;
  },
  isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor(optionName) {
    return args => {
      const normalizedArgs = (0, _utils.normalizeStoreLoadOptionAccessorArguments)(args);
      if (normalizedArgs === undefined) {
        return this._storeLoadOptions[optionName];
      }
      this._storeLoadOptions[optionName] = normalizedArgs;
    };
  },
  sort() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.generateStoreLoadOptionAccessor('sort')(args);
  },
  filter() {
    const newFilter = (0, _utils.normalizeStoreLoadOptionAccessorArguments)(arguments);
    if (newFilter === undefined) {
      return this._storeLoadOptions.filter;
    }
    this._storeLoadOptions.filter = newFilter;
    this.pageIndex(0);
  },
  group() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.generateStoreLoadOptionAccessor('group')(args);
  },
  select() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.generateStoreLoadOptionAccessor('select')(args);
  },
  requireTotalCount(value) {
    if (!(0, _type.isBoolean)(value)) {
      return this._storeLoadOptions.requireTotalCount;
    }
    this._storeLoadOptions.requireTotalCount = value;
  },
  searchValue(value) {
    if (arguments.length < 1) {
      return this._searchValue;
    }
    this._searchValue = value;
    this.pageIndex(0);
  },
  searchOperation(op) {
    if (!(0, _type.isString)(op)) {
      return this._searchOperation;
    }
    this._searchOperation = op;
    this.pageIndex(0);
  },
  searchExpr(expr) {
    const argc = arguments.length;
    if (argc === 0) {
      return this._searchExpr;
    }
    if (argc > 1) {
      expr = [].slice.call(arguments);
    }
    this._searchExpr = expr;
    this.pageIndex(0);
  },
  store() {
    return this._store;
  },
  key() {
    var _this$_store;
    return (_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.key();
  },
  totalCount() {
    return this._totalCount;
  },
  isLoaded() {
    return this._isLoaded;
  },
  isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue() {
    return (0, _queue.create)();
  },
  _changeLoadingCount(increment) {
    const oldLoading = this.isLoading();
    this._loadingCount += increment;
    const newLoading = this.isLoading();
    if (oldLoading ^ newLoading) {
      this._eventsStrategy.fireEvent('loadingChanged', [newLoading]);
    }
  },
  _scheduleLoadCallbacks(deferred) {
    this.beginLoading();
    deferred.always(() => {
      this.endLoading();
    });
  },
  _scheduleFailCallbacks(deferred) {
    var _this = this;
    deferred.fail(function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (args[0] === _utils.CANCELED_TOKEN) {
        return;
      }
      _this._eventsStrategy.fireEvent('loadError', args);
    });
  },
  _fireChanged(args) {
    const date = new Date();
    this._eventsStrategy.fireEvent('changed', args);
    // @ts-expect-error
    this._changedTime = new Date() - date;
  },
  _scheduleChangedCallbacks(deferred) {
    deferred.done(() => this._fireChanged());
  },
  loadSingle(propName, propValue) {
    // @ts-expect-error
    const d = new _deferred.Deferred();
    const key = this.key();
    const store = this._store;
    const options = this._createStoreLoadOptions();
    const handleDone = data => {
      const isEmptyArray = Array.isArray(data) && !data.length;
      if (!(0, _type.isDefined)(data) || isEmptyArray) {
        d.reject(new _errors.errors.Error('E4009'));
      } else {
        if (!Array.isArray(data)) {
          data = [data];
        }
        d.resolve(this._applyMapFunction(data)[0]);
      }
    };
    this._scheduleFailCallbacks(d);
    if (arguments.length < 2) {
      propValue = propName;
      propName = key;
    }
    delete options.skip;
    delete options.group;
    delete options.refresh;
    delete options.pageIndex;
    delete options.searchString;
    // @ts-expect-error
    const shouldForceByKey = () => store instanceof _custom_store.default && !store._byKeyViaLoad();
    (() => {
      // NOTE for CustomStore always using byKey for backward compatibility with "old user datasource"
      if (propName === key || shouldForceByKey()) {
        return store.byKey(propValue, options);
      }
      options.take = 1;
      options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
      return store.load(options);
    })().fail(d.reject).done(handleDone);
    return d.promise();
  },
  load() {
    // @ts-expect-error
    const d = new _deferred.Deferred();
    const loadTask = () => {
      if (this._disposed) {
        return undefined;
      }
      if (!(0, _utils.isPending)(d)) {
        return;
      }
      return this._loadFromStore(loadOperation, d);
    };
    this._scheduleLoadCallbacks(d);
    this._scheduleFailCallbacks(d);
    this._scheduleChangedCallbacks(d);
    const loadOperation = this._createLoadOperation(d);
    this._eventsStrategy.fireEvent('customizeStoreLoadOptions', [loadOperation]);
    this._loadQueue.add(() => {
      if (typeof loadOperation.delay === 'number') {
        this._delayedLoadTask = (0, _common.executeAsync)(loadTask, loadOperation.delay);
      } else {
        loadTask();
      }
      return d.promise();
    });
    return d.promise({
      operationId: loadOperation.operationId
    });
  },
  _onPush(changes) {
    if (this._reshapeOnPush) {
      this.load();
    } else {
      const changingArgs = {
        changes
      };
      this._eventsStrategy.fireEvent('changing', [changingArgs]);
      const group = this.group();
      const items = this.items();
      let groupLevel = 0;
      let dataSourceChanges = this.paginate() || group ? changes.filter(item => item.type === 'update') : changes;
      if (group) {
        groupLevel = Array.isArray(group) ? group.length : 1;
      }
      if (this._mapFunc) {
        dataSourceChanges.forEach(item => {
          if (item.type === 'insert') {
            item.data = this._mapFunc(item.data);
          }
        });
      }
      // @ts-expect-error
      if (changingArgs.postProcessChanges) {
        // @ts-expect-error
        dataSourceChanges = changingArgs.postProcessChanges(dataSourceChanges);
      }
      // @ts-expect-error
      (0, _array_utils.applyBatch)({
        keyInfo: this.store(),
        data: items,
        changes: dataSourceChanges,
        groupCount: groupLevel,
        useInsertIndex: true
      });
      this._fireChanged([{
        changes
      }]);
    }
  },
  _createLoadOperation(deferred) {
    const operationId = this._operationManager.add(deferred);
    const storeLoadOptions = this._createStoreLoadOptions();
    if (this._store && !(0, _type.isEmptyObject)(storeLoadOptions === null || storeLoadOptions === void 0 ? void 0 : storeLoadOptions.langParams)) {
      this._store._langParams = _extends({}, this._store._langParams, storeLoadOptions.langParams);
    }
    deferred.always(() => this._operationManager.remove(operationId));
    return {
      operationId,
      storeLoadOptions
    };
  },
  reload() {
    const store = this.store();
    store._clearCache();
    this._init();
    return this.load();
  },
  cancel(operationId) {
    return this._operationManager.cancel(operationId);
  },
  cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions(storeLoadOptions) {
    if (this._disposed) {
      return;
    }
    if (this.store()._useDefaultSearch) {
      this._addSearchFilter(storeLoadOptions);
    } else {
      storeLoadOptions.searchOperation = this._searchOperation;
      storeLoadOptions.searchValue = this._searchValue;
      storeLoadOptions.searchExpr = this._searchExpr;
    }
  },
  _createStoreLoadOptions() {
    const result = (0, _extend.extend)({}, this._storeLoadOptions);
    this._addSearchOptions(result);
    if (this._paginate) {
      if (this._pageSize) {
        result.skip = this._pageIndex * this._pageSize;
        result.take = this._pageSize;
      }
    }
    result.userData = this._userData;
    return result;
  },
  _addSearchFilter(storeLoadOptions) {
    const value = this._searchValue;
    const op = this._searchOperation;
    let selector = this._searchExpr;
    const searchFilter = [];
    if (!value) {
      return;
    }
    if (!selector) {
      selector = 'this';
    }
    if (!Array.isArray(selector)) {
      selector = [selector];
    }
    // TODO optimize for byKey case
    (0, _iterator.each)(selector, (i, item) => {
      if (searchFilter.length) {
        // @ts-expect-error
        searchFilter.push('or');
      }
      // @ts-expect-error
      searchFilter.push([item, op, value]);
    });
    if (storeLoadOptions.filter) {
      storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
    } else {
      storeLoadOptions.filter = searchFilter;
    }
  },
  _loadFromStore(loadOptions, pendingDeferred) {
    const handleSuccess = (data, extra) => {
      if (this._disposed) {
        return;
      }
      if (!(0, _utils.isPending)(pendingDeferred)) {
        return;
      }
      // Process result
      const loadResult = (0, _extend.extend)((0, _utils.normalizeLoadResult)(data, extra), loadOptions);
      this._eventsStrategy.fireEvent('customizeLoadResult', [loadResult]);
      (0, _deferred.when)(loadResult.data).done(data => {
        loadResult.data = data;
        this._processStoreLoadResult(loadResult, pendingDeferred);
      }).fail(pendingDeferred.reject);
    };
    if (loadOptions.data) {
      // @ts-expect-error
      return new _deferred.Deferred().resolve(loadOptions.data).done(handleSuccess);
    }
    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
  },
  _processStoreLoadResult(loadResult, pendingDeferred) {
    let {
      data
    } = loadResult;
    let {
      extra
    } = loadResult;
    const {
      storeLoadOptions
    } = loadResult;
    const resolvePendingDeferred = () => {
      this._isLoaded = true;
      this._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
      return pendingDeferred.resolve(data, extra);
    };
    const proceedLoadingTotalCount = () => {
      this.store().totalCount(storeLoadOptions).done(count => {
        extra.totalCount = count;
        resolvePendingDeferred();
      }).fail(pendingDeferred.reject);
    };
    if (this._disposed) {
      return;
    }
    // todo: if operation is canceled there is no need to do data transformation
    data = this._applyPostProcessFunction(this._applyMapFunction(data));
    if (!(0, _type.isObject)(extra)) {
      extra = {};
    }
    this._items = data;
    if (!data.length || !this._paginate || this._pageSize && data.length < this._pageSize) {
      this._isLastPage = true;
    }
    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
      proceedLoadingTotalCount();
    } else {
      resolvePendingDeferred();
    }
  },
  _applyMapFunction(data) {
    if (this._mapFunc) {
      return (0, _utils.mapDataRespectingGrouping)(data, this._mapFunc, this.group());
    }
    return data;
  },
  _applyPostProcessFunction(data) {
    if (this._postProcessFunc) {
      return this._postProcessFunc(data);
    }
    return data;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});

/***/ }),

/***/ 69201:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _utils = __webpack_require__(9234);
class OperationManager {
  constructor() {
    // @ts-expect-error
    this._counter = -1;
    // @ts-expect-error
    this._deferreds = {};
  }
  add(deferred) {
    // @ts-expect-error
    this._counter++;
    // @ts-expect-error
    this._deferreds[this._counter] = deferred;
    // @ts-expect-error
    return this._counter;
  }
  remove(operationId) {
    // @ts-expect-error
    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    return delete this._deferreds[operationId];
  }
  cancel(operationId) {
    // @ts-expect-error
    if (operationId in this._deferreds) {
      // @ts-expect-error
      this._deferreds[operationId].reject(_utils.CANCELED_TOKEN);
      return true;
    }
    return false;
  }
  cancelAll() {
    // @ts-expect-error
    while (this._counter > -1) {
      // @ts-expect-error
      this.cancel(this._counter);
      // @ts-expect-error
      this._counter--;
    }
  }
}
exports["default"] = OperationManager;

/***/ }),

/***/ 3097:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalizeStoreLoadOptionAccessorArguments = exports.normalizeLoadResult = exports.normalizeDataSourceOptions = exports.mapDataRespectingGrouping = exports.isPending = exports.CANCELED_TOKEN = void 0;
var _ajax = _interopRequireDefault(__webpack_require__(37208));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _abstract_store = _interopRequireDefault(__webpack_require__(67403));
var _array_store = _interopRequireDefault(__webpack_require__(26562));
var _custom_store = _interopRequireDefault(__webpack_require__(88036));
var _utils = __webpack_require__(16454);
const _excluded = ["items"]; // @ts-expect-error
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }
const CANCELED_TOKEN = exports.CANCELED_TOKEN = 'canceled';
const isPending = deferred => deferred.state() === 'pending';
exports.isPending = isPending;
const normalizeStoreLoadOptionAccessorArguments = originalArguments => {
  // eslint-disable-next-line default-case
  switch (originalArguments.length) {
    case 0:
      return undefined;
    case 1:
      return originalArguments[0];
  }
  return [].slice.call(originalArguments);
};
exports.normalizeStoreLoadOptionAccessorArguments = normalizeStoreLoadOptionAccessorArguments;
const mapGroup = (group, level, mapper) => (0, _iterator.map)(group, item => {
  const restItem = _objectWithoutPropertiesLoose(item, _excluded);
  return _extends({}, restItem, {
    items: mapRecursive(item.items, level - 1, mapper)
  });
});
const mapRecursive = (items, level, mapper) => {
  if (!Array.isArray(items)) return items;
  return level ? mapGroup(items, level, mapper) : (0, _iterator.map)(items, mapper);
};
const mapDataRespectingGrouping = (items, mapper, groupInfo) => {
  const level = groupInfo ? (0, _utils.normalizeSortingInfo)(groupInfo).length : 0;
  return mapRecursive(items, level, mapper);
};
exports.mapDataRespectingGrouping = mapDataRespectingGrouping;
const normalizeLoadResult = (data, extra) => {
  var _data;
  if ((_data = data) !== null && _data !== void 0 && _data.data) {
    extra = data;
    data = data.data;
  }
  if (!Array.isArray(data)) {
    data = [data];
  }
  return {
    data,
    extra
  };
};
exports.normalizeLoadResult = normalizeLoadResult;
const createCustomStoreFromLoadFunc = options => {
  const storeConfig = {};
  (0, _iterator.each)(['useDefaultSearch', 'key', 'load', 'loadMode', 'cacheRawData', 'byKey', 'lookup', 'totalCount', 'insert', 'update', 'remove'], function () {
    storeConfig[this] = options[this];
    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    delete options[this];
  });
  // @ts-expect-error
  return new _custom_store.default(storeConfig);
};
const createStoreFromConfig = storeConfig => {
  const alias = storeConfig.type;
  delete storeConfig.type;
  // @ts-expect-error
  return _abstract_store.default.create(alias, storeConfig);
};
const createCustomStoreFromUrl = (url, normalizationOptions) => new _custom_store.default({
  load: () => _ajax.default.sendRequest({
    url,
    dataType: 'json'
  }),
  loadMode: normalizationOptions === null || normalizationOptions === void 0 ? void 0 : normalizationOptions.fromUrlLoadMode
});
const normalizeDataSourceOptions = (options, normalizationOptions) => {
  let store;
  if (typeof options === 'string') {
    options = {
      paginate: false,
      store: createCustomStoreFromUrl(options, normalizationOptions)
    };
  }
  if (options === undefined) {
    options = [];
  }
  if (Array.isArray(options) || options instanceof _abstract_store.default) {
    options = {
      store: options
    };
  } else {
    options = (0, _extend.extend)({}, options);
  }
  if (options.store === undefined) {
    options.store = [];
  }
  store = options.store;
  if ('load' in options) {
    store = createCustomStoreFromLoadFunc(options);
  } else if (Array.isArray(store)) {
    // @ts-expect-error
    store = new _array_store.default(store);
  } else if ((0, _type.isPlainObject)(store)) {
    store = createStoreFromConfig((0, _extend.extend)({}, store));
  }
  options.store = store;
  return options;
};
exports.normalizeDataSourceOptions = normalizeDataSourceOptions;

/***/ }),

/***/ 2367:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _events_strategy = __webpack_require__(80566);
var _common = __webpack_require__(20576);
var _data = __webpack_require__(47617);
var _deferred = __webpack_require__(62754);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _errors = __webpack_require__(18438);
var _store_helper = _interopRequireDefault(__webpack_require__(99236));
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } // @ts-expect-error
// @ts-expect-error
const {
  abstract
} = _class.default;
const {
  queryByOptions
} = _store_helper.default;
const storeImpl = {};
const Store = _class.default.inherit({
  _langParams: {},
  ctor(options) {
    const that = this;
    options = options || {};
    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
    (0, _iterator.each)(['onLoaded', 'onLoading', 'onInserted', 'onInserting', 'onUpdated', 'onUpdating', 'onPush', 'onRemoved', 'onRemoving', 'onModified', 'onModifying'], (_, optionName) => {
      if (optionName in options) {
        that.on(optionName.slice(2).toLowerCase(), options[optionName]);
      }
    });
    this._key = options.key;
    this._errorHandler = options.errorHandler;
    this._useDefaultSearch = true;
  },
  _clearCache: _common.noop,
  _customLoadOptions() {
    return null;
  },
  key() {
    return this._key;
  },
  keyOf(obj) {
    if (!this._keyGetter) {
      this._keyGetter = (0, _data.compileGetter)(this.key());
    }
    return this._keyGetter(obj);
  },
  _requireKey() {
    if (!this.key()) {
      throw _errors.errors.Error('E4005');
    }
  },
  load(options) {
    const that = this;
    options = options || {};
    this._eventsStrategy.fireEvent('loading', [options]);
    return this._withLock(this._loadImpl(options)).done(result => {
      that._eventsStrategy.fireEvent('loaded', [result, options]);
    });
  },
  _loadImpl(options) {
    if (!(0, _type.isEmptyObject)(this._langParams)) {
      options = options || {};
      options._langParams = _extends({}, this._langParams, options._langParams);
    }
    // @ts-expect-error
    return queryByOptions(this.createQuery(options), options).enumerate();
  },
  _withLock(task) {
    // @ts-expect-error
    const result = new _deferred.Deferred();
    task.done(function () {
      const that = this;
      const args = arguments;
      _utils.processRequestResultLock.promise().done(() => {
        result.resolveWith(that, args);
      });
    }).fail(function () {
      result.rejectWith(this, arguments);
    });
    return result;
  },
  createQuery: abstract,
  totalCount(options) {
    return this._totalCountImpl(options);
  },
  _totalCountImpl(options) {
    return queryByOptions(this.createQuery(options), options, true).count();
  },
  byKey(key, extraOptions) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
  },
  _byKeyImpl: abstract,
  insert(values) {
    const that = this;
    that._eventsStrategy.fireEvent('modifying');
    that._eventsStrategy.fireEvent('inserting', [values]);
    return that._addFailHandlers(that._insertImpl(values).done((callbackValues, callbackKey) => {
      that._eventsStrategy.fireEvent('inserted', [callbackValues, callbackKey]);
      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _insertImpl: abstract,
  update(key, values) {
    const that = this;
    that._eventsStrategy.fireEvent('modifying');
    that._eventsStrategy.fireEvent('updating', [key, values]);
    return that._addFailHandlers(that._updateImpl(key, values).done(() => {
      that._eventsStrategy.fireEvent('updated', [key, values]);
      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _updateImpl: abstract,
  push(changes) {
    const beforePushArgs = {
      changes,
      waitFor: []
    };
    this._eventsStrategy.fireEvent('beforePushAggregation', [beforePushArgs]);
    (0, _deferred.when)(...beforePushArgs.waitFor).done(() => {
      this._pushImpl(changes);
      this._eventsStrategy.fireEvent('beforePush', [{
        changes
      }]);
      this._eventsStrategy.fireEvent('push', [changes]);
    });
  },
  _pushImpl: _common.noop,
  remove(key) {
    const that = this;
    that._eventsStrategy.fireEvent('modifying');
    that._eventsStrategy.fireEvent('removing', [key]);
    return that._addFailHandlers(that._removeImpl(key).done(callbackKey => {
      that._eventsStrategy.fireEvent('removed', [callbackKey]);
      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _removeImpl: abstract,
  _addFailHandlers(deferred) {
    return deferred.fail(this._errorHandler).fail(_errors.handleError);
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
// @ts-expect-error
Store.create = function (alias, options) {
  if (!(alias in storeImpl)) {
    throw _errors.errors.Error('E4020', alias);
  }
  return new storeImpl[alias](options);
};
// @ts-expect-error
Store.registerClass = function (type, alias) {
  if (alias) {
    storeImpl[alias] = type;
  }
  return type;
};
// @ts-expect-error
Store.inherit = function (inheritor) {
  return function (members, alias) {
    const type = inheritor.apply(this, [members]);
    // @ts-expect-error
    Store.registerClass(type, alias);
    return type;
  };
}(Store.inherit);
var _default = exports["default"] = Store;

/***/ }),

/***/ 35044:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _data = __webpack_require__(47617);
var _deferred = __webpack_require__(62754);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _errors = __webpack_require__(18438);
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// @ts-expect-error

const Iterator = _class.default.inherit({
  toArray() {
    const result = [];
    this.reset();
    while (this.next()) {
      // @ts-expect-error
      result.push(this.current());
    }
    return result;
  },
  countable() {
    return false;
  }
});
const ArrayIterator = Iterator.inherit({
  ctor(array) {
    this.array = array;
    this.index = -1;
  },
  next() {
    if (this.index + 1 < this.array.length) {
      this.index++;
      return true;
    }
    return false;
  },
  current() {
    return this.array[this.index];
  },
  reset() {
    this.index = -1;
  },
  toArray() {
    return this.array.slice(0);
  },
  countable() {
    return true;
  },
  count() {
    return this.array.length;
  }
});
const WrappedIterator = Iterator.inherit({
  ctor(iter) {
    this.iter = iter;
  },
  next() {
    return this.iter.next();
  },
  current() {
    return this.iter.current();
  },
  reset() {
    return this.iter.reset();
  }
});
const MapIterator = WrappedIterator.inherit({
  ctor(iter, mapper) {
    this.callBase(iter);
    this.index = -1;
    this.mapper = mapper;
  },
  current() {
    return this.mapper(this.callBase(), this.index);
  },
  next() {
    const hasNext = this.callBase();
    if (hasNext) {
      this.index++;
    }
    return hasNext;
  }
});
const defaultCompare = function (xValue, yValue, options) {
  if ((0, _type.isString)(xValue) && (0, _type.isString)(yValue) && (options !== null && options !== void 0 && options.locale || options !== null && options !== void 0 && options.collatorOptions)) {
    /* eslint-disable-next-line no-undef */
    return new Intl.Collator((options === null || options === void 0 ? void 0 : options.locale) || undefined, (options === null || options === void 0 ? void 0 : options.collatorOptions) || undefined).compare(xValue, yValue);
  }
  xValue = (0, _data.toComparable)(xValue, false, options);
  yValue = (0, _data.toComparable)(yValue, false, options);
  if (xValue === null && yValue !== null) {
    return -1;
  }
  if (xValue !== null && yValue === null) {
    return 1;
  }
  if (xValue === undefined && yValue !== undefined) {
    return 1;
  }
  if (xValue !== undefined && yValue === undefined) {
    return -1;
  }
  if (xValue < yValue) {
    return -1;
  }
  if (xValue > yValue) {
    return 1;
  }
  return 0;
};
const SortIterator = Iterator.inherit({
  ctor(iter, getter, desc, compare) {
    this.langParams = iter.langParams;
    if (!(iter instanceof MapIterator)) {
      iter = new MapIterator(iter, this._wrap);
      iter.langParams = this.langParams;
    }
    this.iter = iter;
    this.rules = [{
      getter,
      desc,
      compare,
      langParams: this.langParams
    }];
  },
  thenBy(getter, desc, compare) {
    const result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);
    if (!this.sortedIter) {
      // @ts-expect-error
      result.rules = this.rules.concat(result.rules);
    }
    return result;
  },
  next() {
    this._ensureSorted();
    return this.sortedIter.next();
  },
  current() {
    this._ensureSorted();
    return this.sortedIter.current();
  },
  reset() {
    delete this.sortedIter;
  },
  countable() {
    return this.sortedIter || this.iter.countable();
  },
  count() {
    if (this.sortedIter) {
      return this.sortedIter.count();
    }
    return this.iter.count();
  },
  _ensureSorted() {
    const that = this;
    if (that.sortedIter) {
      return;
    }
    (0, _iterator.each)(that.rules, function () {
      this.getter = (0, _data.compileGetter)(this.getter);
    });
    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort((x, y) => that._compare(x, y))), that._unwrap);
  },
  _wrap(record, index) {
    return {
      index,
      value: record
    };
  },
  _unwrap(wrappedItem) {
    return wrappedItem.value;
  },
  _getDefaultCompare(langParams) {
    return (xValue, yValue) => defaultCompare(xValue, yValue, langParams);
  },
  _compare(x, y) {
    const xIndex = x.index;
    const yIndex = y.index;
    x = x.value;
    y = y.value;
    if (x === y) {
      return xIndex - yIndex;
    }
    for (let i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
      const rule = this.rules[i];
      const xValue = rule.getter(x);
      const yValue = rule.getter(y);
      const compare = rule.compare || this._getDefaultCompare(rule.langParams);
      const compareResult = compare(xValue, yValue);
      if (compareResult) {
        return rule.desc ? -compareResult : compareResult;
      }
    }
    return xIndex - yIndex;
  }
});
const compileCriteria = function () {
  let langParams = {};
  // eslint-disable-next-line @typescript-eslint/naming-convention
  const _toComparable = value => (0, _data.toComparable)(value, false, langParams);
  const compileUniformEqualsCriteria = crit => {
    const getter = (0, _data.compileGetter)(crit[0][0]);
    const filterValues = crit.reduce((acc, item, i) => {
      if (i % 2 === 0) {
        acc.push(_toComparable(item[2]));
      }
      return acc;
    }, []);
    return obj => {
      // @ts-expect-error
      const value = _toComparable(getter(obj));
      return filterValues.some(filterValue => useStrictComparison(filterValue) ? value === filterValue
      // eslint-disable-next-line eqeqeq
      : value == filterValue);
    };
  };
  const compileGroup = function (crit) {
    if ((0, _utils.isUniformEqualsByOr)(crit)) {
      return compileUniformEqualsCriteria(crit);
    }
    const ops = [];
    let isConjunctiveOperator = false;
    let isConjunctiveNextOperator = false;
    (0, _iterator.each)(crit, function () {
      if (Array.isArray(this) || (0, _type.isFunction)(this)) {
        if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {
          throw new _errors.errors.Error('E4019');
        }
        // @ts-expect-error
        ops.push(compileCriteria(this, langParams));
        isConjunctiveOperator = isConjunctiveNextOperator;
        isConjunctiveNextOperator = true;
      } else {
        isConjunctiveNextOperator = (0, _utils.isConjunctiveOperator)(this);
      }
    });
    return function (d) {
      let result = isConjunctiveOperator;
      for (let i = 0; i < ops.length; i++) {
        // @ts-expect-error
        if (ops[i](d) !== isConjunctiveOperator) {
          result = !isConjunctiveOperator;
          break;
        }
      }
      return result;
    };
  };
  const toString = function (value) {
    var _langParams;
    return (0, _type.isDefined)(value)
    // @ts-expect-error
    ? (_langParams = langParams) !== null && _langParams !== void 0 && _langParams.locale ? value.toLocaleString(langParams.locale) : value.toString() : '';
  };
  const compileBinary = function (crit) {
    crit = (0, _utils.normalizeBinaryCriterion)(crit);
    const getter = (0, _data.compileGetter)(crit[0]);
    const op = crit[1];
    let value = crit[2];
    value = _toComparable(value);
    const compare = (obj, operatorFn) => {
      // @ts-expect-error
      obj = _toComparable(getter(obj));
      return (value == null || obj == null) && value !== obj ? false : operatorFn(obj, value);
    };
    // eslint-disable-next-line default-case
    switch (op.toLowerCase()) {
      case '=':
        // @ts-expect-error
        return compileEquals(getter, value);
      case '<>':
        return compileEquals(getter, value, true);
      case '>':
        return obj => compare(obj, (a, b) => a > b);
      case '<':
        return obj => compare(obj, (a, b) => a < b);
      case '>=':
        return obj => compare(obj, (a, b) => a >= b);
      case '<=':
        return obj => compare(obj, (a, b) => a <= b);
      case 'startswith':
        // @ts-expect-error
        return function (obj) {
          return _toComparable(toString(getter(obj))).indexOf(value) === 0;
        };
      case 'endswith':
        return function (obj) {
          // @ts-expect-error
          const getterValue = _toComparable(toString(getter(obj)));
          const searchValue = toString(value);
          if (getterValue.length < searchValue.length) {
            return false;
          }
          const index = getterValue.lastIndexOf(value);
          return index !== -1 && index === getterValue.length - value.length;
        };
      case 'contains':
        // @ts-expect-error
        return function (obj) {
          return _toComparable(toString(getter(obj))).indexOf(value) > -1;
        };
      case 'notcontains':
        // @ts-expect-error
        return function (obj) {
          return _toComparable(toString(getter(obj))).indexOf(value) === -1;
        };
    }
    throw _errors.errors.Error('E4003', op);
  };
  function compileEquals(getter, value, negate) {
    return function (obj) {
      obj = _toComparable(getter(obj));
      // eslint-disable-next-line eqeqeq
      let result = useStrictComparison(value) ? obj === value : obj == value;
      if (negate) {
        result = !result;
      }
      return result;
    };
  }
  function useStrictComparison(value) {
    return value === '' || value === 0 || value === false;
  }
  function compileUnary(crit) {
    const op = crit[0];
    const criteria = compileCriteria(crit[1], langParams);
    if (op === '!') {
      return function (obj) {
        return !criteria(obj);
      };
    }
    throw _errors.errors.Error('E4003', op);
  }
  return function (crit, options) {
    langParams = options || {};
    if ((0, _type.isFunction)(crit)) {
      return crit;
    }
    if ((0, _utils.isGroupCriterion)(crit)) {
      return compileGroup(crit);
    }
    if ((0, _utils.isUnaryOperation)(crit)) {
      return compileUnary(crit);
    }
    return compileBinary(crit);
  };
}();
const FilterIterator = WrappedIterator.inherit({
  ctor(iter, criteria) {
    this.callBase(iter);
    this.langParams = iter.langParams;
    this.criteria = compileCriteria(criteria, this.langParams);
  },
  next() {
    while (this.iter.next()) {
      if (this.criteria(this.current())) {
        return true;
      }
    }
    return false;
  }
});
const GroupIterator = Iterator.inherit({
  ctor(iter, getter) {
    this.iter = iter;
    this.getter = getter;
  },
  next() {
    this._ensureGrouped();
    return this.groupedIter.next();
  },
  current() {
    this._ensureGrouped();
    return this.groupedIter.current();
  },
  reset() {
    delete this.groupedIter;
  },
  countable() {
    return !!this.groupedIter;
  },
  count() {
    return this.groupedIter.count();
  },
  _ensureGrouped() {
    if (this.groupedIter) {
      return;
    }
    const hash = {};
    const keys = [];
    const {
      iter
    } = this;
    const getter = (0, _data.compileGetter)(this.getter);
    iter.reset();
    while (iter.next()) {
      const current = iter.current();
      // @ts-expect-error
      const key = getter(current);
      if (key in hash) {
        hash[key].push(current);
      } else {
        hash[key] = [current];
        // @ts-expect-error
        keys.push(key);
      }
    }
    this.groupedIter = new ArrayIterator((0, _iterator.map)(keys, key => ({
      key,
      items: hash[key]
    })));
  }
});
const SelectIterator = WrappedIterator.inherit({
  ctor(iter, getter) {
    this.callBase(iter);
    this.getter = (0, _data.compileGetter)(getter);
  },
  current() {
    return this.getter(this.callBase());
  },
  countable() {
    return this.iter.countable();
  },
  count() {
    return this.iter.count();
  }
});
const SliceIterator = WrappedIterator.inherit({
  ctor(iter, skip, take) {
    this.callBase(iter);
    this.skip = Math.max(0, skip);
    this.take = Math.max(0, take);
    this.pos = 0;
  },
  next() {
    if (this.pos >= this.skip + this.take) {
      return false;
    }
    while (this.pos < this.skip && this.iter.next()) {
      this.pos++;
    }
    this.pos++;
    return this.iter.next();
  },
  reset() {
    this.callBase();
    this.pos = 0;
  },
  countable() {
    return this.iter.countable();
  },
  count() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
});
const arrayQueryImpl = function (iter, queryOptions) {
  queryOptions = queryOptions || {};
  if (!(iter instanceof Iterator)) {
    iter = new ArrayIterator(iter);
  }
  if (queryOptions.langParams) {
    iter.langParams = queryOptions.langParams;
  }
  const handleError = function (error) {
    const handler = queryOptions.errorHandler;
    if (handler) {
      handler(error);
    }
    (0, _errors.handleError)(error);
  };
  const aggregateCore = function (aggregator) {
    // @ts-expect-error
    const d = new _deferred.Deferred().fail(handleError);
    let seed;
    const {
      step
    } = aggregator;
    const {
      finalize
    } = aggregator;
    try {
      iter.reset();
      if ('seed' in aggregator) {
        seed = aggregator.seed;
      } else {
        seed = iter.next() ? iter.current() : NaN;
      }
      let accumulator = seed;
      while (iter.next()) {
        accumulator = step(accumulator, iter.current());
      }
      d.resolve(finalize ? finalize(accumulator) : accumulator);
    } catch (x) {
      d.reject(x);
    }
    return d.promise();
  };
  const aggregate = function (seed, step, finalize) {
    if (arguments.length < 2) {
      return aggregateCore({
        step: arguments[0]
      });
    }
    return aggregateCore({
      seed,
      step,
      finalize
    });
  };
  const standardAggregate = function (name) {
    return aggregateCore(_utils.aggregators[name]);
  };
  const select = function (getter) {
    if (!(0, _type.isFunction)(getter) && !Array.isArray(getter)) {
      getter = [].slice.call(arguments);
    }
    return chainQuery(new SelectIterator(iter, getter));
  };
  const selectProp = function (name) {
    return select((0, _data.compileGetter)(name));
  };
  function chainQuery(iter) {
    return arrayQueryImpl(iter, queryOptions);
  }
  return {
    toArray() {
      return iter.toArray();
    },
    enumerate() {
      // @ts-expect-error
      const d = new _deferred.Deferred().fail(handleError);
      try {
        d.resolve(iter.toArray());
      } catch (x) {
        d.reject(x);
      }
      return d.promise();
    },
    setLangParams(options) {
      iter.langParams = options;
    },
    sortBy(getter, desc, compare) {
      return chainQuery(new SortIterator(iter, getter, desc, compare));
    },
    thenBy(getter, desc, compare) {
      if (iter instanceof SortIterator) {
        // @ts-expect-error
        return chainQuery(iter.thenBy(getter, desc, compare));
      }
      throw _errors.errors.Error('E4004');
    },
    filter(criteria) {
      if (!Array.isArray(criteria)) {
        criteria = [].slice.call(arguments);
      }
      return chainQuery(new FilterIterator(iter, criteria));
    },
    slice(skip, take) {
      if (take === undefined) {
        take = Number.MAX_VALUE;
      }
      return chainQuery(new SliceIterator(iter, skip, take));
    },
    select,
    groupBy(getter) {
      return chainQuery(new GroupIterator(iter, getter));
    },
    aggregate,
    count() {
      if (iter.countable()) {
        // @ts-expect-error
        const d = new _deferred.Deferred().fail(handleError);
        try {
          d.resolve(iter.count());
        } catch (x) {
          d.reject(x);
        }
        return d.promise();
      }
      return standardAggregate('count');
    },
    sum(getter) {
      if (getter) {
        // @ts-expect-error
        return selectProp(getter).sum();
      }
      return standardAggregate('sum');
    },
    min(getter) {
      if (getter) {
        // @ts-expect-error
        return selectProp(getter).min();
      }
      return standardAggregate('min');
    },
    max(getter) {
      if (getter) {
        // @ts-expect-error
        return selectProp(getter).max();
      }
      return standardAggregate('max');
    },
    avg(getter) {
      if (getter) {
        // @ts-expect-error
        return selectProp(getter).avg();
      }
      return standardAggregate('avg');
    }
  };
};
var _default = exports["default"] = arrayQueryImpl;

/***/ }),

/***/ 96438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _abstract_store = _interopRequireDefault(__webpack_require__(67403));
var _array_utils = __webpack_require__(60637);
var _errors = __webpack_require__(18438);
var _query = _interopRequireDefault(__webpack_require__(96687));
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// @ts-expect-error

// @ts-expect-error
const ArrayStore = _abstract_store.default.inherit({
  ctor(options) {
    if (Array.isArray(options)) {
      options = {
        data: options
      };
    } else {
      options = options || {};
    }
    this.callBase(options);
    const initialArray = options.data;
    if (initialArray && !Array.isArray(initialArray)) {
      throw _errors.errors.Error('E4006');
    }
    this._array = initialArray || [];
  },
  createQuery() {
    return (0, _query.default)(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl(key) {
    const index = (0, _array_utils.indexByKey)(this, this._array, key);
    if (index === -1) {
      return (0, _utils.rejectedPromise)(_errors.errors.Error('E4009'));
    }
    return (0, _utils.trivialPromise)(this._array[index]);
  },
  _insertImpl(values) {
    // @ts-expect-error
    return (0, _array_utils.insert)(this, this._array, values);
  },
  _pushImpl(changes) {
    // @ts-expect-error
    (0, _array_utils.applyBatch)({
      keyInfo: this,
      data: this._array,
      changes
    });
  },
  _updateImpl(key, values) {
    // @ts-expect-error
    return (0, _array_utils.update)(this, this._array, key, values);
  },
  _removeImpl(key) {
    // @ts-expect-error
    return (0, _array_utils.remove)(this, this._array, key);
  },
  clear() {
    this._eventsStrategy.fireEvent('modifying');
    this._array = [];
    this._eventsStrategy.fireEvent('modified');
  }
}, 'array');
var _default = exports["default"] = ArrayStore;

/***/ }),

/***/ 23011:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.applyBatch = applyBatch;
exports.applyChanges = applyChanges;
exports.createObjectWithChanges = createObjectWithChanges;
exports.indexByKey = indexByKey;
exports.insert = insert;
exports.remove = remove;
exports.update = update;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _data = __webpack_require__(47617);
var _extend = __webpack_require__(13306);
var _object = __webpack_require__(48013);
var _type = __webpack_require__(35922);
var _errors = __webpack_require__(18438);
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } // @ts-expect-error
// @ts-expect-error
function hasKey(target, keyOrKeys) {
  let key;
  // @ts-expect-error
  const keys = typeof keyOrKeys === 'string' ? keyOrKeys.split() : keyOrKeys.slice();
  while (keys.length) {
    key = keys.shift();
    if (key in target) {
      return true;
    }
  }
  return false;
}
function findItems(keyInfo, items, key, groupCount) {
  let childItems;
  let result;
  if (groupCount) {
    for (let i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result = findItems(keyInfo, childItems || [], key, groupCount - 1);
      if (result) {
        return result;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}
function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }
  return items;
}
function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    const dataByKeyMap = {};
    const arrayLength = array.length;
    for (let i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }
    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}
function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}
function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
  return true;
}
function setDataByKeyMapValue(array, key, data) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data;
    array._dataByKeyMapLength += data ? 1 : -1;
  }
}
function cloneInstanceWithChangedPaths(instance, changes, clonedInstances) {
  clonedInstances = clonedInstances || new WeakMap();
  const result = instance ? Object.create(Object.getPrototypeOf(instance)) : {};
  if (instance) {
    clonedInstances.set(instance, result);
  }
  const instanceWithoutPrototype = _extends({}, instance);
  (0, _object.deepExtendArraySafe)(result, instanceWithoutPrototype, true, true);
  // eslint-disable-next-line no-restricted-syntax, guard-for-in
  for (const name in instanceWithoutPrototype) {
    const value = instanceWithoutPrototype[name];
    const change = changes === null || changes === void 0 ? void 0 : changes[name];
    if ((0, _type.isObject)(value) && !(0, _type.isPlainObject)(value) && (0, _type.isObject)(change) && !clonedInstances.has(value)) {
      result[name] = cloneInstanceWithChangedPaths(value, change, clonedInstances);
    }
  }
  // eslint-disable-next-line no-restricted-syntax, guard-for-in
  for (const name in result) {
    const prop = result[name];
    if ((0, _type.isObject)(prop) && clonedInstances.has(prop)) {
      result[name] = clonedInstances.get(prop);
    }
  }
  return result;
}
function createObjectWithChanges(target, changes) {
  // @ts-expect-error
  const result = cloneInstanceWithChangedPaths(target, changes);
  return (0, _object.deepExtendArraySafe)(result, changes, true, true);
}
function applyBatch(_ref) {
  let {
    keyInfo,
    data,
    changes,
    groupCount,
    useInsertIndex,
    immutable,
    disableCache,
    logError,
    skipCopying
  } = _ref;
  const resultItems = immutable === true ? [...data] : data;
  changes.forEach(item => {
    const items = item.type === 'insert' ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);
    // eslint-disable-next-line default-case
    switch (item.type) {
      case 'update':
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;
      case 'insert':
        insert(keyInfo, items, item.data, useInsertIndex && (0, _type.isDefined)(item.index) ? item.index : -1, true, logError, skipCopying);
        break;
      case 'remove':
        remove(keyInfo, items, item.key, true, logError);
        break;
    }
  });
  return resultItems;
}
function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? (0, _utils.rejectedPromise)(_errors.errors.Error(errorCode)) : logError && _errors.errors.log(errorCode);
}
function applyChanges(data, changes) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // @ts-expect-error
  const {
    keyExpr = 'id',
    immutable = true
  } = options;
  const keyGetter = (0, _data.compileGetter)(keyExpr);
  const keyInfo = {
    key: () => keyExpr,
    // @ts-expect-error
    keyOf: obj => keyGetter(obj)
  };
  // @ts-expect-error
  return applyBatch({
    keyInfo,
    data,
    changes,
    immutable,
    disableCache: true,
    logError: true
  });
}
function update(keyInfo, array, key, data, isBatch, immutable, logError) {
  let target;
  const extendComplexObject = true;
  const keyExpr = keyInfo.key();
  if (keyExpr) {
    if (hasKey(data, keyExpr) && !(0, _utils.keysEqual)(keyExpr, key, keyInfo.keyOf(data))) {
      return getErrorResult(isBatch, logError, 'E4017');
    }
    target = getCacheValue(array, key);
    if (!target) {
      const index = indexByKey(keyInfo, array, key);
      if (index < 0) {
        return getErrorResult(isBatch, logError, 'E4009');
      }
      target = array[index];
      if (immutable === true && (0, _type.isDefined)(target)) {
        const newTarget = createObjectWithChanges(target, data);
        array[index] = newTarget;
        return !isBatch && (0, _utils.trivialPromise)(newTarget, key);
      }
    }
  } else {
    target = key;
  }
  (0, _object.deepExtendArraySafe)(target, data, extendComplexObject);
  if (!isBatch) {
    if ((0, _config.default)().useLegacyStoreResult) {
      return (0, _utils.trivialPromise)(key, data);
    }
    return (0, _utils.trivialPromise)(target, key);
  }
}
function insert(keyInfo, array, data, index, isBatch, logError, skipCopying) {
  let keyValue;
  const keyExpr = keyInfo.key();
  const obj = (0, _type.isPlainObject)(data) && !skipCopying ? (0, _extend.extend)({}, data) : data;
  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);
    if (keyValue === undefined || typeof keyValue === 'object' && (0, _type.isEmptyObject)(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw _errors.errors.Error('E4007');
      }
      keyValue = obj[keyExpr] = String(new _guid.default());
    } else if (array[indexByKey(keyInfo, array, keyValue)] !== undefined) {
      return getErrorResult(isBatch, logError, 'E4008');
    }
  } else {
    keyValue = obj;
  }
  if (index >= 0) {
    array.splice(index, 0, obj);
  } else {
    array.push(obj);
  }
  setDataByKeyMapValue(array, keyValue, obj);
  if (!isBatch) {
    return (0, _utils.trivialPromise)((0, _config.default)().useLegacyStoreResult ? data : obj, keyValue);
  }
}
function remove(keyInfo, array, key, isBatch, logError) {
  const index = indexByKey(keyInfo, array, key);
  if (index > -1) {
    array.splice(index, 1);
    setDataByKeyMapValue(array, key, null);
  }
  if (!isBatch) {
    return (0, _utils.trivialPromise)(key);
  }
  if (index < 0) {
    return getErrorResult(isBatch, logError, 'E4009');
  }
}
function indexByKey(keyInfo, array, key) {
  const keyExpr = keyInfo.key();
  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }
  for (let i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if ((0, _utils.keysEqual)(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }
  return -1;
}

/***/ }),

/***/ 65734:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _deferred = __webpack_require__(62754);
var _type = __webpack_require__(35922);
var _abstract_store = _interopRequireDefault(__webpack_require__(67403));
var _array_query = _interopRequireDefault(__webpack_require__(35042));
var _array_utils = __webpack_require__(60637);
var _errors = __webpack_require__(18438);
var _store_helper = _interopRequireDefault(__webpack_require__(99236));
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// @ts-expect-error

const TOTAL_COUNT = 'totalCount';
const LOAD = 'load';
const BY_KEY = 'byKey';
const INSERT = 'insert';
const UPDATE = 'update';
const REMOVE = 'remove';
function isPromise(obj) {
  return obj && (0, _type.isFunction)(obj.then);
}
function trivialPromise(value) {
  // @ts-expect-error
  return new _deferred.Deferred().resolve(value).promise();
}
function ensureRequiredFuncOption(name, obj) {
  if (!(0, _type.isFunction)(obj)) {
    throw _errors.errors.Error('E4011', name);
  }
}
function throwInvalidUserFuncResult(name) {
  throw _errors.errors.Error('E4012', name);
}
function createUserFuncFailureHandler(pendingDeferred) {
  function errorMessageFromXhr(promiseArguments) {
    const xhr = promiseArguments[0];
    const textStatus = promiseArguments[1];
    if (!xhr || !xhr.getResponseHeader) {
      return null;
    }
    return (0, _utils.errorMessageFromXhr)(xhr, textStatus);
  }
  return function (arg) {
    let error;
    if (arg instanceof Error) {
      error = arg;
    } else {
      error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || 'Unknown error');
    }
    if (error.message !== _utils.XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error);
    }
  };
}
function invokeUserLoad(store, options) {
  const userFunc = store._loadFunc;
  let userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options]);
  if (Array.isArray(userResult)) {
    userResult = trivialPromise(userResult);
  } else if (userResult === null || userResult === undefined) {
    userResult = trivialPromise([]);
  } else if (!isPromise(userResult)) {
    throwInvalidUserFuncResult(LOAD);
  }
  return (0, _deferred.fromPromise)(userResult);
}
function invokeUserTotalCountFunc(store, options) {
  const userFunc = store._totalCountFunc;
  let userResult;
  if (!(0, _type.isFunction)(userFunc)) {
    throw _errors.errors.Error('E4021');
  }
  userResult = userFunc.apply(store, [options]);
  if (!isPromise(userResult)) {
    userResult = Number(userResult);
    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }
    userResult = trivialPromise(userResult);
  }
  return (0, _deferred.fromPromise)(userResult);
}
function invokeUserByKeyFunc(store, key, extraOptions) {
  const userFunc = store._byKeyFunc;
  let userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);
  if (!isPromise(userResult)) {
    userResult = trivialPromise(userResult);
  }
  return (0, _deferred.fromPromise)(userResult);
}
function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    const loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }
    loadPromise.always(() => {
      delete store.__rawDataPromise;
    }).done(rawData => {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }
      continuation(rawData);
    }).fail(error => {
      var _store$_errorHandler;
      const userFuncFailureHandler = createUserFuncFailureHandler(pendingDeferred);
      (_store$_errorHandler = store._errorHandler) === null || _store$_errorHandler === void 0 || _store$_errorHandler.call(store, error);
      userFuncFailureHandler(error);
    });
  }
}
function runRawLoadWithQuery(pendingDeferred, store, options, countOnly) {
  options = options || {};
  const userFuncOptions = {};
  if ('userData' in options) {
    // @ts-expect-error
    userFuncOptions.userData = options.userData;
  }
  runRawLoad(pendingDeferred, store, userFuncOptions, rawData => {
    const rawDataQuery = (0, _array_query.default)(rawData, {
      errorHandler: store._errorHandler
    });
    let itemsQuery;
    let totalCountQuery;
    const waitList = [];
    let items;
    let totalCount;
    if (!countOnly) {
      // @ts-expect-error
      itemsQuery = _store_helper.default.queryByOptions(rawDataQuery, options);
      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        // @ts-expect-error
        waitList.push(itemsQuery.enumerate().done(asyncResult => {
          items = asyncResult;
        }));
      }
    }
    if (options.requireTotalCount || countOnly) {
      totalCountQuery = _store_helper.default.queryByOptions(rawDataQuery, options, true);
      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        // @ts-expect-error
        waitList.push(totalCountQuery.count().done(asyncResult => {
          totalCount = asyncResult;
        }));
      }
    }
    _deferred.when.apply(_renderer.default, waitList).done(() => {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail(x => {
      pendingDeferred.reject(x);
    });
  });
}
function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, rawData => {
    const keyExpr = store.key();
    let item;
    for (let i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];
      if ((0, _utils.keysEqual)(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }
    pendingDeferred.reject(_errors.errors.Error('E4009'));
  });
}
// @ts-expect-error
const CustomStore = _abstract_store.default.inherit({
  ctor(options) {
    options = options || {};
    this.callBase(options);
    this._useDefaultSearch = !!options.useDefaultSearch || options.loadMode === 'raw';
    this._loadMode = options.loadMode;
    this._cacheRawData = options.cacheRawData !== false;
    this._loadFunc = options[LOAD];
    this._totalCountFunc = options[TOTAL_COUNT];
    this._byKeyFunc = options[BY_KEY];
    this._insertFunc = options[INSERT];
    this._updateFunc = options[UPDATE];
    this._removeFunc = options[REMOVE];
  },
  _clearCache() {
    delete this.__rawData;
  },
  createQuery() {
    throw _errors.errors.Error('E4010');
  },
  clearRawDataCache() {
    this._clearCache();
  },
  _totalCountImpl(options) {
    // @ts-expect-error
    let d = new _deferred.Deferred();
    if (this._loadMode === 'raw' && !this._totalCountFunc) {
      runRawLoadWithQuery(d, this, options, true);
    } else {
      invokeUserTotalCountFunc(this, options).done(count => {
        d.resolve(Number(count));
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _pushImpl(changes) {
    if (this.__rawData) {
      // @ts-expect-error
      (0, _array_utils.applyBatch)({
        keyInfo: this,
        data: this.__rawData,
        changes
      });
    }
  },
  _loadImpl(options) {
    // @ts-expect-error
    let d = new _deferred.Deferred();
    if (this._loadMode === 'raw') {
      runRawLoadWithQuery(d, this, options, false);
    } else {
      invokeUserLoad(this, options).done((data, extra) => {
        d.resolve(data, extra);
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _byKeyImpl(key, extraOptions) {
    // @ts-expect-error
    const d = new _deferred.Deferred();
    if (this._byKeyViaLoad()) {
      this._requireKey();
      runRawLoadWithKey(d, this, key);
    } else {
      invokeUserByKeyFunc(this, key, extraOptions).done(obj => {
        d.resolve(obj);
      }).fail(createUserFuncFailureHandler(d));
    }
    return d.promise();
  },
  _byKeyViaLoad() {
    return this._loadMode === 'raw' && !this._byKeyFunc;
  },
  _insertImpl(values) {
    const that = this;
    const userFunc = that._insertFunc;
    let userResult;
    // @ts-expect-error
    const d = new _deferred.Deferred();
    ensureRequiredFuncOption(INSERT, userFunc);
    userResult = userFunc.apply(that, [values]); // should return key or data
    if (!isPromise(userResult)) {
      userResult = trivialPromise(userResult);
    }
    (0, _deferred.fromPromise)(userResult).done(serverResponse => {
      if ((0, _config.default)().useLegacyStoreResult) {
        d.resolve(values, serverResponse);
      } else {
        d.resolve(serverResponse || values, that.keyOf(serverResponse));
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _updateImpl(key, values) {
    const userFunc = this._updateFunc;
    let userResult;
    // @ts-expect-error
    const d = new _deferred.Deferred();
    ensureRequiredFuncOption(UPDATE, userFunc);
    userResult = userFunc.apply(this, [key, values]);
    if (!isPromise(userResult)) {
      userResult = trivialPromise(userResult);
    }
    (0, _deferred.fromPromise)(userResult).done(serverResponse => {
      if ((0, _config.default)().useLegacyStoreResult) {
        d.resolve(key, values);
      } else {
        d.resolve(serverResponse || values, key);
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _removeImpl(key) {
    const userFunc = this._removeFunc;
    let userResult;
    // @ts-expect-error
    const d = new _deferred.Deferred();
    ensureRequiredFuncOption(REMOVE, userFunc);
    userResult = userFunc.apply(this, [key]);
    if (!isPromise(userResult)) {
      // @ts-expect-error
      userResult = trivialPromise();
    }
    (0, _deferred.fromPromise)(userResult).done(() => {
      d.resolve(key);
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  }
});
var _default = exports["default"] = CustomStore;

/***/ }),

/***/ 68469:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global Debug */

const window = (0, _window.getWindow)();
let IS_WINJS_ORIGIN;
let IS_LOCAL_ORIGIN;
function isLocalHostName(url) {
  return /^(localhost$|127\.)/i.test(url); // TODO more precise check for 127.x.x.x IP
}
const EndpointSelector = function (config) {
  this.config = config;
  IS_WINJS_ORIGIN = window.location.protocol === 'ms-appx:';
  IS_LOCAL_ORIGIN = isLocalHostName(window.location.hostname);
};
EndpointSelector.prototype = {
  urlFor(key) {
    const bag = this.config[key];
    if (!bag) {
      throw _errors.default.Error('E0006');
    }
    if (bag.production) {
      // @ts-expect-error
      if (IS_WINJS_ORIGIN && !Debug.debuggerEnabled || !IS_WINJS_ORIGIN && !IS_LOCAL_ORIGIN) {
        return bag.production;
      }
    }
    return bag.local;
  }
};
var _default = exports["default"] = EndpointSelector;

/***/ }),

/***/ 56121:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setErrorHandler = exports.handleError = exports.errors = exports.errorHandler = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _error = _interopRequireDefault(__webpack_require__(95640));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const errors = exports.errors = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  E4000: '[DevExpress.data]: {0}',
  E4001: 'Unknown aggregating function is detected: \'{0}\'',
  E4002: 'Unsupported OData protocol version is used',
  E4003: 'Unknown filter operation is used: {0}',
  E4004: 'The thenby() method is called before the sortby() method',
  E4005: 'Store requires a key expression for this operation',
  E4006: 'ArrayStore \'data\' option must be an array',
  E4007: 'Compound keys cannot be auto-generated',
  E4008: 'Attempt to insert an item with a duplicated key',
  E4009: 'Data item cannot be found',
  E4010: 'CustomStore does not support creating queries',
  E4011: 'Custom Store method is not implemented or is not a function: {0}',
  E4012: 'Custom Store method returns an invalid value: {0}',
  E4013: 'Local Store requires the \'name\' configuration option is specified',
  E4014: 'Unknown data type is specified for ODataStore: {0}',
  E4015: 'Unknown entity name or alias is used: {0}',
  E4016: 'The compileSetter(expr) method is called with \'self\' passed as a parameter',
  E4017: 'Keys cannot be modified',
  E4018: 'The server has returned a non-numeric value in a response to an item count request',
  E4019: 'Mixing of group operators inside a single group of filter expression is not allowed',
  E4020: 'Unknown store type is detected: {0}',
  E4021: 'The server response does not provide the totalCount value',
  E4022: 'The server response does not provide the groupCount value',
  E4023: 'Could not parse the following XML: {0}',
  E4024: 'String function {0} cannot be used with the data field {1} of type {2}.',
  W4000: 'Data returned from the server has an incorrect structure',
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
  W4002: 'Data loading has failed for some cells due to the following error: {0}'
});
// eslint-disable-next-line import/no-mutable-exports
let errorHandler = exports.errorHandler = null;
const handleError = function (error) {
  var _errorHandler;
  // @ts-expect-error
  (_errorHandler = errorHandler) === null || _errorHandler === void 0 || _errorHandler(error);
};
// eslint-disable-next-line no-return-assign
exports.handleError = handleError;
const setErrorHandler = handler => exports.errorHandler = errorHandler = handler;
exports.setErrorHandler = setErrorHandler;

/***/ }),

/***/ 60305:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _array_store = _interopRequireDefault(__webpack_require__(26562));
var _errors = __webpack_require__(18438);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

const window = (0, _window.getWindow)();
const {
  abstract
} = _class.default;
const LocalStoreBackend = _class.default.inherit({
  ctor(store, storeOptions) {
    this._store = store;
    this._dirty = !!storeOptions.data;
    this.save();
    const immediate = this._immediate = storeOptions.immediate;
    const flushInterval = Math.max(100, storeOptions.flushInterval || 10 * 1000);
    if (!immediate) {
      const saveProxy = this.save.bind(this);
      setInterval(saveProxy, flushInterval);
      _events_engine.default.on(window, 'beforeunload', saveProxy);
      // @ts-expect-error
      if (window.cordova) {
        // @ts-expect-error
        _dom_adapter.default.listen(_dom_adapter.default.getDocument(), 'pause', saveProxy, false);
      }
    }
  },
  notifyChanged() {
    this._dirty = true;
    if (this._immediate) {
      this.save();
    }
  },
  load() {
    this._store._array = this._loadImpl();
    this._dirty = false;
  },
  save() {
    if (!this._dirty) {
      return;
    }
    this._saveImpl(this._store._array);
    this._dirty = false;
  },
  _loadImpl: abstract,
  _saveImpl: abstract
});
const DomLocalStoreBackend = LocalStoreBackend.inherit({
  ctor(store, storeOptions) {
    const {
      name
    } = storeOptions;
    if (!name) {
      throw _errors.errors.Error('E4013');
    }
    this._key = `dx-data-localStore-${name}`;
    this.callBase(store, storeOptions);
  },
  _loadImpl() {
    const raw = window.localStorage.getItem(this._key);
    if (raw) {
      return JSON.parse(raw);
    }
    return [];
  },
  _saveImpl(array) {
    if (!array.length) {
      window.localStorage.removeItem(this._key);
    } else {
      window.localStorage.setItem(this._key, JSON.stringify(array));
    }
  }
});
const localStoreBackends = {
  dom: DomLocalStoreBackend
};
// @ts-expect-error
const LocalStore = _array_store.default.inherit({
  ctor(options) {
    if (typeof options === 'string') {
      options = {
        name: options
      };
    } else {
      options = options || {};
    }
    this.callBase(options);
    this._backend = new localStoreBackends[options.backend || 'dom'](this, options);
    this._backend.load();
  },
  _clearCache() {
    this._backend.load();
  },
  clear() {
    this.callBase();
    this._backend.notifyChanged();
  },
  _insertImpl(values) {
    const b = this._backend;
    return this.callBase(values).done(b.notifyChanged.bind(b));
  },
  _updateImpl(key, values) {
    const b = this._backend;
    return this.callBase(key, values).done(b.notifyChanged.bind(b));
  },
  _removeImpl(key) {
    const b = this._backend;
    return this.callBase(key).done(b.notifyChanged.bind(b));
  }
}, 'local');
var _default = exports["default"] = LocalStore;

/***/ }),

/***/ 38926:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _query_implementation = __webpack_require__(77549);
const query = function () {
  const impl = Array.isArray(arguments[0]) ? 'array' : 'remote';
  // @ts-expect-error
  return _query_implementation.queryImpl[impl].apply(this, arguments);
};
var _default = exports["default"] = query;

/***/ }),

/***/ 59122:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _deferred = __webpack_require__(62754);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _array_query = _interopRequireDefault(__webpack_require__(35042));
var _errors = __webpack_require__(18438);
var _query_adapters = _interopRequireDefault(__webpack_require__(16135));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable @typescript-eslint/naming-convention */

// @ts-expect-error

const remoteQueryImpl = function (url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};
  const createTask = function (name, args) {
    return {
      name,
      args
    };
  };
  const exec = function (executorTask) {
    // @ts-expect-error
    const d = new _deferred.Deferred();
    let _adapterFactory;
    let _adapter;
    let _taskQueue;
    let _currentTask;
    let _mergedSortArgs;
    const rejectWithNotify = function (error) {
      const handler = queryOptions.errorHandler;
      if (handler) {
        handler(error);
      }
      (0, _errors.handleError)(error);
      d.reject(error);
    };
    function mergeSortTask(task) {
      // eslint-disable-next-line default-case
      switch (task.name) {
        case 'sortBy':
          _mergedSortArgs = [task.args];
          return true;
        case 'thenBy':
          if (!_mergedSortArgs) {
            throw _errors.errors.Error('E4004');
          }
          _mergedSortArgs.push(task.args);
          return true;
      }
      return false;
    }
    function unmergeSortTasks() {
      const head = _taskQueue[0];
      const unmergedTasks = [];
      if (head && head.name === 'multiSort') {
        _taskQueue.shift();
        (0, _iterator.each)(head.args[0], function () {
          // @ts-expect-error
          unmergedTasks.push(createTask(unmergedTasks.length ? 'thenBy' : 'sortBy', this));
        });
      }
      _taskQueue = unmergedTasks.concat(_taskQueue);
    }
    try {
      _adapterFactory = queryOptions.adapter;
      if (!(0, _type.isFunction)(_adapterFactory)) {
        _adapterFactory = _query_adapters.default[_adapterFactory];
      }
      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      const {
        optimize
      } = _adapter;
      if (optimize) optimize(_taskQueue);
      while (_taskQueue.length) {
        /* eslint-disable-next-line prefer-destructuring */
        _currentTask = _taskQueue[0];
        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask('multiSort', [_mergedSortArgs]));
            _mergedSortArgs = null;
            continue;
          }
          if (String(_currentTask.name) !== 'enumerate') {
            if (!_adapter[_currentTask.name] || _adapter[_currentTask.name].apply(_adapter, _currentTask.args) === false) {
              break;
            }
          }
        }
        _taskQueue.shift();
      }
      unmergeSortTasks();
      _adapter.exec(url).done((result, extra) => {
        if (!_taskQueue.length) {
          d.resolve(result, extra);
        } else {
          let clientChain = (0, _array_query.default)(result, {
            errorHandler: queryOptions.errorHandler
          });
          (0, _iterator.each)(_taskQueue, function () {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          });
          clientChain
          // @ts-expect-error
          .done(d.resolve).fail(d.reject);
        }
      }).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }
    return d.promise();
  };
  const query = {};
  (0, _iterator.each)(['sortBy', 'thenBy', 'filter', 'slice', 'select', 'groupBy'], function () {
    const name = String(this);
    query[name] = function () {
      return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name, arguments)));
    };
  });
  (0, _iterator.each)(['count', 'min', 'max', 'sum', 'avg', 'aggregate', 'enumerate'], function () {
    const name = String(this);
    query[name] = function () {
      return exec.call(this, createTask(name, arguments));
    };
  });
  return query;
};
var _default = exports["default"] = remoteQueryImpl;

/***/ }),

/***/ 18475:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _array_query = _interopRequireDefault(__webpack_require__(35042));
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// @ts-expect-error

function multiLevelGroup(query, groupInfo) {
  query = query.groupBy(groupInfo[0].selector);
  if (groupInfo.length > 1) {
    query = query.select(g => (0, _extend.extend)({}, g, {
      // @ts-expect-error
      items: multiLevelGroup((0, _array_query.default)(g.items), groupInfo.slice(1)).toArray()
    }));
  }
  return query;
}
function arrangeSortingInfo(groupInfo, sortInfo) {
  const filteredGroup = [];
  (0, _iterator.each)(groupInfo, (_, group) => {
    const collision = (0, _common.grep)(sortInfo, sort => group.selector === sort.selector);
    if (collision.length < 1) {
      // @ts-expect-error
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}
function queryByOptions(query, options, isCountQuery) {
  var _options;
  options = options || {};
  const {
    filter
  } = options;
  if ((_options = options) !== null && _options !== void 0 && _options.langParams) {
    var _query$setLangParams, _query;
    (_query$setLangParams = (_query = query).setLangParams) === null || _query$setLangParams === void 0 || _query$setLangParams.call(_query, options.langParams);
  }
  if (filter) {
    query = query.filter(filter);
  }
  if (isCountQuery) {
    return query;
  }
  let {
    sort
  } = options;
  const {
    select
  } = options;
  let {
    group
  } = options;
  const {
    skip
  } = options;
  const {
    take
  } = options;
  if (group) {
    group = (0, _utils.normalizeSortingInfo)(group);
    group.keepInitialKeyOrder = !!options.group.keepInitialKeyOrder;
  }
  if (sort || group) {
    sort = (0, _utils.normalizeSortingInfo)(sort || []);
    if (group && !group.keepInitialKeyOrder) {
      sort = arrangeSortingInfo(group, sort);
    }
    (0, _iterator.each)(sort, function (index) {
      query = query[index ? 'thenBy' : 'sortBy'](this.selector, this.desc, this.compare);
    });
  }
  if (select) {
    query = query.select(select);
  }
  if (group) {
    query = multiLevelGroup(query, group);
  }
  if (take || skip) {
    query = query.slice(skip || 0, take);
  }
  return query;
}
var _default = exports["default"] = {
  multiLevelGroup,
  arrangeSortingInfo,
  queryByOptions
};

/***/ }),

/***/ 27592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.errorMessageFromXhr = exports.base64_encode = exports.aggregators = exports.XHR_ERROR_UNLOAD = void 0;
exports.isConjunctiveOperator = isConjunctiveOperator;
exports.isDisjunctiveOperator = isDisjunctiveOperator;
exports.rejectedPromise = exports.processRequestResultLock = exports.normalizeSortingInfo = exports.normalizeBinaryCriterion = exports.keysEqual = exports.isUniformEqualsByOr = exports.isUnaryOperation = exports.isGroupCriterion = void 0;
exports.throttleChanges = throttleChanges;
exports.trivialPromise = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _iterator = __webpack_require__(95479);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable spellcheck/spell-checker */

const ready = _ready_callbacks.default.add;
const XHR_ERROR_UNLOAD = exports.XHR_ERROR_UNLOAD = 'DEVEXTREME_XHR_ERROR_UNLOAD';
const normalizeBinaryCriterion = function (crit) {
  return [crit[0], crit.length < 3 ? '=' : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
};
exports.normalizeBinaryCriterion = normalizeBinaryCriterion;
const normalizeSortingInfo = function (info) {
  if (!Array.isArray(info)) {
    info = [info];
  }
  return (0, _iterator.map)(info, i => {
    const result = {
      selector: (0, _type.isFunction)(i) || typeof i === 'string' ? i : i.getter || i.field || i.selector,
      desc: !!(i.desc || String(i.dir).charAt(0).toLowerCase() === 'd')
    };
    if (i.compare) {
      // @ts-expect-error
      result.compare = i.compare;
    }
    return result;
  });
};
exports.normalizeSortingInfo = normalizeSortingInfo;
const errorMessageFromXhr = exports.errorMessageFromXhr = function () {
  const textStatusMessages = {
    timeout: 'Network connection timeout',
    error: 'Unspecified network error',
    parsererror: 'Unexpected server response'
  };
  const explainTextStatus = function (textStatus) {
    let result = textStatusMessages[textStatus];
    if (!result) {
      return textStatus;
    }
    return result;
  };
  // T542570, https://stackoverflow.com/a/18170879
  let unloading;
  ready(() => {
    const window = (0, _window.getWindow)();
    // @ts-expect-error
    _dom_adapter.default.listen(window, 'beforeunload', () => {
      unloading = true;
    });
  });
  return function (xhr, textStatus) {
    if (unloading) {
      return XHR_ERROR_UNLOAD;
    }
    if (xhr.status < 400) {
      return explainTextStatus(textStatus);
    }
    return xhr.statusText;
  };
}();
const aggregators = exports.aggregators = {
  count: {
    seed: 0,
    step(count) {
      return 1 + count;
    }
  },
  sum: {
    seed: 0,
    step(sum, item) {
      return sum + item;
    }
  },
  min: {
    step(min, item) {
      return item < min ? item : min;
    }
  },
  max: {
    step(max, item) {
      return item > max ? item : max;
    }
  },
  avg: {
    seed: [0, 0],
    step(pair, value) {
      return [pair[0] + value, pair[1] + 1];
    },
    finalize(pair) {
      return pair[1] ? pair[0] / pair[1] : NaN;
    }
  }
};
const processRequestResultLock = exports.processRequestResultLock = function () {
  let lockCount = 0;
  let lockDeferred;
  const obtain = function () {
    if (lockCount === 0) {
      // @ts-expect-error
      lockDeferred = new _deferred.Deferred();
    }
    lockCount++;
  };
  const release = function () {
    lockCount--;
    if (lockCount < 1) {
      lockDeferred.resolve();
    }
  };
  const promise = function () {
    // @ts-expect-error
    const deferred = lockCount === 0 ? new _deferred.Deferred().resolve() : lockDeferred;
    return deferred.promise();
  };
  const reset = function () {
    lockCount = 0;
    if (lockDeferred) {
      lockDeferred.resolve();
    }
  };
  return {
    obtain,
    release,
    promise,
    reset
  };
}();
function isDisjunctiveOperator(condition) {
  return /^(or|\|\||\|)$/i.test(condition);
}
function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}
const keysEqual = function (keyExpr, key1, key2) {
  if (Array.isArray(keyExpr)) {
    const names = (0, _iterator.map)(key1, (v, k) => k);
    let name;
    for (let i = 0; i < names.length; i++) {
      name = names[i];
      if (!(0, _common.equalByValue)(key1[name], key2[name], {
        strict: false
      })) {
        return false;
      }
    }
    return true;
  }
  return (0, _common.equalByValue)(key1, key2, {
    strict: false
  });
};
exports.keysEqual = keysEqual;
const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
// eslint-disable-next-line @typescript-eslint/naming-convention
const base64_encode = function (input) {
  if (!Array.isArray(input)) {
    input = stringToByteArray(String(input));
  }
  let result = '';
  function getBase64Char(index) {
    return BASE64_CHARS.charAt(index);
  }
  for (let i = 0; i < input.length; i += 3) {
    const octet1 = input[i];
    const octet2 = input[i + 1];
    const octet3 = input[i + 2];
    result += (0, _iterator.map)([octet1 >> 2, (octet1 & 3) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (octet2 & 15) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : octet3 & 63], getBase64Char).join('');
  }
  return result;
};
exports.base64_encode = base64_encode;
function stringToByteArray(str) {
  const bytes = [];
  let code;
  let i;
  for (i = 0; i < str.length; i++) {
    code = str.charCodeAt(i);
    if (code < 128) {
      bytes.push(code);
    } else if (code < 2048) {
      bytes.push(192 + (code >> 6), 128 + (code & 63));
    } else if (code < 65536) {
      bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (code & 63));
    } else if (code < 2097152) {
      bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (code & 63));
    }
  }
  return bytes;
}
const isUnaryOperation = function (crit) {
  return crit[0] === '!' && Array.isArray(crit[1]);
};
exports.isUnaryOperation = isUnaryOperation;
const isGroupOperator = function (value) {
  return value === 'and' || value === 'or';
};
const isUniformEqualsByOr = function (crit) {
  if (crit.length > 2 && Array.isArray(crit[0]) && crit[1] === 'or' && typeof crit[0][0] === 'string' && crit[0][1] === '=') {
    const [prop] = crit[0];
    return !crit.find((el, i) => i % 2 !== 0 ? el !== 'or' : !Array.isArray(el) || el.length !== 3 || el[0] !== prop || el[1] !== '=');
  }
  return false;
};
exports.isUniformEqualsByOr = isUniformEqualsByOr;
const isGroupCriterion = function (crit) {
  const first = crit[0];
  const second = crit[1];
  if (Array.isArray(first)) {
    return true;
  }
  if ((0, _type.isFunction)(first)) {
    if (Array.isArray(second) || (0, _type.isFunction)(second) || isGroupOperator(second)) {
      return true;
    }
  }
  return false;
};
exports.isGroupCriterion = isGroupCriterion;
const trivialPromise = function () {
  // @ts-expect-error
  const d = new _deferred.Deferred();
  return d.resolve.apply(d, arguments).promise();
};
exports.trivialPromise = trivialPromise;
const rejectedPromise = function () {
  // @ts-expect-error
  const d = new _deferred.Deferred();
  return d.reject.apply(d, arguments).promise();
};
exports.rejectedPromise = rejectedPromise;
function throttle(func, timeout) {
  let timeoutId;
  return function () {
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        timeoutId = undefined;
        func.call(this);
      }, (0, _type.isFunction)(timeout) ? timeout() : timeout);
    }
    return timeoutId;
  };
}
function throttleChanges(func, timeout) {
  let cache = [];
  const throttled = throttle(function () {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function (changes) {
    if (Array.isArray(changes)) {
      // @ts-expect-error
      cache.push(...changes);
    }
    // @ts-expect-error
    return throttled.call(this, cache);
  };
}

/***/ }),

/***/ 72006:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(54263);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _request_dispatcher = _interopRequireDefault(__webpack_require__(63081));
var _store = _interopRequireDefault(__webpack_require__(341));
var _m_errors = __webpack_require__(56121);
var _m_utils = __webpack_require__(34158);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ODataContext = _class.default.inherit({
  ctor(options) {
    this._requestDispatcher = new _request_dispatcher.default(options);
    this._errorHandler = options.errorHandler;
    (0, _iterator.each)(options.entities || [], (entityAlias, entityOptions) => {
      this[entityAlias] = new _store.default((0, _extend.extend)({}, options, {
        url: `${this._requestDispatcher.url}/${encodeURIComponent(entityOptions.name || entityAlias)}`
      }, entityOptions));
    });
  },
  get(operationName, params) {
    return this.invoke(operationName, params, 'GET');
  },
  invoke(operationName) {
    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let httpMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'POST';
    httpMethod = httpMethod.toLowerCase();
    // @ts-expect-error
    const d = new _deferred.Deferred();
    let url = `${this._requestDispatcher.url}/${encodeURIComponent(operationName)}`;
    let payload;
    if (this.version() === 4) {
      if (httpMethod === 'get') {
        url = (0, _m_utils.formatFunctionInvocationUrl)(url, (0, _m_utils.escapeServiceOperationParams)(params, this.version()));
        // @ts-expect-error
        params = null;
      } else if (httpMethod === 'post') {
        payload = params;
        // @ts-expect-error
        params = null;
      }
    }
    (0, _deferred.when)(this._requestDispatcher.sendRequest(url, httpMethod, (0, _m_utils.escapeServiceOperationParams)(params, this.version()), payload)).done(r => {
      if ((0, _type.isPlainObject)(r) && operationName in r) {
        r = r[operationName];
      }
      d.resolve(r);
    }).fail(this._errorHandler).fail(_m_errors.handleError).fail(d.reject);
    return d.promise();
  },
  objectLink(entityAlias, key) {
    const store = this[entityAlias];
    if (!store) {
      throw _m_errors.errors.Error('E4015', entityAlias);
    }
    if (!(0, _type.isDefined)(key)) {
      return null;
    }
    return {
      __metadata: {
        uri: store._byKeyUrl(key)
      }
    };
  },
  version() {
    return this._requestDispatcher.version;
  }
});
var _default = exports["default"] = ODataContext;

/***/ }),

/***/ 30953:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.odata = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _query_adapters = _interopRequireDefault(__webpack_require__(16135));
var _m_errors = __webpack_require__(56121);
var _m_utils = __webpack_require__(27592);
var _m_utils2 = __webpack_require__(34158);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_PROTOCOL_VERSION = 4;
const STRING_FUNCTIONS = ['contains', 'notcontains', 'startswith', 'endswith'];
const compileCriteria = (() => {
  let protocolVersion;
  let forceLowerCase;
  let fieldTypes;
  const createBinaryOperationFormatter = op => (prop, val) => `${prop} ${op} ${val}`;
  const createStringFuncFormatter = (op, reverse) => (prop, val) => {
    const bag = [op, '('];
    if (forceLowerCase) {
      prop = prop.indexOf('tolower(') === -1 ? `tolower(${prop})` : prop;
      val = val.toLowerCase();
    }
    if (reverse) {
      bag.push(val, ',', prop);
    } else {
      bag.push(prop, ',', val);
    }
    bag.push(')');
    return bag.join('');
  };
  const isStringFunction = function (name) {
    return STRING_FUNCTIONS.some(funcName => funcName === name);
  };
  const formatters = {
    '=': createBinaryOperationFormatter('eq'),
    '<>': createBinaryOperationFormatter('ne'),
    '>': createBinaryOperationFormatter('gt'),
    '>=': createBinaryOperationFormatter('ge'),
    '<': createBinaryOperationFormatter('lt'),
    '<=': createBinaryOperationFormatter('le'),
    // @ts-expect-error
    startswith: createStringFuncFormatter('startswith'),
    // @ts-expect-error
    endswith: createStringFuncFormatter('endswith')
  };
  const formattersV2 = (0, _extend.extend)({}, formatters, {
    /* eslint-disable spellcheck/spell-checker */
    contains: createStringFuncFormatter('substringof', true),
    notcontains: createStringFuncFormatter('not substringof', true)
  });
  const formattersV4 = (0, _extend.extend)({}, formatters, {
    // @ts-expect-error
    contains: createStringFuncFormatter('contains'),
    // @ts-expect-error
    notcontains: createStringFuncFormatter('not contains')
  });
  const compileBinary = criteria => {
    var _fieldTypes;
    criteria = (0, _m_utils.normalizeBinaryCriterion)(criteria);
    const op = criteria[1];
    const fieldName = criteria[0];
    const fieldType = fieldTypes && fieldTypes[fieldName];
    if (fieldType && isStringFunction(op) && fieldType !== 'String') {
      // @ts-expect-error
      throw new _m_errors.errors.Error('E4024', op, fieldName, fieldType);
    }
    const formatters = protocolVersion === 4 ? formattersV4 : formattersV2;
    const formatter = formatters[op.toLowerCase()];
    if (!formatter) {
      throw _m_errors.errors.Error('E4003', op);
    }
    let value = criteria[2];
    if ((_fieldTypes = fieldTypes) !== null && _fieldTypes !== void 0 && _fieldTypes[fieldName]) {
      value = (0, _m_utils2.convertPrimitiveValue)(fieldTypes[fieldName], value);
    }
    return formatter((0, _m_utils2.serializePropName)(fieldName), (0, _m_utils2.serializeValue)(value, protocolVersion));
  };
  const compileUnary = criteria => {
    const op = criteria[0];
    const crit = compileCore(criteria[1]);
    if (op === '!') {
      return `not (${crit})`;
    }
    throw _m_errors.errors.Error('E4003', op);
  };
  const compileGroup = criteria => {
    const bag = [];
    let groupOperator;
    let nextGroupOperator;
    (0, _iterator.each)(criteria, function (index, criterion) {
      if (Array.isArray(criterion)) {
        if (bag.length > 1 && groupOperator !== nextGroupOperator) {
          // @ts-expect-error
          throw new _m_errors.errors.Error('E4019');
        }
        // @ts-expect-error
        bag.push(`(${compileCore(criterion)})`);
        groupOperator = nextGroupOperator;
        nextGroupOperator = 'and';
      } else {
        nextGroupOperator = (0, _m_utils.isConjunctiveOperator)(this) ? 'and' : 'or';
      }
    });
    return bag.join(` ${groupOperator} `);
  };
  const compileCore = criteria => {
    if (Array.isArray(criteria[0])) {
      return compileGroup(criteria);
    }
    if ((0, _m_utils.isUnaryOperation)(criteria)) {
      return compileUnary(criteria);
    }
    return compileBinary(criteria);
  };
  return (criteria, version, types, filterToLower) => {
    fieldTypes = types;
    forceLowerCase = filterToLower ?? (0, _config.default)().oDataFilterToLower;
    protocolVersion = version;
    return compileCore(criteria);
  };
})();
const createODataQueryAdapter = queryOptions => {
  /* eslint-disable  @typescript-eslint/naming-convention */
  let _sorting = [];
  const _criteria = [];
  const _expand = queryOptions.expand;
  let _select;
  let _skip;
  let _take;
  let _countQuery;
  const _oDataVersion = queryOptions.version || DEFAULT_PROTOCOL_VERSION;
  const hasSlice = () => _skip || _take !== undefined;
  const hasFunction = criterion => {
    for (let i = 0; i < criterion.length; i++) {
      if ((0, _type.isFunction)(criterion[i])) {
        return true;
      }
      if (Array.isArray(criterion[i]) && hasFunction(criterion[i])) {
        return true;
      }
    }
    return false;
  };
  const requestData = () => {
    const result = {};
    if (!_countQuery) {
      if (_sorting.length) {
        // @ts-expect-error
        result.$orderby = _sorting.join(',');
      }
      if (_skip) {
        // @ts-expect-error
        result.$skip = _skip;
      }
      if (_take !== undefined) {
        // @ts-expect-error
        result.$top = _take;
      }
      // @ts-expect-error
      result.$select = (0, _m_utils2.generateSelect)(_oDataVersion, _select) || undefined;
      // @ts-expect-error
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      result.$expand = (0, _m_utils2.generateExpand)(_oDataVersion, _expand, _select) || undefined;
    }
    if (_criteria.length) {
      const criteria = _criteria.length < 2 ? _criteria[0] : _criteria;
      const fieldTypes = queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fieldTypes;
      const filterToLower = queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.filterToLower;
      // @ts-expect-error
      result.$filter = compileCriteria(criteria, _oDataVersion, fieldTypes, filterToLower);
    }
    if (_countQuery) {
      // @ts-expect-error
      result.$top = 0;
    }
    if (queryOptions.requireTotalCount || _countQuery) {
      // todo: tests!!!
      if (_oDataVersion !== 4) {
        // @ts-expect-error
        result.$inlinecount = 'allpages';
      } else {
        // @ts-expect-error
        result.$count = 'true';
      }
    }
    return result;
  };
  const tryLiftSelect = tasks => {
    let selectIndex = -1;
    for (let i = 0; i < tasks.length; i++) {
      if (tasks[i].name === 'select') {
        selectIndex = i;
        break;
      }
    }
    if (selectIndex < 0 || !(0, _type.isFunction)(tasks[selectIndex].args[0])) return;
    const nextTask = tasks[1 + selectIndex];
    if (!nextTask || nextTask.name !== 'slice') return;
    tasks[1 + selectIndex] = tasks[selectIndex];
    tasks[selectIndex] = nextTask;
  };
  return {
    optimize: tryLiftSelect,
    exec(url) {
      return (0, _m_utils2.sendRequest)(_oDataVersion, {
        url,
        params: (0, _extend.extend)(requestData(), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.params)
      }, {
        beforeSend: queryOptions.beforeSend,
        jsonp: queryOptions.jsonp,
        withCredentials: queryOptions.withCredentials,
        countOnly: _countQuery,
        deserializeDates: queryOptions.deserializeDates,
        fieldTypes: queryOptions.fieldTypes,
        isPaged: isFinite(_take)
      });
    },
    /* eslint-disable @typescript-eslint/no-invalid-void-type */
    multiSort(args) {
      let rules;
      if (hasSlice()) {
        return false;
      }
      for (let i = 0; i < args.length; i++) {
        const getter = args[i][0];
        const desc = !!args[i][1];
        let rule;
        if (typeof getter !== 'string') {
          return false;
        }
        rule = (0, _m_utils2.serializePropName)(getter);
        if (desc) {
          rule += ' desc';
        }
        rules = rules || [];
        rules.push(rule);
      }
      _sorting = rules;
    },
    slice(skipCount, takeCount) {
      if (hasSlice()) {
        return false;
      }
      _skip = skipCount;
      _take = takeCount;
    },
    filter(criterion) {
      if (hasSlice()) {
        return false;
      }
      if (!Array.isArray(criterion)) {
        criterion = [].slice.call(arguments);
      }
      if (hasFunction(criterion)) {
        return false;
      }
      if (_criteria.length) {
        // @ts-expect-error
        _criteria.push('and');
      }
      // @ts-expect-error
      _criteria.push(criterion);
    },
    select(expr) {
      if (_select || (0, _type.isFunction)(expr)) {
        return false;
      }
      if (!Array.isArray(expr)) {
        expr = [].slice.call(arguments);
      }
      _select = expr;
    },
    // eslint-disable-next-line no-return-assign
    count: () => _countQuery = true
  };
};
_query_adapters.default.odata = createODataQueryAdapter;
const odata = exports.odata = createODataQueryAdapter;

/***/ }),

/***/ 39755:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(54263);
var _utils = __webpack_require__(77869);
// @ts-expect-error

const DEFAULT_PROTOCOL_VERSION = 4;
class RequestDispatcher {
  constructor(options) {
    options = options || {};
    // @ts-expect-error
    this._url = String(options.url).replace(/\/+$/, '');
    // @ts-expect-error
    this._beforeSend = options.beforeSend;
    // @ts-expect-error
    this._jsonp = options.jsonp;
    // @ts-expect-error
    this._version = options.version || DEFAULT_PROTOCOL_VERSION;
    // @ts-expect-error
    this._withCredentials = options.withCredentials;
    // @ts-expect-error
    this._deserializeDates = options.deserializeDates;
    // @ts-expect-error
    this._filterToLower = options.filterToLower;
  }
  sendRequest(url, method, params, payload) {
    return (0, _utils.sendRequest)(this.version, {
      url,
      method,
      params: params || {},
      payload
    }, {
      // @ts-expect-error
      beforeSend: this._beforeSend,
      // @ts-expect-error
      jsonp: this._jsonp,
      // @ts-expect-error
      withCredentials: this._withCredentials,
      // @ts-expect-error
      deserializeDates: this._deserializeDates
    });
  }
  get version() {
    // @ts-expect-error
    return this._version;
  }
  get beforeSend() {
    // @ts-expect-error
    return this._beforeSend;
  }
  get url() {
    // @ts-expect-error
    return this._url;
  }
  get jsonp() {
    // @ts-expect-error
    return this._jsonp;
  }
  get filterToLower() {
    // @ts-expect-error
    return this._filterToLower;
  }
}
exports["default"] = RequestDispatcher;

/***/ }),

/***/ 3207:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
__webpack_require__(54263);
var _config = _interopRequireDefault(__webpack_require__(80209));
var _deferred = __webpack_require__(62754);
var _type = __webpack_require__(35922);
var _abstract_store = _interopRequireDefault(__webpack_require__(67403));
var _errors = __webpack_require__(18438);
var _request_dispatcher = _interopRequireDefault(__webpack_require__(63081));
var _query = _interopRequireDefault(__webpack_require__(96687));
var _m_utils = __webpack_require__(34158);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

const ANONYMOUS_KEY_NAME = '5d46402c-7899-4ea9-bd81-8b73c47c7683';
const expandKeyType = (key, keyType) => ({
  [key]: keyType
});
const mergeFieldTypesWithKeyType = (fieldTypes, keyType) => {
  const result = {};
  // eslint-disable-next-line no-restricted-syntax, guard-for-in
  for (const field in fieldTypes) {
    result[field] = fieldTypes[field];
  }
  // eslint-disable-next-line no-restricted-syntax
  for (const keyName in keyType) {
    if (keyName in result) {
      if (result[keyName] !== keyType[keyName]) {
        _errors.errors.log('W4001', keyName);
      }
    } else {
      result[keyName] = keyType[keyName];
    }
  }
  return result;
};
// @ts-expect-error
const ODataStore = _abstract_store.default.inherit({
  ctor(options) {
    this.callBase(options);
    this._requestDispatcher = new _request_dispatcher.default(options);
    let key = this.key();
    let {
      fieldTypes
    } = options;
    let {
      keyType
    } = options;
    if (keyType) {
      const keyTypeIsString = typeof keyType === 'string';
      if (!key) {
        key = keyTypeIsString ? ANONYMOUS_KEY_NAME : Object.keys(keyType);
        this._legacyAnonymousKey = key;
      }
      if (keyTypeIsString) {
        keyType = expandKeyType(key, keyType);
      }
      fieldTypes = mergeFieldTypesWithKeyType(fieldTypes, keyType);
    }
    this._fieldTypes = fieldTypes || {};
    if (this.version() === 2) {
      this._updateMethod = 'MERGE';
    } else {
      this._updateMethod = 'PATCH';
    }
  },
  _customLoadOptions() {
    return ['expand', 'customQueryParams'];
  },
  _byKeyImpl(key, extraOptions) {
    const params = {};
    if (extraOptions) {
      // @ts-expect-error
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      params.$expand = (0, _m_utils.generateExpand)(this.version(), extraOptions.expand, extraOptions.select) || undefined;
      // @ts-expect-error
      params.$select = (0, _m_utils.generateSelect)(this.version(), extraOptions.select) || undefined;
    }
    return this._requestDispatcher.sendRequest(this._byKeyUrl(key), 'GET', params);
  },
  createQuery(loadOptions) {
    let url;
    const queryOptions = {
      adapter: 'odata',
      beforeSend: this._requestDispatcher.beforeSend,
      errorHandler: this._errorHandler,
      jsonp: this._requestDispatcher.jsonp,
      version: this._requestDispatcher.version,
      withCredentials: this._requestDispatcher._withCredentials,
      expand: loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.expand,
      requireTotalCount: loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.requireTotalCount,
      deserializeDates: this._requestDispatcher._deserializeDates,
      fieldTypes: this._fieldTypes
    };
    // NOTE: For AppBuilder, do not remove
    url = (loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.urlOverride) ?? this._requestDispatcher.url;
    if ((0, _type.isDefined)(this._requestDispatcher.filterToLower)) {
      // @ts-expect-error
      queryOptions.filterToLower = this._requestDispatcher.filterToLower;
    }
    if (loadOptions !== null && loadOptions !== void 0 && loadOptions.customQueryParams) {
      const params = (0, _m_utils.escapeServiceOperationParams)(loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.customQueryParams, this.version());
      if (this.version() === 4) {
        url = (0, _m_utils.formatFunctionInvocationUrl)(url, params);
      } else {
        // @ts-expect-error
        queryOptions.params = params;
      }
    }
    return (0, _query.default)(url, queryOptions);
  },
  _insertImpl(values) {
    this._requireKey();
    // @ts-expect-error
    const d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._requestDispatcher.url, 'POST', null, values)).done(serverResponse => d.resolve(serverResponse && !(0, _config.default)().useLegacyStoreResult ? serverResponse : values, this.keyOf(serverResponse))).fail(d.reject);
    return d.promise();
  },
  _updateImpl(key, values) {
    // @ts-expect-error
    const d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._byKeyUrl(key), this._updateMethod, null, values)).done(serverResponse => (0, _config.default)().useLegacyStoreResult ? d.resolve(key, values) : d.resolve(serverResponse || values, key)).fail(d.reject);
    return d.promise();
  },
  _removeImpl(key) {
    // @ts-expect-error
    const d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._byKeyUrl(key), 'DELETE')).done(() => d.resolve(key)).fail(d.reject);
    return d.promise();
  },
  _convertKey(value) {
    let result = value;
    const fieldTypes = this._fieldTypes;
    const key = this.key() || this._legacyAnonymousKey;
    if (Array.isArray(key)) {
      result = {};
      for (let i = 0; i < key.length; i++) {
        const keyName = key[i];
        result[keyName] = (0, _m_utils.convertPrimitiveValue)(fieldTypes[keyName], value[keyName]);
      }
    } else if (fieldTypes[key]) {
      result = (0, _m_utils.convertPrimitiveValue)(fieldTypes[key], value);
    }
    return result;
  },
  _byKeyUrl(value) {
    const baseUrl = this._requestDispatcher.url;
    const convertedKey = this._convertKey(value);
    return `${baseUrl}(${encodeURIComponent((0, _m_utils.serializeKey)(convertedKey, this.version()))})`;
  },
  version() {
    return this._requestDispatcher.version;
  }
}, 'odata');
var _default = exports["default"] = ODataStore;

/***/ }),

/***/ 34158:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.serializeValue = exports.serializePropName = exports.serializeKey = exports.sendRequest = exports.keyConverters = exports.generateSelect = exports.generateExpand = exports.formatFunctionInvocationUrl = exports.escapeServiceOperationParams = exports.convertPrimitiveValue = exports.EdmLiteral = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _ajax = _interopRequireDefault(__webpack_require__(37208));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _string = __webpack_require__(68752);
var _type = __webpack_require__(35922);
var _errors = __webpack_require__(18438);
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// @ts-expect-error

// @ts-expect-error

const GUID_REGEX = /^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/;
const VERBOSE_DATE_REGEX = /^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/;
const ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]{1}\d{2}(:?)(\d{2})?)?$/;
// Request processing
const JSON_VERBOSE_MIME_TYPE = 'application/json;odata=verbose';
const makeArray = value => (0, _type.type)(value) === 'string' ? value.split() : value;
const hasDot = x => /\./.test(x);
const pad = (text, length, right) => {
  text = String(text);
  while (text.length < length) {
    text = right ? `${text}0` : `0${text}`;
  }
  return text;
};
const formatISO8601 = (date, skipZeroTime, skipTimezone) => {
  const bag = [];
  const isZeroTime = () => date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1;
  // @ts-expect-error
  const padLeft2 = text => pad(text, 2);
  bag.push(date.getFullYear());
  bag.push('-');
  bag.push(padLeft2(date.getMonth() + 1));
  bag.push('-');
  bag.push(padLeft2(date.getDate()));
  if (!(skipZeroTime && isZeroTime())) {
    bag.push('T');
    bag.push(padLeft2(date.getHours()));
    bag.push(':');
    bag.push(padLeft2(date.getMinutes()));
    bag.push(':');
    bag.push(padLeft2(date.getSeconds()));
    if (date.getMilliseconds()) {
      bag.push('.');
      // @ts-expect-error
      bag.push(pad(date.getMilliseconds(), 3));
    }
    if (!skipTimezone) {
      bag.push('Z');
    }
  }
  return bag.join('');
};
const parseISO8601 = isoString => {
  const result = new Date(new Date(0).getTimezoneOffset() * 60 * 1000);
  const chunks = isoString.replace('Z', '').split('T');
  const date = /(\d{4})-(\d{2})-(\d{2})/.exec(chunks[0]);
  const time = /(\d{2}):(\d{2}):(\d{2})\.?(\d{0,7})?/.exec(chunks[1]);
  // @ts-expect-error
  result.setFullYear(Number(date[1]));
  // @ts-expect-error
  result.setMonth(Number(date[2]) - 1);
  // @ts-expect-error
  result.setDate(Number(date[3]));
  if (Array.isArray(time) && time.length) {
    result.setHours(Number(time[1]));
    result.setMinutes(Number(time[2]));
    result.setSeconds(Number(time[3]));
    let fractional = (time[4] || '').slice(0, 3);
    fractional = pad(fractional, 3, true);
    result.setMilliseconds(Number(fractional));
  }
  return result;
};
const isAbsoluteUrl = url => /^(?:[a-z]+:)?\/{2,2}/i.test(url);
const stripParams = url => {
  const index = url.indexOf('?');
  if (index > -1) {
    return url.substr(0, index);
  }
  return url;
};
const toAbsoluteUrl = (basePath, relativePath) => {
  let part;
  const baseParts = stripParams(basePath).split('/');
  const relativeParts = relativePath.split('/');
  baseParts.pop();
  while (relativeParts.length) {
    part = relativeParts.shift();
    if (part === '..') {
      baseParts.pop();
    } else {
      baseParts.push(part);
    }
  }
  return baseParts.join('/');
};
const param = params => {
  const result = [];
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, no-restricted-syntax, guard-for-in
  for (const name in params) {
    // @ts-expect-error
    result.push(`${name}=${params[name]}`);
  }
  return result.join('&');
};
const ajaxOptionsForRequest = function (protocolVersion, request) {
  var _options$beforeSend;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const formatPayload = payload => JSON.stringify(payload, function (key, value) {
    if (!(this[key] instanceof Date)) {
      return value;
    }
    // @ts-expect-error
    value = formatISO8601(this[key]);
    switch (protocolVersion) {
      case 2:
        return value.substr(0, value.length - 1);
      case 3:
      case 4:
        return value;
      default:
        throw _errors.errors.Error('E4002');
    }
  });
  request = (0, _extend.extend)({
    async: true,
    method: 'get',
    url: '',
    params: {},
    payload: null,
    headers: {},
    timeout: 30000
  }, request);
  // @ts-expect-error
  (_options$beforeSend = options.beforeSend) === null || _options$beforeSend === void 0 || _options$beforeSend.call(options, request);
  const {
    async,
    timeout,
    headers
  } = request;
  let {
    url,
    method
  } = request;
  // @ts-expect-error
  const {
    jsonp,
    withCredentials
  } = options;
  method = (method || 'get').toLowerCase();
  const isGet = method === 'get';
  const useJsonp = isGet && jsonp;
  const params = (0, _extend.extend)({}, request.params);
  const ajaxData = isGet ? params : formatPayload(request.payload);
  const qs = !isGet && param(params);
  const contentType = !isGet && JSON_VERBOSE_MIME_TYPE;
  if (qs) {
    url += (url.indexOf('?') > -1 ? '&' : '?') + qs;
  }
  if (useJsonp) {
    ajaxData.$format = 'json';
  }
  return {
    url,
    data: ajaxData,
    dataType: useJsonp ? 'jsonp' : 'json',
    jsonp: useJsonp && '$callback',
    method,
    async,
    timeout,
    headers,
    contentType,
    accepts: {
      json: [JSON_VERBOSE_MIME_TYPE, 'text/plain'].join()
    },
    xhrFields: {
      withCredentials
    }
  };
};
const sendRequest = (protocolVersion, request, options) => {
  const {
    deserializeDates,
    fieldTypes,
    countOnly,
    isPaged
  } = options;
  // @ts-expect-error
  const d = new _deferred.Deferred();
  const ajaxOptions = ajaxOptionsForRequest(protocolVersion, request, options);
  _ajax.default.sendRequest(ajaxOptions).always((obj, textStatus) => {
    const transformOptions = {
      deserializeDates,
      fieldTypes
    };
    const tuple = interpretJsonFormat(obj, textStatus, transformOptions, ajaxOptions);
    // @ts-expect-error
    const {
      error,
      data,
      count
    } = tuple;
    // @ts-expect-error
    let {
      nextUrl
    } = tuple;
    if (error) {
      if (error.message !== _utils.XHR_ERROR_UNLOAD) {
        d.reject(error);
      }
    } else if (countOnly) {
      if (isFinite(count)) {
        d.resolve(count);
      } else {
        d.reject(new _errors.errors.Error('E4018'));
      }
    } else if (nextUrl && !isPaged) {
      if (!isAbsoluteUrl(nextUrl)) {
        nextUrl = toAbsoluteUrl(ajaxOptions.url, nextUrl);
      }
      sendRequest(protocolVersion, {
        url: nextUrl
      }, options).fail(d.reject).done(nextData => d.resolve(data.concat(nextData)));
    } else {
      const extra = isFinite(count) ? {
        totalCount: count
      } : undefined;
      d.resolve(data, extra);
    }
  });
  return d.promise();
};
exports.sendRequest = sendRequest;
const formatDotNetError = errorObj => {
  let message;
  let currentMessage;
  let currentError = errorObj;
  if ('message' in errorObj) {
    var _errorObj$message;
    message = ((_errorObj$message = errorObj.message) === null || _errorObj$message === void 0 ? void 0 : _errorObj$message.value) || errorObj.message;
  }
  /* eslint-disable spellcheck/spell-checker, no-cond-assign */
  while (currentError = currentError.innererror || currentError.internalexception) {
    currentMessage = currentError.message;
    message = currentMessage ?? message;
    if (currentError.internalexception && message.indexOf('inner exception') === -1) {
      break;
    }
  }
  return message;
};
// TODO split: decouple HTTP errors from OData errors
const errorFromResponse = (obj, textStatus, ajaxOptions) => {
  var _response, _response2, _response3, _response4;
  if (textStatus === 'nocontent') {
    return null; // workaround for http://bugs.jquery.com/ticket/13292
  }
  let message = 'Unknown error';
  let response = obj;
  let httpStatus = 200;
  const errorData = {
    requestOptions: ajaxOptions
  };
  if (textStatus !== 'success') {
    const {
      status,
      responseText
    } = obj;
    httpStatus = status;
    message = (0, _utils.errorMessageFromXhr)(obj, textStatus);
    try {
      response = JSON.parse(responseText);
      // eslint-disable-next-line no-empty
    } catch (x) {}
  }
  const errorObj = ((_response = response) === null || _response === void 0 ? void 0 : _response.then) || ((_response2 = response) === null || _response2 === void 0 ? void 0 : _response2.error) || ((_response3 = response) === null || _response3 === void 0 ? void 0 : _response3['odata.error']) || ((_response4 = response) === null || _response4 === void 0 ? void 0 : _response4['@odata.error']);
  // NOTE: $.Deferred rejected and response contain error message
  // NOTE: $.Deferred resolved with odata error
  if (errorObj) {
    message = formatDotNetError(errorObj) || message;
    // @ts-expect-error
    errorData.errorDetails = errorObj;
    if (httpStatus === 200) {
      httpStatus = 500;
    }
    const customCode = Number(errorObj.code);
    if (isFinite(customCode) && customCode >= 400) {
      httpStatus = customCode;
    }
  }
  if (httpStatus >= 400 || httpStatus === 0) {
    // @ts-expect-error
    errorData.httpStatus = httpStatus;
    return (0, _extend.extend)(Error(message), errorData);
  }
  return null;
};
const interpretJsonFormat = (obj, textStatus, transformOptions, ajaxOptions) => {
  const error = errorFromResponse(obj, textStatus, ajaxOptions);
  if (error) {
    return {
      error
    };
  }
  if (!(0, _type.isPlainObject)(obj)) {
    return {
      data: obj
    };
  }
  const value = 'd' in obj && (Array.isArray(obj.d) || (0, _type.isObject)(obj.d))
  // @ts-expect-error
  ? interpretVerboseJsonFormat(obj) : interpretLightJsonFormat(obj);
  transformTypes(value, transformOptions);
  return value;
};
const interpretVerboseJsonFormat = _ref => {
  let {
    d: data
  } = _ref;
  if (!(0, _type.isDefined)(data)) {
    return {
      error: Error('Malformed or unsupported JSON response received')
    };
  }
  return {
    data: data.results ?? data,
    nextUrl: data.__next,
    count: parseInt(data.__count, 10)
  };
};
const interpretLightJsonFormat = obj => ({
  data: obj.value ?? obj,
  nextUrl: obj['@odata.nextLink'],
  count: parseInt(obj['@odata.count'], 10)
});
// Serialization and parsing
const EdmLiteral = exports.EdmLiteral = _class.default.inherit({
  ctor(value) {
    this._value = value;
  },
  valueOf() {
    return this._value;
  }
});
const transformTypes = function (obj) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _iterator.each)(obj, (key, value) => {
    if (value !== null && typeof value === 'object') {
      if ('results' in value) {
        obj[key] = value.results;
      }
      transformTypes(obj[key], options);
    } else if (typeof value === 'string') {
      // @ts-expect-error
      const {
        fieldTypes,
        deserializeDates
      } = options;
      const canBeGuid = !fieldTypes || fieldTypes[key] !== 'String';
      if (canBeGuid && GUID_REGEX.test(value)) {
        obj[key] = new _guid.default(value);
      }
      if (deserializeDates !== false) {
        if (VERBOSE_DATE_REGEX.exec(value)) {
          // @ts-expect-error
          const date = new Date(Number(RegExp.$1) + RegExp.$2 * 60 * 1000);
          obj[key] = new Date(date.valueOf() + date.getTimezoneOffset() * 60 * 1000);
        } else if (ISO8601_DATE_REGEX.test(value)) {
          obj[key] = new Date(parseISO8601(obj[key]).valueOf());
        }
      }
    }
  });
};
const serializeDate = date => `datetime'${formatISO8601(date, true, true)}'`;
const serializeString = value => `'${value.replace(/'/g, '\'\'')}'`;
const serializePropName = propName => propName instanceof EdmLiteral ? propName.valueOf() : propName.replace(/\./g, '/');
exports.serializePropName = serializePropName;
const serializeValueV4 = value => {
  if (value instanceof Date) {
    return formatISO8601(value, false, false);
  }
  if (value instanceof _guid.default) {
    return value.valueOf();
  }
  if (Array.isArray(value)) {
    return `[${value.map(item => serializeValueV4(item)).join(',')}]`;
  }
  return serializeValueV2(value);
};
const serializeValueV2 = value => {
  if (value instanceof Date) {
    return serializeDate(value);
  }
  if (value instanceof _guid.default) {
    return `guid'${value}'`;
  }
  if (value instanceof EdmLiteral) {
    return value.valueOf();
  }
  if (typeof value === 'string') {
    return serializeString(value);
  }
  return String(value);
};
const serializeValue = (value, protocolVersion) => {
  switch (protocolVersion) {
    case 2:
    case 3:
      return serializeValueV2(value);
    case 4:
      return serializeValueV4(value);
    default:
      throw _errors.errors.Error('E4002');
  }
};
exports.serializeValue = serializeValue;
const serializeKey = (key, protocolVersion) => {
  if ((0, _type.isPlainObject)(key)) {
    const parts = [];
    // @ts-expect-error
    (0, _iterator.each)(key, (k, v) => parts.push(`${serializePropName(k)}=${serializeValue(v, protocolVersion)}`));
    return parts.join();
  }
  return serializeValue(key, protocolVersion);
};
exports.serializeKey = serializeKey;
const keyConverters = exports.keyConverters = {
  String: value => `${value}`,
  Int32: value => Math.floor(value),
  Int64: value => value instanceof EdmLiteral ? value : new EdmLiteral(`${value}L`),
  Guid: value => value instanceof _guid.default ? value : new _guid.default(value),
  Boolean: value => !!value,
  Single: value => value instanceof EdmLiteral ? value : new EdmLiteral(`${value}f`),
  Decimal: value => value instanceof EdmLiteral ? value : new EdmLiteral(`${value}m`)
};
const convertPrimitiveValue = (type, value) => {
  if (value === null) return null;
  const converter = keyConverters[type];
  if (!converter) {
    throw _errors.errors.Error('E4014', type);
  }
  return converter(value);
};
exports.convertPrimitiveValue = convertPrimitiveValue;
const generateSelect = (oDataVersion, select) => {
  if (!select) {
    return;
  }
  return oDataVersion < 4 ? serializePropName(select.join()) : (0, _common.grep)(select, hasDot, true).join();
};
exports.generateSelect = generateSelect;
const formatCore = hash => {
  let result = '';
  const selectValue = [];
  const expandValue = [];
  (0, _iterator.each)(hash, (key, value) => {
    if (Array.isArray(value)) {
      // @ts-expect-error
      [].push.apply(selectValue, value);
    }
    if ((0, _type.isPlainObject)(value)) {
      // @ts-expect-error
      expandValue.push(`${key}${formatCore(value)}`);
    }
  });
  if (selectValue.length || expandValue.length) {
    result += '(';
    if (selectValue.length) {
      result += `$select=${(0, _iterator.map)(selectValue, serializePropName).join()}`;
    }
    if (expandValue.length) {
      if (selectValue.length) {
        result += ';';
      }
      result += `$expand=${(0, _iterator.map)(expandValue, serializePropName).join()}`;
    }
    result += ')';
  }
  return result;
};
const format = hash => {
  const result = [];
  // @ts-expect-error
  (0, _iterator.each)(hash, (key, value) => result.push(`${key}${formatCore(value)}`));
  return result.join();
};
const parseCore = (exprParts, root, stepper) => {
  const result = stepper(root, exprParts.shift(), exprParts);
  if (result === false) {
    return;
  }
  parseCore(exprParts, result, stepper);
};
const parseTree = (exprs, root, stepper) => (0, _iterator.each)(exprs, (_, x) => parseCore(x.split('.'), root, stepper));
const generatorV2 = (expand, select) => {
  const hash = {};
  if (expand) {
    (0, _iterator.each)(makeArray(expand), function () {
      hash[serializePropName(this)] = 1;
    });
  }
  if (select) {
    (0, _iterator.each)(makeArray(select), function () {
      const path = this.split('.');
      if (path.length < 2) {
        return;
      }
      path.pop();
      hash[serializePropName(path.join('.'))] = 1;
    });
  }
  return (0, _iterator.map)(hash, (_, v) => v).join();
};
// @ts-expect-error
const generatorV4 = (expand, select) => {
  const hash = {};
  if (expand || select) {
    if (expand) {
      parseTree(makeArray(expand), hash, (node, key, path) => {
        node[key] = node[key] || {};
        return !path.length ? false : node[key];
      });
    }
    if (select) {
      parseTree((0, _common.grep)(makeArray(select), hasDot), hash, (node, key, path) => {
        if (!path.length) {
          node[key] = node[key] || [];
          node[key].push(key);
          return false;
        }
        // eslint-disable-next-line no-return-assign
        return node[key] = node[key] || {};
      });
    }
    return format(hash);
  }
};
const generateExpand = (oDataVersion, expand, select) => oDataVersion < 4 ? generatorV2(expand, select) : generatorV4(expand, select);
exports.generateExpand = generateExpand;
const formatFunctionInvocationUrl = (baseUrl, args) => (0, _string.format)('{0}({1})', baseUrl, (0, _iterator.map)(args || {}, (value, key) => (0, _string.format)('{0}={1}', key, value)).join(','));
exports.formatFunctionInvocationUrl = formatFunctionInvocationUrl;
const escapeServiceOperationParams = (params, version) => {
  if (!params) {
    return params;
  }
  // From WCF Data Services docs:
  // The type of each parameter must be a primitive type.
  // Any data of a non-primitive type must be serialized and passed into a string parameter
  const result = {};
  (0, _iterator.each)(params, (k, v) => {
    result[k] = serializeValue(v, version);
  });
  return result;
};
exports.escapeServiceOperationParams = escapeServiceOperationParams;

/***/ }),

/***/ 28923:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.lock = exports.inactive = exports.active = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _common = __webpack_require__(20576);
var _dom = __webpack_require__(3532);
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ACTIVE_EVENT_NAME = exports.active = 'dxactive';
const INACTIVE_EVENT_NAME = exports.inactive = 'dxinactive';
const ACTIVE_TIMEOUT = 30;
const INACTIVE_TIMEOUT = 400;
const FeedbackEvent = _class.default.inherit({
  ctor(timeout, fire) {
    this._timeout = timeout;
    this._fire = fire;
  },
  start() {
    const that = this;
    this._schedule(() => {
      that.force();
    });
  },
  _schedule(fn) {
    this.stop();
    this._timer = setTimeout(fn, this._timeout);
  },
  stop() {
    clearTimeout(this._timer);
  },
  force() {
    if (this._fired) {
      return;
    }
    this.stop();
    this._fire();
    this._fired = true;
  },
  fired() {
    return this._fired;
  }
});
let activeFeedback;
const FeedbackEmitter = _emitter.default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    this._active = new FeedbackEvent(0, _common.noop);
    this._inactive = new FeedbackEvent(0, _common.noop);
  },
  /* eslint-disable default-case */
  configure(data, eventName) {
    switch (eventName) {
      case ACTIVE_EVENT_NAME:
        data.activeTimeout = data.timeout;
        break;
      case INACTIVE_EVENT_NAME:
        data.inactiveTimeout = data.timeout;
        break;
    }
    this.callBase(data);
  },
  start(e) {
    if (activeFeedback) {
      const activeChildExists = (0, _dom.contains)(this.getElement().get(0), activeFeedback.getElement().get(0));
      const childJustActivated = !activeFeedback._active.fired();
      if (activeChildExists && childJustActivated) {
        this._cancel();
        return;
      }
      activeFeedback._inactive.force();
    }
    activeFeedback = this;
    this._initEvents(e);
    this._active.start();
  },
  _initEvents(e) {
    const that = this;
    const eventTarget = this._getEmitterTarget(e);
    const mouseEvent = (0, _index.isMouseEvent)(e);
    const isSimulator = _devices.default.isSimulator();
    const deferFeedback = isSimulator || !mouseEvent;
    const activeTimeout = (0, _common.ensureDefined)(this.activeTimeout, ACTIVE_TIMEOUT);
    const inactiveTimeout = (0, _common.ensureDefined)(this.inactiveTimeout, INACTIVE_TIMEOUT);
    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, () => {
      that._fireEvent(ACTIVE_EVENT_NAME, e, {
        target: eventTarget
      });
    });
    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, () => {
      that._fireEvent(INACTIVE_EVENT_NAME, e, {
        target: eventTarget
      });
      activeFeedback = null;
    });
  },
  cancel(e) {
    this.end(e);
  },
  end(e) {
    const skipTimers = e.type !== _pointer.default.up;
    if (skipTimers) {
      this._active.stop();
    } else {
      this._active.force();
    }
    this._inactive.start();
    if (skipTimers) {
      this._inactive.force();
    }
  },
  dispose() {
    this._active.stop();
    this._inactive.stop();
    if (activeFeedback === this) {
      activeFeedback = null;
    }
    this.callBase();
  },
  lockInactive() {
    this._active.force();
    this._inactive.stop();
    activeFeedback = null;
    this._cancel();
    return this._inactive.force.bind(this._inactive);
  }
});
// @ts-expect-error
FeedbackEmitter.lock = function (deferred) {
  const lockInactive = activeFeedback ? activeFeedback.lockInactive() : _common.noop;
  deferred.done(lockInactive);
};
(0, _emitter_registrator.default)({
  emitter: FeedbackEmitter,
  events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
});
// @ts-expect-error
const {
  lock
} = FeedbackEmitter;
exports.lock = lock;

/***/ }),

/***/ 54235:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const Emitter = _class.default.inherit({
  ctor(element) {
    this._$element = (0, _renderer.default)(element);
    this._cancelCallback = (0, _callbacks.default)();
    this._acceptCallback = (0, _callbacks.default)();
  },
  getElement() {
    return this._$element;
  },
  validate(e) {
    return !(0, _index.isDxMouseWheelEvent)(e);
  },
  validatePointers(e) {
    return (0, _index.hasTouches)(e) === 1;
  },
  allowInterruptionByMouseWheel() {
    return true;
  },
  configure(data) {
    (0, _extend.extend)(this, data);
  },
  addCancelCallback(callback) {
    this._cancelCallback.add(callback);
  },
  removeCancelCallback() {
    this._cancelCallback.empty();
  },
  _cancel(e) {
    this._cancelCallback.fire(this, e);
  },
  addAcceptCallback(callback) {
    this._acceptCallback.add(callback);
  },
  removeAcceptCallback() {
    this._acceptCallback.empty();
  },
  _accept(e) {
    this._acceptCallback.fire(this, e);
  },
  _requestAccept(e) {
    this._acceptRequestEvent = e;
  },
  _forgetAccept() {
    this._accept(this._acceptRequestEvent);
    this._acceptRequestEvent = null;
  },
  start: _common.noop,
  move: _common.noop,
  end: _common.noop,
  cancel: _common.noop,
  reset() {
    if (this._acceptRequestEvent) {
      this._accept(this._acceptRequestEvent);
    }
  },
  _fireEvent(eventName, e, params) {
    const eventData = (0, _extend.extend)({
      type: eventName,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, params);
    e = (0, _index.fireEvent)(eventData);
    if (e.cancel) {
      this._cancel(e);
    }
    return e;
  },
  _getEmitterTarget(e) {
    return (this.delegateSelector ? (0, _renderer.default)(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: _common.noop
});
var _default = exports["default"] = Emitter;

/***/ }),

/***/ 59227:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _element_data = __webpack_require__(97906);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _wheel = __webpack_require__(765);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const MANAGER_EVENT = 'dxEventManager';
const EMITTER_DATA = 'dxEmitter';
const EventManager = _class.default.inherit({
  ctor() {
    this._attachHandlers();
    this.reset();
    this._proxiedCancelHandler = this._cancelHandler.bind(this);
    this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers() {
    _ready_callbacks.default.add(() => {
      const document = _dom_adapter.default.getDocument();
      // @ts-expect-error
      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
      // @ts-expect-error
      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
      // @ts-expect-error
      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)([_pointer.default.up, _pointer.default.cancel].join(' '), MANAGER_EVENT), this._pointerUpHandler.bind(this));
      // @ts-expect-error
      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_wheel.name, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
    });
  },
  _eachEmitter(callback) {
    const activeEmitters = this._activeEmitters || [];
    let i = 0;
    while (activeEmitters.length > i) {
      const emitter = activeEmitters[i];
      if (callback(emitter) === false) {
        break;
      }
      if (activeEmitters[i] === emitter) {
        i++;
      }
    }
  },
  _applyToEmitters(method, arg) {
    this._eachEmitter(emitter => {
      emitter[method].call(emitter, arg);
    });
  },
  reset() {
    this._eachEmitter(this._proxiedCancelHandler);
    this._activeEmitters = [];
  },
  resetEmitter(emitter) {
    this._proxiedCancelHandler(emitter);
  },
  _pointerDownHandler(e) {
    if ((0, _index.isMouseEvent)(e) && e.which > 1) {
      return;
    }
    this._updateEmitters(e);
  },
  _updateEmitters(e) {
    if (!this._isSetChanged(e)) {
      return;
    }
    this._cleanEmitters(e);
    this._fetchEmitters(e);
  },
  _isSetChanged(e) {
    const currentSet = this._closestEmitter(e);
    const previousSet = this._emittersSet || [];
    let setChanged = currentSet.length !== previousSet.length;
    (0, _iterator.each)(currentSet, (index, emitter) => {
      setChanged = setChanged || previousSet[index] !== emitter;
      return !setChanged;
    });
    this._emittersSet = currentSet;
    return setChanged;
  },
  _closestEmitter(e) {
    const that = this;
    const result = [];
    let $element = (0, _renderer.default)(e.target);
    function handleEmitter(_, emitter) {
      if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
        emitter.addCancelCallback(that._proxiedCancelHandler);
        emitter.addAcceptCallback(that._proxiedAcceptHandler);
        result.push(emitter);
      }
    }
    while ($element.length) {
      const emitters = (0, _element_data.data)($element.get(0), EMITTER_DATA) || [];
      (0, _iterator.each)(emitters, handleEmitter);
      $element = $element.parent();
    }
    return result;
  },
  _acceptHandler(acceptedEmitter, e) {
    this._eachEmitter(emitter => {
      if (emitter !== acceptedEmitter) {
        this._cancelEmitter(emitter, e);
      }
    });
  },
  _cancelHandler(canceledEmitter, e) {
    this._cancelEmitter(canceledEmitter, e);
  },
  _cancelEmitter(emitter, e) {
    const activeEmitters = this._activeEmitters;
    if (e) {
      emitter.cancel(e);
    } else {
      emitter.reset();
    }
    emitter.removeCancelCallback();
    emitter.removeAcceptCallback();
    const emitterIndex = activeEmitters.indexOf(emitter);
    if (emitterIndex > -1) {
      activeEmitters.splice(emitterIndex, 1);
    }
  },
  _cleanEmitters(e) {
    this._applyToEmitters('end', e);
    this.reset(e);
  },
  _fetchEmitters(e) {
    this._activeEmitters = this._emittersSet.slice();
    this._applyToEmitters('start', e);
  },
  _pointerMoveHandler(e) {
    this._applyToEmitters('move', e);
  },
  _pointerUpHandler(e) {
    this._updateEmitters(e);
  },
  _mouseWheelHandler(e) {
    if (!this._allowInterruptionByMouseWheel()) {
      return;
    }
    e.pointers = [null];
    this._pointerDownHandler(e);
    this._adjustWheelEvent(e);
    this._pointerMoveHandler(e);
    e.pointers = [];
    this._pointerUpHandler(e);
  },
  _allowInterruptionByMouseWheel() {
    let allowInterruption = true;
    this._eachEmitter(emitter => {
      allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
      return allowInterruption;
    });
    return allowInterruption;
  },
  _adjustWheelEvent(e) {
    let closestGestureEmitter = null;
    // @ts-expect-error
    this._eachEmitter(emitter => {
      if (!emitter.gesture) {
        return;
      }
      const direction = emitter.getDirection(e);
      if (direction !== 'horizontal' && !e.shiftKey || direction !== 'vertical' && e.shiftKey) {
        closestGestureEmitter = emitter;
        return false;
      }
    });
    if (!closestGestureEmitter) {
      return;
    }
    const direction = closestGestureEmitter.getDirection(e);
    const verticalGestureDirection = direction === 'both' && !e.shiftKey || direction === 'vertical';
    const prop = verticalGestureDirection ? 'pageY' : 'pageX';
    e[prop] += e.delta;
  },
  isActive(element) {
    let result = false;
    this._eachEmitter(emitter => {
      result = result || emitter.getElement().is(element);
    });
    return result;
  }
});
const eventManager = new EventManager();
const EMITTER_SUBSCRIPTION_DATA = 'dxEmitterSubscription';
const registerEmitter = function (emitterConfig) {
  const EmitterClass = emitterConfig.emitter;
  const emitterName = emitterConfig.events[0];
  const emitterEvents = emitterConfig.events;
  (0, _iterator.each)(emitterEvents, (_, eventName) => {
    (0, _event_registrator.default)(eventName, {
      noBubble: !emitterConfig.bubble,
      setup(element) {
        const subscriptions = (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA) || {};
        const emitters = (0, _element_data.data)(element, EMITTER_DATA) || {};
        const emitter = emitters[emitterName] || new EmitterClass(element);
        subscriptions[eventName] = true;
        emitters[emitterName] = emitter;
        (0, _element_data.data)(element, EMITTER_DATA, emitters);
        (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA, subscriptions);
      },
      add(element, handleObj) {
        const emitters = (0, _element_data.data)(element, EMITTER_DATA);
        const emitter = emitters[emitterName];
        emitter.configure((0, _extend.extend)({
          delegateSelector: handleObj.selector
        }, handleObj.data), handleObj.type);
      },
      teardown(element) {
        const subscriptions = (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA);
        const emitters = (0, _element_data.data)(element, EMITTER_DATA);
        const emitter = emitters[emitterName];
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete subscriptions[eventName];
        let disposeEmitter = true;
        (0, _iterator.each)(emitterEvents, (_, eventName) => {
          disposeEmitter = disposeEmitter && !subscriptions[eventName];
          return disposeEmitter;
        });
        if (disposeEmitter) {
          // @ts-expect-error
          if (eventManager.isActive(element)) {
            // @ts-expect-error
            eventManager.resetEmitter(emitter);
          }
          emitter && emitter.dispose();
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete emitters[emitterName];
        }
      }
    });
  });
};
var _default = exports["default"] = registerEmitter;

/***/ }),

/***/ 50202:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const registerEvent = function (name, eventObject) {
  const strategy = {};
  if ('noBubble' in eventObject) {
    strategy.noBubble = eventObject.noBubble;
  }
  if ('bindType' in eventObject) {
    strategy.bindType = eventObject.bindType;
  }
  if ('delegateType' in eventObject) {
    strategy.delegateType = eventObject.delegateType;
  }
  (0, _iterator.each)(['setup', 'teardown', 'add', 'remove', 'trigger', 'handle', '_default', 'dispose'], (_, methodName) => {
    if (!eventObject[methodName]) {
      return;
    }
    strategy[methodName] = function () {
      const args = [].slice.call(arguments);
      args.unshift(this);
      return eventObject[methodName].apply(eventObject, args);
    };
  });
  _event_registrator_callbacks.default.fire(name, strategy);
};
registerEvent.callbacks = _event_registrator_callbacks.default;
var _default = exports["default"] = registerEvent;

/***/ }),

/***/ 71496:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
var _hook_touch_props = _interopRequireDefault(__webpack_require__(2418));
var _event_target = __webpack_require__(39644);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
/* eslint-disable spellcheck/spell-checker */
const EMPTY_EVENT_NAME = 'dxEmptyEventType';
const NATIVE_EVENTS_TO_SUBSCRIBE = {
  mouseenter: 'mouseover',
  mouseleave: 'mouseout',
  pointerenter: 'pointerover',
  pointerleave: 'pointerout'
};
const NATIVE_EVENTS_TO_TRIGGER = {
  focusin: 'focus',
  focusout: 'blur'
};
const NO_BUBBLE_EVENTS = ['blur', 'focus', 'load'];
const forcePassiveFalseEventNames = ['touchmove', 'wheel', 'mousewheel', 'touchstart'];
const EVENT_PROPERTIES = ['target', 'relatedTarget', 'delegateTarget', 'altKey', 'bubbles', 'cancelable', 'changedTouches', 'ctrlKey', 'detail', 'eventPhase', 'metaKey', 'shiftKey', 'view', 'char', 'code', 'charCode', 'key', 'keyCode', 'button', 'buttons', 'offsetX', 'offsetY', 'pointerId', 'pointerType', 'targetTouches', 'toElement', 'touches'];
function matchesSafe(target, selector) {
  // @ts-expect-error
  return !(0, _type.isWindow)(target) && target.nodeName !== '#document' && _dom_adapter.default.elementMatches(target, selector);
}
const elementDataMap = new WeakMap();
let guid = 0;
let skipEvent;
const special = function () {
  const specialData = {};
  _event_registrator_callbacks.default.add((eventName, eventObject) => {
    specialData[eventName] = eventObject;
  });
  return {
    getField(eventName, field) {
      return specialData[eventName] && specialData[eventName][field];
    },
    callMethod(eventName, methodName, context, args) {
      return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context, args);
    }
  };
}();
const eventsEngine = (0, _dependency_injector.default)({
  on: getHandler(normalizeOnArguments(iterate((element, eventName, selector, data, handler) => {
    const handlersController = getHandlersController(element, eventName);
    handlersController.addHandler(handler, selector, data);
  }))),
  one: getHandler(normalizeOnArguments((element, eventName, selector, data, handler) => {
    const oneTimeHandler = function () {
      eventsEngine.off(element, eventName, selector, oneTimeHandler);
      handler.apply(this, arguments);
    };
    eventsEngine.on(element, eventName, selector, data, oneTimeHandler);
  })),
  off: getHandler(normalizeOffArguments(iterate((element, eventName, selector, handler) => {
    const handlersController = getHandlersController(element, eventName);
    handlersController.removeHandler(handler, selector);
  }))),
  trigger: getHandler(normalizeTriggerArguments((element, event, extraParameters) => {
    const eventName = event.type;
    const handlersController = getHandlersController(element, event.type);
    special.callMethod(eventName, 'trigger', element, [event, extraParameters]);
    handlersController.callHandlers(event, extraParameters);
    const noBubble = special.getField(eventName, 'noBubble') || event.isPropagationStopped() || NO_BUBBLE_EVENTS.includes(eventName);
    if (!noBubble) {
      const parents = [];
      const getParents = function (element) {
        const parent = element.parentNode ?? ((0, _type.isObject)(element.host) ? element.host : null);
        if (parent) {
          parents.push(parent);
          getParents(parent);
        }
      };
      getParents(element);
      parents.push(window);
      let i = 0;
      while (parents[i] && !event.isPropagationStopped()) {
        const parentDataByEvent = getHandlersController(parents[i], event.type);
        parentDataByEvent.callHandlers((0, _extend.extend)(event, {
          currentTarget: parents[i]
        }), extraParameters);
        i++;
      }
    }
    if (element.nodeType || (0, _type.isWindow)(element)) {
      special.callMethod(eventName, '_default', element, [event, extraParameters]);
      callNativeMethod(eventName, element);
    }
  })),
  triggerHandler: getHandler(normalizeTriggerArguments((element, event, extraParameters) => {
    const handlersController = getHandlersController(element, event.type);
    handlersController.callHandlers(event, extraParameters);
  }))
});
function applyForEach(args, method) {
  const element = args[0];
  if (!element) {
    return;
  }
  if (_dom_adapter.default.isNode(element) || (0, _type.isWindow)(element)) {
    method.apply(eventsEngine, args);
  } else if (!(0, _type.isString)(element) && 'length' in element) {
    const itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, itemElement => {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw _errors.default.Error('E0025');
  }
}
function getHandler(method) {
  return function () {
    applyForEach(arguments, method);
  };
}
function detectPassiveEventHandlersSupport() {
  let isSupported = false;
  try {
    const options = Object.defineProperty({}, 'passive', {
      get() {
        isSupported = true;
        return true;
      }
    });
    // @ts-expect-error
    window.addEventListener('test', null, options);
    // eslint-disable-next-line no-empty
  } catch (e) {}
  return isSupported;
}
const passiveEventHandlersSupported = (0, _call_once.default)(detectPassiveEventHandlersSupport);
const contains = (container, element) => {
  if ((0, _type.isWindow)(container)) {
    return contains(container.document, element);
  }
  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};
function getHandlersController(element, eventName) {
  let elementData = elementDataMap.get(element);
  eventName = eventName || '';
  const eventNameParts = eventName.split('.');
  const namespaces = eventNameParts.slice(1);
  const eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }
  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }
  const eventData = elementData[eventName];
  return {
    addHandler(handler, selector, data) {
      const callHandler = function (e, extraParameters) {
        const handlerArgs = [e];
        const target = e.currentTarget;
        const {
          relatedTarget
        } = e;
        let secondaryTargetIsInside;
        let result;
        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));
        }
        if (extraParameters !== undefined) {
          handlerArgs.push(extraParameters);
        }
        special.callMethod(eventName, 'handle', element, [e, data]);
        if (!secondaryTargetIsInside) {
          result = handler.apply(target, handlerArgs);
        }
        if (result === false) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      const wrappedHandler = function (e, extraParameters) {
        if (skipEvent && e.type === skipEvent) {
          return;
        }
        e.data = data;
        e.delegateTarget = element;
        if (selector) {
          let currentTarget = e.target;
          while (currentTarget && currentTarget !== element) {
            if (matchesSafe(currentTarget, selector)) {
              e.currentTarget = currentTarget;
              callHandler(e, extraParameters);
            }
            currentTarget = currentTarget.parentNode;
          }
        } else {
          var _e$target;
          e.currentTarget = e.delegateTarget || e.target;
          const isTargetInShadowDOM = Boolean((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.shadowRoot);
          if (isTargetInShadowDOM) {
            const target = (0, _event_target.getEventTarget)(e);
            e.target = target;
          }
          callHandler(e, extraParameters);
        }
      };
      const handleObject = {
        handler,
        wrappedHandler,
        selector,
        type: eventName,
        data,
        namespace: namespaces.join('.'),
        namespaces,
        guid: ++guid
      };
      eventData.handleObjects.push(handleObject);
      const firstHandlerForTheType = eventData.handleObjects.length === 1;
      let shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      let nativeListenerOptions;
      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, 'setup', element, [data, namespaces, handler]);
      }
      if (shouldAddNativeListener) {
        eventData.nativeHandler = getNativeHandler(eventName);
        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.includes(eventName)) {
          nativeListenerOptions = {
            passive: false
          };
        }
        // @ts-expect-error
        eventData.removeListener = _dom_adapter.default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData.nativeHandler, nativeListenerOptions);
      }
      special.callMethod(eventName, 'add', element, [handleObject]);
    },
    removeHandler(handler, selector) {
      const removeByEventName = function (eventName) {
        const eventData = elementData[eventName];
        if (!eventData.handleObjects.length) {
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete elementData[eventName];
          return;
        }
        let removedHandler;
        eventData.handleObjects = eventData.handleObjects.filter(handleObject => {
          const skip = namespaces.length && !isSubset(handleObject.namespaces, namespaces) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName, 'remove', element, [handleObject]);
          }
          return skip;
        });
        const lastHandlerForTheType = !eventData.handleObjects.length;
        const shouldRemoveNativeListener = lastHandlerForTheType && eventName !== EMPTY_EVENT_NAME;
        if (shouldRemoveNativeListener) {
          special.callMethod(eventName, 'teardown', element, [namespaces, removedHandler]);
          if (eventData.nativeHandler) {
            eventData.removeListener();
          }
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete elementData[eventName];
        }
      };
      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        // eslint-disable-next-line no-restricted-syntax, guard-for-in
        for (const name in elementData) {
          removeByEventName(name);
        }
      }
      const elementDataIsEmpty = Object.keys(elementData).length === 0;
      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers(event, extraParameters) {
      let forceStop = false;
      const handleCallback = function (handleObject) {
        if (forceStop) {
          return;
        }
        if (!namespaces.length || isSubset(handleObject.namespaces, namespaces)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };
      eventData.handleObjects.forEach(handleCallback);
      if (namespaces.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}
function getNativeHandler(subscribeName) {
  return function (event, extraParameters) {
    const handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}
function isSubset(original, checked) {
  for (let i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) return false;
  }
  return true;
}
function normalizeOnArguments(callback) {
  return function (element, eventName, selector, data, handler) {
    if (!handler) {
      handler = data;
      data = undefined;
    }
    if (typeof selector !== 'string') {
      data = selector;
      selector = undefined;
    }
    if (!handler && typeof eventName === 'string') {
      handler = data || selector;
      selector = undefined;
      data = undefined;
    }
    callback(element, eventName, selector, data, handler);
  };
}
function normalizeOffArguments(callback) {
  return function (element, eventName, selector, handler) {
    if (typeof selector === 'function') {
      handler = selector;
      selector = undefined;
    }
    callback(element, eventName, selector, handler);
  };
}
function normalizeTriggerArguments(callback) {
  return function (element, src, extraParameters) {
    if (typeof src === 'string') {
      src = {
        type: src
      };
    }
    if (!src.target) {
      src.target = element;
    }
    src.currentTarget = element;
    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }
    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }
    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}
function normalizeEventArguments(callback) {
  eventsEngine.Event = function (src, config) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config);
    }
    if (!src) {
      src = {};
    }
    if (typeof src === 'string') {
      src = {
        type: src
      };
    }
    if (!config) {
      config = {};
    }
    callback.call(this, src, config);
  };
  Object.assign(eventsEngine.Event.prototype, {
    _propagationStopped: false,
    _immediatePropagationStopped: false,
    _defaultPrevented: false,
    isPropagationStopped() {
      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);
    },
    stopPropagation() {
      this._propagationStopped = true;
      this.originalEvent && this.originalEvent.stopPropagation();
    },
    isImmediatePropagationStopped() {
      return this._immediatePropagationStopped;
    },
    stopImmediatePropagation() {
      this.stopPropagation();
      this._immediatePropagationStopped = true;
      this.originalEvent && this.originalEvent.stopImmediatePropagation();
    },
    isDefaultPrevented() {
      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);
    },
    preventDefault() {
      this._defaultPrevented = true;
      this.originalEvent && this.originalEvent.preventDefault();
    }
  });
  return eventsEngine.Event;
}
function iterate(callback) {
  const iterateEventNames = function (element, eventName) {
    if (eventName && eventName.indexOf(' ') > -1) {
      const args = Array.prototype.slice.call(arguments, 0);
      eventName.split(' ').forEach(function (eventName) {
        args[1] = eventName;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };
  return function (element, eventName) {
    if (typeof eventName === 'object') {
      const args = Array.prototype.slice.call(arguments, 0);
      // eslint-disable-next-line no-restricted-syntax, guard-for-in
      for (const name in eventName) {
        args[1] = name;
        args[args.length - 1] = eventName[name];
        iterateEventNames.apply(this, args);
      }
    } else {
      // @ts-expect-error
      iterateEventNames.apply(this, arguments);
    }
  };
}
function callNativeMethod(eventName, element) {
  const nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
  const isLinkClickEvent = function (eventName, element) {
    return eventName === 'click' && element.localName === 'a';
  };
  if (isLinkClickEvent(eventName, element)) return;
  if ((0, _type.isFunction)(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = undefined;
  }
}
function calculateWhich(event) {
  const setForMouseEvent = function (event) {
    const mouseEventRegex = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
    return !event.which && event.button !== undefined && mouseEventRegex.test(event.type);
  };
  const setForKeyEvent = function (event) {
    return event.which == null && event.type.indexOf('key') === 0;
  };
  if (setForKeyEvent(event)) {
    return event.charCode != null ? event.charCode : event.keyCode;
  }
  if (setForMouseEvent(event)) {
    const whichByButton = {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    };
    return whichByButton[event.button];
  }
  return event.which;
}
function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}
initEvent(normalizeEventArguments(function (src, config) {
  var _src$view;
  const srcIsEvent = src instanceof eventsEngine.Event
  // @ts-expect-error
  || (0, _window.hasWindow)() && src instanceof window.Event || ((_src$view = src.view) === null || _src$view === void 0 ? void 0 : _src$view.Event) && src instanceof src.view.Event;
  if (srcIsEvent) {
    this.originalEvent = src;
    this.type = src.type;
    this.currentTarget = undefined;
    if (Object.prototype.hasOwnProperty.call(src, 'isTrusted')) {
      this.isTrusted = src.isTrusted;
    }
    this.timeStamp = src.timeStamp || Date.now();
  } else {
    Object.assign(this, src);
  }
  addProperty('which', calculateWhich, this);
  if (src.type.indexOf('touch') === 0) {
    delete config.pageX;
    delete config.pageY;
  }
  Object.assign(this, config);
  this.guid = ++guid;
}));
function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set(value) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
      });
    }
  });
}
// @ts-expect-error
EVENT_PROPERTIES.forEach(prop => addProperty(prop, event => event[prop]));
(0, _hook_touch_props.default)(addProperty);
const beforeSetStrategy = (0, _callbacks.default)();
const afterSetStrategy = (0, _callbacks.default)();
eventsEngine.set = function (engine) {
  beforeSetStrategy.fire();
  eventsEngine.inject(engine);
  initEvent(engine.Event);
  afterSetStrategy.fire();
};
eventsEngine.subscribeGlobal = function () {
  applyForEach(arguments, normalizeOnArguments(function () {
    const args = arguments;
    eventsEngine.on.apply(this, args);
    beforeSetStrategy.add(function () {
      const offArgs = Array.prototype.slice.call(args, 0);
      offArgs.splice(3, 1);
      eventsEngine.off.apply(this, offArgs);
    });
    afterSetStrategy.add(function () {
      eventsEngine.on.apply(this, args);
    });
  }));
};
eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
var _default = exports["default"] = eventsEngine;

/***/ }),

/***/ 92239:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
const touchPropsToHook = ['pageX', 'pageY', 'screenX', 'screenY', 'clientX', 'clientY'];
const touchPropHook = function (name, event) {
  if (event[name] && !event.touches || !event.touches) {
    return event[name];
  }
  const touches = event.touches.length ? event.touches : event.changedTouches;
  if (!touches.length) {
    return;
  }
  return touches[0][name];
};
function _default(callback) {
  touchPropsToHook.forEach(name => {
    callback(name, event => touchPropHook(name, event));
  }, this);
}

/***/ }),

/***/ 58455:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const COMPOSITION_START_EVENT = 'compositionstart';
const COMPOSITION_END_EVENT = 'compositionend';
const KEYDOWN_EVENT = 'keydown';
const NAMESPACE = 'KeyboardProcessor';
const createKeyDownOptions = e => ({
  keyName: (0, _index.normalizeKeyName)(e),
  key: e.key,
  code: e.code,
  ctrl: e.ctrlKey,
  location: e.location,
  metaKey: e.metaKey,
  shift: e.shiftKey,
  alt: e.altKey,
  which: e.which,
  originalEvent: e
});
const KeyboardProcessor = _class.default.inherit({
  _keydown: (0, _index.addNamespace)(KEYDOWN_EVENT, NAMESPACE),
  _compositionStart: (0, _index.addNamespace)(COMPOSITION_START_EVENT, NAMESPACE),
  _compositionEnd: (0, _index.addNamespace)(COMPOSITION_END_EVENT, NAMESPACE),
  ctor(options) {
    options = options || {};
    if (options.element) {
      this._element = (0, _renderer.default)(options.element);
    }
    if (options.focusTarget) {
      this._focusTarget = options.focusTarget;
    }
    this._handler = options.handler;
    if (this._element) {
      this._processFunction = e => {
        const focusTargets = (0, _renderer.default)(this._focusTarget).toArray();
        const isNotFocusTarget = this._focusTarget && this._focusTarget !== e.target && !focusTargets.includes(e.target);
        const shouldSkipProcessing = this._isComposingJustFinished && e.which === 229 || this._isComposing || isNotFocusTarget;
        this._isComposingJustFinished = false;
        if (!shouldSkipProcessing) {
          this.process(e);
        }
      };
      this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
      _events_engine.default.on(this._element, this._keydown, this._processFunction);
      _events_engine.default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
      _events_engine.default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
  },
  dispose() {
    if (this._element) {
      _events_engine.default.off(this._element, this._keydown, this._processFunction);
      _events_engine.default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
      _events_engine.default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
    this._element = undefined;
    this._handler = undefined;
  },
  process(e) {
    this._handler(createKeyDownOptions(e));
  },
  toggleProcessing(_ref) {
    let {
      type
    } = _ref;
    this._isComposing = type === COMPOSITION_START_EVENT;
    this._isComposingJustFinished = !this._isComposing;
  }
});
// @ts-expect-error
KeyboardProcessor.createKeyDownOptions = createKeyDownOptions;
var _default = exports["default"] = KeyboardProcessor;

/***/ }),

/***/ 73123:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.name = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EVENT_NAME = exports.name = 'dxmousewheel';
const EVENT_NAMESPACE = 'dxWheel';
const NATIVE_EVENT_NAME = 'wheel';
const PIXEL_MODE = 0;
const DELTA_MUTLIPLIER = 30;
const wheel = {
  setup(element) {
    const $element = (0, _renderer.default)(element);
    _events_engine.default.on($element, (0, _index.addNamespace)(NATIVE_EVENT_NAME, EVENT_NAMESPACE), wheel._wheelHandler.bind(wheel));
  },
  teardown(element) {
    _events_engine.default.off(element, `.${EVENT_NAMESPACE}`);
  },
  _wheelHandler(e) {
    const {
      deltaMode,
      deltaY,
      deltaX,
      deltaZ
    } = e.originalEvent;
    (0, _index.fireEvent)({
      type: EVENT_NAME,
      originalEvent: e,
      // @ts-expect-error
      delta: this._normalizeDelta(deltaY, deltaMode),
      deltaX,
      deltaY,
      deltaZ,
      deltaMode,
      pointerType: 'mouse'
    });
    e.stopPropagation();
  },
  _normalizeDelta(delta) {
    let deltaMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIXEL_MODE;
    if (deltaMode === PIXEL_MODE) {
      return -delta;
    }
    // Use multiplier to get rough delta value in px for the LINE or PAGE mode
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460
    return -DELTA_MUTLIPLIER * delta;
  }
};
(0, _event_registrator.default)(EVENT_NAME, wheel);

/***/ }),

/***/ 86468:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _common = __webpack_require__(20576);
var _dom = __webpack_require__(3532);
var _math = __webpack_require__(60810);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _style = __webpack_require__(80968);
var _type = __webpack_require__(35922);
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ready = _ready_callbacks.default.add;
const {
  abs
} = Math;
const SLEEP = 0;
const INITED = 1;
const STARTED = 2;
let TOUCH_BOUNDARY = 10;
const IMMEDIATE_TOUCH_BOUNDARY = 0;
const IMMEDIATE_TIMEOUT = 180;
const supportPointerEvents = function () {
  return (0, _style.styleProp)('pointer-events');
};
const setGestureCover = (0, _call_once.default)(() => {
  const GESTURE_COVER_CLASS = 'dx-gesture-cover';
  const isDesktop = _devices.default.real().deviceType === 'desktop';
  if (!supportPointerEvents() || !isDesktop) {
    return _common.noop;
  }
  const $cover = (0, _renderer.default)('<div>').addClass(GESTURE_COVER_CLASS).css('pointerEvents', 'none');
  // @ts-expect-error
  _events_engine.default.subscribeGlobal($cover, 'dxmousewheel', e => {
    e.preventDefault();
  });
  ready(() => {
    // @ts-expect-error
    $cover.appendTo('body');
  });
  return function (toggle, cursor) {
    $cover.css('pointerEvents', toggle ? 'all' : 'none');
    toggle && $cover.css('cursor', cursor);
  };
});
const gestureCover = function (toggle, cursor) {
  const gestureCoverStrategy = setGestureCover();
  gestureCoverStrategy(toggle, cursor);
};
const GestureEmitter = _emitter.default.inherit({
  gesture: true,
  configure(data) {
    this.getElement().css('msTouchAction', data.immediate ? 'pinch-zoom' : '');
    this.callBase(data);
  },
  allowInterruptionByMouseWheel() {
    return this._stage !== STARTED;
  },
  getDirection() {
    return this.direction;
  },
  _cancel() {
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
    this._stage = SLEEP;
  },
  start(e) {
    if (e._needSkipEvent || (0, _index.needSkipEvent)(e)) {
      this._cancel(e);
      return;
    }
    this._startEvent = (0, _index.createEvent)(e);
    this._startEventData = (0, _index.eventData)(e);
    this._stage = INITED;
    this._init(e);
    this._setupImmediateTimer();
  },
  _setupImmediateTimer() {
    clearTimeout(this._immediateTimer);
    this._immediateAccepted = false;
    if (!this.immediate) {
      return;
    }
    if (this.immediateTimeout === 0) {
      this._immediateAccepted = true;
      return;
    }
    this._immediateTimer = setTimeout(() => {
      this._immediateAccepted = true;
    }, this.immediateTimeout ?? IMMEDIATE_TIMEOUT);
  },
  move(e) {
    if (this._stage === INITED && this._directionConfirmed(e)) {
      this._stage = STARTED;
      this._resetActiveElement();
      this._toggleGestureCover(true);
      this._clearSelection(e);
      this._adjustStartEvent(e);
      this._start(this._startEvent);
      if (this._stage === SLEEP) {
        return;
      }
      this._requestAccept(e);
      this._move(e);
      this._forgetAccept();
    } else if (this._stage === STARTED) {
      this._clearSelection(e);
      this._move(e);
    }
  },
  _directionConfirmed(e) {
    const touchBoundary = this._getTouchBoundary(e);
    // @ts-expect-error
    const delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    const deltaX = abs(delta.x);
    const deltaY = abs(delta.y);
    const horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
    const verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
    const direction = this.getDirection(e);
    const bothAccepted = direction === 'both' && (horizontalMove || verticalMove);
    const horizontalAccepted = direction === 'horizontal' && horizontalMove;
    const verticalAccepted = direction === 'vertical' && verticalMove;
    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
  },
  _validateMove(touchBoundary, mainAxis, crossAxis) {
    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
  },
  _getTouchBoundary(e) {
    return this.immediate || (0, _index.isDxMouseWheelEvent)(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY;
  },
  _adjustStartEvent(e) {
    const touchBoundary = this._getTouchBoundary(e);
    // @ts-expect-error
    const delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    this._startEvent.pageX += (0, _math.sign)(delta.x) * touchBoundary;
    this._startEvent.pageY += (0, _math.sign)(delta.y) * touchBoundary;
  },
  _resetActiveElement() {
    if (_devices.default.real().platform === 'ios' && this.getElement().find(':focus').length) {
      (0, _dom.resetActiveElement)();
    }
  },
  _toggleGestureCover(toggle) {
    this._toggleGestureCoverImpl(toggle);
  },
  _toggleGestureCoverImpl(toggle) {
    const isStarted = this._stage === STARTED;
    if (isStarted) {
      gestureCover(toggle, this.getElement().css('cursor'));
    }
  },
  _clearSelection(e) {
    if ((0, _index.isDxMouseWheelEvent)(e) || (0, _index.isTouchEvent)(e)) {
      return;
    }
    (0, _dom.clearSelection)();
  },
  end(e) {
    this._toggleGestureCover(false);
    if (this._stage === STARTED) {
      this._end(e);
    } else if (this._stage === INITED) {
      this._stop(e);
    }
    this._stage = SLEEP;
  },
  dispose() {
    clearTimeout(this._immediateTimer);
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
  },
  _init: _common.noop,
  _start: _common.noop,
  _move: _common.noop,
  _stop: _common.noop,
  _end: _common.noop
});
// @ts-expect-error
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
// @ts-expect-error
GestureEmitter.touchBoundary = function (newBoundary) {
  if ((0, _type.isDefined)(newBoundary)) {
    TOUCH_BOUNDARY = newBoundary;
    return;
  }
  return TOUCH_BOUNDARY;
};
var _default = exports["default"] = GestureEmitter;

/***/ }),

/***/ 43182:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _frame = __webpack_require__(90057);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _emitter = _interopRequireDefault(__webpack_require__(98621));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  abstract
} = _class.default;
const realDevice = _devices.default.real();
const SCROLL_EVENT = 'scroll';
const SCROLL_INIT_EVENT = 'dxscrollinit';
const SCROLL_START_EVENT = 'dxscrollstart';
const SCROLL_MOVE_EVENT = 'dxscroll';
const SCROLL_END_EVENT = 'dxscrollend';
const SCROLL_STOP_EVENT = 'dxscrollstop';
const SCROLL_CANCEL_EVENT = 'dxscrollcancel';
const Locker = _class.default.inherit(function () {
  const NAMESPACED_SCROLL_EVENT = (0, _index.addNamespace)(SCROLL_EVENT, 'dxScrollEmitter');
  return {
    ctor(element) {
      this._element = element;
      this._locked = false;
      this._proxiedScroll = e => {
        if (!this._disposed) {
          this._scroll(e);
        }
      };
      _events_engine.default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    },
    _scroll: abstract,
    check(e, callback) {
      if (this._locked) {
        callback();
      }
    },
    dispose() {
      this._disposed = true;
      _events_engine.default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    }
  };
}());
const TimeoutLocker = Locker.inherit(function () {
  return {
    ctor(element, timeout) {
      this.callBase(element);
      this._timeout = timeout;
    },
    _scroll() {
      this._prepare();
      this._forget();
    },
    _prepare() {
      if (this._timer) {
        this._clearTimer();
      }
      this._locked = true;
    },
    _clearTimer() {
      clearTimeout(this._timer);
      this._locked = false;
      this._timer = null;
    },
    _forget() {
      const that = this;
      this._timer = setTimeout(() => {
        that._clearTimer();
      }, this._timeout);
    },
    dispose() {
      this.callBase();
      this._clearTimer();
    }
  };
}());
const WheelLocker = TimeoutLocker.inherit(function () {
  const WHEEL_UNLOCK_TIMEOUT = 400;
  return {
    ctor(element) {
      this.callBase(element, WHEEL_UNLOCK_TIMEOUT);
      this._lastWheelDirection = null;
    },
    check(e, callback) {
      this._checkDirectionChanged(e);
      this.callBase(e, callback);
    },
    _checkDirectionChanged(e) {
      if (!(0, _index.isDxMouseWheelEvent)(e)) {
        this._lastWheelDirection = null;
        return;
      }
      const direction = e.shiftKey || false;
      const directionChange = this._lastWheelDirection !== null && direction !== this._lastWheelDirection;
      this._lastWheelDirection = direction;
      this._locked = this._locked && !directionChange;
    }
  };
}());
let PointerLocker = TimeoutLocker.inherit(function () {
  const POINTER_UNLOCK_TIMEOUT = 400;
  return {
    ctor(element) {
      this.callBase(element, POINTER_UNLOCK_TIMEOUT);
    }
  };
}());
(function () {
  const {
    ios: isIos,
    android: isAndroid
  } = realDevice;
  if (!(isIos || isAndroid)) {
    return;
  }
  PointerLocker = Locker.inherit(function () {
    return {
      _scroll() {
        this._locked = true;
        const that = this;
        (0, _frame.cancelAnimationFrame)(this._scrollFrame);
        this._scrollFrame = (0, _frame.requestAnimationFrame)(() => {
          that._locked = false;
        });
      },
      check(e, callback) {
        (0, _frame.cancelAnimationFrame)(this._scrollFrame);
        (0, _frame.cancelAnimationFrame)(this._checkFrame);
        const that = this;
        const {
          callBase
        } = this;
        this._checkFrame = (0, _frame.requestAnimationFrame)(() => {
          callBase.call(that, e, callback);
          that._locked = false;
        });
      },
      dispose() {
        this.callBase();
        (0, _frame.cancelAnimationFrame)(this._scrollFrame);
        (0, _frame.cancelAnimationFrame)(this._checkFrame);
      }
    };
  }());
})();
const ScrollEmitter = _emitter.default.inherit(function () {
  const INERTIA_TIMEOUT = 100;
  const VELOCITY_CALC_TIMEOUT = 200;
  const FRAME_DURATION = Math.round(1000 / 60);
  return {
    ctor(element) {
      this.callBase.apply(this, arguments);
      this.direction = 'both';
      this._pointerLocker = new PointerLocker(element);
      this._wheelLocker = new WheelLocker(element);
    },
    validate() {
      return true;
    },
    configure(data) {
      if (data.scrollTarget) {
        this._pointerLocker.dispose();
        this._wheelLocker.dispose();
        this._pointerLocker = new PointerLocker(data.scrollTarget);
        this._wheelLocker = new WheelLocker(data.scrollTarget);
      }
      this.callBase(data);
    },
    _init(e) {
      this._wheelLocker.check(e, () => {
        if ((0, _index.isDxMouseWheelEvent)(e)) {
          this._accept(e);
        }
      });
      this._pointerLocker.check(e, () => {
        const skipCheck = this.isNative && (0, _index.isMouseEvent)(e);
        if (!(0, _index.isDxMouseWheelEvent)(e) && !skipCheck) {
          this._accept(e);
        }
      });
      this._fireEvent(SCROLL_INIT_EVENT, e);
      this._prevEventData = (0, _index.eventData)(e);
    },
    move(e) {
      this.callBase.apply(this, arguments);
      e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start(e) {
      this._savedEventData = (0, _index.eventData)(e);
      this._fireEvent(SCROLL_START_EVENT, e);
      this._prevEventData = (0, _index.eventData)(e);
    },
    _move(e) {
      const currentEventData = (0, _index.eventData)(e);
      this._fireEvent(SCROLL_MOVE_EVENT, e, {
        delta: (0, _index.eventDelta)(this._prevEventData, currentEventData)
      });
      const delta = (0, _index.eventDelta)(this._savedEventData, currentEventData);
      if (delta.time > VELOCITY_CALC_TIMEOUT) {
        this._savedEventData = this._prevEventData;
      }
      this._prevEventData = (0, _index.eventData)(e);
    },
    _end(e) {
      // @ts-expect-error
      const endEventDelta = (0, _index.eventDelta)(this._prevEventData, (0, _index.eventData)(e));
      let velocity = {
        x: 0,
        y: 0
      };
      if (!(0, _index.isDxMouseWheelEvent)(e) && endEventDelta.time < INERTIA_TIMEOUT) {
        const delta = (0, _index.eventDelta)(this._savedEventData, this._prevEventData);
        const velocityMultiplier = FRAME_DURATION / delta.time;
        velocity = {
          x: delta.x * velocityMultiplier,
          y: delta.y * velocityMultiplier
        };
      }
      this._fireEvent(SCROLL_END_EVENT, e, {
        velocity
      });
    },
    _stop(e) {
      this._fireEvent(SCROLL_STOP_EVENT, e);
    },
    cancel(e) {
      this.callBase.apply(this, arguments);
      this._fireEvent(SCROLL_CANCEL_EVENT, e);
    },
    dispose() {
      this.callBase.apply(this, arguments);
      this._pointerLocker.dispose();
      this._wheelLocker.dispose();
    },
    _clearSelection() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    }
  };
}());
(0, _emitter_registrator.default)({
  emitter: ScrollEmitter,
  events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
});
var _default = exports["default"] = {
  init: SCROLL_INIT_EVENT,
  start: SCROLL_START_EVENT,
  move: SCROLL_MOVE_EVENT,
  end: SCROLL_END_EVENT,
  stop: SCROLL_STOP_EVENT,
  cancel: SCROLL_CANCEL_EVENT,
  scroll: SCROLL_EVENT
};

/***/ }),

/***/ 68344:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.name = void 0;
var _frame = __webpack_require__(90057);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom = __webpack_require__(3532);
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _event_nodes_disposing = __webpack_require__(27575);
var _event_target = __webpack_require__(39644);
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const CLICK_EVENT_NAME = exports.name = 'dxclick';
const misc = {
  requestAnimationFrame: _frame.requestAnimationFrame,
  cancelAnimationFrame: _frame.cancelAnimationFrame
};
let prevented = null;
let lastFiredEvent = null;
const onNodeRemove = () => {
  lastFiredEvent = null;
};
const clickHandler = function (e) {
  const {
    originalEvent
  } = e;
  const eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
  const leftButton = !e.which || e.which === 1;
  if (leftButton && !prevented && !eventAlreadyFired) {
    if (originalEvent) {
      originalEvent.DXCLICK_FIRED = true;
    }
    (0, _event_nodes_disposing.unsubscribeNodesDisposing)(lastFiredEvent, onNodeRemove);
    lastFiredEvent = originalEvent;
    (0, _event_nodes_disposing.subscribeNodesDisposing)(lastFiredEvent, onNodeRemove);
    (0, _index.fireEvent)({
      type: CLICK_EVENT_NAME,
      originalEvent: e
    });
  }
};
const ClickEmitter = _emitter.default.inherit({
  ctor(element) {
    this.callBase(element);
    _events_engine.default.on(this.getElement(), 'click', clickHandler);
  },
  start() {
    prevented = null;
  },
  cancel() {
    prevented = true;
  },
  dispose() {
    _events_engine.default.off(this.getElement(), 'click', clickHandler);
  }
});
// NOTE: fixes native click blur on slow devices
(function () {
  const desktopDevice = _devices.default.real().generic;
  if (!desktopDevice) {
    let startTarget = null;
    let blurPrevented = false;
    const isInput = function (element) {
      return (0, _renderer.default)(element).is('input, textarea, select, button ,:focus, :focus *');
    };
    const pointerDownHandler = function (e) {
      startTarget = e.target;
      blurPrevented = e.isDefaultPrevented();
    };
    const getTarget = function (e) {
      const target = (0, _event_target.getEventTarget)(e);
      return (0, _renderer.default)(target);
    };
    const clickHandler = function (e) {
      const $target = getTarget(e);
      if (!blurPrevented && startTarget && !$target.is(startTarget) && !(0, _renderer.default)(startTarget).is('label') && isInput($target)) {
        (0, _dom.resetActiveElement)();
      }
      startTarget = null;
      blurPrevented = false;
    };
    const NATIVE_CLICK_FIXER_NAMESPACE = 'NATIVE_CLICK_FIXER';
    const document = _dom_adapter.default.getDocument();
    // @ts-expect-error
    _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler);
    // @ts-expect-error
    _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)('click', NATIVE_CLICK_FIXER_NAMESPACE), clickHandler);
  }
})();
(0, _emitter_registrator.default)({
  emitter: ClickEmitter,
  bubble: true,
  events: [CLICK_EVENT_NAME]
});

/***/ }),

/***/ 61114:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.name = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _support = __webpack_require__(60137);
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _hold = _interopRequireDefault(__webpack_require__(11699));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const CONTEXTMENU_NAMESPACE = 'dxContexMenu';
const CONTEXTMENU_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)('contextmenu', CONTEXTMENU_NAMESPACE);
const HOLD_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_hold.default.name, CONTEXTMENU_NAMESPACE);
const CONTEXTMENU_EVENT_NAME = 'dxcontextmenu';
const ContextMenu = _class.default.inherit({
  setup(element) {
    const $element = (0, _renderer.default)(element);
    _events_engine.default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
    if (_support.touch || _devices.default.isSimulator()) {
      _events_engine.default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler(e) {
    if ((0, _index.isMouseEvent)(e) && !_devices.default.isSimulator()) {
      return;
    }
    this._fireContextMenu(e);
  },
  _contextMenuHandler(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu(e) {
    return (0, _index.fireEvent)({
      type: CONTEXTMENU_EVENT_NAME,
      originalEvent: e
    });
  },
  teardown(element) {
    _events_engine.default.off(element, `.${CONTEXTMENU_NAMESPACE}`);
  }
});
(0, _event_registrator.default)(CONTEXTMENU_EVENT_NAME, new ContextMenu());
const name = exports.name = CONTEXTMENU_EVENT_NAME;

/***/ }),

/***/ 40096:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.name = exports.dblClick = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom = __webpack_require__(3532);
var _click = __webpack_require__(95429);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DBLCLICK_EVENT_NAME = exports.name = 'dxdblclick';
const DBLCLICK_NAMESPACE = 'dxDblClick';
const NAMESPACED_CLICK_EVENT = (0, _index.addNamespace)(_click.name, DBLCLICK_NAMESPACE);
const DBLCLICK_TIMEOUT = 300;
const DblClick = _class.default.inherit({
  ctor() {
    this._handlerCount = 0;
    this._forgetLastClick();
  },
  _forgetLastClick() {
    this._firstClickTarget = null;
    this._lastClickTimeStamp = -DBLCLICK_TIMEOUT;
  },
  add() {
    if (this._handlerCount <= 0) {
      _events_engine.default.on(_dom_adapter.default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
    }
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    this._handlerCount += 1;
  },
  _clickHandler(e) {
    const timeStamp = e.timeStamp || Date.now();
    const timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
    // NOTE: jQuery sets `timeStamp = Date.now()` for the triggered events, but
    // in the real event timeStamp is the number of milliseconds elapsed from the
    // beginning of the current document's lifetime till the event was created
    // (https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp).
    const isSimulated = timeBetweenClicks < 0;
    const isDouble = !isSimulated && timeBetweenClicks < DBLCLICK_TIMEOUT;
    if (isDouble) {
      (0, _index.fireEvent)({
        type: DBLCLICK_EVENT_NAME,
        target: (0, _dom.closestCommonParent)(this._firstClickTarget, e.target),
        originalEvent: e
      });
      this._forgetLastClick();
    } else {
      this._firstClickTarget = e.target;
      this._lastClickTimeStamp = timeStamp;
      clearTimeout(this._lastClickClearTimeout);
      this._lastClickClearTimeout = setTimeout(() => {
        this._forgetLastClick();
      }, DBLCLICK_TIMEOUT * 2);
    }
  },
  remove() {
    this._handlerCount -= 1;
    if (this._handlerCount <= 0) {
      this._forgetLastClick();
      _events_engine.default.off(_dom_adapter.default.getDocument(), NAMESPACED_CLICK_EVENT, undefined);
      clearTimeout(this._lastClickClearTimeout);
      this._handlerCount = 0;
    }
  }
});
const dblClick = exports.dblClick = new DblClick();

/***/ }),

/***/ 6647:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.start = exports.move = exports.leave = exports.enter = exports.end = exports.drop = void 0;
var _element_data = __webpack_require__(97906);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _array = __webpack_require__(89386);
var _dom = __webpack_require__(3532);
var iteratorUtils = _interopRequireWildcard(__webpack_require__(95479));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _emitter = _interopRequireDefault(__webpack_require__(98621));
var _index = __webpack_require__(39611);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DRAG_START_EVENT = exports.start = 'dxdragstart';
const DRAG_EVENT = exports.move = 'dxdrag';
const DRAG_END_EVENT = exports.end = 'dxdragend';
const DRAG_ENTER_EVENT = exports.enter = 'dxdragenter';
const DRAG_LEAVE_EVENT = exports.leave = 'dxdragleave';
const DROP_EVENT = exports.drop = 'dxdrop';
const DX_DRAG_EVENTS_COUNT_KEY = 'dxDragEventsCount';
const knownDropTargets = [];
const knownDropTargetSelectors = [];
const knownDropTargetConfigs = [];
const dropTargetRegistration = {
  setup(element, data) {
    const knownDropTarget = knownDropTargets.includes(element);
    if (!knownDropTarget) {
      knownDropTargets.push(element);
      knownDropTargetSelectors.push([]);
      knownDropTargetConfigs.push(data || {});
    }
  },
  add(element, handleObj) {
    const index = knownDropTargets.indexOf(element);
    this.updateEventsCounter(element, handleObj.type, 1);
    const {
      selector
    } = handleObj;
    if (!knownDropTargetSelectors[index].includes(selector)) {
      knownDropTargetSelectors[index].push(selector);
    }
  },
  updateEventsCounter(element, event, value) {
    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].includes(event)) {
      const eventsCount = (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY) || 0;
      (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY, Math.max(0, eventsCount + value));
    }
  },
  remove(element, handleObj) {
    this.updateEventsCounter(element, handleObj.type, -1);
  },
  teardown(element) {
    const handlersCount = (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY);
    if (!handlersCount) {
      const index = knownDropTargets.indexOf(element);
      knownDropTargets.splice(index, 1);
      knownDropTargetSelectors.splice(index, 1);
      knownDropTargetConfigs.splice(index, 1);
      (0, _element_data.removeData)(element, DX_DRAG_EVENTS_COUNT_KEY);
    }
  }
};
(0, _event_registrator.default)(DRAG_ENTER_EVENT, dropTargetRegistration);
(0, _event_registrator.default)(DRAG_LEAVE_EVENT, dropTargetRegistration);
(0, _event_registrator.default)(DROP_EVENT, dropTargetRegistration);
const getItemDelegatedTargets = function ($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  const dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter(selector => selector);
  let $delegatedTargets = $element.find(dropTargetSelectors.join(', '));
  if (knownDropTargetSelectors[dropTargetIndex].includes(undefined)) {
    $delegatedTargets = $delegatedTargets.add($element);
  }
  return $delegatedTargets;
};
const getItemConfig = function ($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  return knownDropTargetConfigs[dropTargetIndex];
};
const getItemPosition = function (dropTargetConfig, $element) {
  if (dropTargetConfig.itemPositionFunc) {
    return dropTargetConfig.itemPositionFunc($element);
  }
  return $element.offset();
};
const getItemSize = function (dropTargetConfig, $element) {
  if (dropTargetConfig.itemSizeFunc) {
    return dropTargetConfig.itemSizeFunc($element);
  }
  return {
    width: $element.get(0).getBoundingClientRect().width,
    height: $element.get(0).getBoundingClientRect().height
  };
};
const DragEmitter = _emitter.default.inherit({
  ctor(element) {
    this.callBase(element);
    this.direction = 'both';
  },
  _init(e) {
    this._initEvent = e;
  },
  _start(e) {
    e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
    this._maxLeftOffset = e.maxLeftOffset;
    this._maxRightOffset = e.maxRightOffset;
    this._maxTopOffset = e.maxTopOffset;
    this._maxBottomOffset = e.maxBottomOffset;
    if (e.targetElements || e.targetElements === null) {
      const dropTargets = (0, _array.wrapToArray)(e.targetElements || []);
      this._dropTargets = iteratorUtils.map(dropTargets, element => (0, _renderer.default)(element).get(0));
    } else {
      this._dropTargets = knownDropTargets;
    }
  },
  _move(e) {
    const eventData = (0, _index.eventData)(e);
    const dragOffset = this._calculateOffset(eventData);
    e = this._fireEvent(DRAG_EVENT, e, {
      offset: dragOffset
    });
    this._processDropTargets(e);
    if (!e._cancelPreventDefault) {
      e.preventDefault();
    }
  },
  _calculateOffset(eventData) {
    return {
      x: this._calculateXOffset(eventData),
      y: this._calculateYOffset(eventData)
    };
  },
  _calculateXOffset(eventData) {
    if (this.direction !== 'vertical') {
      const offset = eventData.x - this._startEventData.x;
      return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset);
    }
    return 0;
  },
  _calculateYOffset(eventData) {
    if (this.direction !== 'horizontal') {
      const offset = eventData.y - this._startEventData.y;
      return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset);
    }
    return 0;
  },
  _fitOffset(offset, minOffset, maxOffset) {
    if (minOffset != null) {
      offset = Math.max(offset, -minOffset);
    }
    if (maxOffset != null) {
      offset = Math.min(offset, maxOffset);
    }
    return offset;
  },
  _processDropTargets(e) {
    const target = this._findDropTarget(e);
    const sameTarget = target === this._currentDropTarget;
    if (!sameTarget) {
      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
      this._currentDropTarget = target;
      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
    }
  },
  _fireDropTargetEvent(event, eventName) {
    if (!this._currentDropTarget) {
      return;
    }
    const eventData = {
      type: eventName,
      originalEvent: event,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    (0, _index.fireEvent)(eventData);
  },
  _findDropTarget(e) {
    const that = this;
    let result;
    iteratorUtils.each(knownDropTargets, (_, target) => {
      if (!that._checkDropTargetActive(target)) {
        return;
      }
      const $target = (0, _renderer.default)(target);
      iteratorUtils.each(getItemDelegatedTargets($target), (_, delegatedTarget) => {
        const $delegatedTarget = (0, _renderer.default)(delegatedTarget);
        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, (0, _renderer.default)(result), e)) {
          result = delegatedTarget;
        }
      });
    });
    return result;
  },
  _checkDropTargetActive(target) {
    let active = false;
    iteratorUtils.each(this._dropTargets, (_, activeTarget) => {
      active = active || activeTarget === target || (0, _dom.contains)(activeTarget, target);
      return !active;
    });
    return active;
  },
  _checkDropTarget(config, $target, $prevTarget, e) {
    const isDraggingElement = $target.get(0) === (0, _renderer.default)(e.target).get(0);
    if (isDraggingElement) {
      return false;
    }
    const targetPosition = getItemPosition(config, $target);
    if (e.pageX < targetPosition.left) {
      return false;
    }
    if (e.pageY < targetPosition.top) {
      return false;
    }
    const targetSize = getItemSize(config, $target);
    if (e.pageX > targetPosition.left + targetSize.width) {
      return false;
    }
    if (e.pageY > targetPosition.top + targetSize.height) {
      return false;
    }
    if ($prevTarget.length && $prevTarget.closest($target).length) {
      return false;
    }
    if (config.checkDropTarget && !config.checkDropTarget($target, e)) {
      return false;
    }
    return $target;
  },
  _end(e) {
    const eventData = (0, _index.eventData)(e);
    this._fireEvent(DRAG_END_EVENT, e, {
      offset: this._calculateOffset(eventData)
    });
    this._fireDropTargetEvent(e, DROP_EVENT);
    delete this._currentDropTarget;
  }
});
(0, _emitter_registrator.default)({
  emitter: DragEmitter,
  events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
});

/***/ }),

/***/ 43246:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  abs
} = Math;
const HOLD_EVENT_NAME = 'dxhold';
const HOLD_TIMEOUT = 750;
const TOUCH_BOUNDARY = 5;
const HoldEmitter = _emitter.default.inherit({
  start(e) {
    this._startEventData = (0, _index.eventData)(e);
    this._startTimer(e);
  },
  _startTimer(e) {
    const holdTimeout = 'timeout' in this ? this.timeout : HOLD_TIMEOUT;
    this._holdTimer = setTimeout(() => {
      this._requestAccept(e);
      this._fireEvent(HOLD_EVENT_NAME, e, {
        target: e.target
      });
      this._forgetAccept();
    }, holdTimeout);
  },
  move(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved(e) {
    // @ts-expect-error
    const delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY;
  },
  end() {
    this._stopTimer();
  },
  _stopTimer() {
    clearTimeout(this._holdTimer);
  },
  cancel() {
    this._stopTimer();
  },
  dispose() {
    this._stopTimer();
  }
});
(0, _emitter_registrator.default)({
  emitter: HoldEmitter,
  bubble: true,
  events: [HOLD_EVENT_NAME]
});
var _default = exports["default"] = {
  name: HOLD_EVENT_NAME
};

/***/ }),

/***/ 84500:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.start = exports.end = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _element_data = __webpack_require__(97906);
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const HOVERSTART_NAMESPACE = 'dxHoverStart';
const HOVERSTART = exports.start = 'dxhoverstart';
const POINTERENTER_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.enter, HOVERSTART_NAMESPACE);
const HOVEREND_NAMESPACE = 'dxHoverEnd';
const HOVEREND = exports.end = 'dxhoverend';
const POINTERLEAVE_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.leave, HOVEREND_NAMESPACE);
const Hover = _class.default.inherit({
  noBubble: true,
  ctor() {
    this._handlerArrayKeyPath = `${this._eventNamespace}_HandlerStore`;
  },
  setup(element) {
    (0, _element_data.data)(element, this._handlerArrayKeyPath, {});
  },
  add(element, handleObj) {
    const that = this;
    const handler = function (e) {
      that._handler(e);
    };
    _events_engine.default.on(element, this._originalEventName, handleObj.selector, handler);
    (0, _element_data.data)(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
  },
  _handler(e) {
    if ((0, _index.isTouchEvent)(e) || _devices.default.isSimulator()) {
      return;
    }
    (0, _index.fireEvent)({
      type: this._eventName,
      originalEvent: e,
      delegateTarget: e.delegateTarget
    });
  },
  remove(element, handleObj) {
    const handler = (0, _element_data.data)(element, this._handlerArrayKeyPath)[handleObj.guid];
    // @ts-expect-error
    _events_engine.default.off(element, this._originalEventName, handleObj.selector, handler);
  },
  teardown(element) {
    (0, _element_data.removeData)(element, this._handlerArrayKeyPath);
  }
});
const HoverStart = Hover.inherit({
  ctor() {
    this._eventNamespace = HOVERSTART_NAMESPACE;
    this._eventName = HOVERSTART;
    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
    this.callBase();
  },
  _handler(e) {
    const pointers = e.pointers || [];
    if (!pointers.length) {
      this.callBase(e);
    }
  }
});
const HoverEnd = Hover.inherit({
  ctor() {
    this._eventNamespace = HOVEREND_NAMESPACE;
    this._eventName = HOVEREND;
    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
    this.callBase();
  }
});
(0, _event_registrator.default)(HOVERSTART, new HoverStart());
(0, _event_registrator.default)(HOVEREND, new HoverEnd());

/***/ }),

/***/ 90215:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _iterator = __webpack_require__(95479);
var support = _interopRequireWildcard(__webpack_require__(60137));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _mouse = _interopRequireDefault(__webpack_require__(66509));
var _mouse_and_touch = _interopRequireDefault(__webpack_require__(87720));
var _touch = _interopRequireDefault(__webpack_require__(69120));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const getStrategy = (support, _ref) => {
  let {
    tablet,
    phone
  } = _ref;
  const pointerEventStrategy = getStrategyFromGlobalConfig();
  if (pointerEventStrategy) {
    return pointerEventStrategy;
  }
  if (support.touch && !(tablet || phone)) {
    return _mouse_and_touch.default;
  }
  if (support.touch) {
    return _touch.default;
  }
  return _mouse.default;
};
// @ts-expect-error
const EventStrategy = getStrategy(support, _devices.default.real());
(0, _iterator.each)(EventStrategy.map, (pointerEvent, originalEvents) => {
  (0, _event_registrator.default)(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
});
const pointer = {
  down: 'dxpointerdown',
  up: 'dxpointerup',
  move: 'dxpointermove',
  cancel: 'dxpointercancel',
  enter: 'dxpointerenter',
  leave: 'dxpointerleave',
  over: 'dxpointerover',
  out: 'dxpointerout'
};
function getStrategyFromGlobalConfig() {
  const eventStrategyName = (0, _config.default)().pointerEventStrategy;
  return {
    'mouse-and-touch': _mouse_and_touch.default,
    touch: _touch.default,
    mouse: _mouse.default
    // @ts-expect-error
  }[eventStrategyName];
}
var _default = exports["default"] = pointer;

/***/ }),

/***/ 88738:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.removeEvent = void 0;
var _element_data = __webpack_require__(97906);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const removeEvent = exports.removeEvent = 'dxremove';
const eventPropName = 'dxRemoveEvent';
(0, _element_data.beforeCleanData)(elements => {
  elements = [].slice.call(elements);
  for (let i = 0; i < elements.length; i++) {
    const $element = (0, _renderer.default)(elements[i]);
    // @ts-expect-error
    if ($element.prop(eventPropName)) {
      $element[0][eventPropName] = null;
      // @ts-expect-error
      _events_engine.default.triggerHandler($element, removeEvent);
    }
  }
});
(0, _event_registrator.default)(removeEvent, {
  noBubble: true,
  setup(element) {
    (0, _renderer.default)(element).prop(eventPropName, true);
  }
});

/***/ }),

/***/ 78546:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.visibility = exports.resize = exports.keyboard = exports.hover = exports.focus = exports.dxClick = exports.click = exports.active = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _keyboard_processor = _interopRequireDefault(__webpack_require__(51661));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function addNamespace(event, namespace) {
  return namespace ? (0, _index.addNamespace)(event, namespace) : event;
}
function executeAction(action, args) {
  return typeof action === 'function' ? action(args) : action.execute(args);
}
const active = exports.active = {
  on: ($el, active, inactive, opts) => {
    const {
      selector,
      showTimeout,
      hideTimeout,
      namespace
    } = opts;
    _events_engine.default.on($el, addNamespace('dxactive', namespace), selector, {
      timeout: showTimeout
    },
    // @ts-expect-error
    event => executeAction(active, {
      event,
      element: event.currentTarget
    }));
    _events_engine.default.on($el, addNamespace('dxinactive', namespace), selector, {
      timeout: hideTimeout
    },
    // @ts-expect-error
    event => executeAction(inactive, {
      event,
      element: event.currentTarget
    }));
  },
  off: ($el, _ref) => {
    let {
      namespace,
      selector
    } = _ref;
    _events_engine.default.off($el, addNamespace('dxactive', namespace), selector);
    _events_engine.default.off($el, addNamespace('dxinactive', namespace), selector);
  }
};
const resize = exports.resize = {
  on: function ($el, resize) {
    let {
      namespace
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _events_engine.default.on($el, addNamespace('dxresize', namespace), resize);
  },
  off: function ($el) {
    let {
      namespace
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _events_engine.default.off($el, addNamespace('dxresize', namespace));
  }
};
const hover = exports.hover = {
  on: ($el, start, end, _ref2) => {
    let {
      selector,
      namespace
    } = _ref2;
    _events_engine.default.on($el, addNamespace('dxhoverend', namespace), selector, event => end(event));
    _events_engine.default.on($el, addNamespace('dxhoverstart', namespace), selector, event => executeAction(start, {
      element: event.target,
      event
    }));
  },
  off: ($el, _ref3) => {
    let {
      selector,
      namespace
    } = _ref3;
    _events_engine.default.off($el, addNamespace('dxhoverstart', namespace), selector);
    _events_engine.default.off($el, addNamespace('dxhoverend', namespace), selector);
  }
};
const visibility = exports.visibility = {
  on: ($el, shown, hiding, _ref4) => {
    let {
      namespace
    } = _ref4;
    _events_engine.default.on($el, addNamespace('dxhiding', namespace), hiding);
    _events_engine.default.on($el, addNamespace('dxshown', namespace), shown);
  },
  off: ($el, _ref5) => {
    let {
      namespace
    } = _ref5;
    _events_engine.default.off($el, addNamespace('dxhiding', namespace));
    _events_engine.default.off($el, addNamespace('dxshown', namespace));
  }
};
const focus = exports.focus = {
  on: ($el, focusIn, focusOut, _ref6) => {
    let {
      namespace
    } = _ref6;
    _events_engine.default.on($el, addNamespace('focusin', namespace), focusIn);
    _events_engine.default.on($el, addNamespace('focusout', namespace), focusOut);
  },
  off: ($el, _ref7) => {
    let {
      namespace
    } = _ref7;
    _events_engine.default.off($el, addNamespace('focusin', namespace));
    _events_engine.default.off($el, addNamespace('focusout', namespace));
  },
  // @ts-expect-error
  trigger: $el => _events_engine.default.trigger($el, 'focus')
};
const dxClick = exports.dxClick = {
  on: function ($el, click) {
    let {
      namespace
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _events_engine.default.on($el, addNamespace('dxclick', namespace), click);
  },
  off: function ($el) {
    let {
      namespace
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _events_engine.default.off($el, addNamespace('dxclick', namespace));
  }
};
const click = exports.click = {
  on: function ($el, click) {
    let {
      namespace
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _events_engine.default.on($el, addNamespace('click', namespace), click);
  },
  off: function ($el) {
    let {
      namespace
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _events_engine.default.off($el, addNamespace('click', namespace));
  }
};
let index = 0;
const keyboardProcessors = {};
const generateListenerId = () => `keyboardProcessorId${index++}`;
const keyboard = exports.keyboard = {
  on: (element, focusTarget, handler) => {
    const listenerId = generateListenerId();
    keyboardProcessors[listenerId] = new _keyboard_processor.default({
      element,
      focusTarget,
      handler
    });
    return listenerId;
  },
  off: listenerId => {
    if (listenerId && keyboardProcessors[listenerId]) {
      keyboardProcessors[listenerId].dispose();
      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
      delete keyboardProcessors[listenerId];
    }
  },
  // NOTE: For tests
  _getProcessor: listenerId => keyboardProcessors[listenerId]
};

/***/ }),

/***/ 45298:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.swipe = exports.start = exports.end = void 0;
var _size = __webpack_require__(58664);
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
var _emitter = _interopRequireDefault(__webpack_require__(98621));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SWIPE_START_EVENT = exports.start = 'dxswipestart';
const SWIPE_EVENT = exports.swipe = 'dxswipe';
const SWIPE_END_EVENT = exports.end = 'dxswipeend';
const HorizontalStrategy = {
  defaultItemSizeFunc() {
    return (0, _size.getWidth)(this.getElement());
  },
  getBounds() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio(e) {
    const endEventData = (0, _index.eventData)(e);
    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe(e) {
    const endEventData = (0, _index.eventData)(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
  }
};
const VerticalStrategy = {
  defaultItemSizeFunc() {
    return (0, _size.getHeight)(this.getElement());
  },
  getBounds() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio(e) {
    const endEventData = (0, _index.eventData)(e);
    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe(e) {
    const endEventData = (0, _index.eventData)(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
  }
};
const STRATEGIES = {
  horizontal: HorizontalStrategy,
  vertical: VerticalStrategy
};
const SwipeEmitter = _emitter.default.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor(element) {
    this.callBase(element);
    this.direction = 'horizontal';
    this.elastic = true;
  },
  _getStrategy() {
    return STRATEGIES[this.direction];
  },
  _defaultItemSizeFunc() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init(e) {
    this._tickData = (0, _index.eventData)(e);
  },
  _start(e) {
    this._savedEventData = (0, _index.eventData)(e);
    e = this._fireEvent(SWIPE_START_EVENT, e);
    if (!e.cancel) {
      this._maxLeftOffset = e.maxLeftOffset;
      this._maxRightOffset = e.maxRightOffset;
      this._maxTopOffset = e.maxTopOffset;
      this._maxBottomOffset = e.maxBottomOffset;
    }
  },
  _move(e) {
    const strategy = this._getStrategy();
    const moveEventData = (0, _index.eventData)(e);
    let offset = strategy.calcOffsetRatio.call(this, e);
    offset = this._fitOffset(offset, this.elastic);
    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
      this._tickData = moveEventData;
    }
    this._fireEvent(SWIPE_EVENT, e, {
      offset
    });
    if (e.cancelable !== false) {
      e.preventDefault();
    }
  },
  _end(e) {
    const strategy = this._getStrategy();
    const offsetRatio = strategy.calcOffsetRatio.call(this, e);
    const isFast = strategy.isFastSwipe.call(this, e);
    let startOffset = offsetRatio;
    let targetOffset = this._calcTargetOffset(offsetRatio, isFast);
    startOffset = this._fitOffset(startOffset, this.elastic);
    targetOffset = this._fitOffset(targetOffset, false);
    this._fireEvent(SWIPE_END_EVENT, e, {
      offset: startOffset,
      targetOffset
    });
  },
  _fitOffset(offset, elastic) {
    const strategy = this._getStrategy();
    const bounds = strategy.getBounds.call(this);
    if (offset < -bounds[0]) {
      return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0];
    }
    if (offset > bounds[1]) {
      return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1];
    }
    return offset;
  },
  _calcTargetOffset(offsetRatio, isFast) {
    let result;
    if (isFast) {
      result = Math.ceil(Math.abs(offsetRatio));
      if (offsetRatio < 0) {
        result = -result;
      }
    } else {
      result = Math.round(offsetRatio);
    }
    return result;
  }
});
(0, _emitter_registrator.default)({
  emitter: SwipeEmitter,
  events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
});

/***/ }),

/***/ 83175:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.exportNames = void 0;
var iteratorUtils = _interopRequireWildcard(__webpack_require__(95479));
var _math = __webpack_require__(60810);
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const DX_PREFIX = 'dx';
const TRANSFORM = 'transform';
const TRANSLATE = 'translate';
const PINCH = 'pinch';
const ROTATE = 'rotate';
const START_POSTFIX = 'start';
const UPDATE_POSTFIX = '';
const END_POSTFIX = 'end';
const eventAliases = [];
const addAlias = function (eventName, eventArgs) {
  eventAliases.push({
    name: eventName,
    args: eventArgs
  });
};
addAlias(TRANSFORM, {
  scale: true,
  deltaScale: true,
  rotation: true,
  deltaRotation: true,
  translation: true,
  deltaTranslation: true
});
addAlias(TRANSLATE, {
  translation: true,
  deltaTranslation: true
});
addAlias(PINCH, {
  scale: true,
  deltaScale: true
});
addAlias(ROTATE, {
  rotation: true,
  deltaRotation: true
});
const getVector = function (first, second) {
  return {
    x: second.pageX - first.pageX,
    y: -second.pageY + first.pageY,
    centerX: (second.pageX + first.pageX) * 0.5,
    centerY: (second.pageY + first.pageY) * 0.5
  };
};
const getEventVector = function (e) {
  const {
    pointers
  } = e;
  return getVector(pointers[0], pointers[1]);
};
const getDistance = function (vector) {
  return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
};
const getScale = function (firstVector, secondVector) {
  return getDistance(firstVector) / getDistance(secondVector);
};
const getRotation = function (firstVector, secondVector) {
  const scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;
  const distanceProduct = getDistance(firstVector) * getDistance(secondVector);
  if (distanceProduct === 0) {
    return 0;
  }
  const sign = (0, _math.sign)(firstVector.x * secondVector.y - secondVector.x * firstVector.y);
  const angle = Math.acos((0, _math.fitIntoRange)(scalarProduct / distanceProduct, -1, 1));
  return sign * angle;
};
const getTranslation = function (firstVector, secondVector) {
  return {
    x: firstVector.centerX - secondVector.centerX,
    y: firstVector.centerY - secondVector.centerY
  };
};
const TransformEmitter = _emitter.default.inherit({
  validatePointers(e) {
    return (0, _index.hasTouches)(e) > 1;
  },
  start(e) {
    this._accept(e);
    const startVector = getEventVector(e);
    this._startVector = startVector;
    this._prevVector = startVector;
    this._fireEventAliases(START_POSTFIX, e);
  },
  move(e) {
    const currentVector = getEventVector(e);
    const eventArgs = this._getEventArgs(currentVector);
    this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);
    this._prevVector = currentVector;
  },
  end(e) {
    const eventArgs = this._getEventArgs(this._prevVector);
    this._fireEventAliases(END_POSTFIX, e, eventArgs);
  },
  _getEventArgs(vector) {
    return {
      scale: getScale(vector, this._startVector),
      deltaScale: getScale(vector, this._prevVector),
      rotation: getRotation(vector, this._startVector),
      deltaRotation: getRotation(vector, this._prevVector),
      translation: getTranslation(vector, this._startVector),
      deltaTranslation: getTranslation(vector, this._prevVector)
    };
  },
  _fireEventAliases(eventPostfix, originalEvent, eventArgs) {
    eventArgs = eventArgs || {};
    iteratorUtils.each(eventAliases, (_, eventAlias) => {
      const args = {};
      iteratorUtils.each(eventAlias.args, name => {
        if (name in eventArgs) {
          args[name] = eventArgs[name];
        }
      });
      this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args);
    });
  }
});
const eventNames = eventAliases.reduce((result, eventAlias) => {
  [START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX].forEach(eventPostfix => {
    result.push(DX_PREFIX + eventAlias.name + eventPostfix);
  });
  return result;
}, []);
(0, _emitter_registrator.default)({
  emitter: TransformEmitter,
  events: eventNames
});
const exportNames = exports.exportNames = {};
iteratorUtils.each(eventNames, (_, eventName) => {
  exportNames[eventName.substring(DX_PREFIX.length)] = eventName;
});

/***/ }),

/***/ 85374:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.triggerShownEvent = exports.triggerResizeEvent = exports.triggerHidingEvent = exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const triggerVisibilityChangeEvent = function (eventName) {
  const VISIBILITY_CHANGE_SELECTOR = '.dx-visibility-change-handler';
  return function (element) {
    const $element = (0, _renderer.default)(element || 'body');
    const changeHandlers = $element.filter(VISIBILITY_CHANGE_SELECTOR)
    // @ts-expect-error
    .add($element.find(VISIBILITY_CHANGE_SELECTOR));
    for (let i = 0; i < changeHandlers.length; i++) {
      _events_engine.default.triggerHandler(changeHandlers[i], eventName);
    }
  };
};
const triggerShownEvent = exports.triggerShownEvent = triggerVisibilityChangeEvent('dxshown');
const triggerHidingEvent = exports.triggerHidingEvent = triggerVisibilityChangeEvent('dxhiding');
const triggerResizeEvent = exports.triggerResizeEvent = triggerVisibilityChangeEvent('dxresize');
var _default = exports["default"] = {
  triggerHidingEvent,
  triggerResizeEvent,
  triggerShownEvent
};

/***/ }),

/***/ 54571:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _browser = _interopRequireDefault(__webpack_require__(47810));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _event_target = __webpack_require__(39644);
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const POINTER_EVENTS_NAMESPACE = 'dxPointerEvents';
const BaseStrategy = _class.default.inherit({
  ctor(eventName, originalEvents) {
    this._eventName = eventName;
    this._originalEvents = (0, _index.addNamespace)(originalEvents, POINTER_EVENTS_NAMESPACE);
    this._handlerCount = 0;
    this.noBubble = this._isNoBubble();
  },
  _isNoBubble() {
    const eventName = this._eventName;
    return eventName === 'dxpointerenter' || eventName === 'dxpointerleave';
  },
  _handler(e) {
    const delegateTarget = this._getDelegateTarget(e);
    const event = {
      type: this._eventName,
      pointerType: e.pointerType || (0, _index.eventSource)(e),
      originalEvent: e,
      delegateTarget,
      // NOTE: TimeStamp normalization (FF bug #238041) (T277118)
      timeStamp: _browser.default.mozilla ? new Date().getTime() : e.timeStamp
    };
    const target = (0, _event_target.getEventTarget)(e);
    // @ts-expect-error
    event.target = target;
    return this._fireEvent(event);
  },
  _getDelegateTarget(e) {
    let delegateTarget;
    if (this.noBubble) {
      delegateTarget = e.delegateTarget;
    }
    return delegateTarget;
  },
  _fireEvent(args) {
    return (0, _index.fireEvent)(args);
  },
  _setSelector(handleObj) {
    this._selector = this.noBubble && handleObj ? handleObj.selector : null;
  },
  _getSelector() {
    return this._selector;
  },
  setup() {
    return true;
  },
  add(element, handleObj) {
    if (this._handlerCount <= 0 || this.noBubble) {
      element = this.noBubble ? element : _dom_adapter.default.getDocument();
      this._setSelector(handleObj);
      const that = this;
      _events_engine.default.on(element, this._originalEvents, this._getSelector(), e => {
        that._handler(e);
      });
    }
    if (!this.noBubble) {
      this._handlerCount++;
    }
  },
  remove(handleObj) {
    this._setSelector(handleObj);
    if (!this.noBubble) {
      this._handlerCount--;
    }
  },
  teardown(element) {
    if (this._handlerCount && !this.noBubble) {
      return;
    }
    element = this.noBubble ? element : _dom_adapter.default.getDocument();
    if (this._originalEvents !== `.${POINTER_EVENTS_NAMESPACE}`) {
      _events_engine.default.off(element, this._originalEvents, this._getSelector());
    }
  },
  dispose(element) {
    element = this.noBubble ? element : _dom_adapter.default.getDocument();
    _events_engine.default.off(element, this._originalEvents);
  }
});
var _default = exports["default"] = BaseStrategy;

/***/ }),

/***/ 45679:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _base = _interopRequireDefault(__webpack_require__(88136));
var _observer = _interopRequireDefault(__webpack_require__(25544));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable spellcheck/spell-checker */
const eventMap = {
  dxpointerdown: 'mousedown',
  dxpointermove: 'mousemove',
  dxpointerup: 'mouseup',
  dxpointercancel: '',
  dxpointerover: 'mouseover',
  dxpointerout: 'mouseout',
  dxpointerenter: 'mouseenter',
  dxpointerleave: 'mouseleave'
};
const normalizeMouseEvent = function (e) {
  e.pointerId = 1;
  return {
    pointers: observer.pointers(),
    pointerId: 1
  };
};
let observer;
let activated = false;
const activateStrategy = function () {
  if (activated) {
    return;
  }
  // @ts-expect-error
  observer = new _observer.default(eventMap, () => true);
  activated = true;
};
const MouseStrategy = _base.default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _fireEvent(args) {
    return this.callBase((0, _extend.extend)(normalizeMouseEvent(args.originalEvent), args));
  }
});
// @ts-expect-error
MouseStrategy.map = eventMap;
// @ts-expect-error
MouseStrategy.normalize = normalizeMouseEvent;
// @ts-expect-error
MouseStrategy.activate = activateStrategy;
// @ts-expect-error
MouseStrategy.resetObserver = function () {
  observer.reset();
};
var _default = exports["default"] = MouseStrategy;

/***/ }),

/***/ 62172:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _base = _interopRequireDefault(__webpack_require__(88136));
var _mouse = _interopRequireDefault(__webpack_require__(66509));
var _touch = _interopRequireDefault(__webpack_require__(69120));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable spellcheck/spell-checker */
const eventMap = {
  dxpointerdown: 'touchstart mousedown',
  dxpointermove: 'touchmove mousemove',
  dxpointerup: 'touchend mouseup',
  dxpointercancel: 'touchcancel',
  dxpointerover: 'mouseover',
  dxpointerout: 'mouseout',
  dxpointerenter: 'mouseenter',
  dxpointerleave: 'mouseleave'
};
let activated = false;
const activateStrategy = function () {
  if (activated) {
    return;
  }
  // @ts-expect-error
  _mouse.default.activate();
  activated = true;
};
const MouseAndTouchStrategy = _base.default.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _handler(e) {
    const isMouse = (0, _index.isMouseEvent)(e);
    if (!isMouse) {
      this._skipNextEvents = true;
    }
    if (isMouse && this._mouseLocked) {
      return;
    }
    if (isMouse && this._skipNextEvents) {
      this._skipNextEvents = false;
      this._mouseLocked = true;
      clearTimeout(this._unlockMouseTimer);
      const that = this;
      this._unlockMouseTimer = setTimeout(() => {
        that._mouseLocked = false;
      }, this.EVENT_LOCK_TIMEOUT);
      return;
    }
    return this.callBase(e);
  },
  _fireEvent(args) {
    // @ts-expect-error
    const normalizer = (0, _index.isMouseEvent)(args.originalEvent) ? _mouse.default.normalize : _touch.default.normalize;
    return this.callBase((0, _extend.extend)(normalizer(args.originalEvent), args));
  },
  dispose() {
    this.callBase();
    this._skipNextEvents = false;
    this._mouseLocked = false;
    clearTimeout(this._unlockMouseTimer);
  }
});
// @ts-expect-error
MouseAndTouchStrategy.map = eventMap;
// @ts-expect-error
MouseAndTouchStrategy.resetObserver = _mouse.default.resetObserver;
var _default = exports["default"] = MouseAndTouchStrategy;

/***/ }),

/***/ 78199:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _iterator = __webpack_require__(95479);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const addEventsListener = function (events, handler) {
  _ready_callbacks.default.add(() => {
    events.split(' ').forEach(event => {
      // @ts-expect-error
      _dom_adapter.default.listen(_dom_adapter.default.getDocument(), event, handler, true);
    });
  });
};
const Observer = function (eventMap, pointerEquals, onPointerAdding) {
  onPointerAdding = onPointerAdding || function () {};
  let pointers = [];
  const getPointerIndex = function (e) {
    let index = -1;
    (0, _iterator.each)(pointers, (i, pointer) => {
      if (!pointerEquals(e, pointer)) {
        return true;
      }
      index = i;
      return false;
    });
    return index;
  };
  const addPointer = function (e) {
    if (getPointerIndex(e) === -1) {
      onPointerAdding(e);
      pointers.push(e);
    }
  };
  const removePointer = function (e) {
    const index = getPointerIndex(e);
    if (index > -1) {
      pointers.splice(index, 1);
    }
  };
  const updatePointer = function (e) {
    pointers[getPointerIndex(e)] = e;
  };
  /* eslint-disable spellcheck/spell-checker */
  addEventsListener(eventMap.dxpointerdown, addPointer);
  addEventsListener(eventMap.dxpointermove, updatePointer);
  addEventsListener(eventMap.dxpointerup, removePointer);
  addEventsListener(eventMap.dxpointercancel, removePointer);
  this.pointers = function () {
    return pointers;
  };
  this.reset = function () {
    pointers = [];
  };
};
var _default = exports["default"] = Observer;

/***/ }),

/***/ 31912:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _base = _interopRequireDefault(__webpack_require__(88136));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable spellcheck/spell-checker */
const eventMap = {
  dxpointerdown: 'touchstart',
  dxpointermove: 'touchmove',
  dxpointerup: 'touchend',
  dxpointercancel: 'touchcancel',
  dxpointerover: '',
  dxpointerout: '',
  dxpointerenter: '',
  dxpointerleave: ''
};
const normalizeTouchEvent = function (e) {
  const pointers = [];
  (0, _iterator.each)(e.touches, (_, touch) => {
    pointers.push((0, _extend.extend)({
      pointerId: touch.identifier
    }, touch));
  });
  return {
    pointers,
    pointerId: e.changedTouches[0].identifier
  };
};
const skipTouchWithSameIdentifier = function (pointerEvent) {
  return _devices.default.real().platform === 'ios' && (pointerEvent === 'dxpointerdown' || pointerEvent === 'dxpointerup');
};
const TouchStrategy = _base.default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    this._pointerId = 0;
  },
  _handler(e) {
    if (skipTouchWithSameIdentifier(this._eventName)) {
      const touch = e.changedTouches[0];
      if (this._pointerId === touch.identifier && this._pointerId !== 0) {
        return;
      }
      this._pointerId = touch.identifier;
    }
    return this.callBase.apply(this, arguments);
  },
  _fireEvent(args) {
    return this.callBase((0, _extend.extend)(normalizeTouchEvent(args.originalEvent), args));
  }
});
// @ts-expect-error
TouchStrategy.map = eventMap;
// @ts-expect-error
TouchStrategy.normalize = normalizeTouchEvent;
var _default = exports["default"] = TouchStrategy;

/***/ }),

/***/ 89488:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.stopEventsSkipping = exports.setEventFixMethod = exports.normalizeKeyName = exports.needSkipEvent = exports.isTouchEvent = exports.isPointerEvent = exports.isMouseEvent = exports.isKeyboardEvent = exports.isFakeClickEvent = exports.isDxMouseWheelEvent = exports.isCommandKeyPressed = exports.hasTouches = exports.getChar = exports.forceSkipEvents = exports.fireEvent = exports.eventSource = exports.eventDelta = exports.eventData = exports.createEvent = exports.addNamespace = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _selectors = __webpack_require__(31421);
var _m_add_namespace = _interopRequireDefault(__webpack_require__(97781));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable spellcheck/spell-checker */
const KEY_MAP = {
  backspace: 'backspace',
  tab: 'tab',
  enter: 'enter',
  escape: 'escape',
  pageup: 'pageUp',
  pagedown: 'pageDown',
  end: 'end',
  home: 'home',
  arrowleft: 'leftArrow',
  arrowup: 'upArrow',
  arrowright: 'rightArrow',
  arrowdown: 'downArrow',
  delete: 'del',
  ' ': 'space',
  f: 'F',
  a: 'A',
  '*': 'asterisk',
  '-': 'minus',
  alt: 'alt',
  control: 'control',
  shift: 'shift'
};
const LEGACY_KEY_CODES = {
  // iOS 10.2 and lower didn't supports KeyboardEvent.key
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'escape',
  33: 'pageUp',
  34: 'pageDown',
  35: 'end',
  36: 'home',
  37: 'leftArrow',
  38: 'upArrow',
  39: 'rightArrow',
  40: 'downArrow',
  46: 'del',
  32: 'space',
  70: 'F',
  65: 'A',
  106: 'asterisk',
  109: 'minus',
  189: 'minus',
  173: 'minus',
  16: 'shift',
  17: 'control',
  18: 'alt'
};
const EVENT_SOURCES_REGEX = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
};
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/no-unsafe-return */
const eventSource = _ref => {
  let {
    type
  } = _ref;
  let result = 'other';
  /* eslint-disable @typescript-eslint/no-invalid-void-type */
  // eslint-disable-next-line consistent-return
  (0, _iterator.each)(EVENT_SOURCES_REGEX, function (key) {
    // eslint-disable-next-line @typescript-eslint/no-invalid-this
    if (this.test(type)) {
      result = key;
      return false;
    }
  });
  return result;
};
exports.eventSource = eventSource;
let fixMethod = e => e;
// @ts-expect-error
const getEvent = originalEvent => _events_engine.default.Event(originalEvent, originalEvent);
// @ts-expect-error
const copyEvent = originalEvent => fixMethod(getEvent(originalEvent), originalEvent);
const isDxEvent = e => eventSource(e) === 'dx';
const isNativeMouseEvent = e => eventSource(e) === 'mouse';
const isNativeTouchEvent = e => eventSource(e) === 'touch';
const isPointerEvent = e => eventSource(e) === 'pointer';
exports.isPointerEvent = isPointerEvent;
const isMouseEvent = e => isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === 'mouse';
exports.isMouseEvent = isMouseEvent;
const isDxMouseWheelEvent = e => e && e.type === 'dxmousewheel';
exports.isDxMouseWheelEvent = isDxMouseWheelEvent;
const isTouchEvent = e => isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === 'touch';
exports.isTouchEvent = isTouchEvent;
const isKeyboardEvent = e => eventSource(e) === 'keyboard';
exports.isKeyboardEvent = isKeyboardEvent;
const isFakeClickEvent = _ref2 => {
  let {
    screenX,
    offsetX,
    pageX
  } = _ref2;
  return screenX === 0 && !offsetX && pageX === 0;
};
exports.isFakeClickEvent = isFakeClickEvent;
const eventData = _ref3 => {
  let {
    pageX,
    pageY,
    timeStamp
  } = _ref3;
  return {
    x: pageX,
    y: pageY,
    time: timeStamp
  };
};
exports.eventData = eventData;
const eventDelta = (from, to) => ({
  x: to.x - from.x,
  y: to.y - from.y,
  time: to.time - from.time || 1
});
exports.eventDelta = eventDelta;
const hasTouches = e => {
  const {
    originalEvent,
    pointers
  } = e;
  if (isNativeTouchEvent(e)) {
    return (originalEvent.touches || []).length;
  }
  if (isDxEvent(e)) {
    return (pointers || []).length;
  }
  return 0;
};
// TODO: for tests
exports.hasTouches = hasTouches;
let skipEvents = false;
const forceSkipEvents = () => {
  skipEvents = true;
};
exports.forceSkipEvents = forceSkipEvents;
const stopEventsSkipping = () => {
  skipEvents = false;
};
// eslint-disable-next-line consistent-return
exports.stopEventsSkipping = stopEventsSkipping;
const needSkipEvent = e => {
  // TODO: for tests
  if (skipEvents) {
    return true;
  }
  // TODO: this checking used in swipeable first move handler. is it correct?
  const {
    target
  } = e;
  const $target = (0, _renderer.default)(target);
  const isContentEditable = (target === null || target === void 0 ? void 0 : target.isContentEditable) || (target === null || target === void 0 ? void 0 : target.hasAttribute('contenteditable'));
  const touchInEditable = $target.is('input, textarea, select') || isContentEditable;
  if (isDxMouseWheelEvent(e)) {
    const isTextArea = $target.is('textarea') && $target.hasClass('dx-texteditor-input');
    if (isTextArea || isContentEditable) {
      return false;
    }
    const isInputFocused = $target.is('input[type=\'number\'], textarea, select') && $target.is(':focus');
    return isInputFocused;
  }
  if (isMouseEvent(e)) {
    return touchInEditable || e.which > 1; // only left mouse button
  }
  if (isTouchEvent(e)) {
    return touchInEditable && (0, _selectors.focused)($target);
  }
};
exports.needSkipEvent = needSkipEvent;
const setEventFixMethod = func => {
  fixMethod = func;
};
exports.setEventFixMethod = setEventFixMethod;
const createEvent = (originalEvent, args) => {
  const event = copyEvent(originalEvent);
  if (args) {
    (0, _extend.extend)(event, args);
  }
  return event;
};
exports.createEvent = createEvent;
const fireEvent = props => {
  const {
    originalEvent,
    delegateTarget
  } = props;
  const event = createEvent(originalEvent, props);
  // @ts-expect-error
  _events_engine.default.trigger(delegateTarget || event.target, event);
  return event;
};
exports.fireEvent = fireEvent;
const normalizeKeyName = _ref4 => {
  let {
    key,
    which
  } = _ref4;
  const normalizedKey = KEY_MAP[key === null || key === void 0 ? void 0 : key.toLowerCase()] || key;
  const normalizedKeyFromWhich = LEGACY_KEY_CODES[which];
  if (normalizedKeyFromWhich && normalizedKey === key) {
    return normalizedKeyFromWhich;
  }
  if (!normalizedKey && which) {
    return String.fromCharCode(which);
  }
  return normalizedKey;
};
exports.normalizeKeyName = normalizeKeyName;
const getChar = _ref5 => {
  let {
    key,
    which
  } = _ref5;
  return key || String.fromCharCode(which);
};
exports.getChar = getChar;
const addNamespace = exports.addNamespace = _m_add_namespace.default;
const isCommandKeyPressed = _ref6 => {
  let {
    ctrlKey,
    metaKey
  } = _ref6;
  return ctrlKey || metaKey;
};
exports.isCommandKeyPressed = isCommandKeyPressed;

/***/ }),

/***/ 97781:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const addNamespace = (eventNames, namespace) => {
  if (!namespace) {
    throw _errors.default.Error('E0017');
  }
  if (Array.isArray(eventNames)) {
    return eventNames.map(eventName => addNamespace(eventName, namespace)).join(' ');
  }
  if (eventNames.indexOf(' ') !== -1) {
    return addNamespace(eventNames.split(/\s+/g), namespace);
  }
  return `${eventNames}.${namespace}`;
};
var _default = exports["default"] = addNamespace;

/***/ }),

/***/ 80406:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.unsubscribeNodesDisposing = exports.subscribeNodesDisposing = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _remove = __webpack_require__(29007);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter(node => !!node);
}
const subscribeNodesDisposing = (event, callback) => {
  // @ts-expect-error
  _events_engine.default.one(nodesByEvent(event), _remove.removeEvent, callback);
};
exports.subscribeNodesDisposing = subscribeNodesDisposing;
const unsubscribeNodesDisposing = (event, callback) => {
  _events_engine.default.off(nodesByEvent(event), _remove.removeEvent, callback);
};
exports.unsubscribeNodesDisposing = unsubscribeNodesDisposing;

/***/ }),

/***/ 8497:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getEventTarget = void 0;
const getEventTarget = event => {
  var _originalEvent$target, _originalEvent$compos;
  const {
    originalEvent
  } = event;
  if (!originalEvent) {
    return event.target;
  }
  const isShadowDOMUsed = Boolean((_originalEvent$target = originalEvent.target) === null || _originalEvent$target === void 0 ? void 0 : _originalEvent$target.shadowRoot);
  if (!isShadowDOMUsed) {
    return originalEvent.target;
  }
  const path = originalEvent.path ?? ((_originalEvent$compos = originalEvent.composedPath) === null || _originalEvent$compos === void 0 ? void 0 : _originalEvent$compos.call(originalEvent));
  const target = (path === null || path === void 0 ? void 0 : path[0]) ?? event.target;
  return target;
};
exports.getEventTarget = getEventTarget;

/***/ }),

/***/ 60082:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _data = __webpack_require__(47617);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _position = __webpack_require__(37518);
var _size = __webpack_require__(58664);
var _string = __webpack_require__(68752);
var _type = __webpack_require__(35922);
var _variable_wrapper = _interopRequireDefault(__webpack_require__(26974));
var _window = __webpack_require__(58201);
var _data_source = __webpack_require__(85273);
var _utils = __webpack_require__(9234);
var _utils2 = __webpack_require__(16454);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _load_panel = _interopRequireDefault(__webpack_require__(97218));
var _filtering = _interopRequireDefault(__webpack_require__(18740));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } // @ts-check
// @ts-expect-error
// @ts-expect-error
const DATAGRID_SELECTION_DISABLED_CLASS = 'dx-selection-disabled';
const DATAGRID_GROUP_OPENED_CLASS = 'dx-datagrid-group-opened';
const DATAGRID_GROUP_CLOSED_CLASS = 'dx-datagrid-group-closed';
const DATAGRID_EXPAND_CLASS = 'dx-datagrid-expand';
const NO_DATA_CLASS = 'nodata';
const SCROLLING_MODE_INFINITE = 'infinite';
const SCROLLING_MODE_VIRTUAL = 'virtual';
const LEGACY_SCROLLING_MODE = 'scrolling.legacyMode';
const SCROLLING_MODE_OPTION = 'scrolling.mode';
const ROW_RENDERING_MODE_OPTION = 'scrolling.rowRenderingMode';
const DATE_INTERVAL_SELECTORS = {
  year(value) {
    return value && value.getFullYear();
  },
  month(value) {
    return value && value.getMonth() + 1;
  },
  day(value) {
    return value && value.getDate();
  },
  quarter(value) {
    return value && Math.floor(value.getMonth() / 3) + 1;
  },
  hour(value) {
    return value && value.getHours();
  },
  minute(value) {
    return value && value.getMinutes();
  },
  second(value) {
    return value && value.getSeconds();
  }
};
const getIntervalSelector = function () {
  const data = arguments[1];
  const value = this.calculateCellValue(data);
  if (!(0, _type.isDefined)(value)) {
    return null;
  }
  if (isDateType(this.dataType)) {
    const nameIntervalSelector = arguments[0];
    return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value);
  }
  if (this.dataType === 'number') {
    const groupInterval = arguments[0];
    return Math.floor(Number(value) / groupInterval) * groupInterval;
  }
};
const equalSelectors = function (selector1, selector2) {
  if ((0, _type.isFunction)(selector1) && (0, _type.isFunction)(selector2)) {
    if (selector1.originalCallback && selector2.originalCallback) {
      return selector1.originalCallback === selector2.originalCallback && selector1.columnIndex === selector2.columnIndex;
    }
  }
  return selector1 === selector2;
};
function isDateType(dataType) {
  return dataType === 'date' || dataType === 'datetime';
}
const setEmptyText = function ($container) {
  $container.get(0).textContent = '\u00A0';
};
const normalizeSortingInfo = function (sort) {
  sort = sort || [];
  const result = (0, _utils2.normalizeSortingInfo)(sort);
  for (let i = 0; i < sort.length; i++) {
    if (sort && sort[i] && sort[i].isExpanded !== undefined) {
      result[i].isExpanded = sort[i].isExpanded;
    }
    if (sort && sort[i] && sort[i].groupInterval !== undefined) {
      result[i].groupInterval = sort[i].groupInterval;
    }
  }
  return result;
};
const formatValue = function (value, options) {
  const valueText = _format_helper.default.format(value, options.format) || value && value.toString() || '';
  const formatObject = {
    value,
    valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
    target: options.target || 'row',
    groupInterval: options.groupInterval
  };
  return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText;
};
const getSummaryText = function (summaryItem, summaryTexts) {
  const displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[`${summaryItem.summaryType}OtherColumn`] || summaryTexts[summaryItem.summaryType];
  return formatValue(summaryItem.value, {
    format: summaryItem.valueFormat,
    getDisplayFormat(valueText) {
      return displayFormat ? (0, _string.format)(displayFormat, valueText, summaryItem.columnCaption) : valueText;
    },
    customizeText: summaryItem.customizeText
  });
};
const getWidgetInstance = function ($element) {
  const editorData = $element.data && $element.data();
  const dxComponents = editorData && editorData.dxComponents;
  const widgetName = dxComponents && dxComponents[0];
  return widgetName && editorData[widgetName];
};
const equalFilterParameters = function (filter1, filter2) {
  if (Array.isArray(filter1) && Array.isArray(filter2)) {
    if (filter1.length !== filter2.length) {
      return false;
    }
    for (let i = 0; i < filter1.length; i++) {
      if (!equalFilterParameters(filter1[i], filter2[i])) {
        return false;
      }
    }
    return true;
  }
  if ((0, _type.isFunction)(filter1) && filter1.columnIndex >= 0 && (0, _type.isFunction)(filter2) && filter2.columnIndex >= 0) {
    return filter1.columnIndex === filter2.columnIndex && (0, _data.toComparable)(filter1.filterValue) === (0, _data.toComparable)(filter2.filterValue) && (0, _data.toComparable)(filter1.selectedFilterOperation) === (0, _data.toComparable)(filter2.selectedFilterOperation);
  }
  return (0, _data.toComparable)(filter1) == (0, _data.toComparable)(filter2); // eslint-disable-line eqeqeq
};
function normalizeGroupingLoadOptions(group) {
  if (!Array.isArray(group)) {
    group = [group];
  }
  return group.map((item, i) => {
    if ((0, _type.isString)(item)) {
      return {
        selector: item,
        isExpanded: i < group.length - 1
      };
    }
    return item;
  });
}
var _default = exports["default"] = {
  renderNoDataText($element) {
    const that = this;
    $element = $element || this.element();
    if (!$element) {
      return;
    }
    const noDataClass = that.addWidgetPrefix(NO_DATA_CLASS);
    let noDataElement = $element.find(`.${noDataClass}`).last();
    const isVisible = this._dataController.isEmpty();
    const isLoading = this._dataController.isLoading();
    if (!noDataElement.length) {
      noDataElement = (0, _renderer.default)('<span>').addClass(noDataClass);
    }
    if (!noDataElement.parent().is($element)) {
      noDataElement.appendTo($element);
    }
    if (isVisible && !isLoading) {
      noDataElement.removeClass('dx-hidden').text(that._getNoDataText());
    } else {
      noDataElement.addClass('dx-hidden');
    }
  },
  renderLoadPanel($element, $container, isLocalStore) {
    const that = this;
    let loadPanelOptions;
    that._loadPanel && that._loadPanel.$element().remove();
    loadPanelOptions = that.option('loadPanel');
    if (loadPanelOptions && (loadPanelOptions.enabled === 'auto' ? !isLocalStore : loadPanelOptions.enabled)) {
      loadPanelOptions = (0, _extend.extend)({
        shading: false,
        message: loadPanelOptions.text,
        container: $container
      }, loadPanelOptions);
      that._loadPanel = that._createComponent((0, _renderer.default)('<div>').appendTo($container), _load_panel.default, loadPanelOptions);
    } else {
      that._loadPanel = null;
    }
  },
  calculateLoadPanelPosition($element) {
    // @ts-expect-error
    const $window = (0, _renderer.default)((0, _window.getWindow)());
    if ((0, _size.getHeight)($element) > (0, _size.getHeight)($window)) {
      return {
        of: $window,
        boundary: $element,
        collision: 'fit'
      };
    }
    return {
      of: $element
    };
  },
  getIndexByKey(key, items, keyName) {
    let index = -1;
    if (key !== undefined && Array.isArray(items)) {
      keyName = arguments.length <= 2 ? 'key' : keyName;
      for (let i = 0; i < items.length; i++) {
        const item = (0, _type.isDefined)(keyName) ? items[i][keyName] : items[i];
        if ((0, _common.equalByValue)(key, item)) {
          index = i;
          break;
        }
      }
    }
    return index;
  },
  combineFilters(filters, operation) {
    let resultFilter = [];
    operation = operation || 'and';
    for (let i = 0; i < filters.length; i++) {
      var _filters$i;
      if (!filters[i]) {
        continue;
      }
      if (((_filters$i = filters[i]) === null || _filters$i === void 0 ? void 0 : _filters$i.length) === 1 && filters[i][0] === '!') {
        if (operation === 'and') {
          return ['!'];
        }
        if (operation === 'or') {
          continue;
        }
      }
      if (resultFilter.length) {
        resultFilter.push(operation);
      }
      resultFilter.push(filters[i]);
    }
    if (resultFilter.length === 1) {
      // eslint-disable-next-line prefer-destructuring
      resultFilter = resultFilter[0];
    }
    if (resultFilter.length) {
      return resultFilter;
    }
    return undefined;
  },
  checkChanges(changes, changeNames) {
    let changesWithChangeNamesCount = 0;
    for (let i = 0; i < changeNames.length; i++) {
      if (changes[changeNames[i]]) {
        changesWithChangeNamesCount++;
      }
    }
    return changes.length && changes.length === changesWithChangeNamesCount;
  },
  equalFilterParameters,
  proxyMethod(instance, methodName, defaultResult) {
    if (!instance[methodName]) {
      instance[methodName] = function () {
        const dataSource = this._dataSource;
        return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;
      };
    }
  },
  formatValue,
  getFormatOptionsByColumn(column, target) {
    return {
      format: column.format,
      getDisplayFormat: column.getDisplayFormat,
      customizeText: column.customizeText,
      target,
      trueText: column.trueText,
      falseText: column.falseText
    };
  },
  getDisplayValue(column, value, data, rowType) {
    if (column.displayValueMap && column.displayValueMap[value] !== undefined) {
      return column.displayValueMap[value];
    }
    if (column.calculateDisplayValue && data && rowType !== 'group') {
      return column.calculateDisplayValue(data);
    }
    if (column.lookup && !(rowType === 'group' && (column.calculateGroupValue || column.calculateDisplayValue))) {
      return column.lookup.calculateCellValue(value);
    }
    return value;
  },
  getGroupRowSummaryText(summaryItems, summaryTexts) {
    let result = '(';
    for (let i = 0; i < summaryItems.length; i++) {
      const summaryItem = summaryItems[i];
      result += (i > 0 ? ', ' : '') + getSummaryText(summaryItem, summaryTexts);
    }
    // eslint-disable-next-line no-return-assign
    return result += ')';
  },
  getSummaryText,
  normalizeSortingInfo,
  getFormatByDataType(dataType) {
    // eslint-disable-next-line default-case
    switch (dataType) {
      case 'date':
        return 'shortDate';
      case 'datetime':
        return 'shortDateShortTime';
      default:
        return undefined;
    }
  },
  getHeaderFilterGroupParameters(column, remoteGrouping) {
    let result = [];
    const dataField = column.dataField || column.name;
    const groupInterval = _filtering.default.getGroupInterval(column);
    if (groupInterval) {
      (0, _iterator.each)(groupInterval, (index, interval) => {
        result.push(remoteGrouping ? {
          selector: dataField,
          groupInterval: interval,
          isExpanded: index < groupInterval.length - 1
        } : getIntervalSelector.bind(column, interval));
      });
      return result;
    }
    if (remoteGrouping) {
      result = [{
        selector: dataField,
        isExpanded: false
      }];
    } else {
      result = function (data) {
        let result = column.calculateCellValue(data);
        if (result === undefined || result === '') {
          result = null;
        }
        return result;
      };
      if (column.sortingMethod) {
        result = [{
          selector: result,
          compare: column.sortingMethod.bind(column)
        }];
      }
    }
    return result;
  },
  equalSortParameters(sortParameters1, sortParameters2, ignoreIsExpanded) {
    sortParameters1 = normalizeSortingInfo(sortParameters1);
    sortParameters2 = normalizeSortingInfo(sortParameters2);
    if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {
      if (sortParameters1.length !== sortParameters2.length) {
        return false;
      }
      for (let i = 0; i < sortParameters1.length; i++) {
        if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
          return false;
        }
      }
      return true;
    }
    return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length);
  },
  getPointsByColumns(items, pointCreated, isVertical, startColumnIndex) {
    const cellsLength = items.length;
    let notCreatePoint = false;
    let item;
    let offset;
    let columnIndex = startColumnIndex || 0;
    const result = [];
    let rtlEnabled;
    for (let i = 0; i <= cellsLength; i++) {
      if (i < cellsLength) {
        item = items.eq(i);
        offset = item.offset();
        rtlEnabled = item.css('direction') === 'rtl';
      }
      const point = {
        index: columnIndex,
        // @ts-expect-error
        x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? (0, _position.getBoundingRect)(item[0]).width : 0) : 0,
        y: offset ? offset.top + (isVertical && i === cellsLength ? (0, _position.getBoundingRect)(item[0]).height : 0) : 0,
        columnIndex
      };
      if (!isVertical && i > 0) {
        const prevItemOffset = items.eq(i - 1).offset();
        if (prevItemOffset.top < point.y) {
          point.y = prevItemOffset.top;
        }
      }
      if (pointCreated) {
        notCreatePoint = pointCreated(point);
      }
      if (!notCreatePoint) {
        result.push(point);
      }
      columnIndex++;
    }
    return result;
  },
  getExpandCellTemplate() {
    return {
      allowRenderToDetachedContainer: true,
      render(container, options) {
        const $container = (0, _renderer.default)(container);
        if ((0, _type.isDefined)(options.value) && !(options.data && options.data.isContinuation) && !options.row.isNewRow) {
          const rowsView = options.component.getView('rowsView');
          $container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
          (0, _renderer.default)('<div>').addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo($container);
          rowsView.setAria('label', options.value ? rowsView.localize('dxDataGrid-ariaCollapse') : rowsView.localize('dxDataGrid-ariaExpand'), $container);
        } else {
          setEmptyText($container);
        }
      }
    };
  },
  setEmptyText,
  isDateType,
  getSelectionRange(focusedElement) {
    try {
      if (focusedElement) {
        return {
          selectionStart: focusedElement.selectionStart,
          selectionEnd: focusedElement.selectionEnd
        };
      }
    } catch (e) {/* empty */}
    return {};
  },
  setSelectionRange(focusedElement, selectionRange) {
    try {
      if (focusedElement && focusedElement.setSelectionRange) {
        focusedElement.setSelectionRange(selectionRange.selectionStart, selectionRange.selectionEnd);
      }
    } catch (e) {/* empty */}
  },
  focusAndSelectElement(component, $element) {
    const isFocused = $element.is(':focus');
    // @ts-expect-error
    _events_engine.default.trigger($element, 'focus');
    const isSelectTextOnEditingStart = component.option('editing.selectTextOnEditStart');
    const element = $element.get(0);
    if (!isFocused && isSelectTextOnEditingStart && $element.is('.dx-texteditor-input') && !$element.is('[readonly]')) {
      const editor = getWidgetInstance($element.closest('.dx-texteditor'));
      (0, _deferred.when)(editor && editor._loadItemDeferred).done(() => {
        element.select();
      });
    }
  },
  getWidgetInstance,
  getLastResizableColumnIndex(columns, resultWidths) {
    const hasResizableColumns = columns.some(column => column && !column.command && !column.fixed && column.allowResizing !== false);
    let lastColumnIndex;
    for (lastColumnIndex = columns.length - 1; columns[lastColumnIndex]; lastColumnIndex--) {
      const column = columns[lastColumnIndex];
      const width = resultWidths && resultWidths[lastColumnIndex];
      const allowResizing = !hasResizableColumns || column.allowResizing !== false;
      if (!column.command && !column.fixed && width !== 'adaptiveHidden' && allowResizing) {
        break;
      }
    }
    return lastColumnIndex;
  },
  isElementInCurrentGrid(controller, $element) {
    if ($element && $element.length) {
      const $grid = $element.closest(`.${controller.getWidgetContainerClass()}`).parent();
      return $grid.is(controller.component.$element());
    }
    return false;
  },
  isVirtualRowRendering(that) {
    const rowRenderingMode = that.option(ROW_RENDERING_MODE_OPTION);
    const isVirtualMode = that.option(SCROLLING_MODE_OPTION) === SCROLLING_MODE_VIRTUAL;
    const isAppendMode = that.option(SCROLLING_MODE_OPTION) === SCROLLING_MODE_INFINITE;
    if (that.option(LEGACY_SCROLLING_MODE) === false && (isVirtualMode || isAppendMode)) {
      return true;
    }
    return rowRenderingMode === SCROLLING_MODE_VIRTUAL;
  },
  getPixelRatio(window) {
    return window.devicePixelRatio || 1;
  },
  getContentHeightLimit(browser) {
    if (browser.mozilla) {
      return 8000000;
    }
    return 15000000 / this.getPixelRatio((0, _window.getWindow)());
  },
  normalizeLookupDataSource(lookup) {
    let lookupDataSourceOptions;
    if (lookup.items) {
      lookupDataSourceOptions = lookup.items;
    } else {
      lookupDataSourceOptions = lookup.dataSource;
      if ((0, _type.isFunction)(lookupDataSourceOptions) && !_variable_wrapper.default.isWrapped(lookupDataSourceOptions)) {
        lookupDataSourceOptions = lookupDataSourceOptions({});
      }
    }
    // @ts-expect-error
    return (0, _utils.normalizeDataSourceOptions)(lookupDataSourceOptions);
  },
  getWrappedLookupDataSource(column, dataSource, filter) {
    if (!dataSource) {
      return [];
    }
    const lookupDataSourceOptions = this.normalizeLookupDataSource(column.lookup);
    if (column.calculateCellValue !== column.defaultCalculateCellValue) {
      return lookupDataSourceOptions;
    }
    const hasGroupPaging = dataSource.remoteOperations().groupPaging;
    const hasLookupOptimization = column.displayField && (0, _type.isString)(column.displayField);
    let cachedUniqueRelevantItems;
    let previousTake;
    let previousSkip;
    const sliceItems = (items, loadOptions) => {
      const start = loadOptions.skip ?? 0;
      const end = loadOptions.take ? start + loadOptions.take : items.length;
      return items.slice(start, end);
    };
    const loadUniqueRelevantItems = loadOptions => {
      const group = normalizeGroupingLoadOptions(hasLookupOptimization ? [column.dataField, column.displayField] : column.dataField);
      // @ts-expect-error
      const d = new _deferred.Deferred();
      const canUseCache = cachedUniqueRelevantItems && (!hasGroupPaging || loadOptions.skip === previousSkip && loadOptions.take === previousTake);
      if (canUseCache) {
        d.resolve(sliceItems(cachedUniqueRelevantItems, loadOptions));
      } else {
        previousSkip = loadOptions.skip;
        previousTake = loadOptions.take;
        dataSource.load({
          filter,
          group,
          take: hasGroupPaging ? loadOptions.take : undefined,
          skip: hasGroupPaging ? loadOptions.skip : undefined
        }).done(items => {
          cachedUniqueRelevantItems = items;
          d.resolve(hasGroupPaging ? items : sliceItems(items, loadOptions));
        }).fail(d.fail);
      }
      return d;
    };
    const lookupDataSource = _extends({}, lookupDataSourceOptions, {
      __dataGridSourceFilter: filter,
      load: loadOptions => {
        // @ts-expect-error
        const d = new _deferred.Deferred();
        loadUniqueRelevantItems(loadOptions).done(items => {
          if (items.length === 0) {
            d.resolve([]);
            return;
          }
          const filter = this.combineFilters(items.flatMap(data => data.key).map(key => [column.lookup.valueExpr, key]), 'or');
          const newDataSource = new _data_source.DataSource(_extends({}, lookupDataSourceOptions, loadOptions, {
            filter: this.combineFilters([filter, loadOptions.filter], 'and'),
            paginate: false // pagination is included to filter
          }));
          newDataSource
          // @ts-expect-error
          .load().done(d.resolve).fail(d.fail);
        }).fail(d.fail);
        return d;
      },
      key: column.lookup.valueExpr,
      byKey(key) {
        const d = (0, _deferred.Deferred)();
        this.load({
          filter: [column.lookup.valueExpr, '=', key]
        }).done(arr => {
          d.resolve(arr[0]);
        });
        return d.promise();
      }
    });
    return lookupDataSource;
  },
  logHeaderFilterDeprecatedWarningIfNeed(component) {
    const since = '23.1';
    const logWarning = component._logDeprecatedOptionWarning.bind(component);
    if ((0, _type.isDefined)(component.option('headerFilter.allowSearch'))) {
      logWarning('headerFilter.allowSearch', {
        since,
        alias: 'headerFilter.search.enabled'
      });
    }
    if ((0, _type.isDefined)(component.option('headerFilter.searchTimeout'))) {
      logWarning('headerFilter.searchTimeout', {
        since,
        alias: 'headerFilter.search.timeout'
      });
    }
    const specificName = component.NAME === 'dxPivotGrid' ? 'dataSource.fields' : 'columns';
    const columns = component.option(specificName);
    if (!Array.isArray(columns)) {
      return;
    }
    const logSpecificDeprecatedWarningIfNeed = columns => {
      columns.forEach(column => {
        var _column$columns;
        const headerFilter = column.headerFilter || {};
        if ((0, _type.isDefined)(headerFilter.allowSearch)) {
          logWarning(`${specificName}[].headerFilter.allowSearch`, {
            since,
            alias: `${specificName}[].headerFilter.search.enabled`
          });
        }
        if ((0, _type.isDefined)(headerFilter.searchMode)) {
          logWarning(`${specificName}[].headerFilter.searchMode`, {
            since,
            alias: `${specificName}[].headerFilter.search.mode`
          });
        }
        if ((_column$columns = column.columns) !== null && _column$columns !== void 0 && _column$columns.length) {
          logSpecificDeprecatedWarningIfNeed(column.columns);
        }
      });
    };
    logSpecificDeprecatedWarningIfNeed(columns);
  }
};

/***/ }),

/***/ 86988:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _position = _interopRequireDefault(__webpack_require__(49387));
var _translator = __webpack_require__(31648);
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _element = __webpack_require__(6415);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _empty_template = __webpack_require__(10688);
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _inflector = __webpack_require__(78008);
var _position2 = __webpack_require__(37518);
var _size = __webpack_require__(58664);
var _string = __webpack_require__(68752);
var _type = __webpack_require__(35922);
var _view_port = __webpack_require__(77695);
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _drag = __webpack_require__(23174);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _index = __webpack_require__(39611);
var _m_animator = _interopRequireDefault(__webpack_require__(13707));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } // @ts-expect-error
// @ts-expect-error
const window = (0, _window.getWindow)();
const KEYDOWN_EVENT = 'keydown';
const DRAGGABLE = 'dxDraggable';
const DRAGSTART_EVENT_NAME = (0, _index.addNamespace)(_drag.start, DRAGGABLE);
const DRAG_EVENT_NAME = (0, _index.addNamespace)(_drag.move, DRAGGABLE);
const DRAGEND_EVENT_NAME = (0, _index.addNamespace)(_drag.end, DRAGGABLE);
const DRAG_ENTER_EVENT_NAME = (0, _index.addNamespace)(_drag.enter, DRAGGABLE);
const DRAGEND_LEAVE_EVENT_NAME = (0, _index.addNamespace)(_drag.leave, DRAGGABLE);
const POINTERDOWN_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.down, DRAGGABLE);
const KEYDOWN_EVENT_NAME = (0, _index.addNamespace)(KEYDOWN_EVENT, DRAGGABLE);
const CLONE_CLASS = 'clone';
let targetDraggable;
let sourceDraggable;
const ANONYMOUS_TEMPLATE_NAME = 'content';
const getMousePosition = event => ({
  // @ts-expect-error
  x: event.pageX - (0, _renderer.default)(window).scrollLeft(),
  // @ts-expect-error
  y: event.pageY - (0, _renderer.default)(window).scrollTop()
});
const GESTURE_COVER_CLASS = 'dx-gesture-cover';
const OVERLAY_WRAPPER_CLASS = 'dx-overlay-wrapper';
const OVERLAY_CONTENT_CLASS = 'dx-overlay-content';
class ScrollHelper {
  constructor(orientation, component) {
    this._$scrollableAtPointer = null;
    this._preventScroll = true;
    this._component = component;
    if (orientation === 'vertical') {
      this._scrollValue = 'scrollTop';
      this._overFlowAttr = 'overflowY';
      this._sizeAttr = 'height';
      this._scrollSizeProp = 'scrollHeight';
      this._clientSizeProp = 'clientHeight';
      this._limitProps = {
        start: 'top',
        end: 'bottom'
      };
    } else {
      this._scrollValue = 'scrollLeft';
      this._overFlowAttr = 'overflowX';
      this._sizeAttr = 'width';
      this._scrollSizeProp = 'scrollWidth';
      this._clientSizeProp = 'clientWidth';
      this._limitProps = {
        start: 'left',
        end: 'right'
      };
    }
  }
  updateScrollable(elements, mousePosition) {
    let isScrollableFound = false;
    elements.some(element => {
      const $element = (0, _renderer.default)(element);
      const isTargetOverOverlayWrapper = $element.hasClass(OVERLAY_WRAPPER_CLASS);
      const isTargetOverOverlayContent = $element.hasClass(OVERLAY_CONTENT_CLASS);
      if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
        return true;
      }
      isScrollableFound = this._trySetScrollable(element, mousePosition);
      return isScrollableFound;
    });
    if (!isScrollableFound) {
      this._$scrollableAtPointer = null;
      this._scrollSpeed = 0;
    }
  }
  isScrolling() {
    return !!this._scrollSpeed;
  }
  isScrollable($element) {
    return ($element.css(this._overFlowAttr) === 'auto' || $element.hasClass('dx-scrollable-container')) && $element.prop(this._scrollSizeProp) > Math.ceil(this._sizeAttr === 'width' ? (0, _size.getWidth)($element) : (0, _size.getHeight)($element));
  }
  _trySetScrollable(element, mousePosition) {
    const that = this;
    const $element = (0, _renderer.default)(element);
    let distanceToBorders;
    const sensitivity = that._component.option('scrollSensitivity');
    let isScrollable = that.isScrollable($element);
    if (isScrollable) {
      distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);
      if (sensitivity > distanceToBorders[that._limitProps.start]) {
        if (!that._preventScroll) {
          that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);
          that._$scrollableAtPointer = $element;
        }
      } else if (sensitivity > distanceToBorders[that._limitProps.end]) {
        if (!that._preventScroll) {
          that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);
          that._$scrollableAtPointer = $element;
        }
      } else {
        isScrollable = false;
        that._preventScroll = false;
      }
    }
    return isScrollable;
  }
  _calculateDistanceToBorders($area, mousePosition) {
    const area = $area.get(0);
    let areaBoundingRect;
    if (area) {
      areaBoundingRect = (0, _position2.getBoundingRect)(area);
      return {
        left: mousePosition.x - areaBoundingRect.left,
        top: mousePosition.y - areaBoundingRect.top,
        right: areaBoundingRect.right - mousePosition.x,
        bottom: areaBoundingRect.bottom - mousePosition.y
      };
    }
    return {};
  }
  _calculateScrollSpeed(distance) {
    const component = this._component;
    const sensitivity = component.option('scrollSensitivity');
    const maxSpeed = component.option('scrollSpeed');
    return Math.ceil(((sensitivity - distance) / sensitivity) ** 2 * maxSpeed);
  }
  scrollByStep() {
    const that = this;
    if (that._$scrollableAtPointer && that._scrollSpeed) {
      if (that._$scrollableAtPointer.hasClass('dx-scrollable-container')) {
        const $scrollable = that._$scrollableAtPointer.closest('.dx-scrollable');
        const scrollableInstance = $scrollable.data('dxScrollable') || $scrollable.data('dxScrollView');
        if (scrollableInstance) {
          const nextScrollPosition = scrollableInstance.scrollOffset()[that._limitProps.start] + that._scrollSpeed;
          scrollableInstance.scrollTo({
            [that._limitProps.start]: nextScrollPosition
          });
        }
      } else {
        const nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;
        that._$scrollableAtPointer[that._scrollValue](nextScrollPosition);
      }
      const dragMoveArgs = that._component._dragMoveArgs;
      if (dragMoveArgs) {
        that._component._dragMoveHandler(dragMoveArgs);
      }
    }
  }
  reset() {
    this._$scrollableAtPointer = null;
    this._scrollSpeed = 0;
    this._preventScroll = true;
  }
  isOutsideScrollable($scrollable, event) {
    if (!$scrollable) {
      return false;
    }
    const scrollableSize = (0, _position2.getBoundingRect)($scrollable.get(0));
    const start = scrollableSize[this._limitProps.start];
    const size = scrollableSize[this._sizeAttr];
    const mousePosition = getMousePosition(event);
    const location = this._sizeAttr === 'width' ? mousePosition.x : mousePosition.y;
    return location < start || location > start + size;
  }
}
const ScrollAnimator = _m_animator.default.inherit({
  ctor(strategy) {
    this.callBase();
    this._strategy = strategy;
  },
  _step() {
    const horizontalScrollHelper = this._strategy._horizontalScrollHelper;
    const verticalScrollHelper = this._strategy._verticalScrollHelper;
    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();
    verticalScrollHelper && verticalScrollHelper.scrollByStep();
  }
});
const Draggable = _dom_component.default.inherit({
  reset: _common.noop,
  dragMove: _common.noop,
  dragEnter: _common.noop,
  dragLeave: _common.noop,
  dragEnd(sourceEvent) {
    const sourceDraggable = this._getSourceDraggable();
    sourceDraggable._fireRemoveEvent(sourceEvent);
    return (0, _deferred.Deferred)().resolve();
  },
  _fireRemoveEvent: _common.noop,
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,
      onDragCancel: null,
      onCancelByEsc: false,
      onDrop: null,
      immediate: true,
      dragDirection: 'both',
      boundary: undefined,
      boundOffset: 0,
      allowMoveByClick: false,
      itemData: null,
      container: undefined,
      dragTemplate: undefined,
      contentTemplate: 'content',
      handle: '',
      filter: '',
      clone: false,
      autoScroll: true,
      scrollSpeed: 30,
      scrollSensitivity: 60,
      group: undefined,
      data: undefined
    });
  },
  _setOptionsByReference() {
    this.callBase.apply(this, arguments);
    (0, _extend.extend)(this._optionsByReference, {
      component: true,
      group: true,
      itemData: true,
      data: true
    });
  },
  _init() {
    this.callBase();
    this._attachEventHandlers();
    this._scrollAnimator = new ScrollAnimator(this);
    this._horizontalScrollHelper = new ScrollHelper('horizontal', this);
    this._verticalScrollHelper = new ScrollHelper('vertical', this);
    this._initScrollTop = 0;
    this._initScrollLeft = 0;
  },
  _normalizeCursorOffset(offset) {
    if ((0, _type.isObject)(offset)) {
      offset = {
        h: offset.x,
        v: offset.y
      };
    }
    offset = (0, _common.splitPair)(offset).map(value => parseFloat(value));
    return {
      left: offset[0],
      top: offset.length === 1 ? offset[0] : offset[1]
    };
  },
  _getNormalizedCursorOffset(offset, options) {
    if ((0, _type.isFunction)(offset)) {
      offset = offset.call(this, options);
    }
    return this._normalizeCursorOffset(offset);
  },
  _calculateElementOffset(options) {
    let elementOffset;
    let dragElementOffset;
    const {
      event
    } = options;
    const $element = (0, _renderer.default)(options.itemElement);
    const $dragElement = (0, _renderer.default)(options.dragElement);
    const isCloned = this._dragElementIsCloned();
    const cursorOffset = this.option('cursorOffset');
    let normalizedCursorOffset = {
      left: 0,
      top: 0
    };
    const currentLocate = this._initialLocate = (0, _translator.locate)($dragElement);
    if (isCloned || options.initialOffset || cursorOffset) {
      elementOffset = options.initialOffset || $element.offset();
      if (cursorOffset) {
        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options);
        if (isFinite(normalizedCursorOffset.left)) {
          elementOffset.left = event.pageX;
        }
        if (isFinite(normalizedCursorOffset.top)) {
          elementOffset.top = event.pageY;
        }
      }
      dragElementOffset = $dragElement.offset();
      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
    }
    return elementOffset;
  },
  _initPosition(options) {
    const $dragElement = (0, _renderer.default)(options.dragElement);
    const elementOffset = this._calculateElementOffset(options);
    if (elementOffset) {
      this._move(elementOffset, $dragElement);
    }
    this._startPosition = (0, _translator.locate)($dragElement);
  },
  _startAnimator() {
    if (!this._scrollAnimator.inProgress()) {
      this._scrollAnimator.start();
    }
  },
  _stopAnimator() {
    this._scrollAnimator.stop();
  },
  _addWidgetPrefix(className) {
    const componentName = this.NAME;
    return (0, _inflector.dasherize)(componentName) + (className ? `-${className}` : '');
  },
  _getItemsSelector() {
    return this.option('filter') || '';
  },
  _$content() {
    const $element = this.$element();
    const $wrapper = $element.children('.dx-template-wrapper');
    return $wrapper.length ? $wrapper : $element;
  },
  _attachEventHandlers() {
    if (this.option('disabled')) {
      return;
    }
    let $element = this._$content();
    let itemsSelector = this._getItemsSelector();
    const allowMoveByClick = this.option('allowMoveByClick');
    const data = {
      direction: this.option('dragDirection'),
      immediate: this.option('immediate'),
      checkDropTarget: ($target, event) => {
        const targetGroup = this.option('group');
        const sourceGroup = this._getSourceDraggable().option('group');
        const $scrollable = this._getScrollable($target);
        if (this._verticalScrollHelper.isOutsideScrollable($scrollable, event) || this._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
          return false;
        }
        return sourceGroup && sourceGroup === targetGroup;
      }
    };
    if (allowMoveByClick) {
      $element = this._getArea();
      _events_engine.default.on($element, POINTERDOWN_EVENT_NAME, data, this._pointerDownHandler.bind(this));
    }
    if (itemsSelector[0] === '>') {
      itemsSelector = itemsSelector.slice(1);
    }
    // @ts-expect-error
    _events_engine.default.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data, this._dragStartHandler.bind(this));
    _events_engine.default.on($element, DRAG_EVENT_NAME, data, this._dragMoveHandler.bind(this));
    _events_engine.default.on($element, DRAGEND_EVENT_NAME, data, this._dragEndHandler.bind(this));
    _events_engine.default.on($element, DRAG_ENTER_EVENT_NAME, data, this._dragEnterHandler.bind(this));
    _events_engine.default.on($element, DRAGEND_LEAVE_EVENT_NAME, data, this._dragLeaveHandler.bind(this));
    if (this.option('onCancelByEsc')) {
      _events_engine.default.on($element, KEYDOWN_EVENT_NAME, this._keydownHandler.bind(this));
    }
  },
  _dragElementIsCloned() {
    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS));
  },
  _getDragTemplateArgs($element, $container) {
    return {
      container: (0, _element.getPublicElement)($container),
      model: {
        itemData: this.option('itemData'),
        itemElement: (0, _element.getPublicElement)($element)
      }
    };
  },
  _createDragElement($element) {
    let result = $element;
    const clone = this.option('clone');
    const $container = this._getContainer();
    let template = this.option('dragTemplate');
    if (template) {
      template = this._getTemplate(template);
      result = (0, _renderer.default)('<div>').appendTo($container);
      template.render(this._getDragTemplateArgs($element, result));
    } else if (clone) {
      result = (0, _renderer.default)('<div>').appendTo($container);
      $element.clone().css({
        width: $element.css('width'),
        height: $element.css('height')
      }).appendTo(result);
    }
    return result.toggleClass(this._addWidgetPrefix(CLONE_CLASS), result.get(0) !== $element.get(0)).toggleClass('dx-rtl', this.option('rtlEnabled'));
  },
  _resetDragElement() {
    if (this._dragElementIsCloned()) {
      this._$dragElement.remove();
    } else {
      this._toggleDraggingClass(false);
    }
    this._$dragElement = null;
  },
  _resetSourceElement() {
    this._toggleDragSourceClass(false);
    this._$sourceElement = null;
  },
  _detachEventHandlers() {
    _events_engine.default.off(this._$content(), `.${DRAGGABLE}`);
    _events_engine.default.off(this._getArea(), `.${DRAGGABLE}`);
  },
  _move(position, $element) {
    (0, _translator.move)($element || this._$dragElement, position);
  },
  _getDraggableElement(e) {
    const $sourceElement = this._getSourceElement();
    if ($sourceElement) {
      return $sourceElement;
    }
    const allowMoveByClick = this.option('allowMoveByClick');
    if (allowMoveByClick) {
      return this.$element();
    }
    let $target = (0, _renderer.default)(e && e.target);
    const itemsSelector = this._getItemsSelector();
    if (itemsSelector[0] === '>') {
      const $items = this._$content().find(itemsSelector);
      if (!$items.is($target)) {
        $target = $target.closest($items);
      }
    }
    return $target;
  },
  _getSourceElement() {
    const draggable = this._getSourceDraggable();
    return draggable._$sourceElement;
  },
  _pointerDownHandler(e) {
    if ((0, _index.needSkipEvent)(e)) {
      return;
    }
    const position = {};
    const $element = this.$element();
    const dragDirection = this.option('dragDirection');
    if (dragDirection === 'horizontal' || dragDirection === 'both') {
      position.left = e.pageX - $element.offset().left + (0, _translator.locate)($element).left - (0, _size.getWidth)($element) / 2;
    }
    if (dragDirection === 'vertical' || dragDirection === 'both') {
      position.top = e.pageY - $element.offset().top + (0, _translator.locate)($element).top - (0, _size.getHeight)($element) / 2;
    }
    this._move(position, $element);
    this._getAction('onDragMove')(this._getEventArgs(e));
  },
  _isValidElement(event, $element) {
    const handle = this.option('handle');
    const $target = (0, _renderer.default)(event.originalEvent && event.originalEvent.target);
    if (handle && !$target.closest(handle).length) {
      return false;
    }
    if (!$element.length) {
      return false;
    }
    return !$element.is('.dx-state-disabled, .dx-state-disabled *');
  },
  _dragStartHandler(e) {
    const $element = this._getDraggableElement(e);
    this.dragInProgress = true;
    if (!this._isValidElement(e, $element)) {
      e.cancel = true;
      return;
    }
    if (this._$sourceElement) {
      return;
    }
    const dragStartArgs = this._getDragStartArgs(e, $element);
    this._getAction('onDragStart')(dragStartArgs);
    if (dragStartArgs.cancel) {
      e.cancel = true;
      return;
    }
    this.option('itemData', dragStartArgs.itemData);
    this._setSourceDraggable();
    this._$sourceElement = $element;
    let initialOffset = $element.offset();
    if (!this._hasClonedDraggable() && this.option('autoScroll')) {
      this._initScrollTop = this._getScrollableScrollTop();
      this._initScrollLeft = this._getScrollableScrollLeft();
      initialOffset = this._getDraggableElementOffset(initialOffset.left, initialOffset.top);
    }
    const $dragElement = this._$dragElement = this._createDragElement($element);
    this._toggleDraggingClass(true);
    this._toggleDragSourceClass(true);
    this._setGestureCoverCursor($dragElement.children());
    const isFixedPosition = $dragElement.css('position') === 'fixed';
    this._initPosition((0, _extend.extend)({}, dragStartArgs, {
      dragElement: $dragElement.get(0),
      initialOffset: isFixedPosition && initialOffset
    }));
    this._getAction('onDraggableElementShown')(_extends({}, dragStartArgs, {
      dragElement: $dragElement
    }));
    const $area = this._getArea();
    const areaOffset = this._getAreaOffset($area);
    const boundOffset = this._getBoundOffset();
    const areaWidth = (0, _size.getOuterWidth)($area);
    const areaHeight = (0, _size.getOuterHeight)($area);
    const elementWidth = (0, _size.getWidth)($dragElement);
    const elementHeight = (0, _size.getHeight)($dragElement);
    const startOffset = {
      left: $dragElement.offset().left - areaOffset.left,
      top: $dragElement.offset().top - areaOffset.top
    };
    if ($area.length) {
      e.maxLeftOffset = startOffset.left - boundOffset.left;
      e.maxRightOffset = areaWidth - startOffset.left - elementWidth - boundOffset.right;
      e.maxTopOffset = startOffset.top - boundOffset.top;
      e.maxBottomOffset = areaHeight - startOffset.top - elementHeight - boundOffset.bottom;
    }
    if (this.option('autoScroll')) {
      this._startAnimator();
    }
  },
  _getAreaOffset($area) {
    const offset = $area && _position.default.offset($area);
    return offset || {
      left: 0,
      top: 0
    };
  },
  _toggleDraggingClass(value) {
    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix('dragging'), value);
  },
  _toggleDragSourceClass(value, $element) {
    const $sourceElement = $element || this._$sourceElement;
    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix('source'), value);
  },
  _setGestureCoverCursor($element) {
    (0, _renderer.default)(`.${GESTURE_COVER_CLASS}`).css('cursor', $element.css('cursor'));
  },
  _getBoundOffset() {
    let boundOffset = this.option('boundOffset');
    if ((0, _type.isFunction)(boundOffset)) {
      boundOffset = boundOffset.call(this);
    }
    return (0, _string.quadToObject)(boundOffset);
  },
  _getArea() {
    let area = this.option('boundary');
    if ((0, _type.isFunction)(area)) {
      area = area.call(this);
    }
    return (0, _renderer.default)(area);
  },
  _getContainer() {
    let container = this.option('container');
    if (container === undefined) {
      container = (0, _view_port.value)();
    }
    return (0, _renderer.default)(container);
  },
  _getDraggableElementOffset(initialOffsetX, initialOffsetY) {
    var _this$_startPosition, _this$_startPosition2;
    const initScrollTop = this._initScrollTop;
    const initScrollLeft = this._initScrollLeft;
    const scrollTop = this._getScrollableScrollTop();
    const scrollLeft = this._getScrollableScrollLeft();
    const elementPosition = (0, _renderer.default)(this.element()).css('position');
    const isFixedPosition = elementPosition === 'fixed';
    const result = {
      left: (((_this$_startPosition = this._startPosition) === null || _this$_startPosition === void 0 ? void 0 : _this$_startPosition.left) ?? 0) + initialOffsetX,
      top: (((_this$_startPosition2 = this._startPosition) === null || _this$_startPosition2 === void 0 ? void 0 : _this$_startPosition2.top) ?? 0) + initialOffsetY
    };
    if (isFixedPosition || this._hasClonedDraggable()) {
      return result;
    }
    return {
      left: (0, _type.isNumeric)(scrollLeft) ? result.left + scrollLeft - initScrollLeft : result.left,
      top: (0, _type.isNumeric)(scrollTop) ? result.top + scrollTop - initScrollTop : result.top
    };
  },
  _hasClonedDraggable() {
    return this.option('clone') || this.option('dragTemplate');
  },
  _dragMoveHandler(e) {
    this._dragMoveArgs = e;
    if (!this._$dragElement) {
      e.cancel = true;
      return;
    }
    const offset = this._getDraggableElementOffset(e.offset.x, e.offset.y);
    this._move(offset);
    this._updateScrollable(e);
    const eventArgs = this._getEventArgs(e);
    this._getAction('onDragMove')(eventArgs);
    if (eventArgs.cancel === true) {
      return;
    }
    const targetDraggable = this._getTargetDraggable();
    targetDraggable.dragMove(e, scrollBy);
  },
  _updateScrollable(e) {
    const that = this;
    if (that.option('autoScroll')) {
      const mousePosition = getMousePosition(e);
      const allObjects = _dom_adapter.default.elementsFromPoint(mousePosition.x, mousePosition.y, this.$element().get(0));
      that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
      that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
    }
  },
  _getScrollable($element) {
    let $scrollable;
    $element.parents().toArray().some(parent => {
      const $parent = (0, _renderer.default)(parent);
      if (this._horizontalScrollHelper.isScrollable($parent) || this._verticalScrollHelper.isScrollable($parent)) {
        $scrollable = $parent;
        return true;
      }
      return false;
    });
    return $scrollable;
  },
  _getScrollableScrollTop() {
    var _this$_getScrollable;
    return ((_this$_getScrollable = this._getScrollable((0, _renderer.default)(this.element()))) === null || _this$_getScrollable === void 0 ? void 0 : _this$_getScrollable.scrollTop()) ?? 0;
  },
  _getScrollableScrollLeft() {
    var _this$_getScrollable2;
    return ((_this$_getScrollable2 = this._getScrollable((0, _renderer.default)(this.element()))) === null || _this$_getScrollable2 === void 0 ? void 0 : _this$_getScrollable2.scrollLeft()) ?? 0;
  },
  _defaultActionArgs() {
    const args = this.callBase.apply(this, arguments);
    const component = this.option('component');
    if (component) {
      args.component = component;
      args.element = component.element();
    }
    return args;
  },
  _getEventArgs(e) {
    const sourceDraggable = this._getSourceDraggable();
    const targetDraggable = this._getTargetDraggable();
    return {
      event: e,
      itemData: sourceDraggable.option('itemData'),
      itemElement: (0, _element.getPublicElement)(sourceDraggable._$sourceElement),
      fromComponent: sourceDraggable.option('component') || sourceDraggable,
      toComponent: targetDraggable.option('component') || targetDraggable,
      fromData: sourceDraggable.option('data'),
      toData: targetDraggable.option('data')
    };
  },
  _getDragStartArgs(e, $itemElement) {
    const args = this._getEventArgs(e);
    return {
      event: args.event,
      itemData: args.itemData,
      itemElement: $itemElement,
      fromData: args.fromData
    };
  },
  _revertItemToInitialPosition() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  },
  _dragEndHandler(e) {
    const d = (0, _deferred.Deferred)();
    const dragEndEventArgs = this._getEventArgs(e);
    const dropEventArgs = this._getEventArgs(e);
    const targetDraggable = this._getTargetDraggable();
    let needRevertPosition = true;
    this.dragInProgress = false;
    try {
      this._getAction('onDragEnd')(dragEndEventArgs);
    } finally {
      (0, _deferred.when)((0, _deferred.fromPromise)(dragEndEventArgs.cancel)).done(cancel => {
        if (!cancel) {
          if (targetDraggable !== this) {
            targetDraggable._getAction('onDrop')(dropEventArgs);
          }
          if (!dropEventArgs.cancel) {
            needRevertPosition = false;
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            (0, _deferred.when)((0, _deferred.fromPromise)(targetDraggable.dragEnd(dragEndEventArgs))).always(d.resolve);
            return;
          }
        }
        d.resolve();
      })
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      .fail(d.resolve);
      d.done(() => {
        if (needRevertPosition) {
          this._revertItemToInitialPosition();
        }
        this._resetDragOptions(targetDraggable);
      });
    }
  },
  _isTargetOverAnotherDraggable(e) {
    const sourceDraggable = this._getSourceDraggable();
    if (this === sourceDraggable) {
      return false;
    }
    const $dragElement = sourceDraggable._$dragElement;
    const $sourceDraggableElement = sourceDraggable.$element();
    const $targetDraggableElement = this.$element();
    const mousePosition = getMousePosition(e);
    const elements = _dom_adapter.default.elementsFromPoint(mousePosition.x, mousePosition.y, this.element());
    const firstWidgetElement = elements.filter(element => {
      const $element = (0, _renderer.default)(element);
      if ($element.hasClass(this._addWidgetPrefix())) {
        return !$element.closest($dragElement).length;
      }
      return false;
    })[0];
    const $sourceElement = this._getSourceElement();
    const isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
    const isTargetOverNestedDraggable = (0, _renderer.default)(firstWidgetElement).closest($sourceElement).length;
    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
  },
  _dragEnterHandler(e) {
    this._fireDragEnterEvent(e);
    if (this._isTargetOverAnotherDraggable(e)) {
      this._setTargetDraggable();
    }
    const sourceDraggable = this._getSourceDraggable();
    sourceDraggable.dragEnter(e);
  },
  _dragLeaveHandler(e) {
    this._fireDragLeaveEvent(e);
    this._resetTargetDraggable();
    if (this !== this._getSourceDraggable()) {
      this.reset();
    }
    const sourceDraggable = this._getSourceDraggable();
    sourceDraggable.dragLeave(e);
  },
  _keydownHandler(e) {
    if (this.dragInProgress && e.key === 'Escape') {
      this._keydownEscapeHandler(e);
    }
  },
  _keydownEscapeHandler(e) {
    var _sourceDraggable;
    const $sourceElement = this._getSourceElement();
    if (!$sourceElement) {
      return;
    }
    const dragCancelEventArgs = this._getEventArgs(e);
    this._getAction('onDragCancel')(dragCancelEventArgs);
    if (dragCancelEventArgs.cancel) {
      return;
    }
    this.dragInProgress = false;
    (_sourceDraggable = sourceDraggable) === null || _sourceDraggable === void 0 || _sourceDraggable._toggleDraggingClass(false);
    this._detachEventHandlers();
    this._revertItemToInitialPosition();
    const targetDraggable = this._getTargetDraggable();
    this._resetDragOptions(targetDraggable);
    this._attachEventHandlers();
  },
  _getAction(name) {
    return this[`_${name}Action`] || this._createActionByOption(name);
  },
  _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initTemplates() {
    if (!this.option('contentTemplate')) return;
    this._templateManager.addDefaultTemplates({
      content: new _empty_template.EmptyTemplate()
    });
    this.callBase.apply(this, arguments);
  },
  _render() {
    this.callBase();
    this.$element().addClass(this._addWidgetPrefix());
    const transclude = this._templateManager.anonymousTemplateName === this.option('contentTemplate');
    const template = this._getTemplateByOption('contentTemplate');
    if (template) {
      (0, _renderer.default)(template.render({
        container: this.element(),
        transclude
      }));
    }
  },
  _optionChanged(args) {
    const {
      name
    } = args;
    switch (name) {
      case 'onDragStart':
      case 'onDragMove':
      case 'onDragEnd':
      case 'onDrop':
      case 'onDragEnter':
      case 'onDragLeave':
      case 'onDragCancel':
      case 'onDraggableElementShown':
        this[`_${name}Action`] = this._createActionByOption(name);
        break;
      case 'dragTemplate':
      case 'contentTemplate':
      case 'container':
      case 'clone':
        break;
      case 'allowMoveByClick':
      case 'dragDirection':
      case 'disabled':
      case 'boundary':
      case 'filter':
      case 'immediate':
        this._resetDragElement();
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case 'onCancelByEsc':
        this._keydownHandler();
        break;
      case 'autoScroll':
        this._verticalScrollHelper.reset();
        this._horizontalScrollHelper.reset();
        break;
      case 'scrollSensitivity':
      case 'scrollSpeed':
      case 'boundOffset':
      case 'handle':
      case 'group':
      case 'data':
      case 'itemData':
        break;
      default:
        this.callBase(args);
    }
  },
  _getTargetDraggable() {
    return targetDraggable || this;
  },
  _getSourceDraggable() {
    return sourceDraggable || this;
  },
  _setTargetDraggable() {
    const currentGroup = this.option('group');
    const sourceDraggable = this._getSourceDraggable();
    if (currentGroup && currentGroup === sourceDraggable.option('group')) {
      targetDraggable = this;
    }
  },
  _setSourceDraggable() {
    sourceDraggable = this;
  },
  _resetSourceDraggable() {
    sourceDraggable = null;
  },
  _resetTargetDraggable() {
    targetDraggable = null;
  },
  _resetDragOptions(targetDraggable) {
    this.reset();
    targetDraggable.reset();
    this._stopAnimator();
    this._horizontalScrollHelper.reset();
    this._verticalScrollHelper.reset();
    this._resetDragElement();
    this._resetSourceElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
  },
  _dispose() {
    this.callBase();
    this._detachEventHandlers();
    this._resetDragElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
    this._$sourceElement = null;
    this._stopAnimator();
  },
  _fireDragEnterEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction('onDragEnter')(args);
  },
  _fireDragLeaveEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction('onDragLeave')(args);
  }
});
(0, _component_registrator.default)(DRAGGABLE, Draggable);
var _default = exports["default"] = Draggable;

/***/ }),

/***/ 90006:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const toMs = _date.default.dateToMilliseconds;
class DateAdapterCore {
  constructor(source) {
    this._source = new Date(source.getTime ? source.getTime() : source);
  }
  get source() {
    return this._source;
  }
  result() {
    return this._source;
  }
  getTimezoneOffset() {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
    const value = this._source.getTimezoneOffset();
    if (format === 'minute') {
      return value * toMs('minute');
    }
    return value;
  }
  getTime() {
    return this._source.getTime();
  }
  setTime(value) {
    this._source.setTime(value);
    return this;
  }
  addTime(value) {
    this._source.setTime(this._source.getTime() + value);
    return this;
  }
  setMinutes(value) {
    this._source.setMinutes(value);
    return this;
  }
  addMinutes(value) {
    this._source.setMinutes(this._source.getMinutes() + value);
    return this;
  }
  subtractMinutes(value) {
    this._source.setMinutes(this._source.getMinutes() - value);
    return this;
  }
}
const DateAdapter = date => new DateAdapterCore(date);
var _default = exports["default"] = DateAdapter;

/***/ }),

/***/ 57880:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _date = __webpack_require__(24321);
var _date2 = _interopRequireDefault(__webpack_require__(91198));
var _m_date_adapter = _interopRequireDefault(__webpack_require__(90006));
var _m_utils_timezones_data = _interopRequireDefault(__webpack_require__(23778));
var _timezone_list = _interopRequireDefault(__webpack_require__(99740));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* globals Intl */

const toMs = _date2.default.dateToMilliseconds;
const MINUTES_IN_HOUR = 60;
const MS_IN_MINUTE = 60000;
const GMT = 'GMT';
const offsetFormatRegexp = /^GMT(?:[+-]\d{2}:\d{2})?$/;
const createUTCDateWithLocalOffset = date => {
  if (!date) {
    return null;
  }
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
};
const createDateFromUTCWithLocalOffset = date => {
  const result = (0, _m_date_adapter.default)(date);
  const timezoneOffsetBeforeInMin = result.getTimezoneOffset();
  result.addTime(result.getTimezoneOffset('minute'));
  result.subtractMinutes(timezoneOffsetBeforeInMin - result.getTimezoneOffset());
  return result.source;
};
const getTimeZones = function () {
  let date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  return _timezone_list.default.value.map(tz => ({
    offset: calculateTimezoneByValue(tz, date),
    title: getTimezoneTitle(tz, date),
    id: tz
  }));
};
const createUTCDate = date => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));
const getTimezoneOffsetChangeInMinutes = (startDate, endDate, updatedStartDate, updatedEndDate) => getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);
const getTimezoneOffsetChangeInMs = (startDate, endDate, updatedStartDate, updatedEndDate) => getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs('minute');
const getDaylightOffset = (startDate, endDate) => new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();
const getDaylightOffsetInMs = (startDate, endDate) => getDaylightOffset(startDate, endDate) * toMs('minute');
const isValidDate = date => date instanceof Date && !isNaN(date.valueOf());
const calculateTimezoneByValueOld = function (timezone) {
  let date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  const customTimezones = _m_utils_timezones_data.default.getTimeZonesOld();
  if (customTimezones.length === 0) {
    return undefined;
  }
  const dateUtc = createUTCDate(date);
  return _m_utils_timezones_data.default.getTimeZoneOffsetById(timezone, dateUtc.getTime());
};
const calculateTimezoneByValueCore = function (timeZone) {
  let date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  const offset = getStringOffset(timeZone, date);
  if (offset === undefined) {
    return undefined;
  }
  if (offset === GMT) {
    return 0;
  }
  const isMinus = offset.substring(3, 4) === '-';
  const hours = offset.substring(4, 6);
  const minutes = offset.substring(7, 9);
  const result = parseInt(hours, 10) + parseInt(minutes, 10) / MINUTES_IN_HOUR;
  return isMinus ? -result : result;
};
const calculateTimezoneByValue = function (timeZone) {
  let date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  if (!timeZone) {
    return undefined;
  }
  const isValidTimezone = _timezone_list.default.value.includes(timeZone);
  if (!isValidTimezone) {
    _errors.default.log('W0009', timeZone);
    return undefined;
  }
  if (!isValidDate(date)) {
    return undefined;
  }
  let result = calculateTimezoneByValueOld(timeZone, date);
  if (result === undefined) {
    result = calculateTimezoneByValueCore(timeZone, date);
  }
  return result;
};
// 'GMTXX:YY' or 'GMT' format
const getStringOffset = function (timeZone) {
  let date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  let result = '';
  try {
    var _dateTimeFormat$forma;
    const dateTimeFormat = new Intl.DateTimeFormat('en-US', {
      timeZone,
      timeZoneName: 'longOffset'
    });
    result = ((_dateTimeFormat$forma = dateTimeFormat.formatToParts(date).find(_ref => {
      let {
        type
      } = _ref;
      return type === 'timeZoneName';
    })) === null || _dateTimeFormat$forma === void 0 ? void 0 : _dateTimeFormat$forma.value) ?? '';
  } catch (e) {
    _errors.default.log('W0009', timeZone);
    return undefined;
  }
  const isSupportedFormat = offsetFormatRegexp.test(result);
  if (!isSupportedFormat) {
    _errors.default.log('W0009', timeZone);
    return undefined;
  }
  return result;
};
const getOffsetNamePart = offset => {
  if (offset === GMT) {
    return `${offset} +00:00`;
  }
  return offset.replace(GMT, `${GMT} `);
};
const getTimezoneTitle = function (timeZone) {
  let date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  if (!isValidDate(date)) {
    return '';
  }
  const tzNamePart = timeZone.replace(/\//g, ' - ').replace(/_/g, ' ');
  const offset = getStringOffset(timeZone, date);
  if (offset === undefined) {
    return undefined;
  }
  const offsetNamePart = getOffsetNamePart(offset);
  return `(${offsetNamePart}) ${tzNamePart}`;
};
// eslint-disable-next-line @typescript-eslint/naming-convention
const _getDaylightOffsetByTimezone = (startDate, endDate, timeZone) => {
  const startDayOffset = calculateTimezoneByValue(timeZone, startDate);
  const endDayOffset = calculateTimezoneByValue(timeZone, endDate);
  if (startDayOffset === undefined || endDayOffset === undefined) {
    return 0;
  }
  return startDayOffset - endDayOffset;
};
const getCorrectedDateByDaylightOffsets = (convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) => {
  const daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);
  const daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);
  const diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;
  return new Date(date.getTime() - diff * toMs('hour'));
};
const correctRecurrenceExceptionByTimezone = function (exception, exceptionByStartDate, timeZone, startDateTimeZone) {
  let isBackConversion = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  let timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / MINUTES_IN_HOUR;
  if (startDateTimeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone);
  } else if (timeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone);
  }
  return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs('hour'));
};
const isTimezoneChangeInDate = date => {
  const startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));
  const endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));
  return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0;
};
const getDateWithoutTimezoneChange = date => {
  const clonedDate = new Date(date);
  if (isTimezoneChangeInDate(clonedDate)) {
    const result = new Date(clonedDate);
    return new Date(result.setDate(result.getDate() + 1));
  }
  return clonedDate;
};
const isSameAppointmentDates = (startDate, endDate) => {
  // NOTE: subtract 1 millisecond to avoid 00.00 time. Method should return 'true' for "2020:10:10 22:00:00" and "2020:10:11 00:00:00", for example.
  endDate = new Date(endDate.getTime() - 1);
  return _date2.default.sameDate(startDate, endDate);
};
const getClientTimezoneOffset = function () {
  let date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  return date.getTimezoneOffset() * MS_IN_MINUTE;
};
const getDiffBetweenClientTimezoneOffsets = function () {
  let firstDate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  let secondDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  return getClientTimezoneOffset(firstDate) - getClientTimezoneOffset(secondDate);
};
const isEqualLocalTimeZone = function (timeZoneName) {
  let date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  if (Intl) {
    const localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
    if (localTimeZoneName === timeZoneName) {
      return true;
    }
  }
  return isEqualLocalTimeZoneByDeclaration(timeZoneName, date);
};
// TODO: Not used anywhere, if it isn't use in the future, then it must be removed
const hasDSTInLocalTimeZone = () => {
  const [startDate, endDate] = getExtremeDates();
  return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset();
};
const getOffset = date => -date.getTimezoneOffset() / MINUTES_IN_HOUR;
const getDateAndMoveHourBack = dateStamp => new Date(dateStamp - toMs('hour'));
const isEqualLocalTimeZoneByDeclarationOld = (timeZoneName, date) => {
  const year = date.getFullYear();
  const configTuple = _m_utils_timezones_data.default.getTimeZoneDeclarationTuple(timeZoneName, year);
  const [summerTime, winterTime] = configTuple;
  const noDSTInTargetTimeZone = configTuple.length < 2;
  if (noDSTInTargetTimeZone) {
    const targetTimeZoneOffset = _m_utils_timezones_data.default.getTimeZoneOffsetById(timeZoneName, date);
    const localTimeZoneOffset = getOffset(date);
    if (targetTimeZoneOffset !== localTimeZoneOffset) {
      return false;
    }
    return !hasDSTInLocalTimeZone();
  }
  const localSummerOffset = getOffset(new Date(summerTime.date));
  const localWinterOffset = getOffset(new Date(winterTime.date));
  if (localSummerOffset !== summerTime.offset) {
    return false;
  }
  if (localSummerOffset === getOffset(getDateAndMoveHourBack(summerTime.date))) {
    return false;
  }
  if (localWinterOffset !== winterTime.offset) {
    return false;
  }
  if (localWinterOffset === getOffset(getDateAndMoveHourBack(winterTime.date))) {
    return false;
  }
  return true;
};
const isEqualLocalTimeZoneByDeclaration = (timeZoneName, date) => {
  const customTimezones = _m_utils_timezones_data.default.getTimeZonesOld();
  const targetTimezoneData = customTimezones.filter(tz => tz.id === timeZoneName);
  if (targetTimezoneData.length === 1) {
    return isEqualLocalTimeZoneByDeclarationOld(timeZoneName, date);
  }
  return false;
};
// TODO: Getting two dates in january or june is the standard mechanism for determining that an offset has occurred.
const getExtremeDates = () => {
  const nowDate = new Date(Date.now());
  const startDate = new Date();
  const endDate = new Date();
  startDate.setFullYear(nowDate.getFullYear(), 0, 1);
  endDate.setFullYear(nowDate.getFullYear(), 6, 1);
  return [startDate, endDate];
};
// TODO Vinogradov refactoring: Change to date utils.
const setOffsetsToDate = (targetDate, offsetsArray) => {
  const newDateMs = offsetsArray.reduce((result, offset) => result + offset, targetDate.getTime());
  return new Date(newDateMs);
};
const addOffsetsWithoutDST = function (date) {
  for (var _len = arguments.length, offsets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    offsets[_key - 1] = arguments[_key];
  }
  const newDate = _date.dateUtilsTs.addOffsets(date, offsets);
  const daylightShift = getDaylightOffsetInMs(date, newDate);
  if (!daylightShift) {
    return newDate;
  }
  const correctLocalDate = _date.dateUtilsTs.addOffsets(newDate, [-daylightShift]);
  const daylightSecondShift = getDaylightOffsetInMs(newDate, correctLocalDate);
  return !daylightSecondShift ? correctLocalDate : newDate;
};
const utils = {
  getDaylightOffset,
  getDaylightOffsetInMs,
  getTimezoneOffsetChangeInMinutes,
  getTimezoneOffsetChangeInMs,
  calculateTimezoneByValue,
  getCorrectedDateByDaylightOffsets,
  isSameAppointmentDates,
  correctRecurrenceExceptionByTimezone,
  getClientTimezoneOffset,
  getDiffBetweenClientTimezoneOffsets,
  createUTCDateWithLocalOffset,
  createDateFromUTCWithLocalOffset,
  createUTCDate,
  isTimezoneChangeInDate,
  getDateWithoutTimezoneChange,
  hasDSTInLocalTimeZone,
  isEqualLocalTimeZone,
  isEqualLocalTimeZoneByDeclaration,
  getTimeZones,
  setOffsetsToDate,
  addOffsetsWithoutDST
};
var _default = exports["default"] = utils;

/***/ }),

/***/ 23778:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _math = __webpack_require__(60810);
var _config = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable radix */

const getConvertedUntils = value => value.split('|').map(until => {
  if (until === 'Infinity') {
    return null;
  }
  return parseInt(until, 36) * 1000;
});
const parseTimezone = timeZoneConfig => {
  const {
    offsets
  } = timeZoneConfig;
  const {
    offsetIndices
  } = timeZoneConfig;
  const {
    untils
  } = timeZoneConfig;
  const offsetList = offsets.split('|').map(value => parseInt(value));
  const offsetIndexList = offsetIndices.split('').map(value => parseInt(value));
  const dateList = getConvertedUntils(untils)
  // eslint-disable-next-line
  .map((accumulator => value => accumulator += value)(0));
  return {
    offsetList,
    offsetIndexList,
    dateList
  };
};
class TimeZoneCache {
  constructor() {
    this.map = new Map();
  }
  tryGet(id) {
    if (!this.map.get(id)) {
      const config = timeZoneDataUtils.getTimezoneById(id);
      if (!config) {
        return false;
      }
      const timeZoneInfo = parseTimezone(config);
      this.map.set(id, timeZoneInfo);
    }
    return this.map.get(id);
  }
}
const tzCache = new TimeZoneCache();
const timeZoneDataUtils = {
  _tzCache: tzCache,
  getTimeZonesOld() {
    return (0, _config.default)().timezones ?? [];
  },
  formatOffset(offset) {
    const hours = Math.floor(offset);
    const minutesInDecimal = offset - hours;
    const signString = (0, _math.sign)(offset) >= 0 ? '+' : '-';
    const hoursString = `0${Math.abs(hours)}`.slice(-2);
    const minutesString = minutesInDecimal > 0 ? `:${minutesInDecimal * 60}` : ':00';
    return signString + hoursString + minutesString;
  },
  formatId(id) {
    return id.split('/').join(' - ').split('_').join(' ');
  },
  getTimezoneById(id) {
    if (!id) {
      return undefined;
    }
    const tzList = this.getTimeZonesOld();
    for (let i = 0; i < tzList.length; i++) {
      const currentId = tzList[i].id;
      if (currentId === id) {
        return tzList[i];
      }
    }
    return undefined;
  },
  getTimeZoneOffsetById(id, timestamp) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : undefined;
  },
  getTimeZoneDeclarationTuple(id, year) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : [];
  },
  getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const tupleResult = [];
    for (let i = 0; i < dateList.length; i++) {
      const currentDate = dateList[i];
      const currentYear = new Date(currentDate).getFullYear();
      if (currentYear === year) {
        const offset = offsetList[offsetIndexList[i + 1]];
        tupleResult.push({
          date: currentDate,
          offset: -offset / 60
        });
      }
      if (currentYear > year) {
        break;
      }
    }
    return tupleResult;
  },
  getUtcOffset(timeZoneInfo, dateTimeStamp) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const infinityUntilCorrection = 1;
    const lastIntervalStartIndex = dateList.length - 1 - infinityUntilCorrection;
    let index = lastIntervalStartIndex;
    while (index >= 0 && dateTimeStamp < dateList[index]) {
      index--;
    }
    const offset = offsetList[offsetIndexList[index + 1]];
    return -offset / 60 || offset;
  }
};
var _default = exports["default"] = timeZoneDataUtils;

/***/ }),

/***/ 99740:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = exports["default"] = {
  value: ['Etc/GMT+12', 'Etc/GMT+11', 'Pacific/Midway', 'Pacific/Niue', 'Pacific/Pago_Pago', 'Pacific/Samoa', 'US/Samoa', 'Etc/GMT+10', 'HST', 'Pacific/Honolulu', 'Pacific/Johnston', 'Pacific/Rarotonga', 'Pacific/Tahiti', 'US/Hawaii', 'Pacific/Marquesas', 'America/Adak', 'America/Atka', 'Etc/GMT+9', 'Pacific/Gambier', 'US/Aleutian', 'America/Anchorage', 'America/Juneau', 'America/Metlakatla', 'America/Nome', 'America/Sitka', 'America/Yakutat', 'Etc/GMT+8', 'Pacific/Pitcairn', 'US/Alaska', 'America/Creston', 'America/Dawson_Creek', 'America/Dawson', 'America/Ensenada', 'America/Fort_Nelson', 'America/Hermosillo', 'America/Los_Angeles', 'America/Phoenix', 'America/Santa_Isabel', 'America/Tijuana', 'America/Vancouver', 'America/Whitehorse', 'Canada/Pacific', 'Canada/Yukon', 'Etc/GMT+7', 'Mexico/BajaNorte', 'MST', 'PST8PDT', 'US/Arizona',
  // Not supported in CI tests
  // 'US/Pacific-New',
  'US/Pacific', 'America/Belize', 'America/Boise', 'America/Cambridge_Bay', 'America/Chihuahua', 'America/Costa_Rica', 'America/Denver', 'America/Edmonton', 'America/El_Salvador', 'America/Guatemala', 'America/Inuvik', 'America/Managua', 'America/Mazatlan', 'America/Monterrey', 'America/Ojinaga', 'America/Regina', 'America/Shiprock', 'America/Swift_Current', 'America/Tegucigalpa', 'America/Yellowknife', 'Canada/Mountain', 'Canada/Saskatchewan', 'Chile/EasterIsland', 'Etc/GMT+6', 'Mexico/BajaSur', 'MST7MDT', 'Navajo', 'Pacific/Easter', 'Pacific/Galapagos', 'US/Mountain', 'America/Atikokan', 'America/Bahia_Banderas', 'America/Bogota', 'America/Cancun', 'America/Cayman', 'America/Chicago', 'America/Coral_Harbour', 'America/Eirunepe', 'America/Guayaquil', 'America/Indiana/Knox', 'America/Indiana/Tell_City', 'America/Jamaica', 'America/Knox_IN', 'America/Lima', 'America/Matamoros', 'America/Menominee', 'America/Merida', 'America/Mexico_City', 'America/North_Dakota/Beulah', 'America/North_Dakota/Center', 'America/North_Dakota/New_Salem', 'America/Panama', 'America/Porto_Acre', 'America/Rainy_River', 'America/Rankin_Inlet', 'America/Resolute', 'America/Rio_Branco', 'America/Winnipeg', 'Brazil/Acre', 'Canada/Central', 'CST6CDT', 'EST', 'Etc/GMT+5', 'Jamaica', 'Mexico/General', 'US/Central', 'US/Indiana-Starke', 'America/Anguilla', 'America/Antigua', 'America/Aruba', 'America/Asuncion', 'America/Barbados', 'America/Blanc-Sablon', 'America/Boa_Vista', 'America/Campo_Grande', 'America/Caracas', 'America/Cuiaba', 'America/Curacao', 'America/Detroit', 'America/Dominica', 'America/Fort_Wayne', 'America/Grand_Turk', 'America/Grenada', 'America/Guadeloupe', 'America/Guyana', 'America/Havana', 'America/Indiana/Indianapolis', 'America/Indiana/Marengo', 'America/Indiana/Petersburg', 'America/Indiana/Vevay', 'America/Indiana/Vincennes', 'America/Indiana/Winamac', 'America/Indianapolis', 'America/Iqaluit', 'America/Kentucky/Louisville', 'America/Kentucky/Monticello', 'America/Kralendijk', 'America/La_Paz', 'America/Louisville', 'America/Lower_Princes', 'America/Manaus', 'America/Marigot', 'America/Martinique', 'America/Montreal', 'America/Montserrat', 'America/Nassau', 'America/New_York', 'America/Nipigon', 'America/Pangnirtung', 'America/Port_of_Spain', 'America/Port-au-Prince', 'America/Porto_Velho', 'America/Puerto_Rico', 'America/Santiago', 'America/Santo_Domingo', 'America/St_Barthelemy', 'America/St_Kitts', 'America/St_Lucia', 'America/St_Thomas', 'America/St_Vincent', 'America/Thunder_Bay', 'America/Toronto', 'America/Tortola', 'America/Virgin', 'Brazil/West', 'Canada/Eastern', 'Chile/Continental', 'Cuba', 'EST5EDT', 'Etc/GMT+4', 'US/East-Indiana', 'US/Eastern', 'US/Michigan', 'America/Araguaina', 'America/Argentina/Buenos_Aires', 'America/Argentina/Catamarca', 'America/Argentina/ComodRivadavia', 'America/Argentina/Cordoba', 'America/Argentina/Jujuy', 'America/Argentina/La_Rioja', 'America/Argentina/Mendoza', 'America/Argentina/Rio_Gallegos', 'America/Argentina/Salta', 'America/Argentina/San_Juan', 'America/Argentina/San_Luis', 'America/Argentina/Tucuman', 'America/Argentina/Ushuaia', 'America/Bahia', 'America/Belem', 'America/Buenos_Aires', 'America/Catamarca', 'America/Cayenne', 'America/Cordoba', 'America/Fortaleza', 'America/Glace_Bay', 'America/Goose_Bay', 'America/Halifax', 'America/Jujuy', 'America/Maceio', 'America/Mendoza', 'America/Moncton', 'America/Montevideo', 'America/Paramaribo', 'America/Punta_Arenas', 'America/Recife', 'America/Rosario', 'America/Santarem', 'America/Sao_Paulo', 'America/Thule', 'Antarctica/Palmer', 'Antarctica/Rothera', 'Atlantic/Bermuda', 'Atlantic/Stanley', 'Brazil/East', 'Canada/Atlantic', 'Etc/GMT+3', 'America/St_Johns', 'Canada/Newfoundland', 'America/Godthab', 'America/Miquelon', 'America/Noronha', 'America/Nuuk', 'Atlantic/South_Georgia', 'Brazil/DeNoronha', 'Etc/GMT+2', 'Atlantic/Cape_Verde', 'Etc/GMT+1', 'Africa/Abidjan', 'Africa/Accra', 'Africa/Bamako', 'Africa/Banjul', 'Africa/Bissau', 'Africa/Conakry', 'Africa/Dakar', 'Africa/Freetown', 'Africa/Lome', 'Africa/Monrovia', 'Africa/Nouakchott', 'Africa/Ouagadougou', 'Africa/Sao_Tome', 'Africa/Timbuktu', 'America/Danmarkshavn', 'America/Scoresbysund', 'Atlantic/Azores', 'Atlantic/Reykjavik', 'Atlantic/St_Helena', 'Etc/GMT-0', 'Etc/GMT', 'Etc/GMT+0', 'Etc/GMT0', 'Etc/Greenwich', 'Etc/UCT', 'Etc/Universal', 'Etc/UTC', 'Etc/Zulu', 'GMT-0', 'GMT', 'GMT+0', 'GMT0', 'Greenwich', 'Iceland', 'UCT', 'Universal', 'UTC', 'Zulu', 'Africa/Algiers', 'Africa/Bangui', 'Africa/Brazzaville', 'Africa/Casablanca', 'Africa/Douala', 'Africa/El_Aaiun', 'Africa/Kinshasa', 'Africa/Lagos', 'Africa/Libreville', 'Africa/Luanda', 'Africa/Malabo', 'Africa/Ndjamena', 'Africa/Niamey', 'Africa/Porto-Novo', 'Africa/Tunis', 'Atlantic/Canary', 'Atlantic/Faeroe', 'Atlantic/Faroe', 'Atlantic/Madeira', 'Eire', 'Etc/GMT-1', 'Europe/Belfast', 'Europe/Dublin', 'Europe/Guernsey', 'Europe/Isle_of_Man', 'Europe/Jersey', 'Europe/Lisbon', 'Europe/London', 'GB-Eire', 'GB', 'Portugal', 'WET', 'Africa/Blantyre', 'Africa/Bujumbura', 'Africa/Cairo', 'Africa/Ceuta', 'Africa/Gaborone', 'Africa/Harare', 'Africa/Johannesburg', 'Africa/Khartoum', 'Africa/Kigali', 'Africa/Lubumbashi', 'Africa/Lusaka', 'Africa/Maputo', 'Africa/Maseru', 'Africa/Mbabane', 'Africa/Tripoli', 'Africa/Windhoek', 'Antarctica/Troll', 'Arctic/Longyearbyen', 'Atlantic/Jan_Mayen', 'CET', 'Egypt', 'Etc/GMT-2', 'Europe/Amsterdam', 'Europe/Andorra', 'Europe/Belgrade', 'Europe/Berlin', 'Europe/Bratislava', 'Europe/Brussels', 'Europe/Budapest', 'Europe/Busingen', 'Europe/Copenhagen', 'Europe/Gibraltar', 'Europe/Kaliningrad', 'Europe/Ljubljana', 'Europe/Luxembourg', 'Europe/Madrid', 'Europe/Malta', 'Europe/Monaco', 'Europe/Oslo', 'Europe/Paris', 'Europe/Podgorica', 'Europe/Prague', 'Europe/Rome', 'Europe/San_Marino', 'Europe/Sarajevo', 'Europe/Skopje', 'Europe/Stockholm', 'Europe/Tirane', 'Europe/Vaduz', 'Europe/Vatican', 'Europe/Vienna', 'Europe/Warsaw', 'Europe/Zagreb', 'Europe/Zurich', 'Libya', 'MET', 'Poland', 'Africa/Addis_Ababa', 'Africa/Asmara', 'Africa/Asmera', 'Africa/Dar_es_Salaam', 'Africa/Djibouti', 'Africa/Juba', 'Africa/Kampala', 'Africa/Mogadishu', 'Africa/Nairobi', 'Antarctica/Syowa', 'Asia/Aden', 'Asia/Amman', 'Asia/Baghdad', 'Asia/Bahrain', 'Asia/Beirut', 'Asia/Damascus', 'Asia/Famagusta', 'Asia/Gaza', 'Asia/Hebron', 'Asia/Istanbul', 'Asia/Jerusalem', 'Asia/Kuwait', 'Asia/Nicosia', 'Asia/Qatar', 'Asia/Riyadh', 'Asia/Tel_Aviv', 'EET', 'Etc/GMT-3', 'Europe/Athens', 'Europe/Bucharest', 'Europe/Chisinau', 'Europe/Helsinki', 'Europe/Istanbul', 'Europe/Kiev', 'Europe/Kirov', 'Europe/Mariehamn', 'Europe/Minsk', 'Europe/Moscow', 'Europe/Nicosia', 'Europe/Riga', 'Europe/Simferopol', 'Europe/Sofia', 'Europe/Tallinn', 'Europe/Tiraspol', 'Europe/Uzhgorod', 'Europe/Vilnius', 'Europe/Zaporozhye', 'Indian/Antananarivo', 'Indian/Comoro', 'Indian/Mayotte', 'Israel', 'Turkey', 'W-SU', 'Asia/Baku', 'Asia/Dubai', 'Asia/Muscat', 'Asia/Tbilisi', 'Asia/Yerevan', 'Etc/GMT-4', 'Europe/Astrakhan', 'Europe/Samara', 'Europe/Saratov', 'Europe/Ulyanovsk', 'Europe/Volgograd', 'Indian/Mahe', 'Indian/Mauritius', 'Indian/Reunion', 'Asia/Kabul', 'Asia/Tehran', 'Iran', 'Antarctica/Mawson', 'Asia/Aqtau', 'Asia/Aqtobe', 'Asia/Ashgabat', 'Asia/Ashkhabad', 'Asia/Atyrau', 'Asia/Dushanbe', 'Asia/Karachi', 'Asia/Oral', 'Asia/Qyzylorda', 'Asia/Samarkand', 'Asia/Tashkent', 'Asia/Yekaterinburg', 'Etc/GMT-5', 'Indian/Kerguelen', 'Indian/Maldives', 'Asia/Calcutta', 'Asia/Colombo', 'Asia/Kolkata', 'Asia/Kathmandu', 'Asia/Katmandu', 'Antarctica/Vostok', 'Asia/Almaty', 'Asia/Bishkek', 'Asia/Dacca', 'Asia/Dhaka', 'Asia/Kashgar', 'Asia/Omsk', 'Asia/Qostanay', 'Asia/Thimbu', 'Asia/Thimphu', 'Asia/Urumqi', 'Etc/GMT-6', 'Indian/Chagos', 'Asia/Rangoon', 'Asia/Yangon', 'Indian/Cocos', 'Antarctica/Davis', 'Asia/Bangkok', 'Asia/Barnaul', 'Asia/Ho_Chi_Minh', 'Asia/Hovd', 'Asia/Jakarta', 'Asia/Krasnoyarsk', 'Asia/Novokuznetsk', 'Asia/Novosibirsk', 'Asia/Phnom_Penh', 'Asia/Pontianak', 'Asia/Saigon', 'Asia/Tomsk', 'Asia/Vientiane', 'Etc/GMT-7', 'Indian/Christmas', 'Antarctica/Casey', 'Asia/Brunei', 'Asia/Choibalsan', 'Asia/Chongqing', 'Asia/Chungking', 'Asia/Harbin', 'Asia/Hong_Kong', 'Asia/Irkutsk', 'Asia/Kuala_Lumpur', 'Asia/Kuching', 'Asia/Macao', 'Asia/Macau', 'Asia/Makassar', 'Asia/Manila', 'Asia/Shanghai', 'Asia/Singapore', 'Asia/Taipei', 'Asia/Ujung_Pandang', 'Asia/Ulaanbaatar', 'Asia/Ulan_Bator', 'Australia/Perth', 'Australia/West', 'Etc/GMT-8', 'Hongkong', 'PRC', 'ROC', 'Singapore', 'Australia/Eucla', 'Asia/Chita', 'Asia/Dili', 'Asia/Jayapura', 'Asia/Khandyga', 'Asia/Pyongyang', 'Asia/Seoul', 'Asia/Tokyo', 'Asia/Yakutsk', 'Etc/GMT-9', 'Japan', 'Pacific/Palau', 'ROK', 'Australia/Adelaide', 'Australia/Broken_Hill', 'Australia/Darwin', 'Australia/North', 'Australia/South', 'Australia/Yancowinna', 'Antarctica/DumontDUrville', 'Asia/Ust-Nera', 'Asia/Vladivostok', 'Australia/ACT', 'Australia/Brisbane', 'Australia/Canberra', 'Australia/Currie', 'Australia/Hobart', 'Australia/Lindeman', 'Australia/Melbourne', 'Australia/NSW', 'Australia/Queensland', 'Australia/Sydney', 'Australia/Tasmania', 'Australia/Victoria', 'Etc/GMT-10', 'Pacific/Chuuk', 'Pacific/Guam', 'Pacific/Port_Moresby', 'Pacific/Saipan', 'Pacific/Truk', 'Pacific/Yap', 'Australia/LHI', 'Australia/Lord_Howe', 'Antarctica/Macquarie', 'Asia/Magadan', 'Asia/Sakhalin', 'Asia/Srednekolymsk', 'Etc/GMT-11', 'Pacific/Bougainville', 'Pacific/Efate', 'Pacific/Guadalcanal', 'Pacific/Kosrae', 'Pacific/Norfolk', 'Pacific/Noumea', 'Pacific/Pohnpei', 'Pacific/Ponape', 'Antarctica/McMurdo', 'Antarctica/South_Pole', 'Asia/Anadyr', 'Asia/Kamchatka', 'Etc/GMT-12', 'Kwajalein', 'NZ', 'Pacific/Auckland', 'Pacific/Fiji', 'Pacific/Funafuti', 'Pacific/Kwajalein', 'Pacific/Majuro', 'Pacific/Nauru', 'Pacific/Tarawa', 'Pacific/Wake', 'Pacific/Wallis', 'NZ-CHAT', 'Pacific/Chatham', 'Etc/GMT-13', 'Pacific/Apia', 'Pacific/Enderbury', 'Pacific/Fakaofo', 'Pacific/Tongatapu', 'Etc/GMT-14', 'Pacific/Kiritimati']
};

/***/ }),

/***/ 30136:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
const DataControllerMock = {
  load: () => (0, _deferred.Deferred)().reject(),
  loadSingle: () => (0, _deferred.Deferred)().reject(),
  loadFromStore: () => (0, _deferred.Deferred)().reject(),
  loadNextPage: () => (0, _deferred.Deferred)().reject(),
  loadOptions: _common.noop,
  userData: _common.noop,
  cancel: _common.noop,
  cancelAll: _common.noop,
  filter: _common.noop,
  addSearchFilter: _common.noop,
  group: _common.noop,
  paginate: _common.noop,
  pageSize: _common.noop,
  pageIndex: _common.noop,
  resetDataSourcePageIndex: _common.noop,
  totalCount: _common.noop,
  isLastPage: _common.noop,
  isLoading: _common.noop,
  isLoaded: _common.noop,
  searchValue: _common.noop,
  searchOperation: _common.noop,
  searchExpr: _common.noop,
  select: _common.noop,
  key: _common.noop,
  keyOf: _common.noop,
  store: _common.noop,
  items: _common.noop,
  applyMapFunction: _common.noop,
  getDataSource: _common.noop,
  reload: _common.noop,
  on: _common.noop,
  off: _common.noop
};
class DataController {
  constructor(dataSource) {
    if (!dataSource) {
      // @ts-expect-error
      // eslint-disable-next-line no-constructor-return
      return DataControllerMock;
    }
    this._dataSource = dataSource;
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (arguments.length < 2) {
      propValue = propName;
      propName = this.key();
    }
    return this._dataSource.loadSingle(propName, propValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value) {
    if (!arguments.length) {
      return this._dataSource.searchValue();
    }
    return this._dataSource.searchValue(value);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    if (!arguments.length) {
      return this._dataSource.searchExpr();
    }
    return this._dataSource.searchExpr(expr);
  }
  select() {
    return this._dataSource.select(...arguments);
  }
  key() {
    return this._dataSource.key();
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    return this._dataSource.items();
  }
  applyMapFunction(data) {
    return this._dataSource._applyMapFunction(data);
  }
  getDataSource() {
    return this._dataSource || null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
}
var _default = exports["default"] = DataController;

/***/ }),

/***/ 50843:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _element_data = __webpack_require__(97906);
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _common = __webpack_require__(20576);
var _dom = __webpack_require__(3532);
var _extend = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
var _validation_engine = _interopRequireDefault(__webpack_require__(90964));
var _validation_message = _interopRequireDefault(__webpack_require__(8336));
var _ui = _interopRequireDefault(__webpack_require__(14390));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INVALID_MESSAGE_AUTO = 'dx-invalid-message-auto';
const READONLY_STATE_CLASS = 'dx-state-readonly';
const INVALID_CLASS = 'dx-invalid';
const DX_INVALID_BADGE_CLASS = 'dx-show-invalid-badge';
const VALIDATION_TARGET = 'dx-validation-target';
const VALIDATION_STATUS_VALID = 'valid';
const VALIDATION_STATUS_INVALID = 'invalid';
const READONLY_NAMESPACE = 'editorReadOnly';
const ALLOWED_STYLING_MODES = ['outlined', 'filled', 'underlined'];
const VALIDATION_MESSAGE_KEYS_MAP = {
  validationMessageMode: 'mode',
  validationMessagePosition: 'positionSide',
  validationMessageOffset: 'offset',
  validationBoundary: 'boundary'
};
// @ts-expect-error
const Editor = _ui.default.inherit({
  ctor() {
    this.showValidationMessageTimeout = null;
    this.validationRequest = (0, _callbacks.default)();
    this.callBase.apply(this, arguments);
  },
  _createElement(element) {
    this.callBase(element);
    const $element = this.$element();
    if ($element) {
      (0, _element_data.data)($element[0], VALIDATION_TARGET, this);
    }
  },
  _initOptions(options) {
    this.callBase.apply(this, arguments);
    // @ts-expect-error
    this.option(_validation_engine.default.initValidationOptions(options));
  },
  _init() {
    this._initialValue = this.option('value');
    this.callBase();
    this._options.cache('validationTooltipOptions', this.option('validationTooltipOptions'));
    const $element = this.$element();
    $element.addClass(DX_INVALID_BADGE_CLASS);
  },
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      value: null,
      name: '',
      onValueChanged: null,
      readOnly: false,
      isValid: true,
      validationError: null,
      validationErrors: null,
      validationStatus: VALIDATION_STATUS_VALID,
      validationMessageMode: 'auto',
      validationMessagePosition: 'bottom',
      validationBoundary: undefined,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {},
      _showValidationMessage: true,
      isDirty: false
    });
  },
  _attachKeyboardEvents() {
    if (!this.option('readOnly')) {
      this.callBase();
    }
  },
  _setOptionsByReference() {
    this.callBase();
    (0, _extend.extend)(this._optionsByReference, {
      validationError: true
    });
  },
  _createValueChangeAction() {
    this._valueChangeAction = this._createActionByOption('onValueChanged', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _suppressValueChangeAction() {
    this._valueChangeActionSuppressed = true;
  },
  _resumeValueChangeAction() {
    this._valueChangeActionSuppressed = false;
  },
  _initMarkup() {
    var _this$option;
    this._toggleReadOnlyState();
    this._setSubmitElementName(this.option('name'));
    this.callBase();
    this._renderValidationState();
    (_this$option = this.option('_onMarkupRendered')) === null || _this$option === void 0 || _this$option();
  },
  _raiseValueChangeAction(value, previousValue) {
    if (!this._valueChangeAction) {
      this._createValueChangeAction();
    }
    this._valueChangeAction(this._valueChangeArgs(value, previousValue));
  },
  _valueChangeArgs(value, previousValue) {
    return {
      value,
      previousValue,
      event: this._valueChangeEventInstance
    };
  },
  _saveValueChangeEvent(e) {
    this._valueChangeEventInstance = e;
  },
  _focusInHandler(e) {
    const isValidationMessageShownOnFocus = this.option('validationMessageMode') === 'auto';
    // NOTE: The click should be processed before the validation message is shown because
    // it can change the editor's value
    if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
      var _this$_validationMess;
      // NOTE: Prevent the validation message from showing
      const $validationMessageWrapper = (_this$_validationMess = this._validationMessage) === null || _this$_validationMess === void 0 ? void 0 : _this$_validationMess.$wrapper();
      $validationMessageWrapper === null || $validationMessageWrapper === void 0 || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO);
      clearTimeout(this.showValidationMessageTimeout);
      // NOTE: Show the validation message after a click changes the value
      this.showValidationMessageTimeout = setTimeout(() => $validationMessageWrapper === null || $validationMessageWrapper === void 0 ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO), 150);
    }
    return this.callBase(e);
  },
  _canValueBeChangedByClick() {
    return false;
  },
  _getStylingModePrefix() {
    return 'dx-editor-';
  },
  _renderStylingMode() {
    const optionName = 'stylingMode';
    const optionValue = this.option(optionName);
    const prefix = this._getStylingModePrefix();
    const allowedStylingClasses = ALLOWED_STYLING_MODES.map(mode => prefix + mode);
    allowedStylingClasses.forEach(className => this.$element().removeClass(className));
    let stylingModeClass = prefix + optionValue;
    if (!allowedStylingClasses.includes(stylingModeClass)) {
      const defaultOptionValue = this._getDefaultOptions()[optionName];
      const platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules())[optionName];
      stylingModeClass = prefix + (platformOptionValue || defaultOptionValue);
    }
    this.$element().addClass(stylingModeClass);
  },
  _getValidationErrors() {
    let validationErrors = this.option('validationErrors');
    if (!validationErrors && this.option('validationError')) {
      validationErrors = [this.option('validationError')];
    }
    return validationErrors;
  },
  _disposeValidationMessage() {
    if (this._$validationMessage) {
      this._$validationMessage.remove();
      this.setAria('describedby', null);
      this._$validationMessage = undefined;
      this._validationMessage = undefined;
    }
  },
  _toggleValidationClasses(isInvalid) {
    this.$element().toggleClass(INVALID_CLASS, isInvalid);
    this.setAria(VALIDATION_STATUS_INVALID, isInvalid || undefined);
  },
  _renderValidationState() {
    const isValid = this.option('isValid') && this.option('validationStatus') !== VALIDATION_STATUS_INVALID;
    const validationErrors = this._getValidationErrors();
    const $element = this.$element();
    this._toggleValidationClasses(!isValid);
    if (!(0, _window.hasWindow)() || this.option('_showValidationMessage') === false) {
      return;
    }
    this._disposeValidationMessage();
    if (!isValid && validationErrors) {
      const {
        validationMessageMode,
        validationMessageOffset,
        validationBoundary,
        rtlEnabled
      } = this.option();
      this._$validationMessage = (0, _renderer.default)('<div>').appendTo($element);
      const validationMessageContentId = `dx-${new _guid.default()}`;
      this.setAria('describedby', validationMessageContentId);
      this._validationMessage = new _validation_message.default(this._$validationMessage, (0, _extend.extend)({
        validationErrors,
        rtlEnabled,
        target: this._getValidationMessageTarget(),
        visualContainer: $element,
        mode: validationMessageMode,
        positionSide: this._getValidationMessagePosition(),
        offset: validationMessageOffset,
        boundary: validationBoundary,
        contentId: validationMessageContentId
      }, this._options.cache('validationTooltipOptions')));
      this._bindInnerWidgetOptions(this._validationMessage, 'validationTooltipOptions');
    }
  },
  _getValidationMessagePosition() {
    return this.option('validationMessagePosition');
  },
  _getValidationMessageTarget() {
    return this.$element();
  },
  _toggleReadOnlyState() {
    const readOnly = this.option('readOnly');
    this._toggleBackspaceHandler(readOnly);
    this.$element().toggleClass(READONLY_STATE_CLASS, !!readOnly);
    this._setAriaReadonly(readOnly);
  },
  _setAriaReadonly(readOnly) {
    this.setAria('readonly', readOnly || undefined);
  },
  _toggleBackspaceHandler(isReadOnly) {
    const $eventTarget = this._keyboardEventBindingTarget();
    const eventName = (0, _index.addNamespace)('keydown', READONLY_NAMESPACE);
    _events_engine.default.off($eventTarget, eventName);
    if (isReadOnly) {
      _events_engine.default.on($eventTarget, eventName, e => {
        if ((0, _index.normalizeKeyName)(e) === 'backspace') {
          e.preventDefault();
        }
      });
    }
  },
  _dispose() {
    const element = this.$element()[0];
    (0, _element_data.data)(element, VALIDATION_TARGET, null);
    clearTimeout(this.showValidationMessageTimeout);
    this._disposeValidationMessage();
    this.callBase();
  },
  _setSubmitElementName(name) {
    const $submitElement = this._getSubmitElement();
    if (!$submitElement) {
      return;
    }
    if (name.length > 0) {
      $submitElement.attr('name', name);
    } else {
      $submitElement.removeAttr('name');
    }
  },
  _getSubmitElement() {
    return null;
  },
  _setValidationMessageOption(_ref) {
    var _this$_validationMess2;
    let {
      name,
      value
    } = _ref;
    const optionKey = VALIDATION_MESSAGE_KEYS_MAP[name] ? VALIDATION_MESSAGE_KEYS_MAP[name] : name;
    (_this$_validationMess2 = this._validationMessage) === null || _this$_validationMess2 === void 0 || _this$_validationMess2.option(optionKey, value);
  },
  _hasActiveElement: _common.noop,
  _optionChanged(args) {
    var _this$_validationMess3;
    switch (args.name) {
      case 'onValueChanged':
        this._createValueChangeAction();
        break;
      case 'readOnly':
        this._toggleReadOnlyState();
        this._refreshFocusState();
        break;
      case 'value':
        if (args.value != args.previousValue) {
          // eslint-disable-line eqeqeq
          this.option('isDirty', this._initialValue !== args.value);
          this.validationRequest.fire({
            value: args.value,
            editor: this
          });
        }
        if (!this._valueChangeActionSuppressed) {
          this._raiseValueChangeAction(args.value, args.previousValue);
          this._saveValueChangeEvent(undefined);
        }
        break;
      case 'width':
        this.callBase(args);
        (_this$_validationMess3 = this._validationMessage) === null || _this$_validationMess3 === void 0 || _this$_validationMess3.updateMaxWidth();
        break;
      case 'name':
        this._setSubmitElementName(args.value);
        break;
      case 'isValid':
      case 'validationError':
      case 'validationErrors':
      case 'validationStatus':
        // @ts-expect-error
        this.option(_validation_engine.default.synchronizeValidationOptions(args, this.option()));
        this._renderValidationState();
        break;
      case 'validationBoundary':
      case 'validationMessageMode':
      case 'validationMessagePosition':
      case 'validationMessageOffset':
        this._setValidationMessageOption(args);
        break;
      case 'rtlEnabled':
        this._setValidationMessageOption(args);
        this.callBase(args);
        break;
      case 'validationTooltipOptions':
        this._innerWidgetOptionChanged(this._validationMessage, args);
        break;
      case '_showValidationMessage':
      case 'isDirty':
        break;
      default:
        this.callBase(args);
    }
  },
  _resetToInitialValue() {
    this.option('value', this._initialValue);
  },
  blur() {
    if (this._hasActiveElement()) {
      (0, _dom.resetActiveElement)();
    }
  },
  clear() {
    const defaultOptions = this._getDefaultOptions();
    this.option('value', defaultOptions.value);
  },
  reset() {
    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
    if (arguments.length) {
      this._initialValue = value;
    }
    this._resetToInitialValue();
    this.option('isDirty', false);
    this.option('isValid', true);
  }
});
Editor.isEditor = instance => instance instanceof Editor;
var _default = exports["default"] = Editor;

/***/ }),

/***/ 94742:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _extend = __webpack_require__(13306);
var _size = __webpack_require__(58664);
var _support = __webpack_require__(60137);
var _window = __webpack_require__(58201);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _themes = __webpack_require__(75811);
var _ui = _interopRequireDefault(__webpack_require__(14390));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// @ts-expect-error

const navigator = (0, _window.getNavigator)();
const LOADINDICATOR_CLASS = 'dx-loadindicator';
const LOADINDICATOR_WRAPPER_CLASS = 'dx-loadindicator-wrapper';
const LOADINDICATOR_CONTENT_CLASS = 'dx-loadindicator-content';
const LOADINDICATOR_ICON_CLASS = 'dx-loadindicator-icon';
const LOADINDICATOR_SEGMENT_CLASS = 'dx-loadindicator-segment';
const LOADINDICATOR_SEGMENT_INNER_CLASS = 'dx-loadindicator-segment-inner';
const LOADINDICATOR_IMAGE_CLASS = 'dx-loadindicator-image';
// @ts-expect-error
const LoadIndicator = _ui.default.inherit({
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      indicatorSrc: '',
      activeStateEnabled: false,
      hoverStateEnabled: false,
      _animatingSegmentCount: 1,
      _animatingSegmentInner: false
    });
  },
  _defaultOptionsRules() {
    const themeName = (0, _themes.current)();
    return this.callBase().concat([{
      device() {
        const realDevice = _devices.default.real();
        const obsoleteAndroid = realDevice.platform === 'android' && !/chrome/i.test(navigator.userAgent);
        return obsoleteAndroid;
      },
      options: {
        viaImage: true
      }
    }, {
      device() {
        return (0, _themes.isMaterialBased)(themeName);
      },
      options: {
        _animatingSegmentCount: 2,
        _animatingSegmentInner: true
      }
    }, {
      device() {
        return (0, _themes.isGeneric)(themeName);
      },
      options: {
        _animatingSegmentCount: 7
      }
    }]);
  },
  _useTemplates() {
    return false;
  },
  _init() {
    this.callBase();
    this.$element().addClass(LOADINDICATOR_CLASS);
    const label = _message.default.format('Loading');
    const aria = {
      role: 'alert',
      label
    };
    this.setAria(aria);
  },
  _initMarkup() {
    this.callBase();
    this._renderWrapper();
    this._renderIndicatorContent();
    this._renderMarkup();
  },
  _renderWrapper() {
    this._$wrapper = (0, _renderer.default)('<div>').addClass(LOADINDICATOR_WRAPPER_CLASS);
    this.$element().append(this._$wrapper);
  },
  _renderIndicatorContent() {
    this._$content = (0, _renderer.default)('<div>').addClass(LOADINDICATOR_CONTENT_CLASS);
    this._$wrapper.append(this._$content);
  },
  _renderMarkup() {
    const {
      viaImage,
      indicatorSrc
    } = this.option();
    if ((0, _support.animation)() && !viaImage && !indicatorSrc) {
      // B236922
      this._renderMarkupForAnimation();
    } else {
      this._renderMarkupForImage();
    }
  },
  _renderMarkupForAnimation() {
    const animatingSegmentInner = this.option('_animatingSegmentInner');
    this._$indicator = (0, _renderer.default)('<div>').addClass(LOADINDICATOR_ICON_CLASS);
    this._$content.append(this._$indicator);
    // Indicator markup
    for (let i = this.option('_animatingSegmentCount'); i >= 0; --i) {
      const $segment = (0, _renderer.default)('<div>').addClass(LOADINDICATOR_SEGMENT_CLASS).addClass(LOADINDICATOR_SEGMENT_CLASS + i);
      if (animatingSegmentInner) {
        $segment.append((0, _renderer.default)('<div>').addClass(LOADINDICATOR_SEGMENT_INNER_CLASS));
      }
      this._$indicator.append($segment);
    }
  },
  _renderMarkupForImage() {
    const {
      indicatorSrc
    } = this.option();
    if (indicatorSrc) {
      this._$wrapper.addClass(LOADINDICATOR_IMAGE_CLASS);
      this._$wrapper.css('backgroundImage', `url(${indicatorSrc})`);
    } else if ((0, _support.animation)()) {
      this._renderMarkupForAnimation();
    }
  },
  _renderDimensions() {
    this.callBase();
    this._updateContentSizeForAnimation();
  },
  _updateContentSizeForAnimation() {
    if (!this._$indicator) {
      return;
    }
    let width = this.option('width');
    let height = this.option('height');
    if (width || height) {
      width = (0, _size.getWidth)(this.$element());
      height = (0, _size.getHeight)(this.$element());
      const minDimension = Math.min(height, width);
      this._$wrapper.css({
        height: minDimension,
        width: minDimension,
        fontSize: minDimension
      });
    }
  },
  _clean() {
    this.callBase();
    this._removeMarkupForAnimation();
    this._removeMarkupForImage();
  },
  _removeMarkupForAnimation() {
    if (!this._$indicator) {
      return;
    }
    this._$indicator.remove();
    delete this._$indicator;
  },
  _removeMarkupForImage() {
    this._$wrapper.css('backgroundImage', 'none');
  },
  _optionChanged(args) {
    switch (args.name) {
      case '_animatingSegmentCount':
      case '_animatingSegmentInner':
      case 'indicatorSrc':
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }
});
(0, _component_registrator.default)('dxLoadIndicator', LoadIndicator);
var _default = exports["default"] = LoadIndicator;

/***/ }),

/***/ 70395:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _ui = _interopRequireDefault(__webpack_require__(89799));
var _themes = __webpack_require__(75811);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LOADPANEL_CLASS = 'dx-loadpanel';
const LOADPANEL_WRAPPER_CLASS = 'dx-loadpanel-wrapper';
const LOADPANEL_INDICATOR_CLASS = 'dx-loadpanel-indicator';
const LOADPANEL_MESSAGE_CLASS = 'dx-loadpanel-message';
const LOADPANEL_CONTENT_CLASS = 'dx-loadpanel-content';
const LOADPANEL_CONTENT_WRAPPER_CLASS = 'dx-loadpanel-content-wrapper';
const LOADPANEL_PANE_HIDDEN_CLASS = 'dx-loadpanel-pane-hidden';
// @ts-expect-error
const LoadPanel = _ui.default.inherit({
  _supportedKeys() {
    return (0, _extend.extend)(this.callBase(), {
      escape: _common.noop
    });
  },
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      message: _message.default.format('Loading'),
      width: 222,
      height: 90,
      animation: null,
      showIndicator: true,
      indicatorSrc: '',
      showPane: true,
      delay: 0,
      templatesRenderAsynchronously: false,
      hideTopOverlayHandler: null,
      focusStateEnabled: false,
      propagateOutsideClick: true,
      preventScrollEvents: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: 'generic'
      },
      options: {
        shadingColor: 'transparent'
      }
    }, {
      device() {
        // @ts-expect-error
        return (0, _themes.isMaterial)();
      },
      options: {
        message: '',
        width: 60,
        height: 60,
        maxHeight: 60,
        maxWidth: 60
      }
    }, {
      device() {
        // @ts-expect-error
        return (0, _themes.isFluent)();
      },
      options: {
        width: 'auto',
        height: 'auto'
      }
    }]);
  },
  _init() {
    this.callBase.apply(this, arguments);
  },
  _render() {
    this.callBase();
    this.$element().addClass(LOADPANEL_CLASS);
    this.$wrapper().addClass(LOADPANEL_WRAPPER_CLASS);
    this._updateWrapperAria();
  },
  _updateWrapperAria() {
    this.$wrapper().removeAttr('aria-label').removeAttr('role');
    const showIndicator = this.option('showIndicator');
    if (!showIndicator) {
      const aria = this._getAriaAttributes();
      this.$wrapper().attr(aria);
    }
  },
  _getAriaAttributes() {
    const {
      message
    } = this.option();
    const label = message || _message.default.format('Loading');
    const aria = {
      role: 'alert',
      'aria-label': label
    };
    return aria;
  },
  _renderContentImpl() {
    this.callBase();
    this.$content().addClass(LOADPANEL_CONTENT_CLASS);
    this._$loadPanelContentWrapper = (0, _renderer.default)('<div>').addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
    this._$loadPanelContentWrapper.appendTo(this.$content());
    this._togglePaneVisible();
    this._cleanPreviousContent();
    this._renderLoadIndicator();
    this._renderMessage();
  },
  _show() {
    const delay = this.option('delay');
    if (!delay) {
      return this.callBase();
    }
    const deferred = (0, _deferred.Deferred)();
    const callBase = this.callBase.bind(this);
    this._clearShowTimeout();
    this._showTimeout = setTimeout(() => {
      callBase().done(() => {
        deferred.resolve();
      });
    }, delay);
    return deferred.promise();
  },
  _hide() {
    this._clearShowTimeout();
    return this.callBase();
  },
  _clearShowTimeout() {
    clearTimeout(this._showTimeout);
  },
  _renderMessage() {
    if (!this._$loadPanelContentWrapper) {
      return;
    }
    const message = this.option('message');
    if (!message) return;
    const $message = (0, _renderer.default)('<div>').addClass(LOADPANEL_MESSAGE_CLASS).text(message);
    this._$loadPanelContentWrapper.append($message);
  },
  _renderLoadIndicator() {
    if (!this._$loadPanelContentWrapper || !this.option('showIndicator')) {
      return;
    }
    if (!this._$indicator) {
      this._$indicator = (0, _renderer.default)('<div>').addClass(LOADPANEL_INDICATOR_CLASS).appendTo(this._$loadPanelContentWrapper);
    }
    this._createComponent(this._$indicator, _load_indicator.default, {
      elementAttr: this._getAriaAttributes(),
      indicatorSrc: this.option('indicatorSrc')
    });
  },
  _cleanPreviousContent() {
    this.$content().find(`.${LOADPANEL_MESSAGE_CLASS}`).remove();
    this.$content().find(`.${LOADPANEL_INDICATOR_CLASS}`).remove();
    delete this._$indicator;
  },
  _togglePaneVisible() {
    this.$content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option('showPane'));
  },
  _optionChanged(args) {
    switch (args.name) {
      case 'delay':
        break;
      case 'message':
      case 'showIndicator':
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage();
        this._updateWrapperAria();
        break;
      case 'showPane':
        this._togglePaneVisible();
        break;
      case 'indicatorSrc':
        this._renderLoadIndicator();
        break;
      default:
        this.callBase(args);
    }
  },
  _dispose() {
    this._clearShowTimeout();
    this.callBase();
  }
});
(0, _component_registrator.default)('dxLoadPanel', LoadPanel);
var _default = exports["default"] = LoadPanel;

/***/ }),

/***/ 23661:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _events_strategy = __webpack_require__(80566);
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _number = _interopRequireDefault(__webpack_require__(18016));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable max-classes-per-file */

// @ts-expect-error

const EMAIL_VALIDATION_REGEX = /^[\d\w.+_-]+@[\d\w._-]+\.[\w]+$/i;
const STATUS = {
  valid: 'valid',
  invalid: 'invalid',
  pending: 'pending'
};
class BaseRuleValidator {
  constructor() {
    this.NAME = 'base';
  }
  defaultMessage(value) {
    // @ts-expect-error
    return _message.default.getFormatter(`validation-${this.NAME}`)(value);
  }
  defaultFormattedMessage(value) {
    // @ts-expect-error
    return _message.default.getFormatter(`validation-${this.NAME}-formatted`)(value);
  }
  _isValueEmpty(value) {
    return !rulesValidators.required.validate(value, {});
  }
  validate(value, rule) {
    const valueArray = Array.isArray(value) ? value : [value];
    let result = true;
    if (valueArray.length) {
      valueArray.every(itemValue => {
        // @ts-expect-error
        result = this._validate(itemValue, rule);
        return result;
      });
    } else {
      // @ts-expect-error
      result = this._validate(null, rule);
    }
    return result;
  }
}
class RequiredRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = 'required';
  }
  _validate(value, rule) {
    if (!(0, _type.isDefined)(value)) return false;
    if (value === false) {
      return false;
    }
    value = String(value);
    if (rule.trim || !(0, _type.isDefined)(rule.trim)) {
      value = value.trim();
    }
    return value !== '';
  }
}
class NumericRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = 'numeric';
  }
  _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }
    if (rule.useCultureSettings && (0, _type.isString)(value)) {
      return !isNaN(_number.default.parse(value));
    }
    return (0, _type.isNumeric)(value);
  }
}
class RangeRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = 'range';
  }
  _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }
    const validNumber = rulesValidators.numeric.validate(value, rule);
    const validValue = (0, _type.isDefined)(value) && value !== '';
    const number = validNumber ? parseFloat(value) : validValue && value.valueOf();
    const {
      min
    } = rule;
    const {
      max
    } = rule;
    if (!(validNumber || (0, _type.isDate)(value)) && !validValue) {
      return false;
    }
    if ((0, _type.isDefined)(min)) {
      if ((0, _type.isDefined)(max)) {
        return number >= min && number <= max;
      }
      return number >= min;
    }
    if ((0, _type.isDefined)(max)) {
      return number <= max;
    }
    throw _errors.default.Error('E0101');
  }
}
class StringLengthRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = 'stringLength';
  }
  _validate(value, rule) {
    value = String(value ?? '');
    if (rule.trim || !(0, _type.isDefined)(rule.trim)) {
      value = value.trim();
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }
    return rulesValidators.range.validate(value.length, (0, _extend.extend)({}, rule));
  }
}
class CustomRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = 'custom';
  }
  validate(value, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && (0, _type.isFunction)(validator.option) && validator.option('dataGetter');
    const extraParams = (0, _type.isFunction)(dataGetter) && dataGetter();
    const params = {
      value,
      validator,
      rule
    };
    if (extraParams) {
      (0, _extend.extend)(params, extraParams);
    }
    return rule.validationCallback(params);
  }
}
class AsyncRuleValidator extends CustomRuleValidator {
  constructor() {
    super();
    this.NAME = 'async';
  }
  validate(value, rule) {
    if (!(0, _type.isDefined)(rule.reevaluate)) {
      (0, _extend.extend)(rule, {
        reevaluate: true
      });
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && (0, _type.isFunction)(validator.option) && validator.option('dataGetter');
    const extraParams = (0, _type.isFunction)(dataGetter) && dataGetter();
    const params = {
      value,
      validator,
      rule
    };
    if (extraParams) {
      (0, _extend.extend)(params, extraParams);
    }
    const callbackResult = rule.validationCallback(params);
    if (!(0, _type.isPromise)(callbackResult)) {
      throw _errors.default.Error('E0103');
    }
    return this._getWrappedPromise((0, _deferred.fromPromise)(callbackResult).promise());
  }
  _getWrappedPromise(promise) {
    const deferred = (0, _deferred.Deferred)();
    promise.then(res => {
      deferred.resolve(res);
    }, err => {
      const res = {
        isValid: false
      };
      if ((0, _type.isDefined)(err)) {
        if ((0, _type.isString)(err)) {
          // @ts-expect-error
          res.message = err;
          // @ts-expect-error
        } else if ((0, _type.isObject)(err) && (0, _type.isDefined)(err.message) && (0, _type.isString)(err.message)) {
          // @ts-expect-error
          res.message = err.message;
        }
      }
      deferred.resolve(res);
    });
    return deferred.promise();
  }
}
class CompareRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = 'compare';
  }
  // @ts-expect-error
  // eslint-disable-next-line consistent-return
  _validate(value, rule) {
    if (!rule.comparisonTarget) {
      throw _errors.default.Error('E0102');
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }
    (0, _extend.extend)(rule, {
      reevaluate: true
    });
    const otherValue = rule.comparisonTarget();
    const type = rule.comparisonType || '==';
    // eslint-disable-next-line default-case
    switch (type) {
      case '==':
        return value == otherValue;
      // eslint-disable-line eqeqeq
      case '!=':
        return value != otherValue;
      // eslint-disable-line eqeqeq
      case '===':
        return value === otherValue;
      case '!==':
        return value !== otherValue;
      case '>':
        return value > otherValue;
      case '>=':
        return value >= otherValue;
      case '<':
        return value < otherValue;
      case '<=':
        return value <= otherValue;
    }
  }
}
class PatternRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = 'pattern';
  }
  _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }
    let {
      pattern
    } = rule;
    if ((0, _type.isString)(pattern)) {
      pattern = new RegExp(pattern);
    }
    return pattern.test(value);
  }
}
class EmailRuleValidator extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = 'email';
  }
  _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }
    return rulesValidators.pattern.validate(value, (0, _extend.extend)({}, rule, {
      pattern: EMAIL_VALIDATION_REGEX
    }));
  }
}
const rulesValidators = {
  required: new RequiredRuleValidator(),
  numeric: new NumericRuleValidator(),
  range: new RangeRuleValidator(),
  stringLength: new StringLengthRuleValidator(),
  custom: new CustomRuleValidator(),
  async: new AsyncRuleValidator(),
  compare: new CompareRuleValidator(),
  pattern: new PatternRuleValidator(),
  email: new EmailRuleValidator()
};
const GroupConfig = _class.default.inherit({
  ctor(group, isRemovable) {
    this.group = group;
    this.validators = [];
    this._isRemovable = isRemovable;
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
    this._resetValidationInfo();
    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
  },
  validate() {
    const result = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };
    this._unsubscribeFromAllChangeEvents();
    this._pendingValidators = [];
    this._resetValidationInfo();
    (0, _iterator.each)(this.validators, (_, validator) => {
      const validatorResult = validator.validate();
      result.isValid = result.isValid && validatorResult.isValid;
      if (validatorResult.brokenRules) {
        result.brokenRules = result.brokenRules.concat(validatorResult.brokenRules);
      }
      // @ts-expect-error
      result.validators.push(validator);
      if (validatorResult.status === STATUS.pending) {
        this._addPendingValidator(validator);
      }
      this._subscribeToChangeEvents(validator);
    });
    if (this._pendingValidators.length) {
      result.status = STATUS.pending;
    } else {
      result.status = result.isValid ? STATUS.valid : STATUS.invalid;
      this._unsubscribeFromAllChangeEvents();
      this._raiseValidatedEvent(result);
    }
    this._updateValidationInfo(result);
    return (0, _extend.extend)({}, this._validationInfo.result);
  },
  _subscribeToChangeEvents(validator) {
    validator.on('validating', this._onValidatorStatusChanged);
    validator.on('validated', this._onValidatorStatusChanged);
  },
  _unsubscribeFromChangeEvents(validator) {
    validator.off('validating', this._onValidatorStatusChanged);
    validator.off('validated', this._onValidatorStatusChanged);
  },
  _unsubscribeFromAllChangeEvents() {
    (0, _iterator.each)(this.validators, (_, validator) => {
      this._unsubscribeFromChangeEvents(validator);
    });
  },
  _updateValidationInfo(result) {
    this._validationInfo.result = result;
    if (result.status !== STATUS.pending) {
      return;
    }
    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = (0, _deferred.Deferred)();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  },
  _addPendingValidator(validator) {
    const foundValidator = (0, _common.grep)(this._pendingValidators, val => val === validator)[0];
    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  },
  _removePendingValidator(validator) {
    const index = this._pendingValidators.indexOf(validator);
    if (index >= 0) {
      this._pendingValidators.splice(index, 1);
    }
  },
  _orderBrokenRules(brokenRules) {
    let orderedRules = [];
    (0, _iterator.each)(this.validators, (_, validator) => {
      const foundRules = (0, _common.grep)(brokenRules, rule => rule.validator === validator);
      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    });
    return orderedRules;
  },
  _updateBrokenRules(result) {
    if (!this._validationInfo.result) {
      return;
    }
    let {
      brokenRules
    } = this._validationInfo.result;
    const rules = (0, _common.grep)(brokenRules, rule => rule.validator !== result.validator);
    if (result.brokenRules) {
      brokenRules = rules.concat(result.brokenRules);
    }
    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  },
  _onValidatorStatusChanged(result) {
    if (result.status === STATUS.pending) {
      this._addPendingValidator(result.validator);
      return;
    }
    this._resolveIfComplete(result);
  },
  _resolveIfComplete(result) {
    this._removePendingValidator(result.validator);
    this._updateBrokenRules(result);
    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();
      if (!this._validationInfo.result) {
        return;
      }
      this._validationInfo.result.status = this._validationInfo.result.brokenRules.length === 0 ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      const res = (0, _extend.extend)({}, this._validationInfo.result, {
        complete: null
      });
      const {
        deferred
      } = this._validationInfo;
      this._validationInfo.deferred = null;
      this._raiseValidatedEvent(res);
      deferred && setTimeout(() => {
        deferred.resolve(res);
      });
    }
  },
  _raiseValidatedEvent(result) {
    this._eventsStrategy.fireEvent('validated', [result]);
  },
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  },
  _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  },
  removeRegisteredValidator(validator) {
    const index = this.validators.indexOf(validator);
    if (index > -1) {
      this.validators.splice(index, 1);
      this._synchronizeValidationInfo();
      this._resolveIfComplete({
        validator
      });
    }
  },
  registerValidator(validator) {
    if (!this.validators.includes(validator)) {
      this.validators.push(validator);
      this._synchronizeValidationInfo();
    }
  },
  reset() {
    (0, _iterator.each)(this.validators, (_, validator) => {
      validator.reset();
    });
    this._pendingValidators = [];
    this._resetValidationInfo();
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
const ValidationEngine = {
  groups: [],
  getGroupConfig(group) {
    const result = (0, _common.grep)(this.groups, config => config.group === group);
    if (result.length) {
      return result[0];
    }
  },
  findGroup($element, model) {
    var _$element$data;
    const hasValidationGroup = (_$element$data = $element.data()) === null || _$element$data === void 0 || (_$element$data = _$element$data.dxComponents) === null || _$element$data === void 0 ? void 0 : _$element$data.includes('dxValidationGroup');
    const validationGroup = hasValidationGroup && $element.dxValidationGroup('instance');
    if (validationGroup) {
      return validationGroup;
    }
    // try to find out if this control is child of validation group
    const $dxGroup = $element.parents('.dx-validationgroup').first();
    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup('instance');
    }
    // Trick to be able to securely get ViewModel instance ($data) in Knockout
    return model;
  },
  initGroups() {
    this.groups = [];
    this.addGroup(undefined, false);
  },
  addGroup(group) {
    let isRemovable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    let config = this.getGroupConfig(group);
    if (!config) {
      config = new GroupConfig(group, isRemovable);
      this.groups.push(config);
    }
    return config;
  },
  removeGroup(group) {
    const config = this.getGroupConfig(group);
    const index = this.groups.indexOf(config);
    if (index > -1) {
      this.groups.splice(index, 1);
    }
    return config;
  },
  _setDefaultMessage(info) {
    const {
      rule,
      validator,
      name
    } = info;
    if (!(0, _type.isDefined)(rule.message)) {
      if (validator.defaultFormattedMessage && (0, _type.isDefined)(name)) {
        rule.message = validator.defaultFormattedMessage(name);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule(info) {
    const {
      result,
      rule
    } = info;
    if (!result.brokenRule) {
      result.brokenRule = rule;
    }
    if (!result.brokenRules) {
      result.brokenRules = [];
    }
    result.brokenRules.push(rule);
  },
  validate(value, rules, name) {
    var _rules$;
    let result = {
      name,
      value,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    const validator = rules === null || rules === void 0 || (_rules$ = rules[0]) === null || _rules$ === void 0 ? void 0 : _rules$.validator;
    const asyncRuleItems = [];
    // @ts-expect-error
    (0, _iterator.each)(rules || [], (_, rule) => {
      const ruleValidator = rulesValidators[rule.type];
      let ruleValidationResult;
      if (ruleValidator) {
        if ((0, _type.isDefined)(rule.isValid) && rule.value === value && !rule.reevaluate) {
          if (!rule.isValid) {
            result.isValid = false;
            this._addBrokenRule({
              result,
              rule
            });
            return false;
          }
          return true;
        }
        rule.value = value;
        if (rule.type === 'async') {
          // @ts-expect-error
          asyncRuleItems.push({
            rule,
            ruleValidator
          });
          return true;
        }
        ruleValidationResult = ruleValidator.validate(value, rule);
        rule.isValid = ruleValidationResult;
        if (!ruleValidationResult) {
          result.isValid = false;
          this._setDefaultMessage({
            rule,
            validator: ruleValidator,
            name
          });
          this._addBrokenRule({
            result,
            rule
          });
        }
        if (!rule.isValid) {
          return false;
        }
      } else {
        throw _errors.default.Error('E0100');
      }
    });
    if (result.isValid && !result.brokenRules && asyncRuleItems.length) {
      result = this._validateAsyncRules({
        value,
        items: asyncRuleItems,
        result,
        name
      });
    }
    this._synchronizeGroupValidationInfo(validator, result);
    result.status = result.pendingRules ? STATUS.pending : result.isValid ? STATUS.valid : STATUS.invalid;
    return result;
  },
  _synchronizeGroupValidationInfo(validator, result) {
    if (!validator) {
      return;
    }
    const groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
    groupConfig._updateBrokenRules.call(groupConfig, {
      validator,
      brokenRules: result.brokenRules ?? []
    });
  },
  _validateAsyncRules(_ref) {
    let {
      result,
      value,
      items,
      name
    } = _ref;
    const asyncResults = [];
    (0, _iterator.each)(items, (_, item) => {
      const validateResult = item.ruleValidator.validate(value, item.rule);
      if (!(0, _type.isPromise)(validateResult)) {
        this._updateRuleConfig({
          rule: item.rule,
          ruleResult: this._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name
        });
      } else {
        if (!result.pendingRules) {
          result.pendingRules = [];
        }
        result.pendingRules.push(item.rule);
        const asyncResult = validateResult.then(res => {
          const ruleResult = this._getPatchedRuleResult(res);
          this._updateRuleConfig({
            rule: item.rule,
            ruleResult,
            validator: item.ruleValidator,
            name
          });
          return ruleResult;
        });
        // @ts-expect-error
        asyncResults.push(asyncResult);
      }
    });
    if (asyncResults.length) {
      result.complete = Promise.all(asyncResults).then(values => this._getAsyncRulesResult({
        result,
        values
      }));
    }
    return result;
  },
  _updateRuleConfig(_ref2) {
    let {
      rule,
      ruleResult,
      validator,
      name
    } = _ref2;
    rule.isValid = ruleResult.isValid;
    if (!ruleResult.isValid) {
      if ((0, _type.isDefined)(ruleResult.message) && (0, _type.isString)(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule,
          validator,
          name
        });
      }
    }
  },
  _getPatchedRuleResult(ruleResult) {
    let result;
    const isValid = true;
    if ((0, _type.isObject)(ruleResult)) {
      result = (0, _extend.extend)({}, ruleResult);
      if (!(0, _type.isDefined)(result.isValid)) {
        result.isValid = isValid;
      }
    } else {
      result = {
        isValid: (0, _type.isBoolean)(ruleResult) ? ruleResult : isValid
      };
    }
    return result;
  },
  _getAsyncRulesResult(_ref3) {
    let {
      values,
      result
    } = _ref3;
    (0, _iterator.each)(values, (index, val) => {
      if (val.isValid === false) {
        result.isValid = val.isValid;
        const rule = result.pendingRules[index];
        this._addBrokenRule({
          result,
          rule
        });
      }
    });
    result.pendingRules = null;
    result.complete = null;
    result.status = result.isValid ? STATUS.valid : STATUS.invalid;
    return result;
  },
  registerValidatorInGroup(group, validator) {
    const groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  removeRegisteredValidator(group, validator) {
    const config = ValidationEngine.getGroupConfig(group);
    if (config) {
      config.removeRegisteredValidator.call(config, validator);
      const validatorsInGroup = config.validators;
      const isRemovable = config._isRemovable;
      const shouldRemoveGroup = validatorsInGroup.length === 0 && isRemovable;
      if (shouldRemoveGroup) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions(options) {
    const initedOptions = {};
    if (options) {
      const syncOptions = ['isValid', 'validationStatus', 'validationError', 'validationErrors'];
      syncOptions.forEach(prop => {
        if (prop in options) {
          (0, _extend.extend)(initedOptions, this.synchronizeValidationOptions({
            name: prop,
            value: options[prop]
          }, options));
        }
      });
    }
    return initedOptions;
  },
  synchronizeValidationOptions(_ref4, options) {
    let {
      name,
      value
    } = _ref4;
    // eslint-disable-next-line default-case
    switch (name) {
      case 'validationStatus':
        {
          const isValid = value === STATUS.valid || value === STATUS.pending;
          return options.isValid !== isValid ? {
            isValid
          } : {};
        }
      case 'isValid':
        {
          const {
            validationStatus
          } = options;
          let newStatus = validationStatus;
          if (value && validationStatus === STATUS.invalid) {
            newStatus = STATUS.valid;
          } else if (!value && validationStatus !== STATUS.invalid) {
            newStatus = STATUS.invalid;
          }
          return newStatus !== validationStatus ? {
            validationStatus: newStatus
          } : {};
        }
      case 'validationErrors':
        {
          const validationError = !value || !value.length ? null : value[0];
          return options.validationError !== validationError ? {
            validationError
          } : {};
        }
      case 'validationError':
        {
          const {
            validationErrors
          } = options;
          if (!value && validationErrors) {
            return {
              validationErrors: null
            };
          }
          if (value && !validationErrors) {
            return {
              validationErrors: [value]
            };
          }
          if (value && validationErrors && value !== validationErrors[0]) {
            validationErrors[0] = value;
            return {
              validationErrors: validationErrors.slice()
            };
          }
        }
    }
    return {};
  },
  validateGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw _errors.default.Error('E0110');
    }
    return groupConfig.validate();
  },
  resetGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw _errors.default.Error('E0110');
    }
    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var _default = exports["default"] = ValidationEngine;

/***/ }),

/***/ 47111:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _extend = __webpack_require__(13306);
var _position = __webpack_require__(37518);
var _size = __webpack_require__(58664);
var _string = __webpack_require__(68752);
var _ui = _interopRequireDefault(__webpack_require__(89799));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const INVALID_MESSAGE = 'dx-invalid-message';
const INVALID_MESSAGE_AUTO = 'dx-invalid-message-auto';
const INVALID_MESSAGE_ALWAYS = 'dx-invalid-message-always';
const INVALID_MESSAGE_CONTENT = 'dx-invalid-message-content';
const VALIDATION_MESSAGE_MIN_WIDTH = 100;
// @ts-expect-error
const ValidationMessage = _ui.default.inherit({
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      integrationOptions: {},
      templatesRenderAsynchronously: false,
      shading: false,
      width: 'auto',
      height: 'auto',
      hideOnOutsideClick: false,
      animation: null,
      visible: true,
      propagateOutsideClick: true,
      _checkParentVisibility: false,
      rtlEnabled: false,
      contentTemplate: this._renderInnerHtml,
      maxWidth: '100%',
      container: this.$element(),
      target: undefined,
      mode: 'auto',
      validationErrors: undefined,
      preventScrollEvents: false,
      positionSide: 'top',
      boundary: undefined,
      offset: {
        h: 0,
        v: 0
      },
      contentId: undefined
    });
  },
  _init() {
    this.callBase();
    this.updateMaxWidth();
    this._updatePosition();
  },
  _initMarkup() {
    this.callBase();
    this._ensureMessageNotEmpty();
    this._updatePositionByTarget();
    this._toggleModeClass();
    this._updateContentId();
  },
  _updatePositionByTarget() {
    const {
      target
    } = this.option();
    this.option('position.of', target);
  },
  _ensureMessageNotEmpty() {
    this._textMarkup = this._getTextMarkup();
    const shouldShowMessage = this.option('visible') && this._textMarkup;
    this._toggleVisibilityClasses(shouldShowMessage);
  },
  _toggleVisibilityClasses(visible) {
    if (visible) {
      this.$element().addClass(INVALID_MESSAGE);
      this.$wrapper().addClass(INVALID_MESSAGE);
    } else {
      this.$element().removeClass(INVALID_MESSAGE);
      this.$wrapper().removeClass(INVALID_MESSAGE);
    }
  },
  _updateContentId() {
    const {
      container,
      contentId
    } = this.option();
    const id = contentId ?? (0, _renderer.default)(container).attr('aria-describedby');
    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr('id', id);
  },
  _renderInnerHtml(element) {
    const $element = element && (0, _renderer.default)(element);
    $element === null || $element === void 0 || $element.html(this._textMarkup);
  },
  _getTextMarkup() {
    const validationErrors = this.option('validationErrors') ?? [];
    let validationErrorMessage = '';
    validationErrors.forEach(err => {
      const separator = validationErrorMessage ? '<br />' : '';
      validationErrorMessage += separator + (0, _string.encodeHtml)((err === null || err === void 0 ? void 0 : err.message) ?? '');
    });
    return validationErrorMessage;
  },
  _toggleModeClass() {
    const mode = this.option('mode');
    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, mode === 'auto').toggleClass(INVALID_MESSAGE_ALWAYS, mode === 'always');
  },
  updateMaxWidth() {
    const target = this.option('target');
    const targetWidth = (0, _size.getOuterWidth)(target);
    let maxWidth = '100%';
    if (targetWidth) {
      // @ts-expect-error
      maxWidth = Math.max(targetWidth, VALIDATION_MESSAGE_MIN_WIDTH);
    }
    this.option({
      maxWidth
    });
  },
  _getPositionsArray(positionSide, rtlSide) {
    switch (positionSide) {
      case 'top':
        return [`${rtlSide} bottom`, `${rtlSide} top`];
      case 'left':
        return ['right', 'left'];
      case 'right':
        return ['left', 'right'];
      default:
        return [`${rtlSide} top`, `${rtlSide} bottom`];
    }
  },
  _updatePosition() {
    const {
      positionSide,
      rtlEnabled,
      offset: componentOffset,
      boundary
    } = this.option();
    const rtlSide = (0, _position.getDefaultAlignment)(rtlEnabled);
    const positions = this._getPositionsArray(positionSide, rtlSide);
    const offset = _extends({}, componentOffset);
    this.$element().addClass(`dx-invalid-message-${positionSide}`);
    if (rtlEnabled && positionSide !== 'left' && positionSide !== 'right') offset.h = -offset.h;
    if (positionSide === 'top') offset.v = -offset.v;
    if (positionSide === 'left') offset.h = -offset.h;
    this.option('position', {
      offset,
      boundary,
      my: positions[0],
      at: positions[1],
      collision: 'none flip'
    });
  },
  _optionChanged(args) {
    const {
      name,
      value,
      previousValue
    } = args;
    switch (name) {
      case 'target':
        this._updatePositionByTarget();
        this.updateMaxWidth();
        this.callBase(args);
        break;
      case 'boundary':
        this.option('position.boundary', value);
        break;
      case 'mode':
        this._toggleModeClass(value);
        break;
      case 'rtlEnabled':
      case 'offset':
      case 'positionSide':
        this.$element().removeClass(`dx-invalid-message-${previousValue}`);
        this._updatePosition();
        break;
      case 'container':
        this._updateContentId();
        this.callBase(args);
        break;
      case 'contentId':
        this._updateContentId();
        break;
      case 'validationErrors':
        this._ensureMessageNotEmpty();
        this._renderInnerHtml(this.$content());
        break;
      default:
        this.callBase(args);
    }
  }
});
(0, _component_registrator.default)('dxValidationMessage', ValidationMessage);
var _default = exports["default"] = ValidationMessage;

/***/ }),

/***/ 46356:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _fx = _interopRequireDefault(__webpack_require__(87209));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _element = __webpack_require__(6415);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _empty_template = __webpack_require__(10688);
var _browser = _interopRequireDefault(__webpack_require__(47810));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _dom = __webpack_require__(3532);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _size = __webpack_require__(58664);
var _type = __webpack_require__(35922);
var _view_port = __webpack_require__(77695);
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _drag = __webpack_require__(23174);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _short = __webpack_require__(72918);
var _index = __webpack_require__(39611);
var _visibility_change = __webpack_require__(80506);
var _hide_callback = __webpack_require__(4928);
var _selectors = __webpack_require__(31421);
var _ui = _interopRequireDefault(__webpack_require__(96688));
var _ui2 = _interopRequireDefault(__webpack_require__(14390));
var _m_overlay_position_controller = __webpack_require__(11346);
var zIndexPool = _interopRequireWildcard(__webpack_require__(16230));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ready = _ready_callbacks.default.add;
const window = (0, _window.getWindow)();
const viewPortChanged = _view_port.changeCallback;
const OVERLAY_CLASS = 'dx-overlay';
const OVERLAY_WRAPPER_CLASS = 'dx-overlay-wrapper';
const OVERLAY_CONTENT_CLASS = 'dx-overlay-content';
const OVERLAY_SHADER_CLASS = 'dx-overlay-shader';
const INNER_OVERLAY_CLASS = 'dx-inner-overlay';
const INVISIBLE_STATE_CLASS = 'dx-state-invisible';
const ANONYMOUS_TEMPLATE_NAME = 'content';
const RTL_DIRECTION_CLASS = 'dx-rtl';
const OVERLAY_STACK = [];
const PREVENT_SAFARI_SCROLLING_CLASS = 'dx-prevent-safari-scrolling';
const TAB_KEY = 'tab';
ready(() => {
  // @ts-expect-error
  _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), _pointer.default.down, e => {
    for (let i = OVERLAY_STACK.length - 1; i >= 0; i--) {
      // @ts-expect-error
      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
        return;
      }
    }
  });
});
// @ts-expect-error
const Overlay = _ui2.default.inherit({
  _supportedKeys() {
    return (0, _extend.extend)(this.callBase(), {
      escape() {
        this.hide();
      }
    });
  },
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      activeStateEnabled: false,
      visible: false,
      deferRendering: true,
      shading: true,
      shadingColor: '',
      wrapperAttr: {},
      position: (0, _extend.extend)({}, _m_overlay_position_controller.OVERLAY_POSITION_ALIASES.center),
      width: '80vw',
      minWidth: null,
      maxWidth: null,
      height: '80vh',
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: 'pop',
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: 'pop',
          duration: 300,
          from: {
            opacity: 1,
            scale: 1
          },
          to: {
            opacity: 0,
            scale: 0.55
          }
        }
      },
      closeOnOutsideClick: false,
      hideOnOutsideClick: false,
      _ignorePreventScrollEventsDeprecation: false,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: 'content',
      innerOverlay: false,
      restorePosition: true,
      container: undefined,
      visualContainer: undefined,
      // NOTE: private options
      hideTopOverlayHandler: () => {
        this.hide();
      },
      hideOnParentScroll: false,
      preventScrollEvents: true,
      onPositioned: null,
      propagateOutsideClick: false,
      ignoreChildEvents: true,
      _checkParentVisibility: true,
      _hideOnParentScrollTarget: undefined,
      _fixWrapperPosition: false
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device() {
        return !(0, _window.hasWindow)();
      },
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: false
      }
    }]);
  },
  _setOptionsByReference() {
    this.callBase();
    (0, _extend.extend)(this._optionsByReference, {
      animation: true
    });
  },
  $wrapper() {
    return this._$wrapper;
  },
  _eventBindingTarget() {
    return this._$content;
  },
  _setDeprecatedOptions() {
    this.callBase();
    (0, _extend.extend)(this._deprecatedOptions, {
      closeOnOutsideClick: {
        since: '22.1',
        alias: 'hideOnOutsideClick'
      }
    });
  },
  ctor(element, options) {
    this.callBase(element, options);
    if (options) {
      if ('preventScrollEvents' in options && !options._ignorePreventScrollEventsDeprecation) {
        this._logDeprecatedPreventScrollEventsInfo();
      }
    }
  },
  _logDeprecatedPreventScrollEventsInfo() {
    this._logDeprecatedOptionWarning('preventScrollEvents', {
      since: '23.1',
      message: 'If you enable this option, end-users may experience scrolling issues.'
    });
  },
  _init() {
    this.callBase();
    this._initActions();
    this._initHideOnOutsideClickHandler();
    this._initTabTerminatorHandler();
    this._customWrapperClass = null;
    this._$wrapper = (0, _renderer.default)('<div>').addClass(OVERLAY_WRAPPER_CLASS);
    this._$content = (0, _renderer.default)('<div>').addClass(OVERLAY_CONTENT_CLASS);
    this._initInnerOverlayClass();
    const $element = this.$element();
    $element.addClass(OVERLAY_CLASS);
    this._$wrapper.attr('data-bind', 'dxControlsDescendantBindings: true');
    this._toggleViewPortSubscription(true);
    this._initHideTopOverlayHandler(this.option('hideTopOverlayHandler'));
    this._parentsScrollSubscriptionInfo = {
      handler: e => {
        this._hideOnParentsScrollHandler(e);
      }
    };
    this.warnPositionAsFunction();
  },
  warnPositionAsFunction() {
    if ((0, _type.isFunction)(this.option('position'))) {
      // position as function deprecated in 21.2
      _errors.default.log('W0018');
    }
  },
  _initInnerOverlayClass() {
    this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option('innerOverlay'));
  },
  _initHideTopOverlayHandler(handler) {
    this._hideTopOverlayHandler = handler;
  },
  _getActionsList() {
    return ['onShowing', 'onShown', 'onHiding', 'onHidden', 'onPositioned', 'onVisualPositionChanged'];
  },
  _initActions() {
    this._actions = {};
    const actions = this._getActionsList();
    (0, _iterator.each)(actions, (_, action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ['disabled', 'readOnly']
      }) || _common.noop;
    });
  },
  _initHideOnOutsideClickHandler() {
    var _this = this;
    this._proxiedDocumentDownHandler = function () {
      return _this._documentDownHandler(...arguments);
    };
  },
  _initMarkup() {
    this.callBase();
    this._renderWrapperAttributes();
    this._initPositionController();
  },
  _documentDownHandler(e) {
    if (this._showAnimationProcessing) {
      this._stopAnimation();
    }
    // @ts-expect-error
    const isAttachedTarget = (0, _renderer.default)(window.document).is(e.target) || (0, _dom.contains)(window.document, e.target);
    const isInnerOverlay = (0, _renderer.default)(e.target).closest(`.${INNER_OVERLAY_CLASS}`).length;
    const outsideClick = isAttachedTarget && !isInnerOverlay && !(this._$content.is(e.target) || (0, _dom.contains)(this._$content.get(0), e.target));
    if (outsideClick && this._shouldHideOnOutsideClick(e)) {
      this._outsideClickHandler(e);
    }
    return this.option('propagateOutsideClick');
  },
  _shouldHideOnOutsideClick(e) {
    const {
      hideOnOutsideClick
    } = this.option();
    if ((0, _type.isFunction)(hideOnOutsideClick)) {
      return hideOnOutsideClick(e);
    }
    return hideOnOutsideClick;
  },
  _outsideClickHandler(e) {
    if (this.option('shading')) {
      e.preventDefault();
    }
    this.hide();
  },
  _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new _empty_template.EmptyTemplate()
    });
    this.callBase();
  },
  _isTopOverlay() {
    const overlayStack = this._overlayStack();
    for (let i = overlayStack.length - 1; i >= 0; i--) {
      const tabbableElements = overlayStack[i]._findTabbableBounds();
      if (tabbableElements.first || tabbableElements.last) {
        return overlayStack[i] === this;
      }
    }
    return false;
  },
  _overlayStack() {
    return OVERLAY_STACK;
  },
  _zIndexInitValue() {
    // @ts-expect-error
    return Overlay.baseZIndex();
  },
  _toggleViewPortSubscription(toggle) {
    var _this2 = this;
    viewPortChanged.remove(this._viewPortChangeHandle);
    if (toggle) {
      this._viewPortChangeHandle = function () {
        _this2._viewPortChangeHandler(...arguments);
      };
      viewPortChanged.add(this._viewPortChangeHandle);
    }
  },
  _viewPortChangeHandler() {
    this._positionController.updateContainer(this.option('container'));
    this._refresh();
  },
  _renderWrapperAttributes() {
    const {
      wrapperAttr
    } = this.option();
    const attributes = (0, _extend.extend)({}, wrapperAttr);
    const classNames = attributes.class;
    delete attributes.class;
    this.$wrapper().attr(attributes).removeClass(this._customWrapperClass).addClass(classNames);
    this._customWrapperClass = classNames;
  },
  _renderVisibilityAnimate(visible) {
    this._stopAnimation();
    return visible ? this._show() : this._hide();
  },
  _getAnimationConfig() {
    return this._getOptionValue('animation', this);
  },
  _toggleBodyScroll: _common.noop,
  _animateShowing() {
    var _this3 = this;
    const animation = this._getAnimationConfig() ?? {};
    const showAnimation = this._normalizeAnimation(animation.show, 'to');
    const startShowAnimation = (showAnimation === null || showAnimation === void 0 ? void 0 : showAnimation.start) ?? _common.noop;
    const completeShowAnimation = (showAnimation === null || showAnimation === void 0 ? void 0 : showAnimation.complete) ?? _common.noop;
    this._animate(showAnimation, function () {
      if (_this3._isAnimationPaused) {
        return;
      }
      if (_this3.option('focusStateEnabled')) {
        // @ts-expect-error
        _events_engine.default.trigger(_this3._focusTarget(), 'focus');
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      completeShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = false;
      _this3._isHidden = false;
      _this3._actions.onShown();
      _this3._toggleSafariScrolling();
      _this3._showingDeferred.resolve();
    }, function () {
      if (_this3._isAnimationPaused) {
        return;
      }
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      startShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = true;
    });
  },
  _processShowingHidingCancel(cancelArg, applyFunction, cancelFunction) {
    if ((0, _type.isPromise)(cancelArg)) {
      cancelArg.then(shouldCancel => {
        if (shouldCancel) {
          cancelFunction();
        } else {
          applyFunction();
        }
      }).catch(() => applyFunction());
    } else {
      cancelArg ? cancelFunction() : applyFunction();
    }
  },
  _show() {
    this._showingDeferred = (0, _deferred.Deferred)();
    this._parentHidden = this._isParentHidden();
    this._showingDeferred.done(() => {
      delete this._parentHidden;
    });
    if (this._parentHidden) {
      this._isHidden = true;
      return this._showingDeferred.resolve();
    }
    if (this._currentVisible) {
      return (0, _deferred.Deferred)().resolve().promise();
    }
    this._currentVisible = true;
    if (this._isHidingActionCanceled) {
      delete this._isHidingActionCanceled;
      this._showingDeferred.reject();
    } else {
      const show = () => {
        this._stopAnimation();
        this._toggleBodyScroll(this.option('enableBodyScroll'));
        this._toggleVisibility(true);
        this._$content.css('visibility', 'hidden');
        this._$content.toggleClass(INVISIBLE_STATE_CLASS, false);
        this._updateZIndexStackPosition(true);
        this._positionController.openingHandled();
        this._renderContent();
        const showingArgs = {
          cancel: false
        };
        this._actions.onShowing(showingArgs);
        const cancelShow = () => {
          this._toggleVisibility(false);
          this._$content.css('visibility', '');
          this._$content.toggleClass(INVISIBLE_STATE_CLASS, true);
          this._isShowingActionCanceled = true;
          this._moveFromContainer();
          this._toggleBodyScroll(true);
          this.option('visible', false);
          this._showingDeferred.resolve();
        };
        const applyShow = () => {
          this._$content.css('visibility', '');
          this._renderVisibility(true);
          this._animateShowing();
        };
        this._processShowingHidingCancel(showingArgs.cancel, applyShow, cancelShow);
      };
      if (this.option('templatesRenderAsynchronously')) {
        this._stopShowTimer();
        // NOTE: T390360, T386038
        this._asyncShowTimeout = setTimeout(show);
      } else {
        show();
      }
    }
    return this._showingDeferred.promise();
  },
  _normalizeAnimation(showHideConfig, direction) {
    if (showHideConfig) {
      showHideConfig = (0, _extend.extend)({
        type: 'slide',
        skipElementInitialStyles: true // NOTE: for fadeIn animation
      }, showHideConfig);
      if ((0, _type.isObject)(showHideConfig[direction])) {
        (0, _extend.extend)(showHideConfig[direction], {
          position: this._positionController.position
        });
      }
    }
    return showHideConfig;
  },
  _animateHiding() {
    var _this4 = this;
    const animation = this._getAnimationConfig() ?? {};
    const hideAnimation = this._normalizeAnimation(animation.hide, 'from');
    const startHideAnimation = (hideAnimation === null || hideAnimation === void 0 ? void 0 : hideAnimation.start) ?? _common.noop;
    const completeHideAnimation = (hideAnimation === null || hideAnimation === void 0 ? void 0 : hideAnimation.complete) ?? _common.noop;
    this._animate(hideAnimation, function () {
      var _this4$_actions;
      _this4._$content.css('pointerEvents', '');
      _this4._renderVisibility(false);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      completeHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = false;
      (_this4$_actions = _this4._actions) === null || _this4$_actions === void 0 || _this4$_actions.onHidden();
      _this4._hidingDeferred.resolve();
    }, function () {
      _this4._$content.css('pointerEvents', 'none');
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      startHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = true;
    });
  },
  _hide() {
    if (!this._currentVisible) {
      return (0, _deferred.Deferred)().resolve().promise();
    }
    this._currentVisible = false;
    this._hidingDeferred = (0, _deferred.Deferred)();
    const hidingArgs = {
      cancel: false
    };
    if (this._isShowingActionCanceled) {
      delete this._isShowingActionCanceled;
      this._hidingDeferred.reject();
    } else {
      this._actions.onHiding(hidingArgs);
      this._toggleSafariScrolling();
      this._toggleBodyScroll(true);
      const cancelHide = () => {
        this._isHidingActionCanceled = true;
        this._toggleBodyScroll(this.option('enableBodyScroll'));
        this.option('visible', true);
        this._hidingDeferred.resolve();
      };
      const applyHide = () => {
        this._forceFocusLost();
        this._toggleShading(false);
        this._toggleSubscriptions(false);
        this._stopShowTimer();
        this._animateHiding();
      };
      this._processShowingHidingCancel(hidingArgs.cancel, applyHide, cancelHide);
    }
    return this._hidingDeferred.promise();
  },
  _forceFocusLost() {
    const activeElement = _dom_adapter.default.getActiveElement();
    const shouldResetActiveElement = !!this._$content.find(activeElement).length;
    if (shouldResetActiveElement) {
      (0, _dom.resetActiveElement)();
    }
  },
  _animate(animation, completeCallback, startCallback) {
    if (animation) {
      startCallback = startCallback || animation.start || _common.noop;
      _fx.default.animate(this._$content, (0, _extend.extend)({}, animation, {
        start: startCallback,
        complete: completeCallback
      }));
    } else {
      completeCallback();
    }
  },
  _stopAnimation() {
    _fx.default.stop(this._$content, true);
  },
  _renderVisibility(visible) {
    if (visible && this._isParentHidden()) {
      return;
    }
    this._currentVisible = visible;
    this._stopAnimation();
    if (!visible) {
      (0, _visibility_change.triggerHidingEvent)(this._$content);
    }
    if (visible) {
      this._checkContainerExists();
      this._moveToContainer();
      this._renderGeometry();
      (0, _visibility_change.triggerShownEvent)(this._$content);
      (0, _visibility_change.triggerResizeEvent)(this._$content);
    } else {
      this._toggleVisibility(visible);
      this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);
      this._updateZIndexStackPosition(visible);
      this._moveFromContainer();
    }
    this._toggleShading(visible);
    this._toggleSubscriptions(visible);
  },
  _updateZIndexStackPosition(pushToStack) {
    const overlayStack = this._overlayStack();
    const index = overlayStack.indexOf(this);
    if (pushToStack) {
      if (index === -1) {
        this._zIndex = zIndexPool.create(this._zIndexInitValue());
        overlayStack.push(this);
      }
      this._$wrapper.css('zIndex', this._zIndex);
      this._$content.css('zIndex', this._zIndex);
    } else if (index !== -1) {
      overlayStack.splice(index, 1);
      zIndexPool.remove(this._zIndex);
    }
  },
  _toggleShading(visible) {
    this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option('shading'));
    this._$wrapper.css('backgroundColor', this.option('shading') ? this.option('shadingColor') : '');
    this._toggleTabTerminator(visible && this.option('shading'));
  },
  _initTabTerminatorHandler() {
    var _this5 = this;
    this._proxiedTabTerminatorHandler = function () {
      _this5._tabKeyHandler(...arguments);
    };
  },
  _toggleTabTerminator(enabled) {
    const eventName = (0, _index.addNamespace)('keydown', this.NAME);
    if (enabled) {
      _events_engine.default.on(_dom_adapter.default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    } else {
      _events_engine.default.off(_dom_adapter.default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    }
  },
  _findTabbableBounds() {
    const $elements = this._$wrapper.find('*');
    const elementsCount = $elements.length - 1;
    const result = {
      first: null,
      last: null
    };
    for (let i = 0; i <= elementsCount; i++) {
      if (!result.first && $elements.eq(i).is(_selectors.tabbable)) {
        result.first = $elements.eq(i);
      }
      if (!result.last && $elements.eq(elementsCount - i).is(_selectors.tabbable)) {
        result.last = $elements.eq(elementsCount - i);
      }
      if (result.first && result.last) {
        break;
      }
    }
    return result;
  },
  _tabKeyHandler(e) {
    if ((0, _index.normalizeKeyName)(e) !== TAB_KEY || !this._isTopOverlay()) {
      return;
    }
    const tabbableElements = this._findTabbableBounds();
    const $firstTabbable = tabbableElements.first;
    const $lastTabbable = tabbableElements.last;
    const isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
    const isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
    const isEmptyTabList = tabbableElements.length === 0;
    const isOutsideTarget = !(0, _dom.contains)(this._$wrapper.get(0), e.target);
    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
      e.preventDefault();
      const $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
      // @ts-expect-error
      _events_engine.default.trigger($focusElement, 'focusin');
      // @ts-expect-error
      _events_engine.default.trigger($focusElement, 'focus');
    }
  },
  _toggleSubscriptions(enabled) {
    if ((0, _window.hasWindow)()) {
      this._toggleHideTopOverlayCallback(enabled);
      this._toggleHideOnParentsScrollSubscription(enabled);
    }
  },
  _toggleHideTopOverlayCallback(subscribe) {
    if (!this._hideTopOverlayHandler) {
      return;
    }
    if (subscribe) {
      _hide_callback.hideCallback.add(this._hideTopOverlayHandler);
    } else {
      _hide_callback.hideCallback.remove(this._hideTopOverlayHandler);
    }
  },
  _toggleHideOnParentsScrollSubscription(needSubscribe) {
    const scrollEvent = (0, _index.addNamespace)('scroll', this.NAME);
    const {
      prevTargets,
      handler
    } = this._parentsScrollSubscriptionInfo ?? {};
    _events_engine.default.off(prevTargets, scrollEvent, handler);
    const hideOnScroll = this.option('hideOnParentScroll');
    if (needSubscribe && hideOnScroll) {
      let $parents = this._getHideOnParentScrollTarget().parents();
      if (_devices.default.real().deviceType === 'desktop') {
        $parents = $parents.add(window);
      }
      _events_engine.default.on($parents, scrollEvent, handler);
      this._parentsScrollSubscriptionInfo.prevTargets = $parents;
    }
  },
  _hideOnParentsScrollHandler(e) {
    let hideHandled = false;
    const hideOnScroll = this.option('hideOnParentScroll');
    if ((0, _type.isFunction)(hideOnScroll)) {
      hideHandled = hideOnScroll(e);
    }
    if (!hideHandled && !this._showAnimationProcessing) {
      this.hide();
    }
  },
  _getHideOnParentScrollTarget() {
    const $hideOnParentScrollTarget = (0, _renderer.default)(this.option('_hideOnParentScrollTarget'));
    if ($hideOnParentScrollTarget.length) {
      return $hideOnParentScrollTarget;
    }
    return this._$wrapper;
  },
  _render() {
    this.callBase();
    this._appendContentToElement();
    this._renderVisibilityAnimate(this.option('visible'));
  },
  _appendContentToElement() {
    if (!this._$content.parent().is(this.$element())) {
      this._$content.appendTo(this.$element());
    }
  },
  _renderContent() {
    const shouldDeferRendering = !this._currentVisible && this.option('deferRendering');
    const isParentHidden = this.option('visible') && this._isParentHidden();
    if (isParentHidden) {
      this._isHidden = true;
      return;
    }
    if (this._contentAlreadyRendered || shouldDeferRendering) {
      return;
    }
    this._contentAlreadyRendered = true;
    this._appendContentToElement();
    this.callBase();
  },
  _isParentHidden() {
    if (!this.option('_checkParentVisibility')) {
      return false;
    }
    if (this._parentHidden !== undefined) {
      return this._parentHidden;
    }
    const $parent = this.$element().parent();
    if ($parent.is(':visible')) {
      return false;
    }
    let isHidden = false;
    // @ts-expect-error
    $parent.add($parent.parents()).each((index, element) => {
      const $element = (0, _renderer.default)(element);
      // @ts-expect-error
      if ($element.css('display') === 'none') {
        isHidden = true;
        return false;
      }
    });
    return isHidden || !_dom_adapter.default.getBody().contains($parent.get(0));
  },
  _renderContentImpl() {
    const whenContentRendered = (0, _deferred.Deferred)();
    const contentTemplateOption = this.option('contentTemplate');
    const contentTemplate = this._getTemplate(contentTemplateOption);
    const transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
    contentTemplate && contentTemplate.render({
      container: (0, _element.getPublicElement)(this.$content()),
      noModel: true,
      transclude,
      onRendered: () => {
        whenContentRendered.resolve();
        // NOTE: T1114344
        if (this.option('templatesRenderAsynchronously')) {
          this._dimensionChanged();
        }
      }
    });
    this._toggleWrapperScrollEventsSubscription(this.option('preventScrollEvents'));
    whenContentRendered.done(() => {
      if (this.option('visible')) {
        this._moveToContainer();
      }
    });
    return whenContentRendered.promise();
  },
  _getPositionControllerConfig() {
    const {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      container,
      visualContainer,
      _fixWrapperPosition,
      restorePosition,
      _skipContentPositioning
    } = this.option();
    // NOTE: position is passed to controller in renderGeometry to prevent window field using in server side mode
    return {
      container,
      visualContainer,
      $root: this.$element(),
      $content: this._$content,
      $wrapper: this._$wrapper,
      onPositioned: this._actions.onPositioned,
      onVisualPositionChanged: this._actions.onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    };
  },
  _initPositionController() {
    this._positionController = new _m_overlay_position_controller.OverlayPositionController(this._getPositionControllerConfig());
  },
  _toggleWrapperScrollEventsSubscription(enabled) {
    const eventName = (0, _index.addNamespace)(_drag.move, this.NAME);
    _events_engine.default.off(this._$wrapper, eventName);
    if (enabled) {
      _events_engine.default.on(this._$wrapper, eventName, {
        validate() {
          return true;
        },
        getDirection() {
          return 'both';
        },
        _toggleGestureCover(toggle) {
          if (!toggle) {
            this._toggleGestureCoverImpl(toggle);
          }
        },
        _clearSelection: _common.noop,
        isNative: true
      }, e => {
        const {
          originalEvent
        } = e.originalEvent;
        const {
          type
        } = originalEvent || {};
        const isWheel = type === 'wheel';
        const isMouseMove = type === 'mousemove';
        const isScrollByWheel = isWheel && !(0, _index.isCommandKeyPressed)(e);
        e._cancelPreventDefault = true;
        if (originalEvent && e.cancelable !== false && (!isMouseMove && !isWheel || isScrollByWheel)) {
          e.preventDefault();
        }
      });
    }
  },
  _moveFromContainer() {
    this._$content.appendTo(this.$element());
    this._$wrapper.detach();
  },
  _checkContainerExists() {
    const $wrapperContainer = this._positionController.$container;
    // NOTE: The container is undefined when DOM is not ready yet. See T1143527
    if ($wrapperContainer === undefined) {
      return;
    }
    const containerExists = $wrapperContainer.length > 0;
    if (!containerExists) {
      _ui.default.log('W1021', this.NAME);
    }
  },
  _moveToContainer() {
    const $wrapperContainer = this._positionController.$container;
    this._$wrapper.appendTo($wrapperContainer);
    this._$content.appendTo(this._$wrapper);
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _renderGeometry(options) {
    const {
      visible
    } = this.option();
    if (visible && (0, _window.hasWindow)()) {
      this._stopAnimation();
      this._renderGeometryImpl();
    }
  },
  _renderGeometryImpl() {
    // NOTE: position can be specified as a function which needs to be called strict on render start
    this._positionController.updatePosition(this._getOptionValue('position'));
    this._renderWrapper();
    this._renderDimensions();
    this._renderPosition();
  },
  _renderPosition() {
    this._positionController.positionContent();
  },
  _isAllWindowCovered() {
    return (0, _type.isWindow)(this._positionController.$visualContainer.get(0)) && this.option('shading');
  },
  _toggleSafariScrolling() {
    const visible = this.option('visible');
    const $body = (0, _renderer.default)(_dom_adapter.default.getBody());
    const isIosSafari = _devices.default.real().platform === 'ios' && _browser.default.safari;
    const isAllWindowCovered = this._isAllWindowCovered();
    const isScrollingPrevented = $body.hasClass(PREVENT_SAFARI_SCROLLING_CLASS);
    const shouldPreventScrolling = !isScrollingPrevented && visible && isAllWindowCovered;
    const shouldEnableScrolling = isScrollingPrevented && (!visible || !isAllWindowCovered || this._disposed);
    if (isIosSafari) {
      if (shouldEnableScrolling) {
        $body.removeClass(PREVENT_SAFARI_SCROLLING_CLASS);
        window.scrollTo(0, this._cachedBodyScrollTop);
        this._cachedBodyScrollTop = undefined;
      } else if (shouldPreventScrolling) {
        this._cachedBodyScrollTop = window.pageYOffset;
        $body.addClass(PREVENT_SAFARI_SCROLLING_CLASS);
      }
    }
  },
  _renderWrapper() {
    this._positionController.styleWrapperPosition();
    this._renderWrapperDimensions();
    this._positionController.positionWrapper();
  },
  _renderWrapperDimensions() {
    const {
      $visualContainer
    } = this._positionController;
    const documentElement = _dom_adapter.default.getDocumentElement();
    const isVisualContainerWindow = (0, _type.isWindow)($visualContainer.get(0));
    const wrapperWidth = isVisualContainerWindow ? documentElement.clientWidth : (0, _size.getOuterWidth)($visualContainer);
    const wrapperHeight = isVisualContainerWindow ? window.innerHeight : (0, _size.getOuterHeight)($visualContainer);
    this._$wrapper.css({
      width: wrapperWidth,
      height: wrapperHeight
    });
  },
  _renderDimensions() {
    const content = this._$content.get(0);
    this._$content.css({
      minWidth: this._getOptionValue('minWidth', content),
      maxWidth: this._getOptionValue('maxWidth', content),
      minHeight: this._getOptionValue('minHeight', content),
      maxHeight: this._getOptionValue('maxHeight', content),
      width: this._getOptionValue('width', content),
      height: this._getOptionValue('height', content)
    });
  },
  _focusTarget() {
    return this._$content;
  },
  _attachKeyboardEvents() {
    this._keyboardListenerId = _short.keyboard.on(this._$content, null, opts => this._keyboardHandler(opts));
  },
  _keyboardHandler(options) {
    const e = options.originalEvent;
    const $target = (0, _renderer.default)(e.target);
    if ($target.is(this._$content) || !this.option('ignoreChildEvents')) {
      this.callBase(...arguments);
    }
  },
  _isVisible() {
    return this.option('visible');
  },
  _visibilityChanged(visible) {
    if (visible) {
      if (this.option('visible')) {
        this._renderVisibilityAnimate(visible);
      }
    } else {
      this._renderVisibilityAnimate(visible);
    }
  },
  _dimensionChanged() {
    this._renderGeometry();
  },
  _clean() {
    const options = this.option();
    if (!this._contentAlreadyRendered && !options.isRenovated) {
      this.$content().empty();
    }
    this._renderVisibility(false);
    this._stopShowTimer();
    this._cleanFocusState();
  },
  _stopShowTimer() {
    if (this._asyncShowTimeout) {
      clearTimeout(this._asyncShowTimeout);
    }
    this._asyncShowTimeout = null;
  },
  _dispose() {
    _fx.default.stop(this._$content, false);
    clearTimeout(this._deferShowTimer);
    this._toggleViewPortSubscription(false);
    this._toggleSubscriptions(false);
    this._updateZIndexStackPosition(false);
    this._toggleTabTerminator(false);
    this._actions = null;
    this._parentsScrollSubscriptionInfo = null;
    this.callBase();
    this._toggleSafariScrolling();
    this.option('visible') && zIndexPool.remove(this._zIndex);
    this._$wrapper.remove();
    this._$content.remove();
  },
  _toggleRTLDirection(rtl) {
    this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl);
  },
  _optionChanged(args) {
    const {
      value,
      name
    } = args;
    if (this._getActionsList().includes(name)) {
      this._initActions();
      return;
    }
    switch (name) {
      case 'animation':
        break;
      case 'shading':
        this._toggleShading(this.option('visible'));
        this._toggleSafariScrolling();
        break;
      case 'shadingColor':
        this._toggleShading(this.option('visible'));
        break;
      case 'width':
      case 'height':
        this._renderGeometry();
        break;
      case 'minWidth':
      case 'maxWidth':
      case 'minHeight':
      case 'maxHeight':
        this._renderGeometry();
        break;
      case 'position':
        this._positionController.updatePosition(this.option('position'));
        this._positionController.restorePositionOnNextRender(true);
        this._renderGeometry();
        this._toggleSafariScrolling();
        break;
      case 'visible':
        this._renderVisibilityAnimate(value).done(() => {
          var _this$_animateDeferre;
          return (_this$_animateDeferre = this._animateDeferred) === null || _this$_animateDeferre === void 0 ? void 0 : _this$_animateDeferre.resolveWith(this);
        }).fail(() => {
          var _this$_animateDeferre2;
          return (_this$_animateDeferre2 = this._animateDeferred) === null || _this$_animateDeferre2 === void 0 ? void 0 : _this$_animateDeferre2.reject();
        });
        break;
      case 'container':
        this._positionController.updateContainer(value);
        this._invalidate();
        this._toggleSafariScrolling();
        break;
      case 'visualContainer':
        this._positionController.updateVisualContainer(value);
        this._renderWrapper();
        this._toggleSafariScrolling();
        break;
      case 'innerOverlay':
        this._initInnerOverlayClass();
        break;
      case 'deferRendering':
      case 'contentTemplate':
        this._contentAlreadyRendered = false;
        this._clean();
        this._invalidate();
        break;
      case 'hideTopOverlayHandler':
        this._toggleHideTopOverlayCallback(false);
        this._initHideTopOverlayHandler(value);
        this._toggleHideTopOverlayCallback(this.option('visible'));
        break;
      case 'hideOnParentScroll':
      case '_hideOnParentScrollTarget':
        this._toggleHideOnParentsScrollSubscription(this.option('visible'));
        break;
      case 'closeOnOutsideClick':
      case 'hideOnOutsideClick':
      case 'propagateOutsideClick':
        break;
      case 'rtlEnabled':
        this._contentAlreadyRendered = false;
        this.callBase(args);
        break;
      case '_fixWrapperPosition':
        this._positionController.fixWrapperPosition = value;
        break;
      case 'wrapperAttr':
        this._renderWrapperAttributes();
        break;
      case 'restorePosition':
        this._positionController.restorePosition = value;
        break;
      case 'preventScrollEvents':
        this._logDeprecatedPreventScrollEventsInfo();
        this._toggleWrapperScrollEventsSubscription(value);
        break;
      default:
        this.callBase(args);
    }
  },
  toggle(showing) {
    showing = showing === undefined ? !this.option('visible') : showing;
    const result = (0, _deferred.Deferred)();
    if (showing === this.option('visible')) {
      return result.resolveWith(this, [showing]).promise();
    }
    const animateDeferred = (0, _deferred.Deferred)();
    this._animateDeferred = animateDeferred;
    this.option('visible', showing);
    animateDeferred.promise()
    // @ts-expect-error
    .done(() => {
      delete this._animateDeferred;
      result.resolveWith(this, [this.option('visible')]);
    }).fail(() => {
      delete this._animateDeferred;
      result.reject();
    });
    return result.promise();
  },
  $content() {
    return this._$content;
  },
  show() {
    return this.toggle(true);
  },
  hide() {
    return this.toggle(false);
  },
  content() {
    return (0, _element.getPublicElement)(this._$content);
  },
  repaint() {
    if (this._contentAlreadyRendered) {
      this._positionController.restorePositionOnNextRender(true);
      this._renderGeometry({
        forceStopAnimation: true
      });
      (0, _visibility_change.triggerResizeEvent)(this._$content);
    } else {
      this.callBase();
    }
  }
});
// @ts-expect-error
Overlay.baseZIndex = zIndex => zIndexPool.base(zIndex);
(0, _component_registrator.default)('dxOverlay', Overlay);
var _default = exports["default"] = Overlay;

/***/ }),

/***/ 11346:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OverlayPositionController = exports.OVERLAY_POSITION_ALIASES = void 0;
var _position = _interopRequireDefault(__webpack_require__(49387));
var _translator = __webpack_require__(31648);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _swatch_container = _interopRequireDefault(__webpack_require__(92591));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const OVERLAY_POSITION_ALIASES = exports.OVERLAY_POSITION_ALIASES = {
  top: {
    my: 'top center',
    at: 'top center'
  },
  bottom: {
    my: 'bottom center',
    at: 'bottom center'
  },
  right: {
    my: 'right center',
    at: 'right center'
  },
  left: {
    my: 'left center',
    at: 'left center'
  },
  center: {
    my: 'center',
    at: 'center'
  },
  'right bottom': {
    my: 'right bottom',
    at: 'right bottom'
  },
  'right top': {
    my: 'right top',
    at: 'right top'
  },
  'left bottom': {
    my: 'left bottom',
    at: 'left bottom'
  },
  'left top': {
    my: 'left top',
    at: 'left top'
  }
};
const OVERLAY_DEFAULT_BOUNDARY_OFFSET = {
  h: 0,
  v: 0
};
class OverlayPositionController {
  constructor(_ref) {
    let {
      position,
      container,
      visualContainer,
      $root,
      $content,
      $wrapper,
      onPositioned,
      onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    } = _ref;
    this._props = {
      position,
      container,
      visualContainer,
      restorePosition,
      onPositioned,
      onVisualPositionChanged,
      _fixWrapperPosition,
      _skipContentPositioning
    };
    this._$root = $root;
    this._$content = $content;
    this._$wrapper = $wrapper;
    this._$markupContainer = undefined;
    this._$visualContainer = undefined;
    this._shouldRenderContentInitialPosition = true;
    this._visualPosition = undefined;
    this._initialPosition = undefined;
    this._previousVisualPosition = undefined;
    this.updateContainer(container);
    this.updatePosition(position);
    this.updateVisualContainer(visualContainer);
  }
  get $container() {
    this.updateContainer(); // NOTE: swatch classes can be updated runtime
    return this._$markupContainer;
  }
  get $visualContainer() {
    return this._$visualContainer;
  }
  get position() {
    return this._position;
  }
  set fixWrapperPosition(fixWrapperPosition) {
    this._props._fixWrapperPosition = fixWrapperPosition;
    this.styleWrapperPosition();
  }
  set restorePosition(restorePosition) {
    this._props.restorePosition = restorePosition;
  }
  restorePositionOnNextRender(value) {
    // NOTE: no visual position means it's a first render
    this._shouldRenderContentInitialPosition = value || !this._visualPosition;
  }
  openingHandled() {
    const shouldRestorePosition = this._props.restorePosition;
    this.restorePositionOnNextRender(shouldRestorePosition);
  }
  updatePosition(positionProp) {
    this._props.position = positionProp;
    this._position = this._normalizePosition(positionProp);
    this.updateVisualContainer();
  }
  updateContainer() {
    let containerProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._props.container;
    this._props.container = containerProp;
    this._$markupContainer = containerProp ? (0, _renderer.default)(containerProp) : _swatch_container.default.getSwatchContainer(this._$root);
    this.updateVisualContainer(this._props.visualContainer);
  }
  updateVisualContainer() {
    let visualContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._props.visualContainer;
    this._props.visualContainer = visualContainer;
    this._$visualContainer = this._getVisualContainer();
  }
  detectVisualPositionChange(event) {
    this._updateVisualPositionValue();
    this._raisePositionedEvents(event);
  }
  positionContent() {
    if (this._shouldRenderContentInitialPosition) {
      this._renderContentInitialPosition();
    } else {
      (0, _translator.move)(this._$content, this._visualPosition);
      this.detectVisualPositionChange();
    }
  }
  positionWrapper() {
    if (this._$visualContainer) {
      // @ts-expect-error
      _position.default.setup(this._$wrapper, {
        my: 'top left',
        at: 'top left',
        of: this._$visualContainer
      });
    }
  }
  styleWrapperPosition() {
    // @ts-expect-error
    const useFixed = (0, _type.isWindow)(this.$visualContainer.get(0)) || this._props._fixWrapperPosition;
    const positionStyle = useFixed ? 'fixed' : 'absolute';
    this._$wrapper.css('position', positionStyle);
  }
  _updateVisualPositionValue() {
    this._previousVisualPosition = this._visualPosition;
    this._visualPosition = (0, _translator.locate)(this._$content);
  }
  _renderContentInitialPosition() {
    this._renderBoundaryOffset();
    (0, _translator.resetPosition)(this._$content);
    // @ts-expect-error
    const wrapperOverflow = this._$wrapper.css('overflow');
    this._$wrapper.css('overflow', 'hidden');
    if (!this._props._skipContentPositioning) {
      // @ts-expect-error
      const resultPosition = _position.default.setup(this._$content, this._position);
      this._initialPosition = resultPosition;
    }
    // @ts-expect-error
    this._$wrapper.css('overflow', wrapperOverflow);
    this.detectVisualPositionChange();
  }
  _raisePositionedEvents(event) {
    const previousPosition = this._previousVisualPosition;
    const newPosition = this._visualPosition;
    const isVisualPositionChanged = (previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition.top) !== newPosition.top || (previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition.left) !== newPosition.left;
    if (isVisualPositionChanged) {
      this._props.onVisualPositionChanged({
        previousPosition,
        position: newPosition,
        event
      });
    }
    this._props.onPositioned({
      position: this._initialPosition
    });
  }
  _renderBoundaryOffset() {
    const boundaryOffset = this._position ?? {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    this._$content.css('margin', `${boundaryOffset.v}px ${boundaryOffset.h}px`);
  }
  _getVisualContainer() {
    var _this$_props$position, _this$_props$position2;
    const containerProp = this._props.container;
    const visualContainerProp = this._props.visualContainer;
    const positionOf = (0, _type.isEvent)((_this$_props$position = this._props.position) === null || _this$_props$position === void 0 ? void 0 : _this$_props$position.of) ? this._props.position.of.target : (_this$_props$position2 = this._props.position) === null || _this$_props$position2 === void 0 ? void 0 : _this$_props$position2.of;
    if (visualContainerProp) {
      return (0, _renderer.default)(visualContainerProp);
    }
    if (containerProp) {
      return (0, _renderer.default)(containerProp);
    }
    if (positionOf) {
      return (0, _renderer.default)(positionOf);
    }
    // @ts-expect-error
    return (0, _renderer.default)(window);
  }
  _normalizePosition(positionProp) {
    const defaultPositionConfig = {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    if ((0, _type.isDefined)(positionProp)) {
      return (0, _extend.extend)(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    }
    return defaultPositionConfig;
  }
  _positionToObject(position) {
    if ((0, _type.isString)(position)) {
      return (0, _extend.extend)({}, OVERLAY_POSITION_ALIASES[position]);
    }
    return position;
  }
}
exports.OverlayPositionController = OverlayPositionController;

/***/ }),

/***/ 16230:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.remove = exports.isLastZIndexInStack = exports.create = exports.clearStack = exports.base = void 0;
var _common = __webpack_require__(20576);
let baseZIndex = 1500;
let zIndexStack = [];
const base = ZIndex => {
  baseZIndex = (0, _common.ensureDefined)(ZIndex, baseZIndex);
  return baseZIndex;
};
exports.base = base;
const create = function () {
  let baseIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : baseZIndex;
  const {
    length
  } = zIndexStack;
  const index = (length ? zIndexStack[length - 1] : baseIndex) + 1;
  zIndexStack.push(index);
  return index;
};
exports.create = create;
const remove = zIndex => {
  const position = zIndexStack.indexOf(zIndex);
  if (position >= 0) {
    zIndexStack.splice(position, 1);
  }
};
exports.remove = remove;
const isLastZIndexInStack = zIndex => zIndexStack.length && zIndexStack[zIndexStack.length - 1] === zIndex;
exports.isLastZIndexInStack = isLastZIndexInStack;
const clearStack = () => {
  zIndexStack = [];
};
exports.clearStack = clearStack;

/***/ }),

/***/ 13707:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _frame = __webpack_require__(90057);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  abstract
} = _class.default;
const Animator = _class.default.inherit({
  ctor() {
    this._finished = true;
    this._stopped = false;
    this._proxiedStepCore = this._stepCore.bind(this);
  },
  start() {
    this._stopped = false;
    this._finished = false;
    this._stepCore();
  },
  stop() {
    this._stopped = true;
    (0, _frame.cancelAnimationFrame)(this._stepAnimationFrame);
  },
  _stepCore() {
    if (this._isStopped()) {
      this._stop();
      return;
    }
    if (this._isFinished()) {
      this._finished = true;
      this._complete();
      return;
    }
    this._step();
    this._stepAnimationFrame = (0, _frame.requestAnimationFrame)(this._proxiedStepCore);
  },
  _step: abstract,
  _isFinished: _common.noop,
  _stop: _common.noop,
  _complete: _common.noop,
  _isStopped() {
    return this._stopped;
  },
  inProgress() {
    return !(this._stopped || this._finished);
  }
});
var _default = exports["default"] = Animator;

/***/ }),

/***/ 79521:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _element = __webpack_require__(6415);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _load_panel = _interopRequireDefault(__webpack_require__(97218));
var _themes = __webpack_require__(75811);
var _m_scroll_viewNative = _interopRequireDefault(__webpack_require__(67398));
var _m_scroll_viewNative2 = _interopRequireDefault(__webpack_require__(59550));
var _m_scroll_view = _interopRequireDefault(__webpack_require__(53864));
var _m_scrollable = _interopRequireDefault(__webpack_require__(18650));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SCROLLVIEW_CLASS = 'dx-scrollview';
const SCROLLVIEW_CONTENT_CLASS = `${SCROLLVIEW_CLASS}-content`;
const SCROLLVIEW_TOP_POCKET_CLASS = `${SCROLLVIEW_CLASS}-top-pocket`;
const SCROLLVIEW_BOTTOM_POCKET_CLASS = `${SCROLLVIEW_CLASS}-bottom-pocket`;
const SCROLLVIEW_PULLDOWN_CLASS = `${SCROLLVIEW_CLASS}-pull-down`;
const SCROLLVIEW_REACHBOTTOM_CLASS = `${SCROLLVIEW_CLASS}-scrollbottom`;
const SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = `${SCROLLVIEW_REACHBOTTOM_CLASS}-indicator`;
const SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = `${SCROLLVIEW_REACHBOTTOM_CLASS}-text`;
const SCROLLVIEW_LOADPANEL = `${SCROLLVIEW_CLASS}-loadpanel`;
const refreshStrategies = {
  pullDown: _m_scroll_viewNative.default,
  swipeDown: _m_scroll_viewNative2.default,
  simulated: _m_scroll_view.default
};
const isServerSide = !(0, _window.hasWindow)();
const scrollViewServerConfig = {
  finishLoading: _common.noop,
  release: _common.noop,
  refresh: _common.noop,
  scrollOffset: () => ({
    top: 0,
    left: 0
  }),
  _optionChanged(args) {
    if (args.name !== 'onUpdated') {
      return this.callBase.apply(this, arguments);
    }
  }
};
const ScrollView = _m_scrollable.default.inherit(isServerSide ? scrollViewServerConfig : {
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      pullingDownText: _message.default.format('dxScrollView-pullingDownText'),
      pulledDownText: _message.default.format('dxScrollView-pulledDownText'),
      refreshingText: _message.default.format('dxScrollView-refreshingText'),
      reachBottomText: _message.default.format('dxScrollView-reachBottomText'),
      onPullDown: null,
      onReachBottom: null,
      refreshStrategy: 'pullDown'
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat([{
      device() {
        const realDevice = _devices.default.real();
        return realDevice.platform === 'android';
      },
      options: {
        refreshStrategy: 'swipeDown'
      }
    }, {
      device() {
        // @ts-expect-error
        return (0, _themes.isMaterialBased)();
      },
      options: {
        pullingDownText: '',
        pulledDownText: '',
        refreshingText: '',
        reachBottomText: ''
      }
    }]);
  },
  _init() {
    this.callBase();
    this._loadingIndicatorEnabled = true;
  },
  _initScrollableMarkup() {
    this.callBase();
    this.$element().addClass(SCROLLVIEW_CLASS);
    this._initContent();
    this._initTopPocket();
    this._initBottomPocket();
    this._initLoadPanel();
  },
  _initContent() {
    const $content = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_CONTENT_CLASS);
    this._$content.wrapInner($content);
  },
  _initTopPocket() {
    const $topPocket = this._$topPocket = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_TOP_POCKET_CLASS);
    const $pullDown = this._$pullDown = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_CLASS);
    $topPocket.append($pullDown);
    this._$content.prepend($topPocket);
  },
  _initBottomPocket() {
    const $bottomPocket = this._$bottomPocket = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS);
    const $reachBottom = this._$reachBottom = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_REACHBOTTOM_CLASS);
    const $loadContainer = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS);
    // @ts-expect-error
    const $loadIndicator = new _load_indicator.default((0, _renderer.default)('<div>')).$element();
    const $text = this._$reachBottomText = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
    this._updateReachBottomText();
    $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
    $bottomPocket.append($reachBottom);
    this._$content.append($bottomPocket);
  },
  _initLoadPanel() {
    const $loadPanelElement = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
    const loadPanelOptions = {
      shading: false,
      delay: 400,
      message: this.option('refreshingText'),
      position: {
        of: this.$element()
      }
    };
    this._loadPanel = this._createComponent($loadPanelElement, _load_panel.default, loadPanelOptions);
  },
  _updateReachBottomText() {
    this._$reachBottomText.text(this.option('reachBottomText'));
  },
  _createStrategy() {
    const strategyName = this.option('useNative') ? this.option('refreshStrategy') : 'simulated';
    const strategyClass = refreshStrategies[strategyName];
    // eslint-disable-next-line new-cap
    this._strategy = new strategyClass(this);
    this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
    this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
    this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
  },
  _createActions() {
    this.callBase();
    this._pullDownAction = this._createActionByOption('onPullDown');
    this._reachBottomAction = this._createActionByOption('onReachBottom');
    this._tryRefreshPocketState();
  },
  _tryRefreshPocketState() {
    this._pullDownEnable(this.hasActionSubscription('onPullDown'));
    this._reachBottomEnable(this.hasActionSubscription('onReachBottom'));
  },
  on(eventName) {
    const result = this.callBase.apply(this, arguments);
    if (eventName === 'pullDown' || eventName === 'reachBottom') {
      this._tryRefreshPocketState();
    }
    return result;
  },
  _pullDownEnable(enabled) {
    if (arguments.length === 0) {
      return this._pullDownEnabled;
    }
    if (this._$pullDown && this._strategy) {
      this._$pullDown.toggle(enabled);
      this._strategy.pullDownEnable(enabled);
      this._pullDownEnabled = enabled;
    }
  },
  _reachBottomEnable(enabled) {
    if (arguments.length === 0) {
      return this._reachBottomEnabled;
    }
    if (this._$reachBottom && this._strategy) {
      this._$reachBottom.toggle(enabled);
      this._strategy.reachBottomEnable(enabled);
      this._reachBottomEnabled = enabled;
    }
  },
  _pullDownHandler() {
    this._loadingIndicator(false);
    this._pullDownLoading();
  },
  _loadingIndicator(value) {
    if (arguments.length < 1) {
      return this._loadingIndicatorEnabled;
    }
    this._loadingIndicatorEnabled = value;
  },
  _pullDownLoading() {
    this.startLoading();
    this._pullDownAction();
  },
  _reachBottomHandler() {
    this._loadingIndicator(false);
    this._reachBottomLoading();
  },
  _reachBottomLoading() {
    this.startLoading();
    this._reachBottomAction();
  },
  _releaseHandler() {
    this.finishLoading();
    this._loadingIndicator(true);
  },
  _optionChanged(args) {
    switch (args.name) {
      case 'onPullDown':
      case 'onReachBottom':
        this._createActions();
        break;
      case 'pullingDownText':
      case 'pulledDownText':
      case 'refreshingText':
      case 'refreshStrategy':
        this._invalidate();
        break;
      case 'reachBottomText':
        this._updateReachBottomText();
        break;
      default:
        this.callBase(args);
    }
  },
  content() {
    return (0, _element.getPublicElement)(this._$content.children().eq(1));
  },
  release(preventReachBottom) {
    if (preventReachBottom !== undefined) {
      this.toggleLoading(!preventReachBottom);
    }
    return this._strategy.release();
  },
  toggleLoading(showOrHide) {
    this._reachBottomEnable(showOrHide);
  },
  refresh() {
    if (!this.hasActionSubscription('onPullDown')) {
      return;
    }
    this._strategy.pendingRelease();
    this._pullDownLoading();
  },
  startLoading() {
    if (this._loadingIndicator() && this.$element().is(':visible')) {
      this._loadPanel.show();
    }
    this._lock();
  },
  finishLoading() {
    this._loadPanel.hide();
    this._unlock();
  },
  _dispose() {
    this._strategy.dispose();
    this.callBase();
    if (this._loadPanel) {
      this._loadPanel.$element().remove();
    }
  }
});
(0, _component_registrator.default)('dxScrollView', ScrollView);
var _default = exports["default"] = ScrollView;

/***/ }),

/***/ 67398:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _translator = __webpack_require__(31648);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _deferred = __webpack_require__(62754);
var _iterator = __webpack_require__(95479);
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _m_scrollable = _interopRequireDefault(__webpack_require__(21606));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = 'dx-scrollview-pull-down-loading';
const SCROLLVIEW_PULLDOWN_READY_CLASS = 'dx-scrollview-pull-down-ready';
const SCROLLVIEW_PULLDOWN_IMAGE_CLASS = 'dx-scrollview-pull-down-image';
const SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = 'dx-scrollview-pull-down-indicator';
const SCROLLVIEW_PULLDOWN_TEXT_CLASS = 'dx-scrollview-pull-down-text';
const SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = 'dx-scrollview-pull-down-text-visible';
const STATE_RELEASED = 0;
const STATE_READY = 1;
const STATE_REFRESHING = 2;
const STATE_LOADING = 3;
const PULLDOWN_RELEASE_TIME = 400;
const PullDownNativeScrollViewStrategy = _m_scrollable.default.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$refreshingText = scrollView._$refreshingText;
    this._$scrollViewContent = (0, _renderer.default)(scrollView.content());
    this._$container = (0, _renderer.default)(scrollView.container());
    this._initCallbacks();
  },
  _initCallbacks() {
    this.pullDownCallbacks = (0, _callbacks.default)();
    this.releaseCallbacks = (0, _callbacks.default)();
    this.reachBottomCallbacks = (0, _callbacks.default)();
  },
  render() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown() {
    const $image = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS);
    const $loadContainer = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
    // @ts-expect-error
    const $loadIndicator = new _load_indicator.default((0, _renderer.default)('<div>')).$element();
    const $text = this._$pullDownText = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
    this._$pullingDownText = (0, _renderer.default)('<div>').text(this.option('pullingDownText')).appendTo($text);
    this._$pulledDownText = (0, _renderer.default)('<div>').text(this.option('pulledDownText')).appendTo($text);
    this._$refreshingText = (0, _renderer.default)('<div>').text(this.option('refreshingText')).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  _releaseState() {
    this._state = STATE_RELEASED;
    this._refreshPullDownText();
  },
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: STATE_RELEASED
    }, {
      element: this._$pulledDownText,
      visibleState: STATE_READY
    }, {
      element: this._$refreshingText,
      visibleState: STATE_REFRESHING
    }];
    (0, _iterator.each)(pullDownTextItems, (_, item) => {
      const action = that._state === item.visibleState ? 'addClass' : 'removeClass';
      item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS);
    });
  },
  update() {
    this.callBase();
    this._setTopPocketOffset();
  },
  _updateDimensions() {
    this.callBase();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  },
  _allowedDirections() {
    const allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  _setTopPocketOffset() {
    this._$topPocket.css({
      top: -this._topPocketSize
    });
  },
  handleEnd() {
    this.callBase();
    this._complete();
  },
  handleStop() {
    this.callBase();
    this._complete();
  },
  _complete() {
    if (this._state === STATE_READY) {
      this._setPullDownOffset(this._topPocketSize);
      clearTimeout(this._pullDownRefreshTimeout);
      this._pullDownRefreshTimeout = setTimeout(() => {
        this._pullDownRefreshing();
      }, 400);
    }
  },
  _setPullDownOffset(offset) {
    (0, _translator.move)(this._$topPocket, {
      top: offset
    });
    (0, _translator.move)(this._$scrollViewContent, {
      top: offset
    });
  },
  handleScroll(e) {
    this.callBase(e);
    // TODO: replace with disabled check
    if (this._state === STATE_REFRESHING) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = (this._location || 0) - currentLocation;
    this._location = currentLocation;
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isPullDown() {
    return this._pullDownEnabled && this._location >= this._topPocketSize;
  },
  _isReachBottom() {
    return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  },
  _reachBottom() {
    if (this._state === STATE_LOADING) {
      return;
    }
    this._state = STATE_LOADING;
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady() {
    if (this._state === STATE_READY) {
      return;
    }
    this._state = STATE_READY;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
  },
  _stateReleased() {
    if (this._state === STATE_RELEASED) {
      return;
    }
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._releaseState();
  },
  _pullDownRefreshing() {
    if (this._state === STATE_REFRESHING) {
      return;
    }
    this._state = STATE_REFRESHING;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  pullDownEnable(enabled) {
    if (enabled) {
      this._updateDimensions();
      this._setTopPocketOffset();
    }
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease() {
    this._state = STATE_READY;
  },
  release() {
    const deferred = (0, _deferred.Deferred)();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    if (this._state === STATE_LOADING) {
      this._state = STATE_RELEASED;
    }
    this._releaseTimeout = setTimeout(() => {
      this._setPullDownOffset(0);
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }, PULLDOWN_RELEASE_TIME);
    return deferred.promise();
  },
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var _default = exports["default"] = PullDownNativeScrollViewStrategy;

/***/ }),

/***/ 59550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _translator = __webpack_require__(31648);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _deferred = __webpack_require__(62754);
var _size = __webpack_require__(58664);
var _index = __webpack_require__(39611);
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _m_scrollable = _interopRequireDefault(__webpack_require__(21606));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS = 'dx-scrollview-pull-down-loading';
const SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = 'dx-scrollview-pull-down-indicator';
const SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = 'dx-scrollview-pull-down-refreshing';
const PULLDOWN_ICON_CLASS = 'dx-icon-pulldown';
const STATE_RELEASED = 0;
const STATE_READY = 1;
const STATE_REFRESHING = 2;
const STATE_TOUCHED = 4;
const STATE_PULLED = 5;
const SwipeDownNativeScrollViewStrategy = _m_scrollable.default.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$scrollViewContent = (0, _renderer.default)(scrollView.content());
    this._$container = (0, _renderer.default)(scrollView.container());
    this._initCallbacks();
    this._location = 0;
  },
  _initCallbacks() {
    this.pullDownCallbacks = (0, _callbacks.default)();
    this.releaseCallbacks = (0, _callbacks.default)();
    this.reachBottomCallbacks = (0, _callbacks.default)();
  },
  render() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown() {
    const $loadContainer = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
    // @ts-expect-error
    const $loadIndicator = new _load_indicator.default((0, _renderer.default)('<div>')).$element();
    this._$icon = (0, _renderer.default)('<div>').addClass(PULLDOWN_ICON_CLASS);
    this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator));
  },
  _releaseState() {
    this._state = STATE_RELEASED;
    this._releasePullDown();
    this._updateDimensions();
  },
  _releasePullDown() {
    this._$pullDown.css({
      opacity: 0
    });
  },
  _updateDimensions() {
    this.callBase();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  },
  _allowedDirections() {
    const allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  handleInit(e) {
    this.callBase(e);
    if (this._state === STATE_RELEASED && this._location === 0) {
      this._startClientY = (0, _index.eventData)(e.originalEvent).y;
      this._state = STATE_TOUCHED;
    }
  },
  handleMove(e) {
    this.callBase(e);
    this._deltaY = (0, _index.eventData)(e.originalEvent).y - this._startClientY;
    if (this._state === STATE_TOUCHED) {
      if (this._pullDownEnabled && this._deltaY > 0) {
        this._state = STATE_PULLED;
      } else {
        this._complete();
      }
    }
    if (this._state === STATE_PULLED) {
      e.preventDefault();
      this._movePullDown();
    }
  },
  _movePullDown() {
    const pullDownHeight = this._getPullDownHeight();
    const top = Math.min(pullDownHeight * 3, this._deltaY + this._getPullDownStartPosition());
    const angle = 180 * top / pullDownHeight / 3;
    this._$pullDown.css({
      opacity: 1
    }).toggleClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS, top < pullDownHeight);
    (0, _translator.move)(this._$pullDown, {
      top
    });
    this._$icon.css({
      transform: `rotate(${angle}deg)`
    });
  },
  _isPullDown() {
    return this._pullDownEnabled && this._state === STATE_PULLED && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
  },
  _getPullDownHeight() {
    return Math.round((0, _size.getOuterHeight)(this._$element) * 0.05);
  },
  _getPullDownStartPosition() {
    return -Math.round((0, _size.getOuterHeight)(this._$pullDown) * 1.5);
  },
  handleEnd() {
    if (this._isPullDown()) {
      this._pullDownRefreshing();
    }
    this._complete();
  },
  handleStop() {
    this._complete();
  },
  _complete() {
    if (this._state === STATE_TOUCHED || this._state === STATE_PULLED) {
      this._releaseState();
    }
  },
  handleScroll(e) {
    this.callBase(e);
    // TODO: replace with disabled check
    if (this._state === STATE_REFRESHING) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = this._location - currentLocation;
    this._location = currentLocation;
    if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isReachBottom() {
    return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  },
  _reachBottom() {
    this.reachBottomCallbacks.fire();
  },
  _stateReleased() {
    if (this._state === STATE_RELEASED) {
      return;
    }
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
    this._releaseState();
  },
  _pullDownRefreshing() {
    this._state = STATE_REFRESHING;
    this._pullDownRefreshHandler();
  },
  _pullDownRefreshHandler() {
    this._refreshPullDown();
    this.pullDownCallbacks.fire();
  },
  _refreshPullDown() {
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
    (0, _translator.move)(this._$pullDown, {
      top: this._getPullDownHeight()
    });
  },
  pullDownEnable(enabled) {
    this._$topPocket.toggle(enabled);
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease() {
    this._state = STATE_READY;
  },
  release() {
    const deferred = (0, _deferred.Deferred)();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    this._releaseTimeout = setTimeout(() => {
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }, 800);
    return deferred.promise();
  },
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var _default = exports["default"] = SwipeDownNativeScrollViewStrategy;

/***/ }),

/***/ 53864:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _size = __webpack_require__(58664);
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _m_scrollable = __webpack_require__(56729);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

const math = Math;
const SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = 'dx-scrollview-pull-down-loading';
const SCROLLVIEW_PULLDOWN_READY_CLASS = 'dx-scrollview-pull-down-ready';
const SCROLLVIEW_PULLDOWN_IMAGE_CLASS = 'dx-scrollview-pull-down-image';
const SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = 'dx-scrollview-pull-down-indicator';
const SCROLLVIEW_PULLDOWN_TEXT_CLASS = 'dx-scrollview-pull-down-text';
const SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = 'dx-scrollview-pull-down-text-visible';
const STATE_RELEASED = 0;
const STATE_READY = 1;
const STATE_REFRESHING = 2;
const STATE_LOADING = 3;
const ScrollViewScroller = _m_scrollable.Scroller.inherit({
  ctor() {
    this._topPocketSize = 0;
    this._bottomPocketSize = 0;
    this.callBase.apply(this, arguments);
    this._initCallbacks();
    this._releaseState();
  },
  _releaseState() {
    this._state = STATE_RELEASED;
    this._refreshPullDownText();
  },
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: STATE_RELEASED
    }, {
      element: this._$pulledDownText,
      visibleState: STATE_READY
    }, {
      element: this._$refreshingText,
      visibleState: STATE_REFRESHING
    }];
    (0, _iterator.each)(pullDownTextItems, (_, item) => {
      const action = that._state === item.visibleState ? 'addClass' : 'removeClass';
      item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS);
    });
  },
  _initCallbacks() {
    this.pullDownCallbacks = (0, _callbacks.default)();
    this.releaseCallbacks = (0, _callbacks.default)();
    this.reachBottomCallbacks = (0, _callbacks.default)();
  },
  _updateBounds() {
    const considerPockets = this._direction !== 'horizontal';
    if (considerPockets) {
      this._topPocketSize = this._$topPocket.get(0).clientHeight;
      this._bottomPocketSize = this._$bottomPocket.get(0).clientHeight;
      const containerEl = this._$container.get(0);
      const contentEl = this._$content.get(0);
      this._bottomBoundary = Math.max(contentEl.clientHeight - this._bottomPocketSize - containerEl.clientHeight, 0);
    }
    this.callBase();
  },
  _updateScrollbar() {
    this._scrollbar.option({
      containerSize: this._containerSize(),
      contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
      scaleRatio: this._getScaleRatio()
    });
  },
  _moveContent() {
    this.callBase();
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (this._isReachBottom()) {
      this._reachBottomReady();
    } else if (this._state !== STATE_RELEASED) {
      this._stateReleased();
    }
  },
  _moveScrollbar() {
    this._scrollbar.moveTo(this._topPocketSize + this._location);
  },
  _isPullDown() {
    return this._pullDownEnabled && this._location >= 0;
  },
  _isReachBottom() {
    const containerEl = this._$container.get(0);
    return this._reachBottomEnabled && Math.round(this._bottomBoundary - Math.ceil(containerEl.scrollTop)) <= 1;
  },
  _scrollComplete() {
    if (this._inBounds() && this._state === STATE_READY) {
      this._pullDownRefreshing();
    } else if (this._inBounds() && this._state === STATE_LOADING) {
      this._reachBottomLoading();
    } else {
      this.callBase();
    }
  },
  _reachBottomReady() {
    if (this._state === STATE_LOADING) {
      return;
    }
    this._state = STATE_LOADING;
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset() {
    return -this._topPocketSize;
  },
  _getMinOffset() {
    return math.min(this.callBase(), -this._topPocketSize);
  },
  _reachBottomLoading() {
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady() {
    if (this._state === STATE_READY) {
      return;
    }
    this._state = STATE_READY;
    this._maxOffset = 0;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
  },
  _stateReleased() {
    if (this._state === STATE_RELEASED) {
      return;
    }
    this._releaseState();
    this._updateBounds();
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this.releaseCallbacks.fire();
  },
  _pullDownRefreshing() {
    if (this._state === STATE_REFRESHING) {
      return;
    }
    this._state = STATE_REFRESHING;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  _releaseHandler() {
    if (this._state === STATE_RELEASED) {
      this._moveToBounds();
    }
    this._update();
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this._releaseTask = (0, _common.executeAsync)(this._release.bind(this));
    return this._releaseTask.promise;
  },
  _release() {
    this._stateReleased();
    this._scrollComplete();
  },
  _reachBottomEnablingHandler(enabled) {
    if (this._reachBottomEnabled === enabled) {
      return;
    }
    this._reachBottomEnabled = enabled;
    this._updateBounds();
  },
  _pullDownEnablingHandler(enabled) {
    if (this._pullDownEnabled === enabled) {
      return;
    }
    this._pullDownEnabled = enabled;
    this._considerTopPocketChange();
    this._updateHandler();
  },
  _considerTopPocketChange() {
    this._location -= (0, _size.getHeight)(this._$topPocket) || -this._topPocketSize;
    this._maxOffset = 0;
    this._move();
  },
  _pendingReleaseHandler() {
    this._state = STATE_READY;
  },
  dispose() {
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this.callBase();
  }
});
const SimulatedScrollViewStrategy = _m_scrollable.SimulatedStrategy.inherit({
  _init(scrollView) {
    this.callBase(scrollView);
    this._$pullDown = scrollView._$pullDown;
    this._$topPocket = scrollView._$topPocket;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._initCallbacks();
  },
  _initCallbacks() {
    this.pullDownCallbacks = (0, _callbacks.default)();
    this.releaseCallbacks = (0, _callbacks.default)();
    this.reachBottomCallbacks = (0, _callbacks.default)();
  },
  render() {
    this._renderPullDown();
    this.callBase();
  },
  _renderPullDown() {
    const $image = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS);
    const $loadContainer = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
    // @ts-expect-error
    const $loadIndicator = new _load_indicator.default((0, _renderer.default)('<div>')).$element();
    const $text = this._$pullDownText = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
    this._$pullingDownText = (0, _renderer.default)('<div>').text(this.option('pullingDownText')).appendTo($text);
    this._$pulledDownText = (0, _renderer.default)('<div>').text(this.option('pulledDownText')).appendTo($text);
    this._$refreshingText = (0, _renderer.default)('<div>').text(this.option('refreshingText')).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  pullDownEnable(enabled) {
    this._eventHandler('pullDownEnabling', enabled);
  },
  reachBottomEnable(enabled) {
    this._eventHandler('reachBottomEnabling', enabled);
  },
  _createScroller(direction) {
    const that = this;
    const scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
    // @ts-expect-error
    scroller.pullDownCallbacks.add(() => {
      that.pullDownCallbacks.fire();
    });
    // @ts-expect-error
    scroller.releaseCallbacks.add(() => {
      that.releaseCallbacks.fire();
    });
    // @ts-expect-error
    scroller.reachBottomCallbacks.add(() => {
      that.reachBottomCallbacks.fire();
    });
  },
  _scrollerOptions(direction) {
    return (0, _extend.extend)(this.callBase(direction), {
      $topPocket: this._$topPocket,
      $bottomPocket: this._$bottomPocket,
      $pullDown: this._$pullDown,
      $pullDownText: this._$pullDownText,
      $pullingDownText: this._$pullingDownText,
      $pulledDownText: this._$pulledDownText,
      $refreshingText: this._$refreshingText
    });
  },
  pendingRelease() {
    this._eventHandler('pendingRelease');
  },
  release() {
    return this._eventHandler('release').done(this._updateAction);
  },
  location() {
    const location = this.callBase();
    location.top += (0, _size.getHeight)(this._$topPocket);
    return location;
  },
  dispose() {
    (0, _iterator.each)(this._scrollers, function () {
      this.dispose();
    });
    this.callBase();
  }
});
var _default = exports["default"] = SimulatedScrollViewStrategy;

/***/ }),

/***/ 12457:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.deviceDependentOptions = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _support = __webpack_require__(60137);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const deviceDependentOptions = function () {
  return [{
    device() {
      return !_support.nativeScrolling;
    },
    options: {
      useNative: false
    }
  }, {
    device(device) {
      return !_devices.default.isSimulator() && _devices.default.real().deviceType === 'desktop' && device.platform === 'generic';
    },
    options: {
      bounceEnabled: false,
      scrollByThumb: true,
      scrollByContent: _support.touch,
      showScrollbar: 'onHover'
    }
  }];
};
exports.deviceDependentOptions = deviceDependentOptions;

/***/ }),

/***/ 18650:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _element = __webpack_require__(6415);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _browser = _interopRequireDefault(__webpack_require__(47810));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _size = __webpack_require__(58664);
var _support = __webpack_require__(60137);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _emitterGesture = _interopRequireDefault(__webpack_require__(37334));
var _index = __webpack_require__(39611);
var _get_element_location_internal = __webpack_require__(60650);
var _m_scrollable = __webpack_require__(12457);
var _m_scrollable2 = _interopRequireDefault(__webpack_require__(21606));
var _m_scrollable3 = __webpack_require__(56729);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SCROLLABLE = 'dxScrollable';
const SCROLLABLE_STRATEGY = 'dxScrollableStrategy';
const SCROLLABLE_CLASS = 'dx-scrollable';
const SCROLLABLE_DISABLED_CLASS = 'dx-scrollable-disabled';
const SCROLLABLE_CONTAINER_CLASS = 'dx-scrollable-container';
const SCROLLABLE_WRAPPER_CLASS = 'dx-scrollable-wrapper';
const SCROLLABLE_CONTENT_CLASS = 'dx-scrollable-content';
const VERTICAL = 'vertical';
const HORIZONTAL = 'horizontal';
const BOTH = 'both';
const Scrollable = _dom_component.default.inherit({
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      disabled: false,
      onScroll: null,
      direction: VERTICAL,
      showScrollbar: 'onScroll',
      useNative: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      onUpdated: null,
      onStart: null,
      onEnd: null,
      onBounce: null,
      useSimulatedScrollbar: false,
      useKeyboard: true,
      inertiaEnabled: true,
      updateManually: false,
      _onVisibilityChanged: _common.noop
    });
  },
  _defaultOptionsRules() {
    return this.callBase().concat((0, _m_scrollable.deviceDependentOptions)(), [{
      device() {
        return _support.nativeScrolling && _devices.default.real().platform === 'android' && !_browser.default.mozilla;
      },
      options: {
        useSimulatedScrollbar: true
      }
    }]);
  },
  _initOptions(options) {
    this.callBase(options);
    if (!('useSimulatedScrollbar' in options)) {
      this._setUseSimulatedScrollbar();
    }
  },
  _setUseSimulatedScrollbar() {
    if (!this.initialOption('useSimulatedScrollbar')) {
      this.option('useSimulatedScrollbar', !this.option('useNative'));
    }
  },
  _init() {
    this.callBase();
    this._initScrollableMarkup();
    this._locked = false;
  },
  _visibilityChanged(visible) {
    if (visible) {
      this.update();
      this._updateRtlPosition();
      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
      delete this._savedScrollOffset;
      this.option('_onVisibilityChanged')(this);
    } else {
      this._savedScrollOffset = this.scrollOffset();
    }
  },
  _initScrollableMarkup() {
    const $element = this.$element().addClass(SCROLLABLE_CLASS);
    const $container = this._$container = (0, _renderer.default)('<div>').addClass(SCROLLABLE_CONTAINER_CLASS);
    const $wrapper = this._$wrapper = (0, _renderer.default)('<div>').addClass(SCROLLABLE_WRAPPER_CLASS);
    const $content = this._$content = (0, _renderer.default)('<div>').addClass(SCROLLABLE_CONTENT_CLASS);
    $content.append($element.contents()).appendTo($container);
    $container.appendTo($wrapper);
    $wrapper.appendTo($element);
  },
  _dimensionChanged() {
    this.update();
    this._updateRtlPosition();
  },
  _initMarkup() {
    this.callBase();
    this._renderDirection();
  },
  _render() {
    this._renderStrategy();
    this._attachEventHandlers();
    this._renderDisabledState();
    this._createActions();
    this.update();
    this.callBase();
    this._updateRtlPosition(true);
  },
  _updateRtlPosition(needInitializeRtlConfig) {
    this._strategy.updateRtlPosition(needInitializeRtlConfig);
  },
  _getMaxOffset() {
    const {
      scrollWidth,
      clientWidth,
      scrollHeight,
      clientHeight
    } = (0, _renderer.default)(this.container()).get(0);
    return {
      left: scrollWidth - clientWidth,
      top: scrollHeight - clientHeight
    };
  },
  _attachEventHandlers() {
    const strategy = this._strategy;
    const initEventData = {
      getDirection: strategy.getDirection.bind(strategy),
      validate: this._validate.bind(this),
      isNative: this.option('useNative'),
      scrollTarget: this._$container
    };
    _events_engine.default.off(this._$wrapper, `.${SCROLLABLE}`);
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.start, SCROLLABLE), strategy.handleStart.bind(strategy));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.move, SCROLLABLE), strategy.handleMove.bind(strategy));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.end, SCROLLABLE), strategy.handleEnd.bind(strategy));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.stop, SCROLLABLE), strategy.handleStop.bind(strategy));
    _events_engine.default.off(this._$container, `.${SCROLLABLE}`);
    _events_engine.default.on(this._$container, (0, _index.addNamespace)('scroll', SCROLLABLE), strategy.handleScroll.bind(strategy));
  },
  _validate(e) {
    if (this._isLocked()) {
      return false;
    }
    this._updateIfNeed();
    return this._moveIsAllowed(e);
  },
  _moveIsAllowed(e) {
    return this._strategy.validate(e);
  },
  handleMove(e) {
    this._strategy.handleMove(e);
  },
  _prepareDirections(value) {
    this._strategy._prepareDirections(value);
  },
  _initHandler() {
    const strategy = this._strategy;
    strategy.handleInit.apply(strategy, arguments);
  },
  _renderDisabledState() {
    this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option('disabled'));
    if (this.option('disabled')) {
      this._lock();
    } else {
      this._unlock();
    }
  },
  _renderDirection() {
    this.$element().removeClass(`dx-scrollable-${HORIZONTAL}`).removeClass(`dx-scrollable-${VERTICAL}`).removeClass(`dx-scrollable-${BOTH}`).addClass(`dx-scrollable-${this.option('direction')}`);
  },
  _renderStrategy() {
    this._createStrategy();
    this._strategy.render();
    this.$element().data(SCROLLABLE_STRATEGY, this._strategy);
  },
  _createStrategy() {
    this._strategy = this.option('useNative') ? new _m_scrollable2.default(this) : new _m_scrollable3.SimulatedStrategy(this);
  },
  _createActions() {
    this._strategy && this._strategy.createActions();
  },
  _clean() {
    this._strategy && this._strategy.dispose();
  },
  _optionChanged(args) {
    switch (args.name) {
      case 'onStart':
      case 'onEnd':
      case 'onUpdated':
      case 'onScroll':
      case 'onBounce':
        this._createActions();
        break;
      case 'direction':
        this._resetInactiveDirection();
        this._invalidate();
        break;
      case 'useNative':
        this._setUseSimulatedScrollbar();
        this._invalidate();
        break;
      case 'inertiaEnabled':
      case 'scrollByThumb':
      case 'bounceEnabled':
      case 'useKeyboard':
      case 'showScrollbar':
      case 'useSimulatedScrollbar':
        this._invalidate();
        break;
      case 'disabled':
        this._renderDisabledState();
        this._strategy && this._strategy.disabledChanged();
        break;
      case 'updateManually':
      case 'scrollByContent':
      case '_onVisibilityChanged':
        break;
      case 'width':
        this.callBase(args);
        this._updateRtlPosition();
        break;
      default:
        this.callBase(args);
    }
  },
  _resetInactiveDirection() {
    const inactiveProp = this._getInactiveProp();
    if (!inactiveProp || !(0, _window.hasWindow)()) {
      return;
    }
    const scrollOffset = this.scrollOffset();
    scrollOffset[inactiveProp] = 0;
    this.scrollTo(scrollOffset);
  },
  // @ts-expect-error
  _getInactiveProp() {
    const direction = this.option('direction');
    if (direction === VERTICAL) {
      return 'left';
    }
    if (direction === HORIZONTAL) {
      return 'top';
    }
  },
  _location() {
    return this._strategy.location();
  },
  _normalizeLocation(location) {
    if ((0, _type.isPlainObject)(location)) {
      const left = (0, _common.ensureDefined)(location.left, location.x);
      const top = (0, _common.ensureDefined)(location.top, location.y);
      return {
        left: (0, _type.isDefined)(left) ? -left : undefined,
        top: (0, _type.isDefined)(top) ? -top : undefined
      };
    }
    const direction = this.option('direction');
    return {
      left: direction !== VERTICAL ? -location : undefined,
      top: direction !== HORIZONTAL ? -location : undefined
    };
  },
  _isLocked() {
    return this._locked;
  },
  _lock() {
    this._locked = true;
  },
  _unlock() {
    if (!this.option('disabled')) {
      this._locked = false;
    }
  },
  _isDirection(direction) {
    const current = this.option('direction');
    if (direction === VERTICAL) {
      return current !== HORIZONTAL;
    }
    if (direction === HORIZONTAL) {
      return current !== VERTICAL;
    }
    return current === direction;
  },
  _updateAllowedDirection() {
    const allowedDirections = this._strategy._allowedDirections();
    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
      this._allowedDirectionValue = BOTH;
    } else if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {
      this._allowedDirectionValue = HORIZONTAL;
    } else if (this._isDirection(VERTICAL) && allowedDirections.vertical) {
      this._allowedDirectionValue = VERTICAL;
    } else {
      this._allowedDirectionValue = null;
    }
  },
  _allowedDirection() {
    return this._allowedDirectionValue;
  },
  $content() {
    return this._$content;
  },
  content() {
    return (0, _element.getPublicElement)(this._$content);
  },
  container() {
    return (0, _element.getPublicElement)(this._$container);
  },
  scrollOffset() {
    return this._strategy._getScrollOffset();
  },
  _isRtlNativeStrategy() {
    const {
      useNative,
      rtlEnabled
    } = this.option();
    return useNative && rtlEnabled;
  },
  scrollTop() {
    return this.scrollOffset().top;
  },
  scrollLeft() {
    return this.scrollOffset().left;
  },
  clientHeight() {
    return (0, _size.getHeight)(this._$container);
  },
  scrollHeight() {
    return (0, _size.getOuterHeight)(this.$content());
  },
  clientWidth() {
    return (0, _size.getWidth)(this._$container);
  },
  scrollWidth() {
    return (0, _size.getOuterWidth)(this.$content());
  },
  update() {
    if (!this._strategy) {
      return;
    }
    return (0, _deferred.when)(this._strategy.update()).done(() => {
      this._updateAllowedDirection();
    });
  },
  scrollBy(distance) {
    distance = this._normalizeLocation(distance);
    if (!distance.top && !distance.left) {
      return;
    }
    this._updateIfNeed();
    this._strategy.scrollBy(distance);
  },
  scrollTo(targetLocation) {
    targetLocation = this._normalizeLocation(targetLocation);
    this._updateIfNeed();
    let location = this._location();
    if (!this.option('useNative')) {
      targetLocation = this._strategy._applyScaleRatio(targetLocation);
      location = this._strategy._applyScaleRatio(location);
    }
    if (this._isRtlNativeStrategy()) {
      location.left -= this._getMaxOffset().left;
    }
    const distance = this._normalizeLocation({
      left: location.left - (0, _common.ensureDefined)(targetLocation.left, location.left),
      top: location.top - (0, _common.ensureDefined)(targetLocation.top, location.top)
    });
    if (!distance.top && !distance.left) {
      return;
    }
    this._strategy.scrollBy(distance);
  },
  scrollToElement(element, offset) {
    const $element = (0, _renderer.default)(element);
    const elementInsideContent = this.$content().find(element).length;
    const elementIsInsideContent = $element.parents(`.${SCROLLABLE_CLASS}`).length - $element.parents(`.${SCROLLABLE_CONTENT_CLASS}`).length === 0;
    if (!elementInsideContent || !elementIsInsideContent) {
      return;
    }
    const scrollPosition = {
      top: 0,
      left: 0
    };
    const direction = this.option('direction');
    if (direction !== VERTICAL) {
      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL, offset);
    }
    if (direction !== HORIZONTAL) {
      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL, offset);
    }
    this.scrollTo(scrollPosition);
  },
  getScrollElementPosition($element, direction, offset) {
    const scrollOffset = this.scrollOffset();
    return (0, _get_element_location_internal.getElementLocationInternal)($element.get(0), direction,
    // @ts-expect-error
    (0, _renderer.default)(this.container()).get(0), scrollOffset, offset);
  },
  _updateIfNeed() {
    if (!this.option('updateManually')) {
      this.update();
    }
  },
  _useTemplates() {
    return false;
  },
  isRenovated() {
    return !!Scrollable.IS_RENOVATED_WIDGET;
  }
});
(0, _component_registrator.default)(SCROLLABLE, Scrollable);
var _default = exports["default"] = Scrollable;

/***/ }),

/***/ 21606:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _size = __webpack_require__(58664);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
var _m_scrollbar = _interopRequireDefault(__webpack_require__(79105));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SCROLLABLE_NATIVE = 'dxNativeScrollable';
const SCROLLABLE_NATIVE_CLASS = 'dx-scrollable-native';
const SCROLLABLE_SCROLLBAR_SIMULATED = 'dx-scrollable-scrollbar-simulated';
const SCROLLABLE_SCROLLBARS_HIDDEN = 'dx-scrollable-scrollbars-hidden';
const VERTICAL = 'vertical';
const HORIZONTAL = 'horizontal';
const HIDE_SCROLLBAR_TIMEOUT = 500;
const NativeStrategy = _class.default.inherit({
  ctor(scrollable) {
    this._init(scrollable);
  },
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = (0, _renderer.default)(scrollable.container());
    this._$content = scrollable.$content();
    this._direction = scrollable.option('direction');
    this._useSimulatedScrollbar = scrollable.option('useSimulatedScrollbar');
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
    this._isRtlNativeStrategy = scrollable._isRtlNativeStrategy.bind(scrollable);
  },
  render() {
    const device = _devices.default.real();
    const deviceType = device.platform;
    this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(`${SCROLLABLE_NATIVE_CLASS}-${deviceType}`).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._isScrollbarVisible());
    if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
      this._renderScrollbars();
    }
  },
  updateRtlPosition(isFirstRender) {
    if (isFirstRender && this.option('rtlEnabled')) {
      if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
        this._moveScrollbars();
      }
    }
  },
  _renderScrollbars() {
    this._scrollbars = {};
    this._hideScrollbarTimeout = 0;
    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
    this._renderScrollbar(VERTICAL);
    this._renderScrollbar(HORIZONTAL);
  },
  _renderScrollbar(direction) {
    if (!this._isDirection(direction)) {
      return;
    }
    this._scrollbars[direction] = new _m_scrollbar.default((0, _renderer.default)('<div>').appendTo(this._$element), {
      direction,
      expandable: this._component.option('scrollByThumb')
    });
  },
  handleInit: _common.noop,
  handleStart: _common.noop,
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      return;
    }
    if (this._allowedDirection()) {
      e.originalEvent.isScrollingEvent = true;
    }
  },
  handleEnd: _common.noop,
  handleCancel: _common.noop,
  handleStop: _common.noop,
  _eachScrollbar(callback) {
    callback = callback.bind(this);
    (0, _iterator.each)(this._scrollbars || {}, (direction, scrollbar) => {
      callback(scrollbar, direction);
    });
  },
  createActions() {
    this._scrollAction = this._createActionByOption('onScroll');
    this._updateAction = this._createActionByOption('onUpdated');
  },
  _createActionArgs() {
    const {
      left,
      top
    } = this.location();
    return {
      event: this._eventForUserAction,
      scrollOffset: this._getScrollOffset(),
      reachedLeft: this._isRtlNativeStrategy() ? this._isReachedRight(-left) : this._isReachedLeft(left),
      reachedRight: this._isRtlNativeStrategy() ? this._isReachedLeft(-Math.abs(left)) : this._isReachedRight(left),
      reachedTop: this._isDirection(VERTICAL) ? Math.round(top) >= 0 : undefined,
      reachedBottom: this._isDirection(VERTICAL) ? Math.round(Math.abs(top) - this._getMaxOffset().top) >= 0 : undefined
    };
  },
  _getScrollOffset() {
    const {
      top,
      left
    } = this.location();
    return {
      top: -top,
      left: this._normalizeOffsetLeft(-left)
    };
  },
  _normalizeOffsetLeft(scrollLeft) {
    if (this._isRtlNativeStrategy()) {
      return this._getMaxOffset().left + scrollLeft;
    }
    return scrollLeft;
  },
  _isReachedLeft(left) {
    return this._isDirection(HORIZONTAL) ? Math.round(left) >= 0 : undefined;
  },
  _isReachedRight(left) {
    return this._isDirection(HORIZONTAL) ? Math.round(Math.abs(left) - this._getMaxOffset().left) >= 0 : undefined;
  },
  _isScrollbarVisible() {
    const {
      showScrollbar
    } = this.option();
    return showScrollbar !== 'never' && showScrollbar !== false;
  },
  handleScroll(e) {
    this._eventForUserAction = e;
    this._moveScrollbars();
    this._scrollAction(this._createActionArgs());
  },
  _moveScrollbars() {
    const {
      top,
      left
    } = this._getScrollOffset();
    this._eachScrollbar(scrollbar => {
      scrollbar.moveTo({
        top: -top,
        left: -left
      });
      scrollbar.option('visible', true);
    });
    this._hideScrollbars();
  },
  _hideScrollbars() {
    clearTimeout(this._hideScrollbarTimeout);
    this._hideScrollbarTimeout = setTimeout(() => {
      this._eachScrollbar(scrollbar => {
        scrollbar.option('visible', false);
      });
    }, HIDE_SCROLLBAR_TIMEOUT);
  },
  location() {
    return {
      left: -this._$container.scrollLeft(),
      top: -this._$container.scrollTop()
    };
  },
  disabledChanged: _common.noop,
  update() {
    this._update();
    this._updateAction(this._createActionArgs());
  },
  _update() {
    this._updateDimensions();
    this._updateScrollbars();
  },
  _updateDimensions() {
    this._containerSize = {
      height: (0, _size.getHeight)(this._$container),
      width: (0, _size.getWidth)(this._$container)
    };
    this._componentContentSize = {
      height: (0, _size.getHeight)(this._component.$content()),
      width: (0, _size.getWidth)(this._component.$content())
    };
    this._contentSize = {
      height: (0, _size.getHeight)(this._$content),
      width: (0, _size.getWidth)(this._$content)
    };
  },
  _updateScrollbars() {
    this._eachScrollbar(function (scrollbar, direction) {
      const dimension = direction === VERTICAL ? 'height' : 'width';
      scrollbar.option({
        containerSize: this._containerSize[dimension],
        contentSize: this._componentContentSize[dimension]
      });
      scrollbar.update();
    });
  },
  _allowedDirections() {
    return {
      vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
      horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width
    };
  },
  dispose() {
    const {
      className
    } = this._$element.get(0);
    const scrollableNativeRegexp = new RegExp(`${SCROLLABLE_NATIVE_CLASS}\\S*`, 'g');
    if (scrollableNativeRegexp.test(className)) {
      this._$element.removeClass(className.match(scrollableNativeRegexp).join(' '));
    }
    _events_engine.default.off(this._$element, `.${SCROLLABLE_NATIVE}`);
    _events_engine.default.off(this._$container, `.${SCROLLABLE_NATIVE}`);
    this._removeScrollbars();
    clearTimeout(this._hideScrollbarTimeout);
  },
  _removeScrollbars() {
    this._eachScrollbar(scrollbar => {
      scrollbar.$element().remove();
    });
  },
  scrollBy(distance) {
    const location = this.location();
    this._$container.scrollTop(Math.round(-location.top - distance.top));
    this._$container.scrollLeft(Math.round(-location.left - distance.left));
  },
  validate(e) {
    if (this.option('disabled')) {
      return false;
    }
    if ((0, _index.isDxMouseWheelEvent)(e) && this._isScrolledInMaxDirection(e)) {
      return false;
    }
    return !!this._allowedDirection();
  },
  // TODO: rtl
  // TODO: horizontal scroll when shift is pressed
  _isScrolledInMaxDirection(e) {
    const container = this._$container.get(0);
    let result;
    if (e.delta > 0) {
      result = e.shiftKey ? !container.scrollLeft : !container.scrollTop;
    } else if (e.shiftKey) {
      result = container.scrollLeft >= this._getMaxOffset().left;
    } else {
      result = container.scrollTop >= this._getMaxOffset().top;
    }
    return result;
  },
  getDirection() {
    return this._allowedDirection();
  }
});
var _default = exports["default"] = NativeStrategy;

/***/ }),

/***/ 56729:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SimulatedStrategy = exports.Scroller = void 0;
var _translator = __webpack_require__(31648);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _inflector = __webpack_require__(78008);
var _iterator = __webpack_require__(95479);
var _position = __webpack_require__(37518);
var _size = __webpack_require__(58664);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
var _m_animator = _interopRequireDefault(__webpack_require__(13707));
var _m_scrollbar = _interopRequireDefault(__webpack_require__(79105));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SCROLLABLE_SIMULATED = 'dxSimulatedScrollable';
const SCROLLABLE_STRATEGY = 'dxScrollableStrategy';
const SCROLLABLE_SIMULATED_CURSOR = `${SCROLLABLE_SIMULATED}Cursor`;
const SCROLLABLE_SIMULATED_KEYBOARD = `${SCROLLABLE_SIMULATED}Keyboard`;
const SCROLLABLE_SIMULATED_CLASS = 'dx-scrollable-simulated';
const SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = 'dx-scrollable-scrollbars-alwaysvisible';
const SCROLLABLE_SCROLLBAR_CLASS = 'dx-scrollable-scrollbar';
const VERTICAL = 'vertical';
const HORIZONTAL = 'horizontal';
const ACCELERATION = 0.92;
const OUT_BOUNDS_ACCELERATION = 0.5;
const MIN_VELOCITY_LIMIT = 1;
const FRAME_DURATION = Math.round(1000 / 60);
const SCROLL_LINE_HEIGHT = 40;
const VALIDATE_WHEEL_TIMEOUT = 500;
const BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5;
const BOUNCE_DURATION = 400;
const BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION;
const BOUNCE_ACCELERATION_SUM = (1 - ACCELERATION ** BOUNCE_FRAMES) / (1 - ACCELERATION);
const KEY_CODES = {
  PAGE_UP: 'pageUp',
  PAGE_DOWN: 'pageDown',
  END: 'end',
  HOME: 'home',
  LEFT: 'leftArrow',
  UP: 'upArrow',
  RIGHT: 'rightArrow',
  DOWN: 'downArrow',
  TAB: 'tab'
};
const InertiaAnimator = _m_animator.default.inherit({
  ctor(scroller) {
    this.callBase();
    this.scroller = scroller;
  },
  VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
  _isFinished() {
    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
  },
  _step() {
    this.scroller._scrollStep(this.scroller._velocity);
    this.scroller._velocity *= this._acceleration();
  },
  _acceleration() {
    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION;
  },
  _complete() {
    this.scroller._scrollComplete();
  }
});
const BounceAnimator = InertiaAnimator.inherit({
  VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
  _isFinished() {
    return this.scroller._crossBoundOnNextStep() || this.callBase();
  },
  _acceleration() {
    return ACCELERATION;
  },
  _complete() {
    this.scroller._move(this.scroller._bounceLocation);
    this.callBase();
  }
});
const Scroller = exports.Scroller = _class.default.inherit({
  ctor(options) {
    this._initOptions(options);
    this._initAnimators();
    this._initScrollbar();
  },
  _initOptions(options) {
    this._location = 0;
    this._topReached = false;
    this._bottomReached = false;
    this._axis = options.direction === HORIZONTAL ? 'x' : 'y';
    this._prop = options.direction === HORIZONTAL ? 'left' : 'top';
    this._dimension = options.direction === HORIZONTAL ? 'width' : 'height';
    this._scrollProp = options.direction === HORIZONTAL ? 'scrollLeft' : 'scrollTop';
    (0, _iterator.each)(options, (optionName, optionValue) => {
      // @ts-expect-error
      this[`_${optionName}`] = optionValue;
    });
  },
  _initAnimators() {
    this._inertiaAnimator = new InertiaAnimator(this);
    this._bounceAnimator = new BounceAnimator(this);
  },
  _initScrollbar() {
    this._scrollbar = new _m_scrollbar.default((0, _renderer.default)('<div>').appendTo(this._$container), {
      direction: this._direction,
      visible: this._scrollByThumb,
      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
      expandable: this._scrollByThumb
    });
    this._$scrollbar = this._scrollbar.$element();
  },
  _visibilityModeNormalize(mode) {
    return mode === true ? 'onScroll' : mode === false ? 'never' : mode;
  },
  _scrollStep(delta) {
    const prevLocation = this._location;
    this._location += delta;
    this._suppressBounce();
    this._move();
    if (Math.abs(prevLocation - this._location) < 1) {
      return;
    }
    _events_engine.default.triggerHandler(this._$container, {
      type: 'scroll'
    });
  },
  _suppressBounce() {
    if (this._bounceEnabled || this._inBounds(this._location)) {
      return;
    }
    this._velocity = 0;
    this._location = this._boundLocation();
  },
  _boundLocation(location) {
    location = location !== undefined ? location : this._location;
    return Math.max(Math.min(location, this._maxOffset), this._minOffset);
  },
  _move(location) {
    this._location = location !== undefined ? location * this._getScaleRatio() : this._location;
    this._moveContent();
    this._moveScrollbar();
  },
  _moveContent() {
    const location = this._location;
    this._$container[this._scrollProp](-location / this._getScaleRatio());
    this._moveContentByTranslator(location);
  },
  _getScaleRatio() {
    if ((0, _window.hasWindow)() && !this._scaleRatio) {
      const element = this._$element.get(0);
      const realDimension = this._getRealDimension(element, this._dimension);
      const baseDimension = this._getBaseDimension(element, this._dimension);
      // NOTE: Ratio can be a fractional number, which leads to inaccuracy in the calculation of sizes.
      //       We should round it to hundredths in order to reduce the inaccuracy and prevent the unexpected appearance of a scrollbar.
      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;
    }
    return this._scaleRatio || 1;
  },
  _getRealDimension(element, dimension) {
    return Math.round((0, _position.getBoundingRect)(element)[dimension]);
  },
  _getBaseDimension(element, dimension) {
    const dimensionName = `offset${(0, _inflector.titleize)(dimension)}`;
    return element[dimensionName];
  },
  _moveContentByTranslator(location) {
    let translateOffset;
    const minOffset = -this._maxScrollPropValue;
    if (location > 0) {
      translateOffset = location;
    } else if (location <= minOffset) {
      translateOffset = location - minOffset;
    } else {
      translateOffset = location % 1;
    }
    if (this._translateOffset === translateOffset) {
      return;
    }
    const targetLocation = {};
    targetLocation[this._prop] = translateOffset;
    this._translateOffset = translateOffset;
    if (translateOffset === 0) {
      (0, _translator.resetPosition)(this._$content);
      return;
    }
    (0, _translator.move)(this._$content, targetLocation);
  },
  _moveScrollbar() {
    this._scrollbar.moveTo(this._location);
  },
  _scrollComplete() {
    if (this._inBounds()) {
      this._hideScrollbar();
      if (this._completeDeferred) {
        this._completeDeferred.resolve();
      }
    }
    this._scrollToBounds();
  },
  _scrollToBounds() {
    if (this._inBounds()) {
      return;
    }
    this._bounceAction();
    this._setupBounce();
    this._bounceAnimator.start();
  },
  _setupBounce() {
    const boundLocation = this._bounceLocation = this._boundLocation();
    const bounceDistance = boundLocation - this._location;
    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;
  },
  _inBounds(location) {
    location = location !== undefined ? location : this._location;
    return this._boundLocation(location) === location;
  },
  _crossBoundOnNextStep() {
    const location = this._location;
    const nextLocation = location + this._velocity;
    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;
  },
  _initHandler(e) {
    this._stopScrolling();
    this._prepareThumbScrolling(e);
  },
  _stopScrolling: (0, _common.deferRenderer)(function () {
    this._hideScrollbar();
    this._inertiaAnimator.stop();
    this._bounceAnimator.stop();
  }),
  _prepareThumbScrolling(e) {
    if ((0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
      return;
    }
    const $target = (0, _renderer.default)(e.originalEvent.target);
    const scrollbarClicked = this._isScrollbar($target);
    if (scrollbarClicked) {
      this._moveToMouseLocation(e);
    }
    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
    if (this._thumbScrolling) {
      this._scrollbar.feedbackOn();
    }
  },
  _isThumbScrollingHandler($target) {
    return this._isThumb($target);
  },
  _moveToMouseLocation(e) {
    const mouseLocation = e[`page${this._axis.toUpperCase()}`] - this._$element.offset()[this._prop];
    const location = this._location + mouseLocation / this._containerToContentRatio() - (0, _size.getHeight)(this._$container) / 2;
    this._scrollStep(-Math.round(location));
  },
  _startHandler() {
    this._showScrollbar();
  },
  _moveHandler(delta) {
    if (this._crossThumbScrolling) {
      return;
    }
    if (this._thumbScrolling) {
      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());
    }
    this._scrollBy(delta);
  },
  _scrollBy(delta) {
    delta = delta[this._axis];
    if (!this._inBounds()) {
      delta *= OUT_BOUNDS_ACCELERATION;
    }
    this._scrollStep(delta);
  },
  _scrollByHandler(delta) {
    this._scrollBy(delta);
    this._scrollComplete();
  },
  _containerToContentRatio() {
    return this._scrollbar.containerToContentRatio();
  },
  _endHandler(velocity) {
    this._completeDeferred = (0, _deferred.Deferred)();
    this._velocity = velocity[this._axis];
    this._inertiaHandler();
    this._resetThumbScrolling();
    return this._completeDeferred.promise();
  },
  _inertiaHandler() {
    this._suppressInertia();
    this._inertiaAnimator.start();
  },
  _suppressInertia() {
    if (!this._inertiaEnabled || this._thumbScrolling) {
      this._velocity = 0;
    }
  },
  _resetThumbScrolling() {
    this._thumbScrolling = false;
    this._crossThumbScrolling = false;
  },
  _stopHandler() {
    if (this._thumbScrolling) {
      this._scrollComplete();
    }
    this._resetThumbScrolling();
    this._scrollToBounds();
  },
  _disposeHandler() {
    this._stopScrolling();
    this._$scrollbar.remove();
  },
  _updateHandler() {
    this._update();
    this._moveToBounds();
  },
  _update() {
    this._stopScrolling();
    return (0, _common.deferUpdate)(() => {
      this._resetScaleRatio();
      this._updateLocation();
      this._updateBounds();
      this._updateScrollbar();
      (0, _common.deferRender)(() => {
        this._moveScrollbar();
        this._scrollbar.update();
      });
    });
  },
  _resetScaleRatio() {
    this._scaleRatio = null;
  },
  _updateLocation() {
    this._location = ((0, _translator.locate)(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
  },
  _updateBounds() {
    this._maxOffset = this._getMaxOffset();
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset() {
    return 0;
  },
  _getMinOffset() {
    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
    return -this._maxScrollPropValue;
  },
  _updateScrollbar: (0, _common.deferUpdater)(function () {
    const containerSize = this._containerSize();
    const contentSize = this._contentSize();
    // NOTE: Real container and content sizes can be a fractional number when scaling.
    //       Let's save sizes when scale = 100% to decide whether it is necessary to show
    //       the scrollbar based on by more precise numbers. We can do it because the container
    //       size to content size ratio should remain approximately the same at any zoom.
    const baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
    const baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
    (0, _common.deferRender)(() => {
      this._scrollbar.option({
        containerSize,
        contentSize,
        baseContainerSize,
        baseContentSize,
        scaleRatio: this._getScaleRatio()
      });
    });
  }),
  _moveToBounds: (0, _common.deferRenderer)((0, _common.deferUpdater)((0, _common.deferRenderer)(function () {
    const location = this._boundLocation();
    const locationChanged = location !== this._location;
    this._location = location;
    this._move();
    if (locationChanged) {
      this._scrollAction();
    }
  }))),
  _createActionsHandler(actions) {
    this._scrollAction = actions.scroll;
    this._bounceAction = actions.bounce;
  },
  _showScrollbar() {
    this._scrollbar.option('visible', true);
  },
  _hideScrollbar() {
    this._scrollbar.option('visible', false);
  },
  _containerSize() {
    return this._getRealDimension(this._$container.get(0), this._dimension);
  },
  _contentSize() {
    const isOverflowHidden = this._$content.css(`overflow${this._axis.toUpperCase()}`) === 'hidden';
    let contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
    if (!isOverflowHidden) {
      const containerScrollSize = this._$content[0][`scroll${(0, _inflector.titleize)(this._dimension)}`] * this._getScaleRatio();
      contentSize = Math.max(containerScrollSize, contentSize);
    }
    return contentSize;
  },
  _validateEvent(e) {
    const $target = (0, _renderer.default)(e.originalEvent.target);
    return this._isThumb($target) || this._isScrollbar($target);
  },
  _isThumb($element) {
    return this._scrollByThumb && this._scrollbar.isThumb($element);
  },
  _isScrollbar($element) {
    return this._scrollByThumb && $element && $element.is(this._$scrollbar);
  },
  _reachedMin() {
    return Math.round(this._location - this._minOffset) <= 0;
  },
  _reachedMax() {
    return Math.round(this._location - this._maxOffset) >= 0;
  },
  _cursorEnterHandler() {
    this._resetScaleRatio();
    this._updateScrollbar();
    this._scrollbar.cursorEnter();
  },
  _cursorLeaveHandler() {
    this._scrollbar.cursorLeave();
  },
  dispose: _common.noop
});
let hoveredScrollable;
let activeScrollable;
const SimulatedStrategy = exports.SimulatedStrategy = _class.default.inherit({
  ctor(scrollable) {
    this._init(scrollable);
  },
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = (0, _renderer.default)(scrollable.container());
    this._$wrapper = scrollable._$wrapper;
    this._$content = scrollable.$content();
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
  },
  render() {
    this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);
    this._createScrollers();
    if (this.option('useKeyboard')) {
      this._$container.prop('tabIndex', 0);
    }
    this._attachKeyboardHandler();
    this._attachCursorHandlers();
  },
  _createScrollers() {
    this._scrollers = {};
    if (this._isDirection(HORIZONTAL)) {
      this._createScroller(HORIZONTAL);
    }
    if (this._isDirection(VERTICAL)) {
      this._createScroller(VERTICAL);
    }
    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, this.option('showScrollbar') === 'always');
  },
  _createScroller(direction) {
    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));
  },
  _scrollerOptions(direction) {
    return {
      direction,
      $content: this._$content,
      $container: this._$container,
      $wrapper: this._$wrapper,
      $element: this._$element,
      scrollByThumb: this.option('scrollByThumb'),
      scrollbarVisible: this.option('showScrollbar'),
      bounceEnabled: this.option('bounceEnabled'),
      inertiaEnabled: this.option('inertiaEnabled'),
      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
    };
  },
  _applyScaleRatio(targetLocation) {
    // eslint-disable-next-line guard-for-in, no-restricted-syntax
    for (const direction in this._scrollers) {
      const prop = this._getPropByDirection(direction);
      if ((0, _type.isDefined)(targetLocation[prop])) {
        const scroller = this._scrollers[direction];
        targetLocation[prop] *= scroller._getScaleRatio();
      }
    }
    return targetLocation;
  },
  _isAnyThumbScrolling($target) {
    let result = false;
    this._eventHandler('isThumbScrolling', $target).done((isThumbScrollingVertical, isThumbScrollingHorizontal) => {
      result = isThumbScrollingVertical || isThumbScrollingHorizontal;
    });
    return result;
  },
  handleInit(e) {
    this._suppressDirections(e);
    this._eventForUserAction = e;
    this._eventHandler('init', e);
  },
  _suppressDirections(e) {
    if ((0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
      this._prepareDirections(true);
      return;
    }
    this._prepareDirections();
    this._eachScroller(function (scroller, direction) {
      const $target = (0, _renderer.default)(e.originalEvent.target);
      const isValid = scroller._validateEvent(e) || this.option('scrollByContent') && this._isContent($target);
      this._validDirections[direction] = isValid;
    });
  },
  _isContent($element) {
    return !!$element.closest(this._$element).length;
  },
  _prepareDirections(value) {
    value = value || false;
    this._validDirections = {};
    this._validDirections[HORIZONTAL] = value;
    this._validDirections[VERTICAL] = value;
  },
  _eachScroller(callback) {
    callback = callback.bind(this);
    (0, _iterator.each)(this._scrollers, (direction, scroller) => {
      callback(scroller, direction);
    });
  },
  handleStart(e) {
    this._eventForUserAction = e;
    this._eventHandler('start').done(this._startAction);
  },
  _saveActive() {
    activeScrollable = this;
  },
  _resetActive() {
    if (activeScrollable === this) {
      activeScrollable = null;
    }
  },
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      this._resetActive();
      return;
    }
    this._saveActive();
    e.preventDefault && e.preventDefault();
    this._adjustDistance(e, e.delta);
    this._eventForUserAction = e;
    this._eventHandler('move', e.delta);
  },
  _adjustDistance(e, distance) {
    distance.x *= this._validDirections[HORIZONTAL];
    distance.y *= this._validDirections[VERTICAL];
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    if (devicePixelRatio && (0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;
    }
  },
  // @ts-expect-error
  _tryGetDevicePixelRatio() {
    if ((0, _window.hasWindow)()) {
      return (0, _window.getWindow)().devicePixelRatio;
    }
  },
  handleEnd(e) {
    this._resetActive();
    this._refreshCursorState(e.originalEvent && e.originalEvent.target);
    this._adjustDistance(e, e.velocity);
    this._eventForUserAction = e;
    return this._eventHandler('end', e.velocity).done(this._endAction);
  },
  handleCancel(e) {
    this._resetActive();
    this._eventForUserAction = e;
    return this._eventHandler('end', {
      x: 0,
      y: 0
    });
  },
  handleStop() {
    this._resetActive();
    this._eventHandler('stop');
  },
  handleScroll() {
    this._updateRtlConfig();
    this._scrollAction();
  },
  _attachKeyboardHandler() {
    _events_engine.default.off(this._$element, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
    if (!this.option('disabled') && this.option('useKeyboard')) {
      _events_engine.default.on(this._$element, (0, _index.addNamespace)('keydown', SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));
    }
  },
  _keyDownHandler(e) {
    clearTimeout(this._updateHandlerTimeout);
    this._updateHandlerTimeout = setTimeout(() => {
      if ((0, _index.normalizeKeyName)(e) === KEY_CODES.TAB) {
        this._eachScroller(scroller => {
          scroller._updateHandler();
        });
      }
    });
    if (!this._$container.is(_dom_adapter.default.getActiveElement(this._$container.get(0)))) {
      return;
    }
    let handled = true;
    switch ((0, _index.normalizeKeyName)(e)) {
      case KEY_CODES.DOWN:
        this._scrollByLine({
          y: 1
        });
        break;
      case KEY_CODES.UP:
        this._scrollByLine({
          y: -1
        });
        break;
      case KEY_CODES.RIGHT:
        this._scrollByLine({
          x: 1
        });
        break;
      case KEY_CODES.LEFT:
        this._scrollByLine({
          x: -1
        });
        break;
      case KEY_CODES.PAGE_DOWN:
        this._scrollByPage(1);
        break;
      case KEY_CODES.PAGE_UP:
        this._scrollByPage(-1);
        break;
      case KEY_CODES.HOME:
        this._scrollToHome();
        break;
      case KEY_CODES.END:
        this._scrollToEnd();
        break;
      default:
        handled = false;
        break;
    }
    if (handled) {
      e.stopPropagation();
      e.preventDefault();
    }
  },
  _scrollByLine(lines) {
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    let scrollOffset = SCROLL_LINE_HEIGHT;
    if (devicePixelRatio) {
      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;
    }
    this.scrollBy({
      top: (lines.y || 0) * -scrollOffset,
      left: (lines.x || 0) * -scrollOffset
    });
  },
  _scrollByPage(page) {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = dimension === 'width' ? _size.getWidth : _size.getHeight;
    distance[prop] = page * -getter(this._$container);
    this.scrollBy(distance);
  },
  _dimensionByProp(prop) {
    return prop === 'left' ? 'width' : 'height';
  },
  _getPropByDirection(direction) {
    return direction === HORIZONTAL ? 'left' : 'top';
  },
  _scrollToHome() {
    const prop = this._wheelProp();
    const distance = {};
    distance[prop] = 0;
    this._component.scrollTo(distance);
  },
  _scrollToEnd() {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = dimension === 'width' ? _size.getWidth : _size.getHeight;
    distance[prop] = getter(this._$content) - getter(this._$container);
    this._component.scrollTo(distance);
  },
  createActions() {
    this._startAction = this._createActionHandler('onStart');
    this._endAction = this._createActionHandler('onEnd');
    this._updateAction = this._createActionHandler('onUpdated');
    this._createScrollerActions();
  },
  _createScrollerActions() {
    this._scrollAction = this._createActionHandler('onScroll');
    this._bounceAction = this._createActionHandler('onBounce');
    this._eventHandler('createActions', {
      scroll: this._scrollAction,
      bounce: this._bounceAction
    });
  },
  _createActionHandler(optionName) {
    const actionHandler = this._createActionByOption(optionName);
    return () => {
      actionHandler((0, _extend.extend)(this._createActionArgs(), arguments));
    };
  },
  _createActionArgs() {
    const {
      horizontal: scrollerX,
      vertical: scrollerY
    } = this._scrollers;
    const offset = this._getScrollOffset();
    this._scrollOffset = {
      top: scrollerY && offset.top,
      left: scrollerX && offset.left
    };
    return {
      event: this._eventForUserAction,
      scrollOffset: this._scrollOffset,
      reachedLeft: scrollerX && scrollerX._reachedMax(),
      reachedRight: scrollerX && scrollerX._reachedMin(),
      reachedTop: scrollerY && scrollerY._reachedMax(),
      reachedBottom: scrollerY && scrollerY._reachedMin()
    };
  },
  _getScrollOffset() {
    return {
      top: -this.location().top,
      left: -this.location().left
    };
  },
  _eventHandler(eventName) {
    const args = [].slice.call(arguments).slice(1);
    const deferreds = (0, _iterator.map)(this._scrollers, scroller => scroller[`_${eventName}Handler`].apply(scroller, args));
    return _deferred.when.apply(_renderer.default, deferreds).promise();
  },
  location() {
    const location = (0, _translator.locate)(this._$content);
    location.top -= this._$container.scrollTop();
    location.left -= this._$container.scrollLeft();
    return location;
  },
  disabledChanged() {
    this._attachCursorHandlers();
  },
  _attachCursorHandlers() {
    _events_engine.default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    if (!this.option('disabled') && this._isHoverMode()) {
      _events_engine.default.on(this._$element, (0, _index.addNamespace)('mouseenter', SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
      _events_engine.default.on(this._$element, (0, _index.addNamespace)('mouseleave', SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));
    }
  },
  _isHoverMode() {
    return this.option('showScrollbar') === 'onHover';
  },
  _cursorEnterHandler(e) {
    e = e || {};
    e.originalEvent = e.originalEvent || {};
    if (activeScrollable || e.originalEvent._hoverHandled) {
      return;
    }
    if (hoveredScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    hoveredScrollable = this;
    this._eventHandler('cursorEnter');
    e.originalEvent._hoverHandled = true;
  },
  _cursorLeaveHandler(e) {
    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
      return;
    }
    this._eventHandler('cursorLeave');
    hoveredScrollable = null;
    this._refreshCursorState(e && e.relatedTarget);
  },
  _refreshCursorState(target) {
    if (!this._isHoverMode() && (!target || activeScrollable)) {
      return;
    }
    const $target = (0, _renderer.default)(target);
    const $scrollable = $target.closest(`.${SCROLLABLE_SIMULATED_CLASS}:not(.dx-state-disabled)`);
    const targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    if (targetScrollable) {
      // @ts-expect-error
      targetScrollable._cursorEnterHandler();
    }
  },
  update() {
    const result = this._eventHandler('update').done(this._updateAction);
    return (0, _deferred.when)(result, (0, _common.deferUpdate)(() => {
      const allowedDirections = this._allowedDirections();
      (0, _common.deferRender)(() => {
        let touchDirection = allowedDirections.vertical ? 'pan-x' : '';
        touchDirection = allowedDirections.horizontal ? 'pan-y' : touchDirection;
        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? 'none' : touchDirection;
        this._$container.css('touchAction', touchDirection);
      });
      return (0, _deferred.when)().promise();
    }));
  },
  _allowedDirections() {
    const bounceEnabled = this.option('bounceEnabled');
    const verticalScroller = this._scrollers[VERTICAL];
    const horizontalScroller = this._scrollers[HORIZONTAL];
    return {
      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
    };
  },
  _updateBounds() {
    this._scrollers[HORIZONTAL] && this._scrollers[HORIZONTAL]._updateBounds();
  },
  _isHorizontalAndRtlEnabled() {
    return this.option('rtlEnabled') && this.option('direction') !== VERTICAL;
  },
  updateRtlPosition(needInitializeRtlConfig) {
    if (needInitializeRtlConfig) {
      this._rtlConfig = {
        scrollRight: 0,
        clientWidth: this._$container.get(0).clientWidth,
        windowPixelRatio: this._getWindowDevicePixelRatio()
      };
    }
    this._updateBounds();
    if (this._isHorizontalAndRtlEnabled()) {
      let scrollLeft = this._getMaxOffset().left - this._rtlConfig.scrollRight;
      if (scrollLeft <= 0) {
        scrollLeft = 0;
        this._rtlConfig.scrollRight = this._getMaxOffset().left;
      }
      if (this._getScrollOffset().left !== scrollLeft) {
        this._rtlConfig.skipUpdating = true;
        this._component.scrollTo({
          left: scrollLeft
        });
        this._rtlConfig.skipUpdating = false;
      }
    }
  },
  _updateRtlConfig() {
    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
      const {
        clientWidth,
        scrollLeft
      } = this._$container.get(0);
      const windowPixelRatio = this._getWindowDevicePixelRatio();
      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;
      }
      this._rtlConfig.clientWidth = clientWidth;
      this._rtlConfig.windowPixelRatio = windowPixelRatio;
    }
  },
  _getWindowDevicePixelRatio() {
    return (0, _window.hasWindow)() ? (0, _window.getWindow)().devicePixelRatio : 1;
  },
  scrollBy(distance) {
    const verticalScroller = this._scrollers[VERTICAL];
    const horizontalScroller = this._scrollers[HORIZONTAL];
    if (verticalScroller) {
      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
    }
    if (horizontalScroller) {
      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
    }
    this._prepareDirections(true);
    this._startAction();
    this._eventHandler('scrollBy', {
      x: distance.left,
      y: distance.top
    });
    this._endAction();
    this._updateRtlConfig();
  },
  validate(e) {
    if ((0, _index.isDxMouseWheelEvent)(e) && (0, _index.isCommandKeyPressed)(e)) {
      return false;
    }
    if (this.option('disabled')) {
      return false;
    }
    if (this.option('bounceEnabled')) {
      return true;
    }
    return (0, _index.isDxMouseWheelEvent)(e) ? this._validateWheel(e) : this._validateMove(e);
  },
  _validateWheel(e) {
    const scroller = this._scrollers[this._wheelDirection(e)];
    const reachedMin = scroller._reachedMin();
    const reachedMax = scroller._reachedMax();
    const contentGreaterThanContainer = !reachedMin || !reachedMax;
    const locatedNotAtBound = !reachedMin && !reachedMax;
    const scrollFromMin = reachedMin && e.delta > 0;
    const scrollFromMax = reachedMax && e.delta < 0;
    let validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
    validated = validated || this._validateWheelTimer !== undefined;
    if (validated) {
      clearTimeout(this._validateWheelTimer);
      this._validateWheelTimer = setTimeout(() => {
        this._validateWheelTimer = undefined;
      }, VALIDATE_WHEEL_TIMEOUT);
    }
    return validated;
  },
  _validateMove(e) {
    if (!this.option('scrollByContent') && !(0, _renderer.default)(e.target).closest(`.${SCROLLABLE_SCROLLBAR_CLASS}`).length) {
      return false;
    }
    return this._allowedDirection();
  },
  getDirection(e) {
    return (0, _index.isDxMouseWheelEvent)(e) ? this._wheelDirection(e) : this._allowedDirection();
  },
  _wheelProp() {
    return this._wheelDirection() === HORIZONTAL ? 'left' : 'top';
  },
  _wheelDirection(e) {
    switch (this.option('direction')) {
      case HORIZONTAL:
        return HORIZONTAL;
      case VERTICAL:
        return VERTICAL;
      default:
        return e && e.shiftKey ? HORIZONTAL : VERTICAL;
    }
  },
  dispose() {
    this._resetActive();
    if (hoveredScrollable === this) {
      hoveredScrollable = null;
    }
    this._eventHandler('dispose');
    this._detachEventHandlers();
    this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);
    this._eventForUserAction = null;
    clearTimeout(this._validateWheelTimer);
    clearTimeout(this._updateHandlerTimeout);
  },
  _detachEventHandlers() {
    _events_engine.default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    _events_engine.default.off(this._$container, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
  }
});

/***/ }),

/***/ 79105:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _translator = __webpack_require__(31648);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _type = __webpack_require__(35922);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _index = __webpack_require__(39611);
var _ui = _interopRequireDefault(__webpack_require__(14390));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

const SCROLLBAR = 'dxScrollbar';
const SCROLLABLE_SCROLLBAR_CLASS = 'dx-scrollable-scrollbar';
const SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = `${SCROLLABLE_SCROLLBAR_CLASS}-active`;
const SCROLLABLE_SCROLL_CLASS = 'dx-scrollable-scroll';
const SCROLLABLE_SCROLL_CONTENT_CLASS = 'dx-scrollable-scroll-content';
const HOVER_ENABLED_STATE = 'dx-scrollbar-hoverable';
const HORIZONTAL = 'horizontal';
const THUMB_MIN_SIZE = 15;
const SCROLLBAR_VISIBLE = {
  onScroll: 'onScroll',
  onHover: 'onHover',
  always: 'always',
  never: 'never'
};
let activeScrollbar = null;
const Scrollbar = _ui.default.inherit({
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      direction: null,
      visible: false,
      activeStateEnabled: false,
      visibilityMode: SCROLLBAR_VISIBLE.onScroll,
      containerSize: 0,
      contentSize: 0,
      expandable: true,
      scaleRatio: 1
    });
  },
  _init() {
    this.callBase();
    this._isHovered = false;
  },
  _initMarkup() {
    this._renderThumb();
    this.callBase();
  },
  _render() {
    this.callBase();
    this._renderDirection();
    this._update();
    this._attachPointerDownHandler();
    this.option('hoverStateEnabled', this._isHoverMode());
    this.$element().toggleClass(HOVER_ENABLED_STATE, this.option('hoverStateEnabled'));
  },
  _renderThumb() {
    this._$thumb = (0, _renderer.default)('<div>').addClass(SCROLLABLE_SCROLL_CLASS);
    (0, _renderer.default)('<div>').addClass(SCROLLABLE_SCROLL_CONTENT_CLASS).appendTo(this._$thumb);
    this.$element().addClass(SCROLLABLE_SCROLLBAR_CLASS).append(this._$thumb);
  },
  isThumb($element) {
    return !!this.$element().find($element).length;
  },
  _isHoverMode() {
    const visibilityMode = this.option('visibilityMode');
    return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option('expandable');
  },
  _renderDirection() {
    const direction = this.option('direction');
    this.$element().addClass(`dx-scrollbar-${direction}`);
    this._dimension = direction === HORIZONTAL ? 'width' : 'height';
    this._prop = direction === HORIZONTAL ? 'left' : 'top';
  },
  _attachPointerDownHandler() {
    _events_engine.default.on(this._$thumb, (0, _index.addNamespace)(_pointer.default.down, SCROLLBAR), this.feedbackOn.bind(this));
  },
  feedbackOn(e) {
    e === null || e === void 0 || e.preventDefault();
    this.$element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
    activeScrollbar = this;
  },
  feedbackOff() {
    this.$element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
    activeScrollbar = null;
  },
  cursorEnter() {
    this._isHovered = true;
    if (this._needScrollbar()) {
      this.option('visible', true);
    }
  },
  cursorLeave() {
    this._isHovered = false;
    this.option('visible', false);
  },
  _renderDimensions() {
    this._$thumb.css({
      width: this.option('width'),
      height: this.option('height')
    });
  },
  _toggleVisibility(visible) {
    if (this.option('visibilityMode') === SCROLLBAR_VISIBLE.onScroll) {
      // NOTE: need to relayout thumb and show it instantly
      this._$thumb.css('opacity');
    }
    visible = this._adjustVisibility(visible);
    this.option().visible = visible;
    this._$thumb.toggleClass('dx-state-invisible', !visible);
  },
  _adjustVisibility(visible) {
    if (this._baseContainerToContentRatio && !this._needScrollbar()) {
      return false;
    }
    // eslint-disable-next-line default-case
    switch (this.option('visibilityMode')) {
      case SCROLLBAR_VISIBLE.onScroll:
        break;
      case SCROLLBAR_VISIBLE.onHover:
        visible = visible || !!this._isHovered;
        break;
      case SCROLLBAR_VISIBLE.never:
        visible = false;
        break;
      case SCROLLBAR_VISIBLE.always:
        visible = true;
        break;
    }
    return visible;
  },
  moveTo(location) {
    if (this._isHidden()) {
      return;
    }
    if ((0, _type.isPlainObject)(location)) {
      location = location[this._prop] || 0;
    }
    const scrollBarLocation = {};
    scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
    (0, _translator.move)(this._$thumb, scrollBarLocation);
  },
  _calculateScrollBarPosition(location) {
    return -location * this._thumbRatio;
  },
  _update() {
    const containerSize = Math.round(this.option('containerSize'));
    const contentSize = Math.round(this.option('contentSize'));
    let baseContainerSize = Math.round(this.option('baseContainerSize'));
    let baseContentSize = Math.round(this.option('baseContentSize'));
    // NOTE: if current scrollbar's using outside of scrollable
    if (isNaN(baseContainerSize)) {
      baseContainerSize = containerSize;
      baseContentSize = contentSize;
    }
    this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
    this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
    const thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), THUMB_MIN_SIZE));
    this._thumbRatio = (containerSize - thumbSize) / (this.option('scaleRatio') * (contentSize - containerSize));
    this.option(this._dimension, thumbSize / this.option('scaleRatio'));
    this.$element().css('display', this._needScrollbar() ? '' : 'none');
  },
  _isHidden() {
    return this.option('visibilityMode') === SCROLLBAR_VISIBLE.never;
  },
  _needScrollbar() {
    return !this._isHidden() && this._baseContainerToContentRatio < 1;
  },
  containerToContentRatio() {
    return this._realContainerToContentRatio;
  },
  _normalizeSize(size) {
    return (0, _type.isPlainObject)(size) ? size[this._dimension] || 0 : size;
  },
  _clean() {
    this.callBase();
    if (this === activeScrollbar) {
      activeScrollbar = null;
    }
    _events_engine.default.off(this._$thumb, `.${SCROLLBAR}`);
  },
  _optionChanged(args) {
    if (this._isHidden()) {
      return;
    }
    switch (args.name) {
      case 'containerSize':
      case 'contentSize':
        this.option()[args.name] = this._normalizeSize(args.value);
        this._update();
        break;
      case 'baseContentSize':
      case 'baseContainerSize':
        this._update();
        break;
      case 'visibilityMode':
      case 'direction':
        this._invalidate();
        break;
      case 'scaleRatio':
        this._update();
        break;
      default:
        this.callBase.apply(this, arguments);
    }
  },
  update: (0, _common.deferRenderer)(function () {
    this._adjustVisibility() && this.option('visible', true);
  })
});
_ready_callbacks.default.add(() => {
  // @ts-expect-error
  _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), (0, _index.addNamespace)(_pointer.default.up, SCROLLBAR), () => {
    if (activeScrollbar) {
      // @ts-expect-error
      activeScrollbar.feedbackOff();
    }
  });
});
var _default = exports["default"] = Scrollbar;

/***/ }),

/***/ 39550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertDevExtremeVersion = assertDevExtremeVersion;
exports.assertedVersionsCompatible = assertedVersionsCompatible;
exports.clearAssertedVersions = clearAssertedVersions;
exports.getPreviousMajorVersion = getPreviousMajorVersion;
exports.parseVersion = parseVersion;
exports.stringifyVersion = stringifyVersion;
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const MAX_MINOR_VERSION = 2;
const MIN_MINOR_VERSION = 1;
const assertedVersions = [];
const VERSION_SPLITTER = '.';
function stringifyVersion(version) {
  const {
    major,
    minor,
    patch
  } = version;
  return [major, minor, patch].join(VERSION_SPLITTER);
}
function parseVersion(version) {
  const [major, minor, patch] = version.split('.').map(Number);
  return {
    major,
    minor,
    patch
  };
}
function assertDevExtremeVersion(packageName, version) {
  assertedVersions.push({
    packageName,
    version
  });
}
function clearAssertedVersions() {}
function stringifyVersionList(assertedVersionList) {
  return assertedVersionList.map(assertedVersion => `${assertedVersion.packageName}: ${assertedVersion.version}`).join('\n');
}
function versionsEqual(versionA, versionB) {
  return versionA.major === versionB.major && versionA.minor === versionB.minor && versionA.patch === versionB.patch;
}
function getPreviousMajorVersion(_ref) {
  let {
    major,
    minor,
    patch
  } = _ref;
  const previousMajorVersion = minor === MIN_MINOR_VERSION ? {
    major: major - 1,
    minor: MAX_MINOR_VERSION,
    patch
  } : {
    major,
    minor: minor - 1,
    patch
  };
  return previousMajorVersion;
}
function assertedVersionsCompatible(currentVersion) {
  const mismatchingVersions = assertedVersions.filter(assertedVersion => !versionsEqual(parseVersion(assertedVersion.version), currentVersion));
  if (mismatchingVersions.length) {
    _errors.default.log('W0023', stringifyVersionList([{
      packageName: 'devextreme',
      version: stringifyVersion(currentVersion)
    }, ...mismatchingVersions]));
    return false;
  }
  return true;
}

/***/ }),

/***/ 41690:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AdvancedChart = void 0;
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _base_axis = __webpack_require__(41278);
var _series_family = __webpack_require__(1939);
var _utils = __webpack_require__(19157);
var _range_data_calculator = _interopRequireDefault(__webpack_require__(63407));
var _range = __webpack_require__(21177);
var _utils2 = __webpack_require__(34434);
var _m_base_chart = __webpack_require__(14107);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } // @ts-expect-error
const {
  isArray
} = Array;
const DEFAULT_AXIS_NAME = 'defaultAxisName';
const FONT = 'font';
const COMMON_AXIS_SETTINGS = 'commonAxisSettings';
const DEFAULT_PANE_NAME = 'default';
const VISUAL_RANGE = 'VISUAL_RANGE';
function prepareAxis(axisOptions) {
  if (isArray(axisOptions)) {
    return axisOptions.length === 0 ? [{}] : axisOptions;
  }
  return [axisOptions];
}
function processBubbleMargin(marginOptions, bubbleSize) {
  if (marginOptions.processBubbleSize) {
    marginOptions.size = bubbleSize;
  }
  return marginOptions;
}
function estimateBubbleSize(size, panesCount, maxSize, rotated) {
  const width = rotated ? size.width / panesCount : size.width;
  const height = rotated ? size.height : size.height / panesCount;
  return Math.min(width, height) * maxSize;
}
function setAxisVisualRangeByOption(arg, axis, isDirectOption, index) {
  let options;
  let visualRange;
  if (isDirectOption) {
    visualRange = arg.value;
    options = {
      skipEventRising: true
    };
    const wrappedVisualRange = wrapVisualRange(arg.fullName, visualRange);
    if (wrappedVisualRange) {
      options = {
        allowPartialUpdate: true
      };
      visualRange = wrappedVisualRange;
    }
  } else {
    visualRange = ((0, _type.isDefined)(index) ? arg.value[index] : arg.value).visualRange;
  }
  axis.visualRange(visualRange, options);
}
function getAxisTypes(groupsData, axis, isArgumentAxes) {
  if (isArgumentAxes) {
    return {
      argumentAxisType: groupsData.argumentAxisType,
      argumentType: groupsData.argumentType
    };
  }
  const {
    valueAxisType,
    valueType
  } = groupsData.groups.find(g => g.valueAxis === axis);
  return {
    valueAxisType,
    valueType
  };
}
function wrapVisualRange(fullName, value) {
  const pathElements = fullName.split('.');
  const destElem = pathElements.at(-1);
  if (destElem === 'endValue' || destElem === 'startValue') {
    return {
      [destElem]: value
    };
  }
  return undefined;
}
const AdvancedChart = exports.AdvancedChart = _m_base_chart.BaseChart.inherit({
  _fontFields: [`${COMMON_AXIS_SETTINGS}.label.${FONT}`, `${COMMON_AXIS_SETTINGS}.title.${FONT}`],
  _partialOptionChangesMap: {
    visualRange: VISUAL_RANGE,
    _customVisualRange: VISUAL_RANGE,
    strips: 'REFRESH_AXES',
    constantLines: 'REFRESH_AXES'
  },
  _partialOptionChangesPath: {
    argumentAxis: ['strips', 'constantLines', 'visualRange', '_customVisualRange'],
    valueAxis: ['strips', 'constantLines', 'visualRange', '_customVisualRange']
  },
  _initCore() {
    this._panesClipRects = {};
    this.callBase();
  },
  _disposeCore() {
    const disposeObjectsInArray = this._disposeObjectsInArray;
    const panesClipRects = this._panesClipRects;
    this.callBase();
    disposeObjectsInArray.call(panesClipRects, 'fixed');
    disposeObjectsInArray.call(panesClipRects, 'base');
    disposeObjectsInArray.call(panesClipRects, 'wide');
    this._panesClipRects = null;
    this._labelsAxesGroup.linkOff();
    this._labelsAxesGroup.dispose();
    this._labelsAxesGroup = null;
  },
  _dispose() {
    const disposeObjectsInArray = this._disposeObjectsInArray;
    this.callBase();
    this.panes = null;
    if (this._legend) {
      this._legend.dispose();
      this._legend = null;
    }
    disposeObjectsInArray.call(this, 'panesBackground');
    disposeObjectsInArray.call(this, 'seriesFamilies');
    this._disposeAxes();
  },
  _createPanes() {
    this._cleanPanesClipRects('fixed');
    this._cleanPanesClipRects('base');
    this._cleanPanesClipRects('wide');
  },
  _cleanPanesClipRects(clipArrayName) {
    const clipArray = this._panesClipRects[clipArrayName];
    (clipArray || []).forEach(clipRect => {
      clipRect === null || clipRect === void 0 || clipRect.dispose();
    });
    this._panesClipRects[clipArrayName] = [];
  },
  _getElementsClipRectID(paneName) {
    const clipShape = this._panesClipRects.fixed[this._getPaneIndex(paneName)];
    return clipShape === null || clipShape === void 0 ? void 0 : clipShape.id;
  },
  _getPaneIndex(paneName) {
    const name = paneName || DEFAULT_PANE_NAME;
    return this.panes.findIndex(pane => pane.name === name);
  },
  _updateSize(forceUpdateCanvas) {
    this.callBase();
    if (forceUpdateCanvas && (0, _utils2.areCanvasesDifferent)(this.__currentCanvas, this._canvas)) {
      this.__currentCanvas = (0, _utils2.floorCanvasDimensions)(this._canvas);
    }
    (0, _utils.setCanvasValues)(this._canvas);
  },
  _reinitAxes() {
    this.panes = this._createPanes();
    this._populateAxes();
    this._axesReinitialized = true;
  },
  _populateAxes() {
    const {
      panes
    } = this;
    const rotated = this._isRotated();
    const argumentAxesOptions = prepareAxis(this.option('argumentAxis') || {})[0];
    const valueAxisOption = this.option('valueAxis');
    const valueAxesOptions = prepareAxis(valueAxisOption || {});
    let argumentAxesPopulatedOptions = [];
    const valueAxesPopulatedOptions = [];
    const axisNames = [];
    let valueAxesCounter = 0;
    let paneWithNonVirtualAxis;
    const crosshairMargins = this._getCrosshairMargins();
    function getNextAxisName() {
      const name = DEFAULT_AXIS_NAME + String(valueAxesCounter);
      valueAxesCounter += 1;
      return name;
    }
    if (rotated) {
      paneWithNonVirtualAxis = argumentAxesOptions.position === 'right' ? panes[panes.length - 1].name : panes[0].name;
    } else {
      paneWithNonVirtualAxis = argumentAxesOptions.position === 'top' ? panes[0].name : panes[panes.length - 1].name;
    }
    argumentAxesPopulatedOptions = (0, _utils.map)(panes, pane => {
      const virtual = pane.name !== paneWithNonVirtualAxis;
      return this._populateAxesOptions('argumentAxis', argumentAxesOptions, {
        pane: pane.name,
        name: null,
        optionPath: 'argumentAxis',
        crosshairMargin: rotated ? crosshairMargins.x : crosshairMargins.y
      }, rotated, virtual);
    });
    valueAxesOptions.forEach((axisOptions, priority) => {
      var _axisOptions$panes;
      let axisPanes = [];
      const {
        name
      } = axisOptions;
      if (name && axisNames.includes(name)) {
        this._incidentOccurred('E2102');
        return;
      }
      if (name) {
        axisNames.push(name);
      }
      if (axisOptions.pane) {
        axisPanes.push(axisOptions.pane);
      }
      if ((_axisOptions$panes = axisOptions.panes) !== null && _axisOptions$panes !== void 0 && _axisOptions$panes.length) {
        axisPanes = axisPanes.concat(axisOptions.panes.slice(0));
      }
      axisPanes = (0, _utils.unique)(axisPanes);
      if (!axisPanes.length) {
        axisPanes.push(undefined);
      }
      axisPanes.forEach(pane => {
        const optionPath = isArray(valueAxisOption) ? `valueAxis[${String(priority)}]` : 'valueAxis';
        valueAxesPopulatedOptions.push(this._populateAxesOptions('valueAxis', axisOptions, {
          name: name || getNextAxisName(),
          pane,
          priority,
          optionPath,
          crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x
        }, rotated));
      });
    });
    this._redesignAxes(argumentAxesPopulatedOptions, true, paneWithNonVirtualAxis);
    this._redesignAxes(valueAxesPopulatedOptions, false);
  },
  _redesignAxes(options, isArgumentAxes, paneWithNonVirtualAxis) {
    const axesBasis = [];
    let axes = isArgumentAxes ? this._argumentAxes : this._valueAxes;
    options.forEach(opt => {
      var _axes;
      const curAxes = (_axes = axes) === null || _axes === void 0 ? void 0 : _axes.filter(a => a.name === opt.name && (!(0, _type.isDefined)(opt.pane) && this.panes.some(p => p.name === a.pane) || a.pane === opt.pane));
      if (curAxes !== null && curAxes !== void 0 && curAxes.length) {
        curAxes.forEach(axis => {
          const axisTypes = getAxisTypes(this._groupsData, axis, isArgumentAxes); // T891599
          axis.updateOptions(opt);
          if (isArgumentAxes) {
            axis.setTypes(axisTypes.argumentAxisType, axisTypes.argumentType, 'argumentType');
          } else {
            axis.setTypes(axisTypes.valueAxisType, axisTypes.valueType, 'valueType');
          }
          axis.validate();
          axesBasis.push({
            axis
          });
        });
      } else {
        axesBasis.push({
          options: opt
        });
      }
    });
    if (axes) {
      (0, _iterator.reverseEach)(axes, (index, axis) => {
        if (!axesBasis.some(basis => basis.axis && basis.axis === axis)) {
          this._disposeAxis(index, isArgumentAxes);
        }
      });
    } else if (isArgumentAxes) {
      axes = this._argumentAxes = [];
    } else {
      axes = this._valueAxes = [];
    }
    axesBasis.forEach(basis => {
      let {
        axis
      } = basis;
      if (basis.axis && isArgumentAxes) {
        basis.axis.isVirtual = basis.axis.pane !== paneWithNonVirtualAxis;
      } else if (basis.options) {
        axis = this._createAxis(isArgumentAxes, basis.options, isArgumentAxes ? basis.options.pane !== paneWithNonVirtualAxis : undefined);
        axes.push(axis);
      }
      axis.applyVisualRangeSetter(this._getVisualRangeSetter());
    });
  },
  _disposeAxis(index, isArgumentAxis) {
    const axes = isArgumentAxis ? this._argumentAxes : this._valueAxes;
    const axis = axes[index];
    if (!axis) return;
    axis.dispose();
    axes.splice(index, 1);
  },
  _disposeAxes() {
    const disposeObjectsInArray = this._disposeObjectsInArray;
    disposeObjectsInArray.call(this, '_argumentAxes');
    disposeObjectsInArray.call(this, '_valueAxes');
  },
  _appendAdditionalSeriesGroups() {
    this._crosshairCursorGroup.linkAppend();
    // this._legendGroup.linkAppend();
    if (this._scrollBar) {
      // TODO: Must be appended in the same place where removed (chart)
      this._scrollBarGroup.linkAppend();
    }
  },
  _getLegendTargets() {
    return (this.series || []).map(s => {
      const item = this._getLegendOptions(s);
      item.legendData.series = s;
      if (!s.getOptions().showInLegend) {
        item.legendData.visible = false;
      }
      return item;
    });
  },
  _legendItemTextField: 'name',
  _seriesPopulatedHandlerCore() {
    this._processSeriesFamilies();
    this._processValueAxisFormat();
  },
  _renderTrackers() {
    for (let i = 0; i < this.series.length; i += 1) {
      this.series[i].drawTrackers();
    }
    // TODO we don't need it
    // if (that._legend) {
    //    legendHasInsidePosition && that._legendGroup.append(that._renderer.root);
    // }
  },
  _specialProcessSeries() {
    this._processSeriesFamilies();
  },
  _processSeriesFamilies() {
    var _this$seriesFamilies;
    const types = [];
    const families = [];
    let paneSeries;
    const themeManager = this._themeManager;
    const negativesAsZeroes = themeManager.getOptions('negativesAsZeroes');
    const negativesAsZeros = themeManager.getOptions('negativesAsZeros'); // misspelling case
    const familyOptions = {
      minBubbleSize: themeManager.getOptions('minBubbleSize'),
      maxBubbleSize: themeManager.getOptions('maxBubbleSize'),
      barGroupPadding: themeManager.getOptions('barGroupPadding'),
      barGroupWidth: themeManager.getOptions('barGroupWidth'),
      negativesAsZeroes: (0, _type.isDefined)(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros
    };
    if ((_this$seriesFamilies = this.seriesFamilies) !== null && _this$seriesFamilies !== void 0 && _this$seriesFamilies.length) {
      this.seriesFamilies.forEach(family => {
        family.updateOptions(familyOptions);
        family.adjustSeriesValues();
      });
      return;
    }
    this.series.forEach(item => {
      if (!types.includes(item.type)) {
        types.push(item.type);
      }
    });
    this._getLayoutTargets().forEach(pane => {
      paneSeries = this._getSeriesForPane(pane.name);
      types.forEach(type => {
        const family = new _series_family.SeriesFamily({
          type,
          pane: pane.name,
          minBubbleSize: familyOptions.minBubbleSize,
          maxBubbleSize: familyOptions.maxBubbleSize,
          barGroupPadding: familyOptions.barGroupPadding,
          barGroupWidth: familyOptions.barGroupWidth,
          negativesAsZeroes: familyOptions.negativesAsZeroes,
          rotated: this._isRotated()
        });
        family.add(paneSeries);
        family.adjustSeriesValues();
        families.push(family);
      });
    });
    this.seriesFamilies = families;
  },
  _updateSeriesDimensions() {
    const seriesFamilies = this.seriesFamilies || [];
    for (let i = 0; i < seriesFamilies.length; i += 1) {
      const family = seriesFamilies[i];
      family.updateSeriesValues();
      family.adjustSeriesDimensions();
    }
  },
  _getLegendCallBack(series) {
    var _this$_legend;
    return (_this$_legend = this._legend) === null || _this$_legend === void 0 ? void 0 : _this$_legend.getActionCallback(series);
  },
  _appendAxesGroups() {
    this._stripsGroup.linkAppend();
    this._gridGroup.linkAppend();
    this._axesGroup.linkAppend();
    this._labelsAxesGroup.linkAppend();
    this._constantLinesGroup.linkAppend();
    this._stripLabelAxesGroup.linkAppend();
    this._scaleBreaksGroup.linkAppend();
  },
  _populateMarginOptions() {
    const bubbleSize = estimateBubbleSize(this.getSize(), this.panes.length, this._themeManager.getOptions('maxBubbleSize'), this._isRotated());
    let argumentMarginOptions = {};
    this._valueAxes.forEach(valueAxis => {
      const groupSeries = this.series.filter(series => series.getValueAxis() === valueAxis);
      let marginOptions = {};
      groupSeries.forEach(series => {
        if (series.isVisible()) {
          const seriesMarginOptions = processBubbleMargin(series.getMarginOptions(), bubbleSize);
          marginOptions = (0, _utils.mergeMarginOptions)(marginOptions, seriesMarginOptions);
          argumentMarginOptions = (0, _utils.mergeMarginOptions)(argumentMarginOptions, seriesMarginOptions);
        }
      });
      valueAxis.setMarginOptions(marginOptions);
    });
    this._argumentAxes.forEach(a => a.setMarginOptions(argumentMarginOptions));
  },
  _populateBusinessRange(updatedAxis, keepRange) {
    const rotated = this._isRotated();
    const series = this._getVisibleSeries();
    const argRanges = {};
    const commonArgRange = new _range.Range({
      rotated: !!rotated
    });
    const getPaneName = axis => axis.pane || DEFAULT_PANE_NAME;
    this.panes.forEach(p => {
      argRanges[p.name] = new _range.Range({
        rotated: !!rotated
      });
    });
    this._valueAxes.forEach(valueAxis => {
      const groupRange = new _range.Range({
        rotated: !!rotated,
        pane: valueAxis.pane,
        axis: valueAxis.name
      });
      const groupSeries = series.filter(series => series.getValueAxis() === valueAxis);
      groupSeries.forEach(series => {
        const seriesRange = series.getRangeData();
        groupRange.addRange(seriesRange.val);
        argRanges[getPaneName(valueAxis)].addRange(seriesRange.arg);
      });
      if (!updatedAxis || updatedAxis && groupSeries.length && valueAxis === updatedAxis) {
        valueAxis.setGroupSeries(groupSeries);
        valueAxis.setBusinessRange(groupRange, this._axesReinitialized || keepRange, this._argumentAxes[0]._lastVisualRangeUpdateMode);
      }
    });
    if (!updatedAxis || updatedAxis && series.length) {
      Object.keys(argRanges).forEach(p => commonArgRange.addRange(argRanges[p]));
      const commonInterval = commonArgRange.interval;
      this._argumentAxes.forEach(a => {
        const currentInterval = argRanges[getPaneName(a)].interval ?? commonInterval; // T956425
        a.setBusinessRange(new _range.Range(_extends({}, commonArgRange, {
          interval: currentInterval
        })), this._axesReinitialized, undefined, this._groupsData.categories);
      });
    }
    this._populateMarginOptions();
  },
  getArgumentAxis() {
    return (this._argumentAxes || []).find(a => !a.isVirtual);
  },
  getValueAxis(name) {
    return (this._valueAxes || []).find((0, _type.isDefined)(name) ? a => a.name === name : a => a.pane === this.defaultPane);
  },
  _getGroupsData() {
    const groups = [];
    this._valueAxes.forEach(axis => {
      groups.push({
        series: this.series.filter(series => series.getValueAxis() === axis),
        valueAxis: axis,
        valueOptions: axis.getOptions()
      });
    });
    return {
      groups,
      argumentAxes: this._argumentAxes,
      argumentOptions: this._argumentAxes[0].getOptions()
    };
  },
  _groupSeries() {
    this._correctValueAxes(false);
    this._groupsData = this._getGroupsData();
  },
  _processValueAxisFormat() {
    const axesWithFullStackedFormat = [];
    this.series.forEach(series => {
      const axis = series.getValueAxis();
      if (series.isFullStackedSeries()) {
        axis.setPercentLabelFormat();
        axesWithFullStackedFormat.push(axis);
      }
    });
    this._valueAxes.forEach(axis => {
      if (!axesWithFullStackedFormat.includes(axis)) {
        axis.resetAutoLabelFormat(); // B239299
      }
    });
  },
  _populateAxesOptions(typeSelector, userOptions, axisOptions, rotated, virtual) {
    const preparedUserOptions = this._prepareStripsAndConstantLines(typeSelector, userOptions, rotated);
    const options = (0, _extend2.extend)(true, {}, preparedUserOptions, axisOptions, this._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));
    if (virtual) {
      options.visible = false;
      options.tick.visible = false;
      options.minorTick.visible = false;
      options.label.visible = false;
      options.title = {};
    }
    return options;
  },
  _getValFilter(series) {
    return _range_data_calculator.default.getViewPortFilter(series.getValueAxis().visualRange() || {});
  },
  _createAxis(isArgumentAxes, options, virtual) {
    const typeSelector = isArgumentAxes ? 'argumentAxis' : 'valueAxis';
    const renderingSettings = (0, _extend2.extend)({
      renderer: this._renderer,
      incidentOccurred: this._incidentOccurred,
      eventTrigger: this._eventTrigger,
      axisClass: isArgumentAxes ? 'arg' : 'val',
      widgetClass: 'dxc',
      stripsGroup: this._stripsGroup,
      stripLabelAxesGroup: this._stripLabelAxesGroup,
      constantLinesGroup: this._constantLinesGroup,
      scaleBreaksGroup: this._scaleBreaksGroup,
      axesContainerGroup: this._axesGroup,
      labelsAxesGroup: this._labelsAxesGroup,
      gridGroup: this._gridGroup,
      isArgumentAxis: isArgumentAxes,
      getTemplate: template => this._getTemplate(template)
    }, this._getAxisRenderingOptions(typeSelector));
    const axis = new _base_axis.Axis(renderingSettings);
    axis.updateOptions(options);
    axis.isVirtual = virtual;
    return axis;
  },
  _applyVisualRangeByVirtualAxes() {
    return false;
  },
  _applyCustomVisualRangeOption(axis, range) {
    if (axis.getOptions().optionPath) {
      this._parseVisualRangeOption(`${axis.getOptions().optionPath}.visualRange`, range);
    }
  },
  _getVisualRangeSetter() {
    return (axis, _ref) => {
      let {
        skipEventRising,
        range
      } = _ref;
      this._applyCustomVisualRangeOption(axis, range);
      axis.setCustomVisualRange(range);
      axis.skipEventRising = skipEventRising;
      if (!this._applyVisualRangeByVirtualAxes(axis, range)) {
        if (this._applyingChanges) {
          this._change_VISUAL_RANGE();
        } else {
          this._requestChange([VISUAL_RANGE]);
        }
      }
    };
  },
  _getTrackerSettings() {
    return (0, _extend2.extend)(this.callBase(), {
      argumentAxis: this.getArgumentAxis()
    });
  },
  _prepareStripsAndConstantLines(typeSelector, userOptions, rotated) {
    userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);
    if (userOptions.strips) {
      userOptions.strips.forEach((line, i) => {
        userOptions.strips[i] = (0, _extend2.extend)(true, {}, userOptions.stripStyle, line);
      });
    }
    if (userOptions.constantLines) {
      userOptions.constantLines.forEach((line, i) => {
        userOptions.constantLines[i] = (0, _extend2.extend)(true, {}, userOptions.constantLineStyle, line);
      });
    }
    return userOptions;
  },
  refresh() {
    this._disposeAxes();
    this.callBase();
  },
  _layoutAxes(drawAxes) {
    drawAxes();
    const needSpace = this.checkForMoreSpaceForPanesCanvas();
    if (needSpace) {
      const rect = this._rect.slice();
      const size = this._layout.backward(rect, rect, [needSpace.width, needSpace.height]);
      needSpace.width = Math.max(0, size[0]);
      needSpace.height = Math.max(0, size[1]);
      this._canvas = this._createCanvasFromRect(rect);
      drawAxes(needSpace);
    }
  },
  checkForMoreSpaceForPanesCanvas() {
    return this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), this._isRotated());
  },
  _parseVisualRangeOption(fullName, value) {
    const name = fullName.split(/[.[]/)[0];
    let index = fullName.match(/\d+/g);
    index = (0, _type.isDefined)(index) ? parseInt(index[0], 10) : index;
    if (fullName.indexOf('visualRange') > 0) {
      if ((0, _type.type)(value) !== 'object') {
        value = wrapVisualRange(fullName, value) ?? value;
      }
      this._setCustomVisualRange(name, index, value);
    } else if (((0, _type.type)(value) === 'object' || isArray(value)) && name.indexOf('Axis') > 0 && JSON.stringify(value).indexOf('visualRange') > 0) {
      if ((0, _type.isDefined)(value.visualRange)) {
        this._setCustomVisualRange(name, index, value.visualRange);
      } else if (isArray(value)) {
        value.forEach((a, i) => {
          if ((0, _type.isDefined)(a.visualRange)) {
            this._setCustomVisualRange(name, i, a.visualRange);
          }
        });
      }
    }
  },
  _setCustomVisualRange(axesName, index, value) {
    const options = this._options.silent(axesName);
    if (!options) {
      return;
    }
    if (!(0, _type.isDefined)(index)) {
      options._customVisualRange = value;
    } else {
      options[index]._customVisualRange = value;
    }
    this._axesReinitialized = true;
  },
  _raiseZoomEndHandlers() {
    this._valueAxes.forEach(axis => axis.handleZoomEnd());
  },
  _setOptionsByReference() {
    this.callBase();
    (0, _extend2.extend)(this._optionsByReference, {
      'valueAxis.visualRange': true
    });
  },
  _notifyOptionChanged(option, value) {
    this.callBase.apply(this, arguments);
    if (!this._optionChangedLocker) {
      this._parseVisualRangeOption(option, value);
    }
  },
  _notifyVisualRange() {
    this._valueAxes.forEach(axis => {
      const axisPath = axis.getOptions().optionPath;
      if (axisPath) {
        const path = `${axisPath}.visualRange`;
        const visualRange = (0, _utils.convertVisualRangeObject)(axis.visualRange(), !isArray(this.option(path)));
        if (!axis.skipEventRising || !(0, _utils.rangesAreEqual)(visualRange, this.option(path))) {
          if (!this.option(axisPath) && axisPath !== 'valueAxis') {
            this.option(axisPath, {
              name: axis.name,
              visualRange
            });
          } else {
            this.option(path, visualRange);
          }
        } else {
          axis.skipEventRising = null;
        }
      }
    });
  },
  _notify() {
    this.callBase();
    this._axesReinitialized = false;
    if (this.option('disableTwoWayBinding') !== true) {
      // for dashboards T732396
      this.skipOptionsRollBack = true; // T1037806
      this._notifyVisualRange();
      this.skipOptionsRollBack = false;
    }
  },
  _getAxesForScaling() {
    return this._valueAxes;
  },
  _getAxesByOptionPath(arg, isDirectOption, optionName) {
    const sourceAxes = this._getAxesForScaling();
    let axes = [];
    if (isDirectOption) {
      let axisPath;
      if (arg.fullName) {
        axisPath = arg.fullName.slice(0, arg.fullName.indexOf('.'));
      }
      axes = sourceAxes.filter(a => a.getOptions().optionPath === axisPath);
    } else if ((0, _type.type)(arg.value) === 'object') {
      axes = sourceAxes.filter(a => a.getOptions().optionPath === arg.name);
    } else if (isArray(arg.value)) {
      arg.value.forEach((v, index) => {
        const axis = sourceAxes.filter(a => a.getOptions().optionPath === `${arg.name}[${index}]`)[0];
        if ((0, _type.isDefined)(v[optionName]) && (0, _type.isDefined)(axis)) {
          axes[index] = axis;
        }
      });
    }
    return axes;
  },
  _optionChanged(arg) {
    if (!this._optionChangedLocker) {
      const optionName = 'visualRange';
      let axes;
      const isDirectOption = arg.fullName.indexOf(optionName) > 0 ? true : this.getPartialChangeOptionsName(arg).indexOf(optionName) > -1 ? false : undefined;
      if ((0, _type.isDefined)(isDirectOption)) {
        axes = this._getAxesByOptionPath(arg, isDirectOption, optionName);
        if (axes) {
          if (axes.length > 1 || isArray(arg.value)) {
            axes.forEach((a, index) => setAxisVisualRangeByOption(arg, a, isDirectOption, index));
          } else if (axes.length === 1) {
            setAxisVisualRangeByOption(arg, axes[0], isDirectOption);
          }
        }
      }
    }
    this.callBase(arg);
  },
  _change_VISUAL_RANGE() {
    this._recreateSizeDependentObjects(false);
    if (!this._changes.has('FULL_RENDER')) {
      const resizePanesOnZoom = this.option('resizePanesOnZoom');
      this._doRender({
        force: true,
        drawTitle: false,
        drawLegend: false,
        adjustAxes: resizePanesOnZoom ?? (this.option('adjustAxesOnZoom') || false),
        animate: false
      });
      this._raiseZoomEndHandlers();
    }
  },
  // API
  resetVisualRange() {
    this._valueAxes.forEach(axis => {
      axis.resetVisualRange(false); // T602156
      this._applyCustomVisualRangeOption(axis);
    });
    this._requestChange([VISUAL_RANGE]);
  },
  _getCrosshairMargins() {
    return {
      x: 0,
      y: 0
    };
  },
  _legendDataField: 'series',
  _adjustSeriesLabels: _common.noop,
  _correctValueAxes: _common.noop
});

/***/ }),

/***/ 14107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.overlapping = exports.BaseChart = void 0;
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
var _layout_manager = __webpack_require__(61189);
var trackerModule = _interopRequireWildcard(__webpack_require__(19957));
var _chart_theme_manager = __webpack_require__(99327);
var _data_validator = __webpack_require__(45865);
var _legend = __webpack_require__(16342);
var _data_source = __webpack_require__(1539);
var _export = __webpack_require__(82454);
var _loading_indicator = __webpack_require__(64758);
var _title = __webpack_require__(17384);
var _tooltip = __webpack_require__(14371);
var _utils = __webpack_require__(19157);
var _base_series = __webpack_require__(54932);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _rolling_stock = __webpack_require__(56136);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// PLUGINS_SECTION

const {
  isArray
} = Array;
const REINIT_REFRESH_ACTION = '_reinit';
const REINIT_DATA_SOURCE_REFRESH_ACTION = '_updateDataSource';
const DATA_INIT_REFRESH_ACTION = '_dataInit';
const FORCE_RENDER_REFRESH_ACTION = '_forceRender';
const RESIZE_REFRESH_ACTION = '_resize';
const ACTIONS_BY_PRIORITY = [REINIT_REFRESH_ACTION, REINIT_DATA_SOURCE_REFRESH_ACTION, DATA_INIT_REFRESH_ACTION, FORCE_RENDER_REFRESH_ACTION, RESIZE_REFRESH_ACTION];
const DEFAULT_OPACITY = 0.3;
const REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS = ['series', 'commonSeriesSettings', 'dataPrepareSettings', 'seriesSelectionMode', 'pointSelectionMode', 'synchronizeMultiAxes', 'resolveLabelsOverlapping'];
const REFRESH_SERIES_FAMILIES_ACTION_OPTIONS = ['minBubbleSize', 'maxBubbleSize', 'barGroupPadding', 'barGroupWidth', 'negativesAsZeroes', 'negativesAsZeros' // misspelling case
];
const FORCE_RENDER_REFRESH_ACTION_OPTIONS = ['adaptiveLayout', 'crosshair', 'resolveLabelOverlapping', 'adjustOnZoom', 'stickyHovering'];
const FONT = 'font';
function checkHeightRollingStock(rollingStocks, stubCanvas) {
  const canvasSize = stubCanvas.end - stubCanvas.start;
  let size = 0;
  rollingStocks.forEach(rollingStock => {
    size += rollingStock.getBoundingRect().width;
  });
  while (canvasSize < size) {
    size -= findAndKillSmallValue(rollingStocks);
  }
}
function findAndKillSmallValue(rollingStocks) {
  const smallestObject = rollingStocks.reduce((prev, rollingStock, index) => {
    if (!rollingStock) return prev;
    const value = rollingStock.value();
    return value < prev.value ? {
      value,
      rollingStock,
      index
    } : prev;
  }, {
    rollingStock: undefined,
    value: Infinity,
    index: undefined
  });
  smallestObject.rollingStock.getLabels()[0].draw(false);
  const {
    width
  } = smallestObject.rollingStock.getBoundingRect();
  rollingStocks[smallestObject.index] = null;
  return width;
}
function checkStackOverlap(rollingStocks) {
  let i;
  let j;
  let iLength;
  let jLength;
  let overlap = false;
  for (i = 0, iLength = rollingStocks.length - 1; i < iLength; i++) {
    for (j = i + 1, jLength = rollingStocks.length; j < jLength; j++) {
      if (i !== j && checkStacksOverlapping(rollingStocks[i], rollingStocks[j], true)) {
        overlap = true;
        break;
      }
    }
    if (overlap) break;
  }
  return overlap;
}
function resolveLabelOverlappingInOneDirection(points, canvas, isRotated, isInverted, shiftFunction) {
  let customSorting = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : () => 0;
  const rollingStocks = [];
  const stubCanvas = {
    start: isRotated ? canvas.left : canvas.top,
    end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom
  };
  let hasStackedSeries = false;
  let sortRollingStocks;
  points.forEach(p => {
    if (!p) return;
    hasStackedSeries = hasStackedSeries || p.series.isStackedSeries() || p.series.isFullStackedSeries();
    p.getLabels().forEach(l => {
      if (l.isVisible()) {
        rollingStocks.push(new _rolling_stock.RollingStock(l, isRotated, shiftFunction));
      }
    });
  });
  if (hasStackedSeries) {
    if (Number(!isRotated) ^ Number(isInverted)) {
      rollingStocks.reverse();
    }
    sortRollingStocks = isInverted ? rollingStocks : sortRollingStocksByValue(rollingStocks);
  } else {
    const rollingStocksTmp = rollingStocks.slice();
    sortRollingStocks = rollingStocks.sort((a, b) => customSorting(a, b) || a.getInitialPosition() - b.getInitialPosition() || rollingStocksTmp.indexOf(a) - rollingStocksTmp.indexOf(b));
  }
  if (!checkStackOverlap(sortRollingStocks)) return false;
  checkHeightRollingStock(sortRollingStocks, stubCanvas);
  prepareOverlapStacks(sortRollingStocks);
  sortRollingStocks.reverse();
  moveRollingStock(sortRollingStocks, stubCanvas);
  return true;
}
function checkStacksOverlapping(firstRolling, secondRolling, inTwoSides) {
  if (!firstRolling || !secondRolling) return;
  const firstRect = firstRolling.getBoundingRect();
  const secondRect = secondRolling.getBoundingRect();
  const oppositeOverlapping = inTwoSides ? firstRect.oppositeStart <= secondRect.oppositeStart && firstRect.oppositeEnd > secondRect.oppositeStart || secondRect.oppositeStart <= firstRect.oppositeStart && secondRect.oppositeEnd > firstRect.oppositeStart : true;
  return firstRect.end > secondRect.start && oppositeOverlapping;
}
function sortRollingStocksByValue(rollingStocks) {
  const positiveRollingStocks = [];
  const negativeRollingStocks = [];
  rollingStocks.forEach(stock => {
    if (stock.value() > 0) {
      positiveRollingStocks.push(stock);
    } else {
      negativeRollingStocks.unshift(stock);
    }
  });
  return positiveRollingStocks.concat(negativeRollingStocks);
}
function prepareOverlapStacks(rollingStocks) {
  let root;
  for (let i = 0; i < rollingStocks.length - 1; i += 1) {
    const currentRollingStock = root || rollingStocks[i];
    if (checkStacksOverlapping(currentRollingStock, rollingStocks[i + 1])) {
      currentRollingStock.toChain(rollingStocks[i + 1]);
      rollingStocks[i + 1] = null;
      root = currentRollingStock;
    } else {
      root = rollingStocks[i + 1] || currentRollingStock;
    }
  }
}
function rollingStocksIsOut(rollingStock, canvas) {
  return rollingStock.getBoundingRect().end > canvas.end;
}
function moveRollingStock(rollingStocks, canvas) {
  for (let i = 0; i < rollingStocks.length; i += 1) {
    const currentRollingStock = rollingStocks[i];
    let shouldSetCanvas = true;
    if (currentRollingStock !== null && rollingStocksIsOut(currentRollingStock, canvas)) {
      const currentBBox = currentRollingStock.getBoundingRect();
      for (let j = i + 1; j < rollingStocks.length; j += 1) {
        const nextRollingStock = rollingStocks[j];
        if (nextRollingStock) {
          const nextBBox = nextRollingStock.getBoundingRect();
          if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {
            nextRollingStock.toChain(currentRollingStock);
            shouldSetCanvas = false;
            break;
          }
        }
      }
    }
    if (shouldSetCanvas) {
      currentRollingStock === null || currentRollingStock === void 0 || currentRollingStock.setRollingStockInCanvas(canvas);
    }
  }
}
function getLegendFields(name) {
  return {
    nameField: `${name}Name`,
    colorField: `${name}Color`,
    indexField: `${name}Index`
  };
}
function getLegendSettings(legendDataField) {
  const formatObjectFields = getLegendFields(legendDataField);
  return {
    getFormatObject(data) {
      const res = {};
      res[formatObjectFields.indexField] = data.id;
      res[formatObjectFields.colorField] = data.states.normal.fill;
      res[formatObjectFields.nameField] = data.text;
      return res;
    },
    textField: formatObjectFields.nameField
  };
}
function checkOverlapping(firstRect, secondRect) {
  return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height);
}
const overlapping = exports.overlapping = {
  resolveLabelOverlappingInOneDirection
};
const BaseChart = exports.BaseChart = _m_base_widget.default.inherit({
  _eventsMap: {
    onSeriesClick: {
      name: 'seriesClick'
    },
    onPointClick: {
      name: 'pointClick'
    },
    onArgumentAxisClick: {
      name: 'argumentAxisClick'
    },
    onLegendClick: {
      name: 'legendClick'
    },
    onSeriesSelectionChanged: {
      name: 'seriesSelectionChanged'
    },
    onPointSelectionChanged: {
      name: 'pointSelectionChanged'
    },
    onSeriesHoverChanged: {
      name: 'seriesHoverChanged'
    },
    onPointHoverChanged: {
      name: 'pointHoverChanged'
    },
    onDone: {
      name: 'done',
      actionSettings: {
        excludeValidators: ['disabled']
      }
    },
    onZoomStart: {
      name: 'zoomStart'
    },
    onZoomEnd: {
      name: 'zoomEnd'
    }
  },
  _fontFields: [`legend.${FONT}`, `legend.title.${FONT}`, `legend.title.subtitle.${FONT}`, `commonSeriesSettings.label.${FONT}`],
  _rootClassPrefix: 'dxc',
  _rootClass: 'dxc-chart',
  _initialChanges: ['INIT'],
  _themeDependentChanges: ['REFRESH_SERIES_REINIT'],
  _getThemeManagerOptions() {
    const themeOptions = this.callBase.apply(this, arguments);
    themeOptions.options = this.option();
    return themeOptions;
  },
  _createThemeManager() {
    const chartOption = this.option();
    const themeManager = new _chart_theme_manager.ThemeManager(this._getThemeManagerOptions());
    themeManager.setTheme(chartOption.theme, chartOption.rtlEnabled);
    return themeManager;
  },
  _initCore() {
    this._canvasClipRect = this._renderer.clipRect();
    this._createHtmlStructure();
    this._createLegend();
    this._createTracker();
    this._needHandleRenderComplete = true;
    this.layoutManager = new _layout_manager.LayoutManager();
    this._createScrollBar();
    _events_engine.default.on(this._$element, 'contextmenu', event => {
      if ((0, _index.isTouchEvent)(event) || (0, _index.isPointerEvent)(event)) {
        event.preventDefault();
      }
    });
    _events_engine.default.on(this._$element, 'MSHoldVisual', event => {
      event.preventDefault();
    });
  },
  // Common functionality is overridden because Chart has its own layout logic.
  // Nevertheless common logic should be used.
  _getLayoutItems: _common.noop,
  _layoutManagerOptions() {
    return this._themeManager.getOptions('adaptiveLayout');
  },
  _reinit() {
    (0, _utils.setCanvasValues)(this._canvas);
    this._reinitAxes();
    this._requestChange(['DATA_SOURCE', 'DATA_INIT', 'CORRECT_AXIS', 'FULL_RENDER']);
  },
  _correctAxes: _common.noop,
  _createHtmlStructure() {
    const renderer = this._renderer;
    const {
      root
    } = renderer;
    const createConstantLinesGroup = function () {
      // TODO: Must be created in the same place where used (advanced chart)
      return renderer.g().attr({
        class: 'dxc-constant-lines-group'
      }).linkOn(root, 'constant-lines');
    };
    this._constantLinesGroup = {
      dispose() {
        this.under.dispose();
        this.above.dispose();
      },
      linkOff() {
        this.under.linkOff();
        this.above.linkOff();
      },
      clear() {
        this.under.linkRemove().clear();
        this.above.linkRemove().clear();
      },
      linkAppend() {
        this.under.linkAppend();
        this.above.linkAppend();
      }
    };
    this._labelsAxesGroup = renderer.g().attr({
      class: 'dxc-elements-axes-group'
    });
    const appendLabelsAxesGroup = () => {
      this._labelsAxesGroup.linkOn(root, 'elements');
    };
    this._backgroundRect = renderer.rect().attr({
      fill: 'gray',
      opacity: 0.0001
    }).append(root);
    this._panesBackgroundGroup = renderer.g().attr({
      class: 'dxc-background'
    }).append(root);
    this._stripsGroup = renderer.g().attr({
      class: 'dxc-strips-group'
    }).linkOn(root, 'strips'); // TODO: Must be created in the same place where used (advanced chart)
    this._gridGroup = renderer.g().attr({
      class: 'dxc-grids-group'
    }).linkOn(root, 'grids'); // TODO: Must be created in the same place where used (advanced chart)
    this._panesBorderGroup = renderer.g().attr({
      class: 'dxc-border'
    }).linkOn(root, 'border'); // TODO: Must be created in the same place where used (chart)
    this._axesGroup = renderer.g().attr({
      class: 'dxc-axes-group'
    }).linkOn(root, 'axes'); // TODO: Must be created in the same place where used (advanced chart)
    this._executeAppendBeforeSeries(appendLabelsAxesGroup);
    this._stripLabelAxesGroup = renderer.g().attr({
      class: 'dxc-strips-labels-group'
    }).linkOn(root, 'strips-labels'); // TODO: Must be created in the same place where used (advanced chart)
    this._constantLinesGroup.under = createConstantLinesGroup();
    this._seriesGroup = renderer.g().attr({
      class: 'dxc-series-group'
    }).linkOn(root, 'series');
    this._executeAppendAfterSeries(appendLabelsAxesGroup);
    this._constantLinesGroup.above = createConstantLinesGroup();
    this._scaleBreaksGroup = renderer.g().attr({
      class: 'dxc-scale-breaks'
    }).linkOn(root, 'scale-breaks');
    this._labelsGroup = renderer.g().attr({
      class: 'dxc-labels-group'
    }).linkOn(root, 'labels');
    this._crosshairCursorGroup = renderer.g().attr({
      class: 'dxc-crosshair-cursor'
    }).linkOn(root, 'crosshair');
    this._legendGroup = renderer.g().attr({
      class: 'dxc-legend',
      'clip-path': this._getCanvasClipRectID()
    }).linkOn(root, 'legend').linkAppend(root).enableLinks();
    this._scrollBarGroup = renderer.g().attr({
      class: 'dxc-scroll-bar'
    }).linkOn(root, 'scroll-bar');
  },
  _executeAppendBeforeSeries() {},
  _executeAppendAfterSeries() {},
  _disposeObjectsInArray(propName, fieldNames) {
    (this[propName] || []).forEach(item => {
      if (fieldNames && item) {
        fieldNames.forEach(field => {
          var _item$field;
          (_item$field = item[field]) === null || _item$field === void 0 || _item$field.dispose();
        });
      } else {
        item === null || item === void 0 || item.dispose();
      }
    });
    this[propName] = null;
  },
  _disposeCore() {
    const disposeObject = propName => {
      // TODO: What is the purpose of the `if` check in a private function?
      if (this[propName]) {
        this[propName].dispose();
        this[propName] = null;
      }
    };
    const unlinkGroup = name => {
      this[name].linkOff();
    };
    const disposeObjectsInArray = this._disposeObjectsInArray;
    this._renderer.stopAllAnimations();
    disposeObjectsInArray.call(this, 'series');
    disposeObject('_tracker');
    disposeObject('_crosshair');
    this.layoutManager = this._userOptions = this._canvas = this._groupsData = null;
    unlinkGroup('_stripsGroup');
    unlinkGroup('_gridGroup');
    unlinkGroup('_axesGroup');
    unlinkGroup('_constantLinesGroup');
    unlinkGroup('_stripLabelAxesGroup');
    unlinkGroup('_panesBorderGroup');
    unlinkGroup('_seriesGroup');
    unlinkGroup('_labelsGroup');
    unlinkGroup('_crosshairCursorGroup');
    unlinkGroup('_legendGroup');
    unlinkGroup('_scrollBarGroup');
    unlinkGroup('_scaleBreaksGroup');
    disposeObject('_canvasClipRect');
    disposeObject('_panesBackgroundGroup');
    disposeObject('_backgroundRect');
    disposeObject('_stripsGroup');
    disposeObject('_gridGroup');
    disposeObject('_axesGroup');
    disposeObject('_constantLinesGroup');
    disposeObject('_stripLabelAxesGroup');
    disposeObject('_panesBorderGroup');
    disposeObject('_seriesGroup');
    disposeObject('_labelsGroup');
    disposeObject('_crosshairCursorGroup');
    disposeObject('_legendGroup');
    disposeObject('_scrollBarGroup');
    disposeObject('_scaleBreaksGroup');
  },
  _getAnimationOptions() {
    return this._themeManager.getOptions('animation');
  },
  _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  // TODO: Theme manager should stop knowing about user options then this method can be removed
  _getOption(name) {
    return this._themeManager.getOptions(name);
  },
  _applySize(rect) {
    this._rect = rect.slice();
    if (!this._changes.has('FULL_RENDER')) {
      this._processRefreshData(RESIZE_REFRESH_ACTION);
    }
  },
  // _resize: function () {
  //    if (this._updateLockCount) {// T244164
  //        this._processRefreshData(RESIZE_REFRESH_ACTION);
  //    } else {
  //        this._render(this.__renderOptions || { animate: false, isResize: true });
  //    }
  // },
  _resize() {
    this._doRender(this.__renderOptions || {
      animate: false,
      isResize: true
    });
  },
  _trackerType: 'ChartTracker',
  _createTracker() {
    // eslint-disable-next-line import/namespace
    this._tracker = new trackerModule[this._trackerType]({
      seriesGroup: this._seriesGroup,
      renderer: this._renderer,
      tooltip: this._tooltip,
      legend: this._legend,
      eventTrigger: this._eventTrigger
    });
  },
  _getTrackerSettings() {
    return (0, _extend.extend)({
      chart: this
    }, this._getSelectionModes());
  },
  _getSelectionModes() {
    const themeManager = this._themeManager;
    return {
      seriesSelectionMode: themeManager.getOptions('seriesSelectionMode'),
      pointSelectionMode: themeManager.getOptions('pointSelectionMode')
    };
  },
  _updateTracker(trackerCanvases) {
    this._tracker.update(this._getTrackerSettings());
    this._tracker.setCanvases({
      left: 0,
      right: this._canvas.width,
      top: 0,
      bottom: this._canvas.height
    }, trackerCanvases);
  },
  _createCanvasFromRect(rect) {
    const currentCanvas = this._canvas;
    return (0, _utils.setCanvasValues)({
      left: rect[0],
      top: rect[1],
      right: currentCanvas.width - rect[2],
      bottom: currentCanvas.height - rect[3],
      width: currentCanvas.width,
      height: currentCanvas.height
    });
  },
  _doRender(_options) {
    if (this._canvas.width === 0 && this._canvas.height === 0) return;
    this._resetIsReady(); // T207606
    const drawOptions = this._prepareDrawOptions(_options);
    const {
      recreateCanvas
    } = drawOptions;
    // T207665
    this._preserveOriginalCanvas();
    // T207665
    if (recreateCanvas) {
      this.__currentCanvas = this._canvas;
    } else {
      this._canvas = this.__currentCanvas;
    }
    recreateCanvas && this._updateCanvasClipRect(this._canvas);
    this._canvas = this._createCanvasFromRect(this._rect);
    this._renderer.stopAllAnimations(true);
    this._cleanGroups();
    const startTime = new Date();
    this._renderElements(drawOptions);
    this._lastRenderingTime = Number(new Date()) - Number(startTime);
  },
  _preserveOriginalCanvas() {
    this.__originalCanvas = this._canvas;
    this._canvas = (0, _extend.extend)({}, this._canvas); // NOTE: Instance of the original canvas must be preserved
  },
  _layoutAxes: _common.noop,
  _renderElements(drawOptions) {
    const preparedOptions = this._prepareToRender(drawOptions);
    const isRotated = this._isRotated();
    const isLegendInside = this._isLegendInside();
    const trackerCanvases = [];
    const dirtyCanvas = (0, _extend.extend)({}, this._canvas);
    let argBusinessRange;
    let zoomMinArg;
    let zoomMaxArg;
    this._renderer.lock();
    if (drawOptions.drawLegend && this._legend) {
      this._legendGroup.linkAppend();
    }
    this.layoutManager.setOptions(this._layoutManagerOptions());
    const layoutTargets = this._getLayoutTargets();
    this._layoutAxes(needSpace => {
      const axisDrawOptions = needSpace ? (0, _extend.extend)({}, drawOptions, {
        animate: false,
        recreateCanvas: true
      }) : drawOptions;
      const canvas = this._renderAxes(axisDrawOptions, preparedOptions);
      this._shrinkAxes(needSpace, canvas);
    });
    this._applyClipRects(preparedOptions);
    this._appendSeriesGroups();
    this._createCrosshairCursor();
    layoutTargets.forEach(_ref => {
      let {
        canvas
      } = _ref;
      trackerCanvases.push({
        left: canvas.left,
        right: canvas.width - canvas.right,
        top: canvas.top,
        bottom: canvas.height - canvas.bottom
      });
    });
    if (this._scrollBar) {
      argBusinessRange = this._argumentAxes[0].getTranslator().getBusinessRange();
      if (argBusinessRange.axisType === 'discrete' && argBusinessRange.categories && argBusinessRange.categories.length <= 1 || argBusinessRange.axisType !== 'discrete' && argBusinessRange.min === argBusinessRange.max) {
        zoomMinArg = zoomMaxArg = undefined;
      } else {
        zoomMinArg = argBusinessRange.minVisible;
        zoomMaxArg = argBusinessRange.maxVisible;
      }
      this._scrollBar.init(argBusinessRange, !this._argumentAxes[0].getOptions().valueMarginsEnabled).setPosition(zoomMinArg, zoomMaxArg);
    }
    this._updateTracker(trackerCanvases);
    this._updateLegendPosition(drawOptions, isLegendInside);
    this._applyPointMarkersAutoHiding();
    this._renderSeries(drawOptions, isRotated, isLegendInside);
    this._renderGraphicObjects();
    this._renderer.unlock();
  },
  _updateLegendPosition: _common.noop,
  _createCrosshairCursor: _common.noop,
  _appendSeriesGroups() {
    this._seriesGroup.linkAppend();
    this._labelsGroup.linkAppend();
    this._appendAdditionalSeriesGroups();
  },
  _renderSeries(drawOptions, isRotated, isLegendInside) {
    this._calculateSeriesLayout(drawOptions, isRotated);
    this._renderSeriesElements(drawOptions, isLegendInside);
  },
  _calculateSeriesLayout(drawOptions, isRotated) {
    drawOptions.hideLayoutLabels = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), isRotated) && !this._themeManager.getOptions('adaptiveLayout').keepLabels;
    this._updateSeriesDimensions(drawOptions);
  },
  _getArgFilter() {
    return () => true;
  },
  _getValFilter() {
    return () => true;
  },
  _getPointsToAnimation(series) {
    const argViewPortFilter = this._getArgFilter();
    return series.map(s => {
      const valViewPortFilter = this._getValFilter(s);
      return s.getPoints().filter(p => p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)))).length;
    });
  },
  _renderSeriesElements(drawOptions, isLegendInside) {
    const {
      series
    } = this;
    const resolveLabelOverlapping = this._themeManager.getOptions('resolveLabelOverlapping');
    const pointsToAnimation = this._getPointsToAnimation(series);
    series.forEach((singleSeries, index) => {
      this._applyExtraSettings(singleSeries, drawOptions);
      const animationEnabled = drawOptions.animate && pointsToAnimation[index] <= drawOptions.animationPointsLimit && this._renderer.animationEnabled();
      singleSeries.draw(animationEnabled, drawOptions.hideLayoutLabels, this._getLegendCallBack(singleSeries));
    });
    if (resolveLabelOverlapping === 'none') {
      this._adjustSeriesLabels(false);
    } else {
      this._locateLabels(resolveLabelOverlapping);
    }
    this._renderTrackers(isLegendInside);
    this._tracker.repairTooltip();
    this._renderExtraElements();
    this._clearCanvas();
    this._seriesElementsDrawn = true;
  },
  _changesApplied() {
    if (this._seriesElementsDrawn) {
      this._seriesElementsDrawn = false;
      this._drawn();
      this._renderCompleteHandler();
    }
  },
  _locateLabels(resolveLabelOverlapping) {
    this._resolveLabelOverlapping(resolveLabelOverlapping);
  },
  _renderExtraElements() {},
  _clearCanvas() {
    // T207665, T336349, T503616
    this._canvas = this.__originalCanvas;
  },
  _resolveLabelOverlapping(resolveLabelOverlapping) {
    let func;
    switch (resolveLabelOverlapping) {
      case 'stack':
        func = this._resolveLabelOverlappingStack;
        break;
      case 'hide':
        func = this._resolveLabelOverlappingHide;
        break;
      case 'shift':
        func = this._resolveLabelOverlappingShift;
        break;
      default:
        break;
    }
    return (0, _type.isFunction)(func) && func.call(this);
  },
  _getVisibleSeries() {
    return (0, _common.grep)(this.getAllSeries(), series => series.isVisible());
  },
  _resolveLabelOverlappingHide() {
    const labels = [];
    let currentLabel;
    let nextLabel;
    let currentLabelRect;
    let nextLabelRect;
    let i;
    let j;
    let points;
    const series = this._getVisibleSeries();
    for (i = 0; i < series.length; i++) {
      points = series[i].getVisiblePoints();
      for (j = 0; j < points.length; j++) {
        labels.push.apply(labels, points[j].getLabels());
      }
    }
    for (i = 0; i < labels.length; i++) {
      currentLabel = labels[i];
      if (!currentLabel.isVisible()) {
        continue;
      }
      currentLabelRect = currentLabel.getBoundingRect();
      for (j = i + 1; j < labels.length; j++) {
        nextLabel = labels[j];
        nextLabelRect = nextLabel.getBoundingRect();
        if (checkOverlapping(currentLabelRect, nextLabelRect)) {
          nextLabel.draw(false);
        }
      }
    }
  },
  _cleanGroups() {
    this._stripsGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    this._gridGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    this._axesGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    this._constantLinesGroup.clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    this._stripLabelAxesGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    // that._seriesGroup.linkRemove().clear();
    this._labelsGroup.linkRemove().clear();
    this._crosshairCursorGroup.linkRemove().clear();
    this._scaleBreaksGroup.linkRemove().clear();
  },
  _allowLegendInsidePosition() {
    return false;
  },
  _createLegend() {
    const legendSettings = getLegendSettings(this._legendDataField);
    this._legend = new _legend.Legend({
      renderer: this._renderer,
      widget: this,
      group: this._legendGroup,
      backgroundClass: 'dxc-border',
      itemGroupClass: 'dxc-item',
      titleGroupClass: 'dxc-title',
      textField: legendSettings.textField,
      getFormatObject: legendSettings.getFormatObject,
      allowInsidePosition: this._allowLegendInsidePosition()
    });
    this._updateLegend();
    this._layout.add(this._legend);
  },
  _updateLegend() {
    const themeManager = this._themeManager;
    const legendOptions = themeManager.getOptions('legend');
    const legendData = this._getLegendData();
    legendOptions.containerBackgroundColor = themeManager.getOptions('containerBackgroundColor');
    legendOptions._incidentOccurred = this._incidentOccurred; // TODO: Why is `_` used?
    this._legend.update(legendData, legendOptions, themeManager.theme('legend').title);
    this._change(['LAYOUT']);
  },
  _prepareDrawOptions(drawOptions) {
    const animationOptions = this._getAnimationOptions();
    const options = (0, _extend.extend)({}, {
      force: false,
      adjustAxes: true,
      drawLegend: true,
      drawTitle: true,
      animate: animationOptions.enabled,
      animationPointsLimit: animationOptions.maxPointCountSupported
    }, drawOptions, this.__renderOptions); // NOTE: This is to support `render` method options
    if (!(0, _type.isDefined)(options.recreateCanvas)) {
      options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle;
    }
    return options;
  },
  _processRefreshData(newRefreshAction) {
    const currentRefreshActionPosition = ACTIONS_BY_PRIORITY.indexOf(this._currentRefreshData);
    const newRefreshActionPosition = ACTIONS_BY_PRIORITY.indexOf(newRefreshAction);
    if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition) {
      this._currentRefreshData = newRefreshAction;
      // this._invalidate();
    }
    this._requestChange(['REFRESH']);
  },
  _getLegendData() {
    return (0, _utils.map)(this._getLegendTargets(), item => {
      const {
        legendData
      } = item;
      const style = item.getLegendStyles;
      let {
        opacity
      } = style.normal;
      if (!item.visible) {
        if (!(0, _type.isDefined)(opacity) || opacity > DEFAULT_OPACITY) {
          opacity = DEFAULT_OPACITY;
        }
        legendData.textOpacity = DEFAULT_OPACITY;
      }
      const opacityStyle = {
        opacity
      };
      legendData.states = {
        hover: (0, _extend.extend)({}, style.hover, opacityStyle),
        selection: (0, _extend.extend)({}, style.selection, opacityStyle),
        normal: (0, _extend.extend)({}, style.normal, opacityStyle)
      };
      return legendData;
    });
  },
  _getLegendOptions(item) {
    return {
      legendData: {
        text: item[this._legendItemTextField],
        id: item.index,
        visible: true
      },
      getLegendStyles: item.getLegendStyles(),
      visible: item.isVisible()
    };
  },
  _disposeSeries(seriesIndex) {
    var _this$series;
    if (this.series) {
      if ((0, _type.isDefined)(seriesIndex)) {
        this.series[seriesIndex].dispose();
        this.series.splice(seriesIndex, 1);
      } else {
        this.series.forEach(s => s.dispose());
        this.series.length = 0;
      }
    }
    if (!((_this$series = this.series) !== null && _this$series !== void 0 && _this$series.length)) {
      this.series = [];
    }
  },
  _disposeSeriesFamilies() {
    (this.seriesFamilies || []).forEach(family => {
      family.dispose();
    });
    this.seriesFamilies = null;
    this._needHandleRenderComplete = true;
  },
  _optionChanged(arg) {
    this._themeManager.resetOptions(arg.name);
    this.callBase.apply(this, arguments);
  },
  _applyChanges() {
    this._themeManager.update(this._options.silent());
    this.callBase(...arguments);
  },
  _optionChangesMap: {
    animation: 'ANIMATION',
    dataSource: 'DATA_SOURCE',
    palette: 'PALETTE',
    paletteExtensionMode: 'PALETTE',
    legend: 'FORCE_DATA_INIT',
    seriesTemplate: 'FORCE_DATA_INIT',
    export: 'FORCE_RENDER',
    valueAxis: 'AXES_AND_PANES',
    argumentAxis: 'AXES_AND_PANES',
    commonAxisSettings: 'AXES_AND_PANES',
    panes: 'AXES_AND_PANES',
    commonPaneSettings: 'AXES_AND_PANES',
    defaultPane: 'AXES_AND_PANES',
    containerBackgroundColor: 'AXES_AND_PANES',
    rotated: 'ROTATED',
    autoHidePointMarkers: 'REFRESH_SERIES_REINIT',
    customizePoint: 'REFRESH_SERIES_REINIT',
    customizeLabel: 'REFRESH_SERIES_REINIT',
    scrollBar: 'SCROLL_BAR'
  },
  _optionChangesOrder: ['ROTATED', 'PALETTE', 'REFRESH_SERIES_REINIT', 'USE_SPIDER_WEB', 'AXES_AND_PANES', 'INIT', 'REINIT', 'DATA_SOURCE', 'REFRESH_SERIES_DATA_INIT', 'DATA_INIT', 'FORCE_DATA_INIT', 'REFRESH_AXES', 'CORRECT_AXIS'],
  _customChangesOrder: ['ANIMATION', 'REFRESH_SERIES_FAMILIES', 'FORCE_FIRST_DRAWING', 'FORCE_DRAWING', 'FORCE_RENDER', 'VISUAL_RANGE', 'SCROLL_BAR', 'REINIT', 'REFRESH', 'FULL_RENDER'],
  _change_ANIMATION() {
    this._renderer.updateAnimationOptions(this._getAnimationOptions());
  },
  _change_DATA_SOURCE() {
    this._needHandleRenderComplete = true;
    this._updateDataSource();
  },
  _change_PALETTE() {
    this._themeManager.updatePalette();
    this._refreshSeries('DATA_INIT');
  },
  _change_REFRESH_SERIES_DATA_INIT() {
    this._refreshSeries('DATA_INIT');
  },
  _change_DATA_INIT() {
    if ((!this.series || this.needToPopulateSeries) && !this._changes.has('FORCE_DATA_INIT')) {
      this._dataInit();
    }
  },
  _change_FORCE_DATA_INIT() {
    this._dataInit();
  },
  _change_REFRESH_SERIES_FAMILIES() {
    this._processSeriesFamilies();
    this._populateBusinessRange();
    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_FORCE_RENDER() {
    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_AXES_AND_PANES() {
    this._refreshSeries('INIT');
  },
  _change_ROTATED() {
    this._createScrollBar();
    this._refreshSeries('INIT');
  },
  _change_REFRESH_SERIES_REINIT() {
    this._refreshSeries('INIT');
  },
  _change_REFRESH_AXES() {
    (0, _utils.setCanvasValues)(this._canvas);
    this._reinitAxes();
    this._requestChange(['CORRECT_AXIS', 'FULL_RENDER']);
  },
  _change_SCROLL_BAR() {
    this._createScrollBar();
    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_REINIT() {
    this._processRefreshData(REINIT_REFRESH_ACTION);
  },
  _change_FORCE_DRAWING() {
    this._resetComponentsAnimation();
  },
  _change_FORCE_FIRST_DRAWING() {
    this._resetComponentsAnimation(true);
  },
  _resetComponentsAnimation(isFirstDrawing) {
    this.series.forEach(s => {
      s.resetApplyingAnimation(isFirstDrawing);
    });
    this._resetAxesAnimation(isFirstDrawing);
  },
  _resetAxesAnimation: _common.noop,
  _refreshSeries(actionName) {
    this.needToPopulateSeries = true;
    this._requestChange([actionName]);
  },
  _change_CORRECT_AXIS() {
    this._correctAxes();
  },
  _doRefresh() {
    const methodName = this._currentRefreshData;
    if (methodName) {
      this._currentRefreshData = null;
      this._renderer.stopAllAnimations(true);
      this[methodName]();
    }
  },
  _updateCanvasClipRect(canvas) {
    const width = Math.max(canvas.width - canvas.left - canvas.right, 0);
    const height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);
    this._canvasClipRect.attr({
      x: canvas.left,
      y: canvas.top,
      width,
      height
    });
    this._backgroundRect.attr({
      x: canvas.left,
      y: canvas.top,
      width,
      height
    });
  },
  _getCanvasClipRectID() {
    return this._canvasClipRect.id;
  },
  _dataSourceChangedHandler() {
    if (this._changes.has('INIT')) {
      this._requestChange(['DATA_INIT']);
    } else {
      this._requestChange(['FORCE_DATA_INIT']);
    }
  },
  _dataInit() {
    this._dataSpecificInit(true);
  },
  _processSingleSeries(singleSeries) {
    singleSeries.createPoints(false);
  },
  _handleSeriesDataUpdated() {
    if (this._getVisibleSeries().some(s => s.useAggregation())) {
      this._populateMarginOptions();
    }
    this.series.forEach(s => this._processSingleSeries(s), this);
  },
  _dataSpecificInit(needRedraw) {
    if (!this.series || this.needToPopulateSeries) {
      this.series = this._populateSeries();
    }
    this._repopulateSeries();
    this._seriesPopulatedHandlerCore();
    this._populateBusinessRange();
    this._tracker.updateSeries(this.series, this._changes.has('INIT'));
    this._updateLegend();
    if (needRedraw) {
      this._requestChange(['FULL_RENDER']);
    }
    // needRedraw && that._forceRender();
  },
  _forceRender() {
    this._doRender({
      force: true
    });
  },
  _repopulateSeries() {
    const themeManager = this._themeManager;
    const data = this._dataSourceItems();
    const dataValidatorOptions = themeManager.getOptions('dataPrepareSettings');
    const seriesTemplate = themeManager.getOptions('seriesTemplate');
    if (seriesTemplate) {
      this._populateSeries(data);
    }
    this._groupSeries();
    const parsedData = (0, _data_validator.validateData)(data, this._groupsData, this._incidentOccurred, dataValidatorOptions);
    themeManager.resetPalette();
    this.series.forEach(singleSeries => {
      singleSeries.updateData(parsedData[singleSeries.getArgumentField()]);
    });
    this._handleSeriesDataUpdated();
  },
  _renderCompleteHandler() {
    let allSeriesInited = true;
    if (this._needHandleRenderComplete) {
      this.series.forEach(s => {
        allSeriesInited = allSeriesInited && s.canRenderCompleteHandle();
      });
      if (allSeriesInited) {
        this._needHandleRenderComplete = false;
        this._eventTrigger('done', {
          target: this
        });
      }
    }
  },
  _dataIsReady() {
    // In order to support scenario when chart is created without "dataSource" and it is considered
    // as data is being loaded the check for state of "dataSource" option is added
    return (0, _type.isDefined)(this.option('dataSource')) && this._dataIsLoaded();
  },
  _populateSeriesOptions(data) {
    const themeManager = this._themeManager;
    const seriesTemplate = themeManager.getOptions('seriesTemplate');
    const seriesOptions = seriesTemplate ? (0, _utils.processSeriesTemplate)(seriesTemplate, data || []) : this.option('series');
    const allSeriesOptions = isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [];
    const extraOptions = this._getExtraOptions();
    let particularSeriesOptions;
    let seriesTheme;
    const seriesThemes = [];
    const seriesVisibilityChanged = target => {
      this._specialProcessSeries();
      this._populateBusinessRange(target && target.getValueAxis(), true);
      this._renderer.stopAllAnimations(true);
      this._updateLegend();
      this._requestChange(['FULL_RENDER']);
    };
    for (let i = 0; i < allSeriesOptions.length; i++) {
      particularSeriesOptions = (0, _extend.extend)(true, {}, allSeriesOptions[i], extraOptions);
      if (!(0, _type.isDefined)(particularSeriesOptions.name) || particularSeriesOptions.name === '') {
        particularSeriesOptions.name = `Series ${(i + 1).toString()}`;
      }
      particularSeriesOptions.rotated = this._isRotated();
      particularSeriesOptions.customizePoint = themeManager.getOptions('customizePoint');
      particularSeriesOptions.customizeLabel = themeManager.getOptions('customizeLabel');
      particularSeriesOptions.visibilityChanged = seriesVisibilityChanged;
      particularSeriesOptions.incidentOccurred = this._incidentOccurred;
      seriesTheme = themeManager.getOptions('series', particularSeriesOptions, allSeriesOptions.length);
      if (this._checkPaneName(seriesTheme)) {
        seriesThemes.push(seriesTheme);
      }
    }
    return seriesThemes;
  },
  _populateSeries(data) {
    var _this$series3;
    const seriesBasis = [];
    const incidentOccurred = this._incidentOccurred;
    const seriesThemes = this._populateSeriesOptions(data);
    let particularSeries;
    let disposeSeriesFamilies = false;
    this.needToPopulateSeries = false;
    seriesThemes.forEach(theme => {
      var _this$series2;
      const findSeries = s => s.name === theme.name && !seriesBasis.map(sb => sb.series).includes(s);
      const curSeries = (_this$series2 = this.series) === null || _this$series2 === void 0 ? void 0 : _this$series2.find(findSeries);
      if (curSeries && curSeries.type === theme.type) {
        seriesBasis.push({
          series: curSeries,
          options: theme
        });
      } else {
        seriesBasis.push({
          options: theme
        });
        disposeSeriesFamilies = true;
      }
    });
    ((_this$series3 = this.series) === null || _this$series3 === void 0 ? void 0 : _this$series3.length) !== 0 && this._tracker.clearHover();
    (0, _iterator.reverseEach)(this.series, (index, series) => {
      if (!seriesBasis.some(s => series === s.series)) {
        this._disposeSeries(index);
        disposeSeriesFamilies = true;
      }
    });
    !disposeSeriesFamilies && (disposeSeriesFamilies = seriesBasis.some(sb => sb.series.name !== seriesThemes[sb.series.index].name));
    this.series = [];
    disposeSeriesFamilies && this._disposeSeriesFamilies();
    this._themeManager.resetPalette();
    const eventPipe = data => {
      this.series.forEach(currentSeries => {
        currentSeries.notify(data);
      });
    };
    seriesBasis.forEach(basis => {
      var _this$_argumentAxes;
      const seriesTheme = basis.options;
      const argumentAxis = ((_this$_argumentAxes = this._argumentAxes) === null || _this$_argumentAxes === void 0 ? void 0 : _this$_argumentAxes.filter(a => a.pane === seriesTheme.pane)[0]) ?? this.getArgumentAxis();
      const renderSettings = {
        commonSeriesModes: this._getSelectionModes(),
        argumentAxis,
        valueAxis: this._getValueAxis(seriesTheme.pane, seriesTheme.axis)
      };
      if (basis.series) {
        particularSeries = basis.series;
        particularSeries.updateOptions(seriesTheme, renderSettings);
      } else {
        particularSeries = new _base_series.Series((0, _extend.extend)({
          renderer: this._renderer,
          seriesGroup: this._seriesGroup,
          labelsGroup: this._labelsGroup,
          eventTrigger: this._eventTrigger,
          eventPipe,
          incidentOccurred
        }, renderSettings), seriesTheme);
      }
      if (!particularSeries.isUpdated) {
        incidentOccurred('E2101', [seriesTheme.type]);
      } else {
        particularSeries.index = this.series.length;
        this.series.push(particularSeries);
      }
    });
    return this.series;
  },
  getStackedPoints(point) {
    const stackName = point.series.getStackName();
    return this._getVisibleSeries().reduce((stackPoints, series) => {
      if (!(0, _type.isDefined)(series.getStackName()) || !(0, _type.isDefined)(stackName) || stackName === series.getStackName()) {
        stackPoints = stackPoints.concat(series.getPointsByArg(point.argument));
      }
      return stackPoints;
    }, []);
  },
  // API
  getAllSeries: function getAllSeries() {
    return (this.series || []).slice();
  },
  getSeriesByName: function getSeriesByName(name) {
    const found = (this.series || []).find(singleSeries => singleSeries.name === name);
    return found || null;
  },
  getSeriesByPos: function getSeriesByPos(pos) {
    return (this.series || [])[pos];
  },
  clearSelection: function clearSelection() {
    this._tracker.clearSelection();
  },
  hideTooltip() {
    this._tracker._hideTooltip();
  },
  clearHover() {
    this._tracker.clearHover();
  },
  render(renderOptions) {
    this.__renderOptions = renderOptions;
    this.__forceRender = renderOptions && renderOptions.force;
    this.callBase.apply(this, arguments);
    this.__renderOptions = this.__forceRender = null;
    return this;
  },
  refresh() {
    this._disposeSeries();
    this._disposeSeriesFamilies();
    this._requestChange(['CONTAINER_SIZE', 'REFRESH_SERIES_REINIT']);
  },
  _getMinSize() {
    const adaptiveLayout = this._layoutManagerOptions();
    return [adaptiveLayout.width, adaptiveLayout.height];
  },
  _change_REFRESH() {
    if (!this._changes.has('INIT')) {
      this._doRefresh();
    } else {
      this._currentRefreshData = null;
    }
  },
  _change_FULL_RENDER() {
    this._forceRender();
  },
  _change_INIT() {
    this._reinit();
  },
  _stopCurrentHandling() {
    if (this._disposed) {
      return;
    }
    this._tracker.stopCurrentHandling();
  }
});
REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS.forEach(name => {
  BaseChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_DATA_INIT';
});
FORCE_RENDER_REFRESH_ACTION_OPTIONS.forEach(name => {
  BaseChart.prototype._optionChangesMap[name] = 'FORCE_RENDER';
});
REFRESH_SERIES_FAMILIES_ACTION_OPTIONS.forEach(name => {
  BaseChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_FAMILIES';
});
BaseChart.addPlugin(_export.plugin);
BaseChart.addPlugin(_title.plugin);
BaseChart.addPlugin(_data_source.plugin);
BaseChart.addPlugin(_tooltip.plugin);
BaseChart.addPlugin(_loading_indicator.plugin);
// These are charts specifics on using title - they cannot be omitted because of charts custom layout.
// eslint-disable-next-line
const {
  _change_TITLE
} = BaseChart.prototype;
BaseChart.prototype._change_TITLE = function () {
  _change_TITLE.apply(this, arguments);
  this._change(['FORCE_RENDER']);
};

/***/ }),

/***/ 56136:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RollingStock = void 0;
class RollingStock {
  constructor(label, isRotated, shiftFunction) {
    const bBox = label.getBoundingRect();
    const {
      x
    } = bBox;
    const {
      y
    } = bBox;
    const endX = bBox.x + bBox.width;
    const endY = bBox.y + bBox.height;
    this.labels = [label];
    this.shiftFunction = shiftFunction;
    this.bBox = {
      start: isRotated ? x : y,
      width: isRotated ? bBox.width : bBox.height,
      end: isRotated ? endX : endY,
      oppositeStart: isRotated ? y : x,
      oppositeEnd: isRotated ? endY : endX
    };
    this.initialPosition = isRotated ? bBox.x : bBox.y;
  }
  toChain(nextRollingStock) {
    const nextRollingStockBBox = nextRollingStock.getBoundingRect();
    nextRollingStock.shift(nextRollingStockBBox.start - this.bBox.end);
    this.changeBoxWidth(nextRollingStockBBox.width);
    this.labels = this.labels.concat(nextRollingStock.labels);
  }
  getBoundingRect() {
    return this.bBox;
  }
  shift(shiftLength) {
    this.labels.forEach(label => {
      const bBox = label.getBoundingRect();
      const coords = this.shiftFunction(bBox, shiftLength);
      if (!label.hideInsideLabel(coords)) {
        label.shift(coords.x, coords.y);
      }
    });
    this.bBox.end -= shiftLength;
    this.bBox.start -= shiftLength;
  }
  setRollingStockInCanvas(canvas) {
    if (this.bBox.end > canvas.end) {
      this.shift(this.bBox.end - canvas.end);
    }
  }
  getLabels() {
    return this.labels;
  }
  value() {
    return this.labels[0].getData().value;
  }
  getInitialPosition() {
    return this.initialPosition;
  }
  changeBoxWidth(width) {
    this.bBox.end += width;
    this.bBox.width += width;
  }
}
exports.RollingStock = RollingStock;

/***/ }),

/***/ 55845:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _size = __webpack_require__(58664);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _base_theme_manager = __webpack_require__(43637);
var _base_widget = __webpack_require__(98469);
var _errors_warnings = _interopRequireDefault(__webpack_require__(80726));
var _helpers = __webpack_require__(3603);
var _layout = _interopRequireDefault(__webpack_require__(94551));
var _renderer2 = __webpack_require__(56453);
var _utils = __webpack_require__(19157);
var _utils2 = __webpack_require__(34434);
var _m_charts = _interopRequireDefault(__webpack_require__(66798));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

const {
  log
} = _errors_warnings.default;
const OPTION_RTL_ENABLED = 'rtlEnabled';
const SIZED_ELEMENT_CLASS = 'dx-sized-element';
const baseOptionMethod = _dom_component.default.prototype.option;
function getTrue() {
  return true;
}
function getFalse() {
  return false;
}
function defaultOnIncidentOccurred(e) {
  if (!e.component._eventsStrategy.hasEvent('incidentOccurred')) {
    log.apply(null, [e.target.id].concat(e.target.args || []));
  }
}
function pickPositiveValue(values) {
  return values.reduce((result, value) => value > 0 && !result ? value : result, 0);
}
// TODO - Changes handling
// * Provide more validation - something like
//     _changes: [{
//         code: "THEME",
//         options: ["theme"],
//         type: "option",
//         handler: function () {
//             this._setThemeAndRtl();
//         }
//     }, {
//         code: "CONTAINER_SIZE",
//         options: ["size", "option"],
//         type: "layout",
//         handler: function () {
//             this._updateSize();
//         }
//     }]
const getEmptyComponent = function () {
  const emptyComponentConfig = {
    _initTemplates() {},
    ctor(element, options) {
      this.callBase(element, options);
      const sizedElement = _dom_adapter.default.createElement('div');
      const width = options && (0, _type.isNumeric)(options.width) ? `${options.width}px` : '100%';
      const height = options && (0, _type.isNumeric)(options.height) ? `${options.height}px` : `${this._getDefaultSize().height}px`;
      _dom_adapter.default.setStyle(sizedElement, 'width', width);
      _dom_adapter.default.setStyle(sizedElement, 'height', height);
      _dom_adapter.default.setClass(sizedElement, SIZED_ELEMENT_CLASS, false);
      _dom_adapter.default.insertElement(element, sizedElement);
    }
  };
  const EmptyComponent = _dom_component.default.inherit(emptyComponentConfig);
  const originalInherit = EmptyComponent.inherit;
  EmptyComponent.inherit = function (config) {
    Object.keys(config).forEach(field => {
      if ((0, _type.isFunction)(config[field]) && field.substr(0, 1) !== '_' && field !== 'option' || field === '_dispose' || field === '_optionChanged') {
        config[field] = _common.noop;
      }
    });
    return originalInherit.call(this, config);
  };
  return EmptyComponent;
};
function callForEach(functions) {
  functions.forEach(c => c());
}
const isServerSide = !(0, _window.hasWindow)();
function sizeIsValid(value) {
  return (0, _type.isDefined)(value) && value > 0;
}
const baseWidget = isServerSide ? getEmptyComponent() : _dom_component.default.inherit({
  _eventsMap: {
    onIncidentOccurred: {
      name: 'incidentOccurred',
      actionSettings: {
        excludeValidators: ['disabled']
      }
    },
    onDrawn: {
      name: 'drawn',
      actionSettings: {
        excludeValidators: ['disabled']
      }
    }
  },
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      onIncidentOccurred: defaultOnIncidentOccurred
    });
  },
  _useLinks: true,
  _init() {
    this._$element.children(`.${SIZED_ELEMENT_CLASS}`).remove();
    this._graphicObjects = {};
    this.callBase(...arguments);
    this._changesLocker = 0;
    this._optionChangedLocker = 0;
    this._asyncFirstDrawing = true;
    this._changes = (0, _helpers.changes)();
    this._suspendChanges();
    this._themeManager = this._createThemeManager();
    this._themeManager.setCallback(() => {
      this._requestChange(this._themeDependentChanges);
    });
    this._renderElementAttributes();
    this._initRenderer();
    // Shouldn't "_useLinks" be passed to the renderer instead of doing 3 checks here?
    const useLinks = this._useLinks;
    // There is an implicit relation between `_useLinks` and `loading indicator` - it uses links
    // Though this relation is not ensured in code
    // we will immediately know when it is broken - `loading indicator` will break on construction
    if (useLinks) {
      this._renderer.root.enableLinks().virtualLink('core').virtualLink('peripheral');
    }
    this._renderVisibilityChange();
    this._attachVisibilityChangeHandlers();
    this._toggleParentsScrollSubscription(this._isVisible());
    this._initEventTrigger();
    this._incidentOccurred = (0, _base_widget.createIncidentOccurred)(this.NAME, this._eventTrigger);
    this._layout = new _layout.default();
    // Such solution is used only to avoid writing lots of "after"
    // for all core elements in all widgets
    // May be later a proper solution would be found
    if (useLinks) {
      this._renderer.root.linkAfter('core');
    }
    this._initPlugins();
    this._initCore();
    if (useLinks) {
      this._renderer.root.linkAfter();
    }
    this._change(this._initialChanges);
  },
  _createThemeManager() {
    return new _base_theme_manager.BaseThemeManager(this._getThemeManagerOptions());
  },
  _getThemeManagerOptions() {
    return {
      themeSection: this._themeSection,
      fontFields: this._fontFields
    };
  },
  _initialChanges: ['LAYOUT', 'RESIZE_HANDLER', 'THEME', 'DISABLED'],
  _initPlugins() {
    (0, _iterator.each)(this._plugins, (_, plugin) => {
      plugin.init.call(this);
    });
  },
  _disposePlugins() {
    (0, _iterator.each)(this._plugins.slice().reverse(), (_, plugin) => {
      plugin.dispose.call(this);
    });
  },
  _change(codes) {
    this._changes.add(codes);
  },
  _suspendChanges() {
    this._changesLocker += 1;
  },
  _resumeChanges() {
    if (--this._changesLocker === 0 && this._changes.count() > 0 && !this._applyingChanges) {
      this._renderer.lock();
      this._applyingChanges = true;
      this._applyChanges();
      this._changes.reset();
      this._applyingChanges = false;
      this._changesApplied();
      this._renderer.unlock();
      if (this._optionsQueue) {
        this._applyQueuedOptions();
      }
      this.resolveItemsDeferred(this._legend ? [this._legend] : []);
      this._optionChangedLocker += 1;
      this._notify();
      this._optionChangedLocker -= 1;
    }
  },
  resolveItemsDeferred(items) {
    this._resolveDeferred(this._getTemplatesItems(items));
  },
  _collectTemplatesFromItems(items) {
    return items.reduce((prev, i) => ({
      items: prev.items.concat(i.getTemplatesDef()),
      groups: prev.groups.concat(i.getTemplatesGroups())
    }), {
      items: [],
      groups: []
    });
  },
  _getTemplatesItems(items) {
    const elements = this._collectTemplatesFromItems(items);
    const extraItems = this._getExtraTemplatesItems();
    return {
      items: extraItems.items.concat(elements.items),
      groups: extraItems.groups.concat(elements.groups),
      launchRequest: [extraItems.launchRequest],
      doneRequest: [extraItems.doneRequest]
    };
  },
  _getExtraTemplatesItems() {
    return {
      items: [],
      groups: [],
      launchRequest: () => {},
      doneRequest: () => {}
    };
  },
  _resolveDeferred(_ref) {
    let {
      items,
      launchRequest,
      doneRequest,
      groups
    } = _ref;
    this._setGroupsVisibility(groups, 'hidden');
    if (this._changesApplying) {
      this._changesApplying = false;
      callForEach(doneRequest);
      return;
    }
    let syncRendering = true;
    _deferred.when.apply(this, items).done(() => {
      if (syncRendering) {
        this._setGroupsVisibility(groups, 'visible');
        return;
      }
      callForEach(launchRequest);
      this._changesApplying = true;
      const changes = ['LAYOUT', 'FULL_RENDER'];
      if (this._asyncFirstDrawing) {
        changes.push('FORCE_FIRST_DRAWING');
        this._asyncFirstDrawing = false;
      } else {
        changes.push('FORCE_DRAWING');
      }
      this._requestChange(changes);
      this._setGroupsVisibility(groups, 'visible');
    });
    syncRendering = false;
  },
  _setGroupsVisibility(groups, visibility) {
    groups.forEach(g => g.attr({
      visibility
    }));
  },
  _applyQueuedOptions() {
    const queue = this._optionsQueue;
    this._optionsQueue = null;
    this.beginUpdate();
    (0, _iterator.each)(queue, (_, action) => {
      action();
    });
    this.endUpdate();
  },
  _requestChange(codes) {
    this._suspendChanges();
    this._change(codes);
    this._resumeChanges();
  },
  _applyChanges() {
    const changes = this._changes;
    const order = this._totalChangesOrder;
    const changesOrderLength = order.length;
    for (let i = 0; i < changesOrderLength; i += 1) {
      if (changes.has(order[i])) {
        this[`_change_${order[i]}`]();
      }
    }
  },
  _optionChangesOrder: ['EVENTS', 'THEME', 'RENDERER', 'RESIZE_HANDLER'],
  _layoutChangesOrder: ['ELEMENT_ATTR', 'CONTAINER_SIZE', 'LAYOUT'],
  _customChangesOrder: ['DISABLED'],
  _change_EVENTS() {
    this._eventTrigger.applyChanges();
  },
  _change_THEME() {
    this._setThemeAndRtl();
  },
  _change_RENDERER() {
    this._setRendererOptions();
  },
  _change_RESIZE_HANDLER() {
    this._setupResizeHandler();
  },
  _change_ELEMENT_ATTR() {
    this._renderElementAttributes();
    this._change(['CONTAINER_SIZE']);
  },
  _change_CONTAINER_SIZE() {
    this._updateSize();
  },
  _change_LAYOUT() {
    this._setContentSize();
  },
  _change_DISABLED() {
    const renderer = this._renderer;
    const {
      root
    } = renderer;
    if (this.option('disabled')) {
      this._initDisabledState = root.attr('pointer-events');
      root.attr({
        'pointer-events': 'none',
        filter: renderer.getGrayScaleFilter().id
      });
    } else if (root.attr('pointer-events') === 'none') {
      root.attr({
        'pointer-events': (0, _type.isDefined)(this._initDisabledState) ? this._initDisabledState : null,
        filter: null
      });
    }
  },
  _themeDependentChanges: ['RENDERER'],
  _initRenderer() {
    // Canvas is calculated before the renderer is created in order to capture actual
    // size of the container
    const rawCanvas = this._calculateRawCanvas();
    this._canvas = (0, _utils2.floorCanvasDimensions)(rawCanvas);
    this._renderer = new _renderer2.Renderer({
      cssClass: `${this._rootClassPrefix} ${this._rootClass}`,
      pathModified: this.option('pathModified'),
      container: this._$element[0]
    });
    this._renderer.resize(this._canvas.width, this._canvas.height);
  },
  _disposeRenderer() {
    this._renderer.dispose();
  },
  _disposeGraphicObjects() {
    Object.keys(this._graphicObjects).forEach(id => {
      this._graphicObjects[id].dispose();
    });
    this._graphicObjects = null;
  },
  _getAnimationOptions: _common.noop,
  render() {
    this._requestChange(['CONTAINER_SIZE']);
    const visible = this._isVisible();
    this._toggleParentsScrollSubscription(visible);
    !visible && this._stopCurrentHandling();
  },
  _toggleParentsScrollSubscription(subscribe) {
    let $parents = (0, _renderer.default)(this._renderer.root.element).parents();
    const scrollEvents = 'scroll.viz_widgets';
    if (_devices.default.real().platform === 'generic') {
      $parents = $parents.add((0, _window.getWindow)());
    }
    this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function () {
      this._stopCurrentHandling();
    }.bind(this);
    _events_engine.default.off((0, _renderer.default)('').add(this._$prevRootParents), scrollEvents, this._proxiedTargetParentsScrollHandler);
    if (subscribe) {
      _events_engine.default.on($parents, scrollEvents, this._proxiedTargetParentsScrollHandler);
      this._$prevRootParents = $parents;
    }
  },
  _stopCurrentHandling: _common.noop,
  _dispose() {
    if (this._disposed) {
      return;
    }
    this.callBase(...arguments);
    this._toggleParentsScrollSubscription(false);
    this._removeResizeHandler();
    this._layout.dispose();
    this._eventTrigger.dispose();
    this._disposeCore();
    this._disposePlugins();
    this._disposeGraphicObjects();
    this._disposeRenderer();
    this._themeManager.dispose();
    this._themeManager = null;
    this._renderer = null;
    this._eventTrigger = null;
  },
  _initEventTrigger() {
    const callback = (name, actionSettings) => this._createActionByOption(name, actionSettings);
    this._eventTrigger = (0, _base_widget.createEventTrigger)(this._eventsMap, callback);
  },
  _calculateRawCanvas() {
    const size = this.option('size') || {};
    const margin = this.option('margin') || {};
    const defaultCanvas = this._getDefaultSize() || {};
    const getSizeOfSide = (size, side, getter) => {
      if (sizeIsValid(size[side]) || !(0, _window.hasWindow)()) {
        return 0;
      }
      const elementSize = getter(this._$element);
      return elementSize <= 1 ? 0 : elementSize;
    };
    const elementWidth = getSizeOfSide(size, 'width', x => (0, _size.getWidth)(x));
    const elementHeight = getSizeOfSide(size, 'height', x => (0, _size.getHeight)(x));
    let canvas = {
      width: size.width <= 0 ? 0 : pickPositiveValue([size.width, elementWidth, defaultCanvas.width]),
      height: size.height <= 0 ? 0 : pickPositiveValue([size.height, elementHeight, defaultCanvas.height]),
      left: pickPositiveValue([margin.left, defaultCanvas.left]),
      top: pickPositiveValue([margin.top, defaultCanvas.top]),
      right: pickPositiveValue([margin.right, defaultCanvas.right]),
      bottom: pickPositiveValue([margin.bottom, defaultCanvas.bottom])
    };
    // This for backward compatibility - widget was not rendered when canvas is empty.
    // Now it will be rendered but because of "width" and "height"
    // of the root both set to 0 it will not be visible.
    if (canvas.width - canvas.left - canvas.right <= 0 || canvas.height - canvas.top - canvas.bottom <= 0) {
      canvas = {
        width: 0,
        height: 0
      };
    }
    return canvas;
  },
  _updateSize() {
    const rawCanvas = this._calculateRawCanvas();
    if ((0, _utils2.areCanvasesDifferent)(this._canvas, rawCanvas) || this.__forceRender /* for charts */) {
      this._canvas = (0, _utils2.floorCanvasDimensions)(rawCanvas);
      this._recreateSizeDependentObjects(true);
      this._renderer.resize(this._canvas.width, this._canvas.height);
      this._change(['LAYOUT']);
    }
  },
  _recreateSizeDependentObjects: _common.noop,
  _getMinSize() {
    return [0, 0];
  },
  _getAlignmentRect: _common.noop,
  _setContentSize() {
    const canvas = this._canvas;
    const layout = this._layout;
    let rect = canvas.width > 0 && canvas.height > 0 ? [canvas.left, canvas.top, canvas.width - canvas.right, canvas.height - canvas.bottom] : [0, 0, 0, 0];
    rect = layout.forward(rect, this._getMinSize());
    const nextRect = this._applySize(rect) || rect;
    layout.backward(nextRect, this._getAlignmentRect() || nextRect);
  },
  _getOption(name, isScalar) {
    const theme = this._themeManager.theme(name);
    const option = this.option(name);
    return isScalar ? option !== undefined ? option : theme : (0, _extend.extend)(true, {}, theme, option);
  },
  _setupResizeHandler() {
    const redrawOnResize = (0, _utils.parseScalar)(this._getOption('redrawOnResize', true), true);
    if (this._disposeResizeHandler) {
      this._removeResizeHandler();
    }
    this._disposeResizeHandler = (0, _base_widget.createResizeHandler)(this._$element[0], redrawOnResize, () => this._requestChange(['CONTAINER_SIZE']));
  },
  _removeResizeHandler() {
    if (this._disposeResizeHandler) {
      this._disposeResizeHandler();
      this._disposeResizeHandler = null;
    }
  },
  // This is actually added only to make loading indicator pluggable.
  // This is bad but much better than entire loading indicator in BaseWidget.
  _onBeginUpdate: _common.noop,
  beginUpdate() {
    // The "_initialized" flag is checked because
    // first time "beginUpdate" is called in the constructor.
    if (this._initialized && this._isUpdateAllowed()) {
      this._onBeginUpdate();
      this._suspendChanges();
    }
    this.callBase(...arguments);
    return this;
  },
  endUpdate() {
    this.callBase();
    this._isUpdateAllowed() && this._resumeChanges();
    return this;
  },
  option(name) {
    // NOTE: `undefined` has to be returned because base option setter returns `undefined`.
    // `argument.length` and `isObject` checks are copypaste from Component.
    if (this._initialized && this._applyingChanges && (arguments.length > 1 || (0, _type.isObject)(name))) {
      this._optionsQueue = this._optionsQueue || [];
      this._optionsQueue.push(this._getActionForUpdating(arguments));
    } else {
      return baseOptionMethod.apply(this, arguments);
    }
  },
  _getActionForUpdating(args) {
    return () => {
      baseOptionMethod.apply(this, args);
    };
  },
  // For quite a long time the following method were abstract (from the Component perspective).
  // Now they are not but that basic functionality is not required here.
  _clean: _common.noop,
  _render: _common.noop,
  _optionChanged(arg) {
    if (this._optionChangedLocker) {
      return;
    }
    const partialChanges = this.getPartialChangeOptionsName(arg);
    let changes = [];
    if (partialChanges.length > 0) {
      partialChanges.forEach(pc => changes.push(this._partialOptionChangesMap[pc]));
    } else {
      changes.push(this._optionChangesMap[arg.name]);
    }
    changes = changes.filter(c => !!c);
    if (this._eventTrigger.change(arg.name)) {
      this._change(['EVENTS']);
    } else if (changes.length > 0) {
      this._change(changes);
    } else {
      this.callBase.apply(this, arguments);
    }
  },
  _notify: _common.noop,
  _changesApplied: _common.noop,
  _optionChangesMap: {
    size: 'CONTAINER_SIZE',
    margin: 'CONTAINER_SIZE',
    redrawOnResize: 'RESIZE_HANDLER',
    theme: 'THEME',
    rtlEnabled: 'THEME',
    encodeHtml: 'THEME',
    elementAttr: 'ELEMENT_ATTR',
    disabled: 'DISABLED'
  },
  _partialOptionChangesMap: {},
  _partialOptionChangesPath: {},
  getPartialChangeOptionsName(changedOption) {
    const {
      fullName
    } = changedOption;
    const sections = fullName.split(/[.]/);
    const {
      name
    } = changedOption;
    const {
      value
    } = changedOption;
    const options = this._partialOptionChangesPath[name];
    const partialChangeOptionsName = [];
    if (options) {
      if (options === true) {
        partialChangeOptionsName.push(name);
      } else {
        options.forEach(op => {
          fullName.indexOf(op) >= 0 && partialChangeOptionsName.push(op);
        });
        if (sections.length === 1) {
          if ((0, _type.type)(value) === 'object') {
            this._addOptionsNameForPartialUpdate(value, options, partialChangeOptionsName);
          } else if ((0, _type.type)(value) === 'array') {
            if (value.length > 0 && value.every(item => this._checkOptionsForPartialUpdate(item, options))) {
              value.forEach(item => {
                this._addOptionsNameForPartialUpdate(item, options, partialChangeOptionsName);
              });
            }
          }
        }
      }
    }
    return partialChangeOptionsName.filter((value, index, self) => self.indexOf(value) === index);
  },
  _checkOptionsForPartialUpdate(optionObject, options) {
    return !Object.keys(optionObject).some(key => options.indexOf(key) === -1);
  },
  _addOptionsNameForPartialUpdate(optionObject, options, partialChangeOptionsName) {
    const optionKeys = Object.keys(optionObject);
    if (this._checkOptionsForPartialUpdate(optionObject, options)) {
      optionKeys.forEach(key => options.indexOf(key) > -1 && partialChangeOptionsName.push(key));
    }
  },
  _visibilityChanged() {
    this.render();
  },
  _setThemeAndRtl() {
    this._themeManager.setTheme(this.option('theme'), this.option(OPTION_RTL_ENABLED));
  },
  _getRendererOptions() {
    return {
      rtl: this.option(OPTION_RTL_ENABLED),
      encodeHtml: this.option('encodeHtml'),
      animation: this._getAnimationOptions()
    };
  },
  _setRendererOptions() {
    this._renderer.setOptions(this._getRendererOptions());
  },
  svg() {
    return this._renderer.svg();
  },
  getSize() {
    const canvas = this._canvas || {};
    return {
      width: canvas.width,
      height: canvas.height
    };
  },
  isReady: getFalse,
  _dataIsReady: getTrue,
  _resetIsReady() {
    this.isReady = getFalse;
  },
  _renderGraphicObjects() {
    const renderer = this._renderer;
    const graphics = _m_charts.default.getGraphicObjects();
    Object.keys(graphics).forEach(id => {
      if (!this._graphicObjects[id]) {
        const {
          type,
          colors,
          rotationAngle,
          template,
          width,
          height
        } = graphics[id];
        switch (type) {
          case 'linear':
            this._graphicObjects[id] = renderer.linearGradient(colors, id, rotationAngle);
            break;
          case 'radial':
            this._graphicObjects[id] = renderer.radialGradient(colors, id);
            break;
          case 'pattern':
            this._graphicObjects[id] = renderer.customPattern(id, this._getTemplate(template), width, height);
            break;
          default:
            break;
        }
      }
    });
  },
  _drawn() {
    this.isReady = getFalse;
    if (this._dataIsReady()) {
      this._renderer.onEndAnimation(() => {
        this.isReady = getTrue;
      });
    }
    this._eventTrigger('drawn', {});
  }
});
var _default = exports["default"] = baseWidget;
(0, _helpers.replaceInherit)(baseWidget);

/***/ }),

/***/ 32595:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const themes = [{
  baseThemeName: 'material.blue.light',
  theme: {
    name: 'fluent.blue.light'
  }
}, {
  baseThemeName: 'fluent.blue.light',
  theme: {
    name: 'fluent.blue.light.compact'
  }
}, {
  baseThemeName: 'material.blue.dark',
  theme: {
    name: 'fluent.blue.dark'
  }
}, {
  baseThemeName: 'fluent.blue.dark',
  theme: {
    name: 'fluent.blue.dark.compact'
  }
}];
var _default = exports["default"] = themes;

/***/ }),

/***/ 85900:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const ACCENT_COLOR = '#f05b41';
const BACKGROUND_COLOR = '#fff';
const TITLE_COLOR = '#333';
const SUBTITLE_COLOR = '#8899a8';
const TEXT_COLOR = '#707070';
const BORDER_COLOR = '#dee1e3';
var _default = exports["default"] = [{
  baseThemeName: 'generic.light',
  theme: {
    name: 'generic.carmine',
    defaultPalette: 'Carmine',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    export: {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        default: {
          color: TITLE_COLOR,
          borderColor: '#b1b7bd',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#b1b7bd',
          backgroundColor: '#faf2f0'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#6d7781',
          backgroundColor: '#faf2f0'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#6d7781',
          backgroundColor: '#f5e7e4'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: BACKGROUND_COLOR,
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      font: {
        color: TITLE_COLOR
      },
      border: {
        color: BORDER_COLOR
      },
      color: BACKGROUND_COLOR
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#c1c5c7'
        }
      }
    },
    rangeSelector: {
      scale: {
        breakStyle: {
          color: '#c1c5c7'
        },
        tick: {
          opacity: 0.12
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#f0ad4e',
      maxColor: '#f74d61'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: SUBTITLE_COLOR
          }
        }
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    gauge: {
      valueIndicators: {
        rangebar: {
          color: ACCENT_COLOR
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          color: ACCENT_COLOR
        }
      }
    }
  }
}, {
  baseThemeName: 'generic.carmine',
  theme: {
    name: 'generic.carmine.compact'
  }
}];

/***/ }),

/***/ 11269:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const WHITE = '#ffffff';
const BLACK = '#000000';
const CONTRAST_ACTIVE = '#cf00da';
const MARKER_COLOR = '#f8ca00';
const AREA_LAYER_COLOR = '#686868';
var _default = exports["default"] = [{
  baseThemeName: 'generic.light',
  theme: {
    name: 'generic.contrast',
    defaultPalette: 'Bright',
    font: {
      color: WHITE
    },
    backgroundColor: BLACK,
    primaryTitleColor: WHITE,
    secondaryTitleColor: WHITE,
    gridColor: WHITE,
    axisColor: WHITE,
    export: {
      backgroundColor: BLACK,
      font: {
        color: WHITE
      },
      button: {
        default: {
          color: WHITE,
          borderColor: WHITE,
          backgroundColor: BLACK
        },
        hover: {
          color: WHITE,
          borderColor: WHITE,
          backgroundColor: '#cf00d7'
        },
        focus: {
          color: WHITE,
          borderColor: '#cf00d7',
          backgroundColor: BLACK
        },
        active: {
          color: BLACK,
          borderColor: WHITE,
          backgroundColor: WHITE
        }
      },
      borderColor: WHITE,
      menuButtonColor: BLACK,
      activeBackgroundColor: WHITE,
      activeColor: BLACK,
      selectedBorderColor: CONTRAST_ACTIVE,
      selectedColor: CONTRAST_ACTIVE,
      shadowColor: 'none'
    },
    tooltip: {
      border: {
        color: WHITE
      },
      font: {
        color: WHITE
      },
      color: BLACK
    },
    'chart:common': {
      commonSeriesSettings: {
        valueErrorBar: {
          color: WHITE
        },
        hoverStyle: {
          hatching: {
            opacity: 0.5
          }
        },
        selectionStyle: {
          hatching: {
            opacity: 0.35
          }
        },
        label: {
          font: {
            color: WHITE
          },
          border: {
            color: WHITE
          }
        }
      }
    },
    'chart:common:axis': {
      constantLineStyle: {
        color: WHITE
      }
    },
    'chart:common:annotation': {
      font: {
        color: WHITE
      },
      border: {
        color: WHITE
      },
      color: BLACK
    },
    chart: {
      commonSeriesSettings: {},
      crosshair: {
        color: '#cf00d7'
      },
      commonPaneSettings: {
        backgroundColor: BLACK,
        border: {
          color: WHITE
        }
      },
      scrollBar: {
        color: WHITE
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#cf00d7'
        }
      },
      zoomAndPan: {
        dragBoxStyle: {
          color: WHITE,
          opacity: 0.7
        }
      }
    },
    pie: {
      commonSeriesSettings: {
        pie: {
          hoverStyle: {
            hatching: {
              opacity: 0.5
            }
          },
          selectionStyle: {
            hatching: {
              opacity: 0.35
            }
          }
        },
        doughnut: {
          hoverStyle: {
            hatching: {
              opacity: 0.5
            }
          },
          selectionStyle: {
            hatching: {
              opacity: 0.35
            }
          }
        },
        donut: {
          hoverStyle: {
            hatching: {
              opacity: 0.5
            }
          },
          selectionStyle: {
            hatching: {
              opacity: 0.35
            }
          }
        }
      }
    },
    gauge: {
      rangeContainer: {
        backgroundColor: WHITE
      },
      valueIndicators: {
        _default: {
          color: WHITE
        },
        rangebar: {
          color: WHITE,
          backgroundColor: BLACK
        },
        // eslint-disable-next-line spellcheck/spell-checker
        twocolorneedle: {
          secondColor: WHITE
        },
        // eslint-disable-next-line spellcheck/spell-checker
        trianglemarker: {
          color: WHITE
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          color: WHITE,
          text: {
            font: {
              color: BLACK
            }
          }
        }
      }
    },
    barGauge: {
      backgroundColor: '#3c3c3c'
    },
    rangeSelector: {
      scale: {
        tick: {
          color: WHITE,
          opacity: 0.4
        },
        minorTick: {
          color: WHITE,
          opacity: 0.12
        },
        breakStyle: {
          color: '#cf00d7'
        }
      },
      selectedRangeColor: CONTRAST_ACTIVE,
      sliderMarker: {
        color: CONTRAST_ACTIVE
      },
      sliderHandle: {
        color: CONTRAST_ACTIVE,
        opacity: 1
      },
      shutter: {
        opacity: 0.75
      },
      background: {
        color: BLACK
      }
    },
    map: {
      background: {
        borderColor: WHITE
      },
      layer: {
        label: {
          stroke: BLACK,
          font: {
            color: WHITE
          }
        }
      },
      'layer:area': {
        borderColor: BLACK,
        color: AREA_LAYER_COLOR,
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE,
        label: {
          font: {
            opacity: 1
          }
        }
      },
      'layer:line': {
        color: '#267cff',
        hoveredColor: '#f613ff',
        selectedColor: WHITE
      },
      'layer:marker:dot': {
        borderColor: BLACK,
        color: MARKER_COLOR,
        backColor: BLACK,
        backOpacity: 0.32
      },
      'layer:marker:bubble': {
        color: MARKER_COLOR,
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:marker:pie': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      controlBar: {
        borderColor: WHITE,
        color: BLACK,
        opacity: 0.3
      }
    },
    treeMap: {
      tile: {
        color: '#70c92f'
      },
      group: {
        color: '#797979',
        label: {
          font: {
            color: WHITE
          }
        }
      }
    },
    sparkline: {
      pointColor: BLACK
    },
    bullet: {},
    polar: {
      commonSeriesSettings: {}
    },
    funnel: {
      label: {
        connector: {
          opacity: 1
        }
      }
    },
    sankey: {
      label: {
        font: {
          color: WHITE
        },
        shadow: {
          opacity: 0
        }
      },
      node: {
        border: {
          visible: true,
          width: 1,
          color: WHITE
        }
      },
      link: {
        opacity: 0.5,
        border: {
          visible: true,
          width: 1,
          color: WHITE
        },
        hoverStyle: {
          opacity: 0.9
        }
      }
    }
  }
}, {
  baseThemeName: 'generic.contrast',
  theme: {
    name: 'generic.contrast.compact'
  }
}];

/***/ }),

/***/ 4691:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const WHITE = '#ffffff';
const BLACK = '#000000';
const SOME_GREY = '#2b2b2b';
const RANGE_COLOR = '#b5b5b5';
const GREY_GREEN = '#303030';
const AREA_LAYER_COLOR = '#686868';
const LINE_COLOR = '#c7c7c7';
const TARGET_COLOR = '#8e8e8e';
const POSITIVE_COLOR = '#b8b8b8';
const BORDER_COLOR = '#494949';
var _default = exports["default"] = [{
  baseThemeName: 'generic.light',
  theme: {
    name: 'generic.dark',
    font: {
      color: '#808080'
    },
    backgroundColor: '#2a2a2a',
    primaryTitleColor: '#dedede',
    secondaryTitleColor: '#a3a3a3',
    gridColor: '#555555',
    axisColor: '#a3a3a3',
    export: {
      backgroundColor: '#2a2a2a',
      font: {
        color: '#dbdbdb'
      },
      button: {
        default: {
          color: '#dedede',
          borderColor: '#4d4d4d',
          backgroundColor: '#2e2e2e'
        },
        hover: {
          color: '#dedede',
          borderColor: '#6c6c6c',
          backgroundColor: '#444'
        },
        focus: {
          color: '#dedede',
          borderColor: '#8d8d8d',
          backgroundColor: '#444444'
        },
        active: {
          color: '#dedede',
          borderColor: '#8d8d8d',
          backgroundColor: '#555555'
        }
      },
      shadowColor: '#292929'
    },
    tooltip: {
      color: SOME_GREY,
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: '#929292'
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        },
        valueErrorBar: {
          color: WHITE
        }
      }
    },
    'chart:common:axis': {
      constantLineStyle: {
        color: WHITE
      }
    },
    'chart:common:annotation': {
      font: {
        color: '#929292'
      },
      border: {
        color: BORDER_COLOR
      },
      color: SOME_GREY,
      shadow: {
        opacity: 0.008,
        offsetY: 4,
        blur: 8
      }
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#818181'
        }
      },
      zoomAndPan: {
        dragBoxStyle: {
          color: WHITE
        }
      }
    },
    gauge: {
      rangeContainer: {
        backgroundColor: RANGE_COLOR
      },
      valueIndicators: {
        _default: {
          color: RANGE_COLOR
        },
        rangebar: {
          color: '#84788b'
        },
        // eslint-disable-next-line spellcheck/spell-checker
        twocolorneedle: {
          secondColor: '#ba544d'
        },
        // eslint-disable-next-line spellcheck/spell-checker
        trianglemarker: {
          color: '#b7918f'
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          color: '#ba544d'
        }
      }
    },
    barGauge: {
      backgroundColor: '#3c3c3c'
    },
    rangeSelector: {
      scale: {
        tick: {
          color: WHITE,
          opacity: 0.32
        },
        minorTick: {
          color: WHITE,
          opacity: 0.1
        },
        breakStyle: {
          color: '#818181'
        }
      },
      selectedRangeColor: RANGE_COLOR,
      sliderMarker: {
        color: RANGE_COLOR,
        font: {
          color: GREY_GREEN
        }
      },
      sliderHandle: {
        color: WHITE,
        opacity: 0.2
      },
      shutter: {
        color: SOME_GREY,
        opacity: 0.9
      }
    },
    map: {
      background: {
        borderColor: '#3f3f3f'
      },
      layer: {
        label: {
          stroke: BLACK,
          font: {
            color: WHITE
          }
        }
      },
      'layer:area': {
        borderColor: GREY_GREEN,
        color: AREA_LAYER_COLOR,
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:line': {
        color: '#c77244',
        hoveredColor: '#ff5d04',
        selectedColor: '#ff784f'
      },
      'layer:marker:bubble': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:marker:pie': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      legend: {
        border: {
          color: '#3f3f3f'
        },
        font: {
          color: WHITE
        }
      },
      controlBar: {
        borderColor: LINE_COLOR,
        color: GREY_GREEN
      }
    },
    treeMap: {
      group: {
        color: '#4c4c4c',
        label: {
          font: {
            color: '#a3a3a3'
          }
        }
      }
    },
    sparkline: {
      lineColor: LINE_COLOR,
      firstLastColor: LINE_COLOR,
      barPositiveColor: POSITIVE_COLOR,
      barNegativeColor: TARGET_COLOR,
      winColor: POSITIVE_COLOR,
      lossColor: TARGET_COLOR,
      pointColor: GREY_GREEN
    },
    bullet: {
      targetColor: TARGET_COLOR
    },
    funnel: {
      item: {
        border: {
          color: '#2a2a2a'
        }
      }
    },
    sankey: {
      label: {
        font: {
          color: WHITE
        },
        shadow: {
          opacity: 0
        }
      },
      node: {
        border: {
          color: '#2a2a2a'
        }
      },
      link: {
        color: '#888888',
        border: {
          color: '#2a2a2a'
        },
        hoverStyle: {
          color: '#bbbbbb'
        }
      }
    }
  }
}, {
  baseThemeName: 'generic.dark',
  theme: {
    name: 'generic.dark.compact'
  }
}];

/***/ }),

/***/ 73932:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const ACCENT_COLOR = '#3debd3';
const BACKGROUND_COLOR = '#465672';
const TITLE_COLOR = '#fff';
const SUBTITLE_COLOR = '#919bac';
const TEXT_COLOR = '#c7ccd4';
const BORDER_COLOR = '#596980';
var _default = exports["default"] = [{
  baseThemeName: 'generic.dark',
  theme: {
    name: 'generic.darkmoon',
    defaultPalette: 'Dark Moon',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    export: {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        default: {
          color: TITLE_COLOR,
          borderColor: '#7a889e',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#9da8b8',
          backgroundColor: '#596e92'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#c4cad4',
          backgroundColor: '#596e92'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#c4cad4',
          backgroundColor: '#6b80a4'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: '#62789e',
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      font: {
        color: TITLE_COLOR
      },
      border: {
        color: BORDER_COLOR
      },
      color: '#62789e'
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#73869e'
        }
      }
    },
    gauge: {
      valueIndicators: {
        rangebar: {
          color: ACCENT_COLOR
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          color: ACCENT_COLOR,
          text: {
            font: {
              color: BACKGROUND_COLOR
            }
          }
        }
      }
    },
    barGauge: {
      backgroundColor: '#526280'
    },
    funnel: {
      item: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#f0ad4e',
      maxColor: '#f9517e'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: TITLE_COLOR
          }
        }
      }
    },
    map: {
      background: {
        borderColor: BORDER_COLOR
      },
      'layer:area': {
        color: '#97a3b6',
        borderColor: BACKGROUND_COLOR
      }
    },
    rangeSelector: {
      shutter: {
        color: BACKGROUND_COLOR
      },
      scale: {
        breakStyle: {
          color: '#73869e'
        },
        tick: {
          opacity: 0.2
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR,
        font: {
          color: '#000'
        }
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    sankey: {
      link: {
        border: {
          color: BACKGROUND_COLOR
        }
      },
      node: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    }
  }
}, {
  baseThemeName: 'generic.darkmoon',
  theme: {
    name: 'generic.darkmoon.compact'
  }
}];

/***/ }),

/***/ 34893:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const ACCENT_COLOR = '#9c63ff';
const BACKGROUND_COLOR = '#17171f';
const TITLE_COLOR = '#f5f6f7';
const SUBTITLE_COLOR = '#fff';
const TEXT_COLOR = '#b2b2b6';
const BORDER_COLOR = '#343840';
var _default = exports["default"] = [{
  baseThemeName: 'generic.dark',
  theme: {
    name: 'generic.darkviolet',
    defaultPalette: 'Dark Violet',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    export: {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        default: {
          color: TITLE_COLOR,
          borderColor: '#414152',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#5c5c74',
          backgroundColor: '#2d2d3c'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#7c7c97',
          backgroundColor: '#2d2d3c'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#7c7c97',
          backgroundColor: '#3c3c51'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: BACKGROUND_COLOR,
      border: {
        color: '#414152'
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      font: {
        color: TITLE_COLOR
      },
      border: {
        color: '#414152'
      },
      color: BACKGROUND_COLOR
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#575e6b'
        }
      }
    },
    funnel: {
      item: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#f0ad4e',
      maxColor: '#d9534f'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: SUBTITLE_COLOR
          }
        }
      }
    },
    rangeSelector: {
      shutter: {
        color: BACKGROUND_COLOR
      },
      scale: {
        breakStyle: {
          color: '#575e6b'
        },
        tick: {
          opacity: 0.2
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR,
        font: {
          color: '#fff'
        }
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    gauge: {
      valueIndicators: {
        rangebar: {
          color: ACCENT_COLOR
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          color: ACCENT_COLOR
        }
      }
    },
    sankey: {
      link: {
        border: {
          color: BACKGROUND_COLOR
        }
      },
      node: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    }
  }
}, {
  baseThemeName: 'generic.darkviolet',
  theme: {
    name: 'generic.darkviolet.compact'
  }
}];

/***/ }),

/***/ 50008:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const ACCENT_COLOR = '#3cbab2';
const BACKGROUND_COLOR = '#f5f5f5';
const TITLE_COLOR = '#28484f';
const SUBTITLE_COLOR = '#7eb2be';
const TEXT_COLOR = '#657c80';
const BORDER_COLOR = '#dedede';
var _default = exports["default"] = [{
  baseThemeName: 'generic.light',
  theme: {
    name: 'generic.greenmist',
    defaultPalette: 'Green Mist',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    export: {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        default: {
          color: TITLE_COLOR,
          borderColor: '#a2b4b8',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#7f989e',
          backgroundColor: 'rgba(222, 222, 222, 0.4)'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#5f777c',
          backgroundColor: 'rgba(222, 222, 222, 0.4)'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#5f777c',
          backgroundColor: 'rgba(222, 222, 222, 0.8)'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: '#fff',
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      color: '#fff',
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#c1c1c1'
        }
      }
    },
    funnel: {
      item: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#ffc852',
      maxColor: '#f74a5e'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: SUBTITLE_COLOR
          }
        }
      }
    },
    rangeSelector: {
      shutter: {
        color: BACKGROUND_COLOR
      },
      scale: {
        breakStyle: {
          color: '#c1c1c1'
        },
        tick: {
          opacity: 0.12
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    gauge: {
      valueIndicators: {
        rangebar: {
          color: ACCENT_COLOR
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          color: ACCENT_COLOR
        }
      }
    }
  }
}, {
  baseThemeName: 'generic.greenmist',
  theme: {
    name: 'generic.greenmist.compact'
  }
}];

/***/ }),

/***/ 97269:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  barGauge: {
    backgroundColor: '#e0e0e0',
    relativeInnerRadius: 0.3,
    barSpacing: 4,
    resolveLabelOverlapping: 'hide',
    label: {
      indent: 20,
      connectorWidth: 2,
      font: {
        size: 16
      }
    },
    legend: {
      visible: false
    },
    indicator: {
      hasPositiveMeaning: true,
      layout: {
        horizontalAlignment: _contants.CENTER,
        verticalAlignment: _contants.BOTTOM
      },
      text: {
        font: {
          size: 18
        }
      }
    }
  }
};

/***/ }),

/***/ 81124:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = exports["default"] = {
  bullet: {
    color: '#e8c267',
    targetColor: '#666666',
    targetWidth: 4,
    showTarget: true,
    showZeroLevel: true,
    tooltip: {
      enabled: true
    }
  }
};

/***/ }),

/***/ 77104:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  'chart:common': {
    animation: {
      enabled: true,
      duration: 1000,
      easing: 'easeOutCubic',
      maxPointCountSupported: 300
    },
    commonSeriesSettings: {
      border: {
        visible: false,
        width: 2
      },
      showInLegend: true,
      visible: true,
      hoverMode: 'nearestPoint',
      selectionMode: 'includePoints',
      hoverStyle: {
        hatching: {
          direction: _contants.RIGHT,
          width: 2,
          step: 6,
          opacity: 0.75
        },
        highlight: true,
        border: {
          visible: false,
          width: 3
        }
      },
      selectionStyle: {
        hatching: {
          direction: _contants.RIGHT,
          width: 2,
          step: 6,
          opacity: 0.5
        },
        highlight: true,
        border: {
          visible: false,
          width: 3
        }
      },
      valueErrorBar: {
        displayMode: 'auto',
        value: 1,
        color: _contants.BLACK,
        lineWidth: 2,
        edgeLength: 8
      },
      label: {
        visible: false,
        alignment: _contants.CENTER,
        rotationAngle: 0,
        horizontalOffset: 0,
        verticalOffset: 0,
        radialOffset: 0,
        showForZeroValues: true,
        customizeText: undefined,
        maxLabelCount: undefined,
        position: _contants.OUTSIDE,
        font: {
          color: _contants.WHITE
        },
        border: {
          visible: false,
          width: 1,
          color: _contants.LIGHT_GREY,
          dashStyle: _contants.SOLID
        },
        connector: {
          visible: false,
          width: 1
        }
      }
    },
    seriesSelectionMode: 'single',
    pointSelectionMode: 'single',
    equalRowHeight: true,
    dataPrepareSettings: {
      checkTypeForAllData: false,
      convertToAxisDataType: true,
      sortingMethod: true
    },
    title: {
      margin: 10
    },
    adaptiveLayout: {
      width: 80,
      height: 80,
      keepLabels: true
    },
    _rtl: {
      legend: {
        itemTextPosition: _contants.LEFT
      }
    },
    resolveLabelOverlapping: _contants.NONE
  },
  'chart:common:axis': {
    visible: true,
    valueMarginsEnabled: true,
    placeholderSize: null,
    logarithmBase: 10,
    discreteAxisDivisionMode: 'betweenLabels',
    aggregatedPointsPosition: 'betweenTicks',
    width: 1,
    label: {
      visible: true
    },
    grid: {
      visible: false,
      width: 1
    },
    minorGrid: {
      visible: false,
      width: 1,
      opacity: 0.3
    },
    tick: {
      visible: true,
      width: 1,
      length: 7,
      shift: 3
    },
    minorTick: {
      visible: false,
      width: 1,
      opacity: 0.3,
      length: 7,
      shift: 3
    },
    stripStyle: {
      paddingLeftRight: 10,
      paddingTopBottom: 5
    },
    constantLineStyle: {
      width: 1,
      color: _contants.BLACK,
      dashStyle: _contants.SOLID,
      label: {
        visible: true,
        position: _contants.INSIDE
      }
    },
    marker: {
      label: {}
    }
  },
  'chart:common:annotation': {
    font: {
      color: '#333333'
    },
    tooltipEnabled: true,
    border: {
      width: 1,
      color: '#dddddd',
      dashStyle: _contants.SOLID,
      visible: true
    },
    color: _contants.WHITE,
    opacity: 0.9,
    arrowLength: 14,
    arrowWidth: 14,
    paddingLeftRight: 10,
    paddingTopBottom: 10,
    shadow: {
      opacity: 0.15,
      offsetX: 0,
      offsetY: 1,
      blur: 4,
      color: _contants.BLACK
    },
    image: {
      width: 30,
      height: 30
    },
    wordWrap: 'normal',
    textOverflow: 'ellipsis',
    allowDragging: false
  },
  chart: {
    commonSeriesSettings: {
      type: 'line',
      stack: 'default',
      aggregation: {
        enabled: undefined
      },
      point: {
        visible: true,
        symbol: 'circle',
        size: 12,
        border: {
          visible: false,
          width: 1
        },
        hoverMode: 'onlyPoint',
        selectionMode: 'onlyPoint',
        hoverStyle: {
          border: {
            visible: true,
            width: 4
          }
        },
        selectionStyle: {
          border: {
            visible: true,
            width: 4
          }
        }
      },
      scatter: {},
      line: {
        width: 2,
        dashStyle: _contants.SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3
        }
      },
      stackedline: {
        width: 2,
        dashStyle: _contants.SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3
        }
      },
      stackedspline: {
        width: 2,
        dashStyle: _contants.SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3
        }
      },
      fullstackedline: {
        width: 2,
        dashStyle: _contants.SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3
        }
      },
      fullstackedspline: {
        width: 2,
        dashStyle: _contants.SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3
        }
      },
      stepline: {
        width: 2,
        dashStyle: _contants.SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3
        }
      },
      area: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      stackedarea: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      fullstackedarea: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      fullstackedsplinearea: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      steparea: {
        border: {
          visible: true,
          width: 2
        },
        point: {
          visible: false
        },
        hoverStyle: {
          border: {
            visible: true,
            width: 3
          }
        },
        selectionStyle: {
          border: {
            visible: true,
            width: 3
          }
        },
        opacity: 0.5
      },
      spline: {
        width: 2,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3
        }
      },
      splinearea: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      stackedsplinearea: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      bar: {
        cornerRadius: 0,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        }
      },
      stackedbar: {
        cornerRadius: 0,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        },
        label: {
          position: _contants.INSIDE
        }
      },
      fullstackedbar: {
        cornerRadius: 0,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        },
        label: {
          position: _contants.INSIDE
        }
      },
      rangebar: {
        cornerRadius: 0,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        }
      },
      rangearea: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      // eslint-disable-next-line spellcheck/spell-checker
      rangesplinearea: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      bubble: {
        opacity: 0.5,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        }
      },
      candlestick: {
        width: 1,
        reduction: {
          color: _contants.RED
        },
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3,
          highlight: false
        },
        point: {
          border: {
            visible: true
          }
        }
      },
      stock: {
        width: 1,
        reduction: {
          color: _contants.RED
        },
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          },
          highlight: false
        },
        selectionStyle: {
          width: 3,
          highlight: false
        },
        point: {
          border: {
            visible: true
          }
        }
      }
    },
    crosshair: {
      enabled: false,
      color: '#f05b41',
      width: 1,
      dashStyle: _contants.SOLID,
      label: {
        visible: false,
        font: {
          color: _contants.WHITE,
          size: 12
        }
      },
      verticalLine: {
        visible: true
      },
      horizontalLine: {
        visible: true
      }
    },
    commonAxisSettings: {
      multipleAxesSpacing: 5,
      forceUserTickInterval: false,
      breakStyle: {
        width: 5,
        color: '#ababab',
        line: 'waved'
      },
      label: {
        displayMode: 'standard',
        overlappingBehavior: 'hide',
        indentFromAxis: 10,
        wordWrap: 'normal',
        textOverflow: 'none'
      },
      title: {
        font: {
          size: 16
        },
        margin: 6,
        alignment: _contants.CENTER
      },
      constantLineStyle: {
        paddingLeftRight: 10,
        paddingTopBottom: 10
      }
    },
    horizontalAxis: {
      position: _contants.BOTTOM,
      axisDivisionFactor: 70,
      label: {
        rotationAngle: 90,
        staggeringSpacing: 5,
        alignment: _contants.CENTER
      },
      stripStyle: {
        label: {
          horizontalAlignment: _contants.CENTER,
          verticalAlignment: _contants.TOP
        }
      },
      constantLineStyle: {
        label: {
          horizontalAlignment: _contants.RIGHT,
          verticalAlignment: _contants.TOP
        }
      },
      constantLines: []
    },
    verticalAxis: {
      position: _contants.LEFT,
      axisDivisionFactor: 40,
      label: {
        alignment: _contants.RIGHT
      },
      stripStyle: {
        label: {
          horizontalAlignment: _contants.LEFT,
          verticalAlignment: _contants.CENTER
        }
      },
      constantLineStyle: {
        label: {
          horizontalAlignment: _contants.LEFT,
          verticalAlignment: _contants.TOP
        }
      },
      constantLines: []
    },
    argumentAxis: {
      endOnTick: false,
      aggregateByCategory: true,
      workWeek: [1, 2, 3, 4, 5]
    },
    valueAxis: {
      grid: {
        visible: true
      },
      autoBreaksEnabled: false,
      maxAutoBreakCount: 4
    },
    commonPaneSettings: {
      backgroundColor: _contants.NONE,
      border: {
        color: _contants.LIGHT_GREY,
        width: 1,
        visible: false,
        top: true,
        bottom: true,
        left: true,
        right: true,
        dashStyle: _contants.SOLID
      }
    },
    scrollBar: {
      visible: false,
      offset: 5,
      color: 'gray',
      width: 10
    },
    adjustOnZoom: true,
    autoHidePointMarkers: true,
    rotated: false,
    synchronizeMultiAxes: true,
    stickyHovering: true,
    barGroupPadding: 0.3,
    minBubbleSize: 12,
    maxBubbleSize: 0.2,
    zoomAndPan: {
      dragBoxStyle: {
        color: '#2a2a2a',
        opacity: 0.2
      },
      panKey: 'shift',
      allowMouseWheel: true,
      allowTouchGestures: true
    }
  }
};

/***/ }),

/***/ 71160:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WHITE = exports.TOP = exports.SOME_GREY = exports.SOLID = exports.SECONDARY_TITLE_COLOR = exports.RIGHT = exports.RED = exports.PRIMARY_TITLE_COLOR = exports.OUTSIDE = exports.NONE = exports.LIGHT_GREY = exports.LEFT = exports.INSIDE = exports.GREY_GREEN = exports.CENTER = exports.BOTTOM = exports.BLACK = void 0;
const WHITE = exports.WHITE = '#ffffff';
const BLACK = exports.BLACK = '#000000';
const LIGHT_GREY = exports.LIGHT_GREY = '#d3d3d3';
const GREY_GREEN = exports.GREY_GREEN = '#303030';
const SOME_GREY = exports.SOME_GREY = '#2b2b2b';
const RED = exports.RED = '#ff0000';
const PRIMARY_TITLE_COLOR = exports.PRIMARY_TITLE_COLOR = '#232323';
const SECONDARY_TITLE_COLOR = exports.SECONDARY_TITLE_COLOR = '#767676';
const NONE = exports.NONE = 'none';
const SOLID = exports.SOLID = 'solid';
const TOP = exports.TOP = 'top';
const RIGHT = exports.RIGHT = 'right';
const BOTTOM = exports.BOTTOM = 'bottom';
const LEFT = exports.LEFT = 'left';
const CENTER = exports.CENTER = 'center';
const INSIDE = exports.INSIDE = 'inside';
const OUTSIDE = exports.OUTSIDE = 'outside';

/***/ }),

/***/ 47541:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  funnel: {
    sortData: true,
    valueField: 'val',
    colorField: 'color',
    argumentField: 'arg',
    hoverEnabled: true,
    selectionMode: 'single',
    item: {
      border: {
        visible: false,
        width: 2,
        color: _contants.WHITE
      },
      hoverStyle: {
        hatching: {
          opacity: 0.75,
          step: 6,
          width: 2,
          direction: _contants.RIGHT
        },
        border: {}
      },
      selectionStyle: {
        hatching: {
          opacity: 0.5,
          step: 6,
          width: 2,
          direction: _contants.RIGHT
        },
        border: {}
      }
    },
    title: {
      margin: 10
    },
    adaptiveLayout: {
      width: 80,
      height: 80,
      keepLabels: true
    },
    legend: {
      visible: false
    },
    _rtl: {
      legend: {
        itemTextPosition: _contants.LEFT
      }
    },
    tooltip: {
      customizeTooltip(info) {
        return {
          text: `${info.item.argument} ${info.valueText}`
        };
      }
    },
    inverted: false,
    algorithm: 'dynamicSlope',
    neckWidth: 0,
    neckHeight: 0,
    resolveLabelOverlapping: 'shift',
    label: {
      textOverflow: 'ellipsis',
      wordWrap: 'normal',
      visible: true,
      horizontalAlignment: _contants.RIGHT,
      horizontalOffset: 0,
      verticalOffset: 0,
      showForZeroValues: false,
      customizeText(info) {
        return `${info.item.argument} ${info.valueText}`;
      },
      position: 'columns',
      font: {
        color: _contants.WHITE
      },
      border: {
        visible: false,
        width: 1,
        color: _contants.LIGHT_GREY,
        dashStyle: _contants.SOLID
      },
      connector: {
        visible: true,
        width: 1,
        opacity: 0.5
      }
    }
  }
};

/***/ }),

/***/ 19879:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  gauge: {
    scale: {
      tick: {
        visible: true,
        length: 5,
        width: 2,
        opacity: 1
      },
      minorTick: {
        visible: false,
        length: 3,
        width: 1,
        opacity: 1
      },
      label: {
        visible: true,
        alignment: _contants.CENTER,
        hideFirstOrLast: 'last',
        overlappingBehavior: 'hide'
      },
      position: _contants.TOP,
      endOnTick: false
    },
    rangeContainer: {
      offset: 0,
      width: 5,
      backgroundColor: '#808080'
    },
    valueIndicators: {
      _default: {
        color: '#c2c2c2'
      },
      rangebar: {
        space: 2,
        size: 10,
        color: '#cbc5cf',
        backgroundColor: _contants.NONE,
        text: {
          indent: 0,
          font: {
            size: 14,
            color: null
          }
        }
      },
      // eslint-disable-next-line spellcheck/spell-checker
      twocolorneedle: {
        secondColor: '#e18e92'
      },
      // eslint-disable-next-line spellcheck/spell-checker
      trianglemarker: {
        space: 2,
        length: 14,
        width: 13,
        color: '#8798a5'
      },
      // eslint-disable-next-line spellcheck/spell-checker
      textcloud: {
        arrowLength: 5,
        horizontalOffset: 6,
        verticalOffset: 3,
        color: '#679ec5',
        text: {
          font: {
            color: _contants.WHITE,
            size: 18
          }
        }
      }
    },
    indicator: {
      hasPositiveMeaning: true,
      layout: {
        horizontalAlignment: _contants.CENTER,
        verticalAlignment: _contants.BOTTOM
      },
      text: {
        font: {
          size: 18
        }
      }
    },
    _circular: {
      scale: {
        scaleDivisionFactor: 17,
        orientation: _contants.OUTSIDE,
        label: {
          indentFromTick: 10
        }
      },
      rangeContainer: {
        orientation: _contants.OUTSIDE
      },
      valueIndicatorType: 'rectangleneedle',
      subvalueIndicatorType: 'trianglemarker',
      valueIndicators: {
        _type: 'rectangleneedle',
        _default: {
          offset: 20,
          indentFromCenter: 0,
          width: 2,
          spindleSize: 14,
          spindleGapSize: 10,
          beginAdaptingAtRadius: 50
        },
        // eslint-disable-next-line spellcheck/spell-checker
        triangleneedle: {
          width: 4
        },
        // eslint-disable-next-line spellcheck/spell-checker
        twocolorneedle: {
          space: 2,
          secondFraction: 0.4
        },
        rangebar: {
          offset: 30
        },
        // eslint-disable-next-line spellcheck/spell-checker
        trianglemarker: {
          offset: 6
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          offset: -6
        }
      }
    },
    _linear: {
      scale: {
        scaleDivisionFactor: 25,
        horizontalOrientation: _contants.RIGHT,
        verticalOrientation: _contants.BOTTOM,
        label: {
          indentFromTick: -10
        }
      },
      rangeContainer: {
        horizontalOrientation: _contants.RIGHT,
        verticalOrientation: _contants.BOTTOM
      },
      valueIndicatorType: 'rangebar',
      subvalueIndicatorType: 'trianglemarker',
      valueIndicators: {
        _type: 'rectangle',
        _default: {
          offset: 2.5,
          length: 15,
          width: 15
        },
        rectangle: {
          width: 10
        },
        rangebar: {
          offset: 10,
          horizontalOrientation: _contants.RIGHT,
          verticalOrientation: _contants.BOTTOM
        },
        // eslint-disable-next-line spellcheck/spell-checker
        trianglemarker: {
          offset: 10,
          horizontalOrientation: _contants.LEFT,
          verticalOrientation: _contants.TOP
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          offset: -1,
          horizontalOrientation: _contants.LEFT,
          verticalOrientation: _contants.TOP
        }
      }
    }
  }
};

/***/ }),

/***/ 13919:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _bar_gauge = _interopRequireDefault(__webpack_require__(97269));
var _bullet = _interopRequireDefault(__webpack_require__(81124));
var _chart = _interopRequireDefault(__webpack_require__(77104));
var _contants = __webpack_require__(71160);
var _funnel = _interopRequireDefault(__webpack_require__(47541));
var _gauge = _interopRequireDefault(__webpack_require__(19879));
var _pie_chart = _interopRequireDefault(__webpack_require__(67975));
var _polar_chart = _interopRequireDefault(__webpack_require__(55439));
var _range_selector = _interopRequireDefault(__webpack_require__(86596));
var _sankey = _interopRequireDefault(__webpack_require__(46968));
var _sparkline = _interopRequireDefault(__webpack_require__(80816));
var _tree_map = _interopRequireDefault(__webpack_require__(4387));
var _vector_map = _interopRequireDefault(__webpack_require__(18463));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var _default = exports["default"] = [{
  baseThemeName: undefined,
  theme: _extends({
    name: 'generic.light',
    isDefault: true,
    font: {
      color: _contants.SECONDARY_TITLE_COLOR,
      family: '\'Segoe UI\', \'Helvetica Neue\', \'Trebuchet MS\', Verdana, sans-serif',
      weight: 400,
      size: 12,
      cursor: 'default'
    },
    redrawOnResize: true,
    backgroundColor: _contants.WHITE,
    primaryTitleColor: _contants.PRIMARY_TITLE_COLOR,
    secondaryTitleColor: _contants.SECONDARY_TITLE_COLOR,
    gridColor: _contants.LIGHT_GREY,
    axisColor: _contants.SECONDARY_TITLE_COLOR,
    title: {
      backgroundColor: _contants.WHITE,
      font: {
        size: 28,
        family: '\'Segoe UI Light\', \'Helvetica Neue Light\', \'Segoe UI\', \'Helvetica Neue\', \'Trebuchet MS\', Verdana, sans-serif',
        weight: 200
      },
      subtitle: {
        font: {
          size: 16
        },
        offset: 0,
        wordWrap: 'normal',
        textOverflow: 'ellipsis'
      },
      wordWrap: 'normal',
      textOverflow: 'ellipsis'
    },
    loadingIndicator: {
      text: 'Loading...'
    },
    export: {
      backgroundColor: _contants.WHITE,
      margin: 10,
      font: {
        size: 14,
        color: _contants.PRIMARY_TITLE_COLOR,
        weight: 400
      },
      button: {
        margin: {
          top: 8,
          left: 10,
          right: 10,
          bottom: 8
        },
        default: {
          color: '#333',
          borderColor: '#ddd',
          backgroundColor: _contants.WHITE
        },
        hover: {
          color: '#333',
          borderColor: '#bebebe',
          backgroundColor: '#e6e6e6'
        },
        focus: {
          color: _contants.BLACK,
          borderColor: '#9d9d9d',
          backgroundColor: '#e6e6e6'
        },
        active: {
          color: '#333',
          borderColor: '#9d9d9d',
          backgroundColor: '#d4d4d4'
        }
      },
      shadowColor: _contants.LIGHT_GREY
    },
    tooltip: {
      enabled: false,
      border: {
        width: 1,
        color: _contants.LIGHT_GREY,
        dashStyle: _contants.SOLID,
        visible: true
      },
      font: {
        color: _contants.PRIMARY_TITLE_COLOR
      },
      color: _contants.WHITE,
      arrowLength: 10,
      paddingLeftRight: 18,
      paddingTopBottom: 15,
      textAlignment: 'center',
      shared: false,
      location: _contants.CENTER,
      shadow: {
        opacity: 0.4,
        offsetX: 0,
        offsetY: 4,
        blur: 2,
        color: _contants.BLACK
      },
      interactive: false
    },
    legend: {
      hoverMode: 'includePoints',
      verticalAlignment: _contants.TOP,
      horizontalAlignment: _contants.RIGHT,
      position: _contants.OUTSIDE,
      visible: true,
      margin: 10,
      markerSize: 12,
      border: {
        visible: false,
        width: 1,
        cornerRadius: 0,
        dashStyle: _contants.SOLID
      },
      paddingLeftRight: 20,
      paddingTopBottom: 15,
      columnCount: 0,
      rowCount: 0,
      columnItemSpacing: 20,
      rowItemSpacing: 8,
      title: {
        backgroundColor: _contants.WHITE,
        margin: {
          left: 0,
          bottom: 9,
          right: 0,
          top: 0
        },
        font: {
          size: 18,
          weight: 200
        },
        subtitle: {
          offset: 0,
          font: {
            size: 14
          },
          wordWrap: 'none',
          textOverflow: 'ellipsis'
        },
        wordWrap: 'none',
        textOverflow: 'ellipsis'
      }
    }
  }, _chart.default, _funnel.default, _gauge.default, _bar_gauge.default, _vector_map.default, _pie_chart.default, _polar_chart.default, _range_selector.default, _sankey.default, _sparkline.default, _bullet.default, _tree_map.default)
}, {
  baseThemeName: 'generic.light',
  theme: {
    name: 'generic.light.compact'
  }
}];

/***/ }),

/***/ 67975:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  pie: {
    innerRadius: 0.5,
    minDiameter: 0.5,
    type: 'pie',
    dataPrepareSettings: {
      _skipArgumentSorting: true
    },
    commonSeriesSettings: {
      pie: {
        border: {
          visible: false,
          width: 2,
          color: _contants.WHITE
        },
        hoverStyle: {
          hatching: {
            direction: _contants.RIGHT,
            width: 4,
            step: 10,
            opacity: 0.75
          },
          highlight: true,
          border: {
            visible: false,
            width: 2
          }
        },
        selectionStyle: {
          hatching: {
            direction: _contants.RIGHT,
            width: 4,
            step: 10,
            opacity: 0.5
          },
          highlight: true,
          border: {
            visible: false,
            width: 2
          }
        }
      },
      doughnut: {
        border: {
          visible: false,
          width: 2,
          color: _contants.WHITE
        },
        hoverStyle: {
          hatching: {
            direction: _contants.RIGHT,
            width: 4,
            step: 10,
            opacity: 0.75
          },
          highlight: true,
          border: {
            visible: false,
            width: 2
          }
        },
        selectionStyle: {
          hatching: {
            direction: _contants.RIGHT,
            width: 4,
            step: 10,
            opacity: 0.5
          },
          highlight: true,
          border: {
            visible: false,
            width: 2
          }
        }
      },
      donut: {
        border: {
          visible: false,
          width: 2,
          color: _contants.WHITE
        },
        hoverStyle: {
          hatching: {
            direction: _contants.RIGHT,
            width: 4,
            step: 10,
            opacity: 0.75
          },
          highlight: true,
          border: {
            visible: false,
            width: 2
          }
        },
        selectionStyle: {
          hatching: {
            direction: _contants.RIGHT,
            width: 4,
            step: 10,
            opacity: 0.5
          },
          highlight: true,
          border: {
            visible: false,
            width: 2
          }
        }
      },
      label: {
        textOverflow: 'ellipsis',
        wordWrap: 'normal'
      }
    },
    legend: {
      hoverMode: 'allArgumentPoints',
      backgroundColor: _contants.NONE
    },
    adaptiveLayout: {
      keepLabels: false
    }
  }
};

/***/ }),

/***/ 55439:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  polar: {
    commonSeriesSettings: {
      type: 'scatter',
      closed: true,
      point: {
        visible: true,
        symbol: 'circle',
        size: 12,
        border: {
          visible: false,
          width: 1
        },
        hoverMode: 'onlyPoint',
        selectionMode: 'onlyPoint',
        hoverStyle: {
          border: {
            visible: true,
            width: 4
          },
          size: 12
        },
        selectionStyle: {
          border: {
            visible: true,
            width: 4
          },
          size: 12
        }
      },
      scatter: {},
      line: {
        width: 2,
        dashStyle: _contants.SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: _contants.NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      area: {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      stackedline: {
        width: 2
      },
      bar: {
        opacity: 0.8
      },
      stackedbar: {
        opacity: 0.8
      }
    },
    adaptiveLayout: {
      width: 80,
      height: 80,
      keepLabels: true
    },
    barGroupPadding: 0.3,
    commonAxisSettings: {
      visible: true,
      forceUserTickInterval: false,
      label: {
        overlappingBehavior: 'hide',
        indentFromAxis: 5
      },
      grid: {
        visible: true
      },
      minorGrid: {
        visible: true
      },
      tick: {
        visible: true
      },
      title: {
        font: {
          size: 16
        },
        margin: 10
      }
    },
    argumentAxis: {
      startAngle: 0,
      firstPointOnStartAngle: false,
      period: undefined
    },
    valueAxis: {
      endOnTick: false,
      tick: {
        visible: false
      }
    },
    horizontalAxis: {
      position: _contants.TOP,
      axisDivisionFactor: 50,
      label: {
        alignment: _contants.CENTER
      }
    },
    verticalAxis: {
      position: _contants.TOP,
      axisDivisionFactor: 30,
      label: {
        alignment: _contants.RIGHT
      }
    }
  }
};

/***/ }),

/***/ 86596:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  rangeSelector: {
    scale: {
      valueMarginsEnabled: true,
      width: 1,
      color: _contants.BLACK,
      opacity: 0.1,
      showCustomBoundaryTicks: true,
      aggregateByCategory: true,
      label: {
        overlappingBehavior: 'hide',
        alignment: _contants.CENTER,
        visible: true,
        topIndent: 7,
        font: {
          size: 11
        }
      },
      tick: {
        width: 1,
        color: _contants.BLACK,
        opacity: 0.17,
        visible: true,
        length: 12
      },
      minorTick: {
        width: 1,
        color: _contants.BLACK,
        opacity: 0.05,
        visible: true,
        length: 12
      },
      marker: {
        width: 1,
        color: '#000000',
        opacity: 0.1,
        visible: true,
        separatorHeight: 33,
        topIndent: 10,
        textLeftIndent: 7,
        textTopIndent: 11,
        label: {}
      },
      logarithmBase: 10,
      workWeek: [1, 2, 3, 4, 5],
      breakStyle: {
        width: 5,
        color: '#ababab',
        line: 'waved'
      },
      endOnTick: false
    },
    selectedRangeColor: '#606060',
    sliderMarker: {
      visible: true,
      paddingTopBottom: 2,
      paddingLeftRight: 4,
      color: '#606060',
      invalidRangeColor: _contants.RED,
      font: {
        color: _contants.WHITE,
        size: 11
      }
    },
    sliderHandle: {
      width: 1,
      color: _contants.BLACK,
      opacity: 0.2
    },
    shutter: {
      opacity: 0.75
    },
    background: {
      color: '#c0bae1',
      visible: true,
      image: {
        location: 'full'
      }
    },
    behavior: {
      snapToTicks: true,
      animationEnabled: true,
      moveSelectedRangeByClick: true,
      manualRangeSelectionEnabled: true,
      allowSlidersSwap: true,
      valueChangeMode: 'onHandleRelease'
    },
    redrawOnResize: true,
    chart: {
      barGroupPadding: 0.3,
      minBubbleSize: 12,
      maxBubbleSize: 0.2,
      topIndent: 0.1,
      bottomIndent: 0,
      valueAxis: {
        inverted: false,
        logarithmBase: 10
      },
      commonSeriesSettings: {
        type: 'area',
        aggregation: {
          enabled: undefined
        },
        point: {
          visible: false
        },
        scatter: {
          point: {
            visible: true
          }
        }
      }
    }
  }
};

/***/ }),

/***/ 46968:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  sankey: {
    sourceField: 'source',
    targetField: 'target',
    weightField: 'weight',
    hoverEnabled: true,
    alignment: _contants.CENTER,
    adaptiveLayout: {
      width: 80,
      height: 80,
      keepLabels: true
    },
    label: {
      visible: true,
      horizontalOffset: 8,
      verticalOffset: 0,
      overlappingBehavior: 'ellipsis',
      useNodeColors: false,
      font: {
        color: _contants.BLACK,
        weight: 500
      },
      border: {
        visible: false,
        width: 2,
        color: _contants.WHITE
      },
      customizeText(info) {
        return info.title;
      },
      shadow: {
        opacity: 0.2,
        offsetX: 0,
        offsetY: 1,
        blur: 1,
        color: _contants.WHITE
      }
    },
    title: {
      margin: 10,
      font: {
        size: 28,
        weight: 200
      },
      subtitle: {
        font: {
          size: 16
        }
      }
    },
    tooltip: {
      enabled: true
    },
    node: {
      padding: 30,
      width: 8,
      opacity: 1,
      border: {
        color: _contants.WHITE,
        width: 1,
        visible: false
      },
      hoverStyle: {
        hatching: {
          opacity: 0.75,
          step: 6,
          width: 2,
          direction: _contants.RIGHT
        },
        border: {}
      }
    },
    link: {
      color: '#888888',
      colorMode: 'none',
      opacity: 0.3,
      border: {
        color: _contants.WHITE,
        width: 1,
        visible: false
      },
      hoverStyle: {
        opacity: 0.5,
        hatching: {
          opacity: 0.75,
          step: 6,
          width: 2,
          direction: _contants.RIGHT
        },
        border: {}
      }
    }
  }
};

/***/ }),

/***/ 80816:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  sparkline: {
    lineColor: '#666666',
    lineWidth: 2,
    areaOpacity: 0.2,
    minColor: '#e8c267',
    maxColor: '#e55253',
    barPositiveColor: '#a9a9a9',
    barNegativeColor: '#d7d7d7',
    winColor: '#a9a9a9',
    lossColor: '#d7d7d7',
    firstLastColor: '#666666',
    pointSymbol: 'circle',
    pointColor: _contants.WHITE,
    pointSize: 4,
    type: 'line',
    argumentField: 'arg',
    valueField: 'val',
    winlossThreshold: 0,
    showFirstLast: true,
    showMinMax: false,
    tooltip: {
      enabled: true
    }
  }
};

/***/ }),

/***/ 4387:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  treeMap: {
    tile: {
      border: {
        width: 1,
        opacity: 0.2,
        color: '#000000'
      },
      color: '#5f8b95',
      hoverStyle: {
        hatching: {
          opacity: 0.75,
          step: 6,
          width: 2,
          direction: 'right'
        },
        border: {}
      },
      selectionStyle: {
        hatching: {
          opacity: 0.5,
          step: 6,
          width: 2,
          direction: 'right'
        },
        border: {
          opacity: 1
        }
      },
      label: {
        visible: true,
        paddingLeftRight: 5,
        paddingTopBottom: 4,
        font: {
          color: '#ffffff',
          weight: 600
        },
        shadow: {
          opacity: 0.6,
          offsetX: 0,
          offsetY: 1,
          blur: 2,
          color: '#000000'
        },
        wordWrap: 'normal',
        textOverflow: 'ellipsis'
      }
    },
    group: {
      padding: 4,
      border: {
        width: 1
      },
      color: '#eeeeee',
      hoverStyle: {
        hatching: {
          opacity: 0,
          step: 6,
          width: 2,
          direction: 'right'
        },
        border: {}
      },
      selectionStyle: {
        hatching: {
          opacity: 0,
          step: 6,
          width: 2,
          direction: 'right'
        },
        border: {}
      },
      label: {
        visible: true,
        paddingLeftRight: 5,
        paddingTopBottom: 4,
        font: {
          color: _contants.SECONDARY_TITLE_COLOR,
          weight: 600
        },
        textOverflow: 'ellipsis'
      }
    },
    title: {
      subtitle: {}
    },
    tooltip: {},
    loadingIndicator: {}
  }
};

/***/ }),

/***/ 18463:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _contants = __webpack_require__(71160);
var _default = exports["default"] = {
  map: {
    title: {
      margin: 10
    },
    background: {
      borderWidth: 1,
      borderColor: '#cacaca'
    },
    layer: {
      label: {
        enabled: false,
        stroke: _contants.WHITE,
        'stroke-width': 1,
        'stroke-opacity': 0.7,
        font: {
          color: _contants.SOME_GREY,
          size: 12
        }
      }
    },
    'layer:area': {
      borderWidth: 1,
      borderColor: _contants.WHITE,
      color: '#d2d2d2',
      hoveredBorderColor: _contants.GREY_GREEN,
      selectedBorderWidth: 2,
      selectedBorderColor: _contants.GREY_GREEN,
      label: {
        'stroke-width': 2,
        font: {
          size: 16
        }
      }
    },
    'layer:line': {
      borderWidth: 2,
      color: '#ba8365',
      hoveredColor: '#a94813',
      selectedBorderWidth: 3,
      selectedColor: '#e55100',
      label: {
        'stroke-width': 2,
        font: {
          size: 16
        }
      }
    },
    'layer:marker': {
      label: {
        enabled: true,
        'stroke-width': 1,
        font: {
          size: 12
        }
      }
    },
    'layer:marker:dot': {
      borderWidth: 2,
      borderColor: _contants.WHITE,
      size: 8,
      selectedStep: 2,
      backStep: 18,
      backColor: _contants.WHITE,
      backOpacity: 0.32,
      shadow: true
    },
    'layer:marker:bubble': {
      minSize: 20,
      maxSize: 50,
      hoveredBorderWidth: 1,
      hoveredBorderColor: _contants.GREY_GREEN,
      selectedBorderWidth: 2,
      selectedBorderColor: _contants.GREY_GREEN
    },
    'layer:marker:pie': {
      size: 50,
      hoveredBorderWidth: 1,
      hoveredBorderColor: _contants.GREY_GREEN,
      selectedBorderWidth: 2,
      selectedBorderColor: _contants.GREY_GREEN
    },
    'layer:marker:image': {
      size: 20
    },
    legend: {
      verticalAlignment: _contants.BOTTOM,
      horizontalAlignment: _contants.RIGHT,
      position: _contants.INSIDE,
      backgroundOpacity: 0.65,
      border: {
        visible: true
      },
      paddingLeftRight: 16,
      paddingTopBottom: 12
    },
    controlBar: {
      borderColor: '#5d5d5d',
      borderWidth: 3,
      color: _contants.WHITE,
      margin: 20,
      opacity: 0.3
    },
    _rtl: {
      legend: {
        itemTextPosition: _contants.LEFT
      }
    }
  }
};

/***/ }),

/***/ 93820:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const ACCENT_COLOR = '#7ab8eb';
const BACKGROUND_COLOR = '#fff';
const TITLE_COLOR = '#333';
const SUBTITLE_COLOR = '#99a1a8';
const TEXT_COLOR = '#707070';
const BORDER_COLOR = '#e8eaeb';
var _default = exports["default"] = [{
  baseThemeName: 'generic.light',
  theme: {
    name: 'generic.softblue',
    defaultPalette: 'Soft Blue',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    export: {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        default: {
          color: TITLE_COLOR,
          borderColor: '#c9d0d4',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#a7b2b9',
          backgroundColor: '#e6e6e6'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#82929b',
          backgroundColor: '#e6e6e6'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#82929b',
          backgroundColor: '#d4d4d4'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: BACKGROUND_COLOR,
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      color: BACKGROUND_COLOR,
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#cfd2d3'
        }
      }
    },
    rangeSelector: {
      scale: {
        breakStyle: {
          color: '#cfd2d3'
        },
        tick: {
          opacity: 0.12
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#f0ad4e',
      maxColor: '#d9534f'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: SUBTITLE_COLOR
          }
        }
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    gauge: {
      valueIndicators: {
        rangebar: {
          color: ACCENT_COLOR
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          color: ACCENT_COLOR
        }
      }
    }
  }
}, {
  baseThemeName: 'generic.softblue',
  theme: {
    name: 'generic.softblue.compact'
  }
}];

/***/ }),

/***/ 88484:
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const FONT_FAMILY = '\'Roboto\', \'RobotoFallback\', \'Helvetica\', \'Arial\', sans-serif';
const LIGHT_TITLE_COLOR = 'rgba(0,0,0,0.87)';
const LIGHT_LABEL_COLOR = 'rgba(0,0,0,0.54)';
const DARK_TITLE_COLOR = 'rgba(255,255,255,0.87)';
const DARK_LABEL_COLOR = 'rgba(255,255,255,0.54)';
const DARK_BACKGROUND_COLOR = '#363640';
const WHITE = '#ffffff';
const BLACK = '#000000';
const RANGE_COLOR = '#b5b5b5';
const AREA_LAYER_COLOR = '#686868';
const LINE_COLOR = '#c7c7c7';
const TARGET_COLOR = '#8e8e8e';
const POSITIVE_COLOR = '#b8b8b8';
const LABEL_BORDER_COLOR = '#494949';
const BREAK_STYLE_COLOR = '#818181';
const themes = [{
  baseThemeName: 'generic.light',
  theme: {
    name: 'material',
    defaultPalette: 'Material',
    font: {
      family: FONT_FAMILY
    },
    title: {
      margin: {
        top: 20,
        bottom: 20,
        left: 0,
        right: 0
      },
      font: {
        size: 20,
        family: FONT_FAMILY,
        weight: 500
      },
      horizontalAlignment: 'left',
      subtitle: {
        font: {
          size: 14
        },
        horizontalAlignment: 'left'
      }
    },
    tooltip: {
      shadow: {
        opacity: 0
      },
      border: {
        visible: false
      },
      paddingLeftRight: 8,
      paddingTopBottom: 6,
      arrowLength: 0,
      location: 'edge',
      color: '#616161',
      font: {
        color: WHITE
      },
      cornerRadius: 4
    },
    chart: {
      commonAxisSettings: {
        minorTick: {
          opacity: 0.5
        },
        label: {
          font: {
            size: 11
          }
        }
      },
      commonAnnotationSettings: {
        font: {
          color: WHITE
        },
        border: {
          color: '#616161'
        },
        color: '#616161',
        arrowLength: 14,
        arrowWidth: 0,
        shadow: {
          opacity: 0.08,
          offsetY: 4,
          blur: 8
        },
        cornerRadius: 4
      }
    },
    pie: {
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    polar: {
      commonAxisSettings: {
        minorTick: {
          opacity: 0.5
        }
      },
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    funnel: {
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    gauge: {
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    barGauge: {
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    rangeSelector: {
      sliderHandle: {
        opacity: 0.5
      }
    },
    treeMap: {
      group: {
        label: {
          font: {
            weight: 500
          }
        }
      }
    }
  }
}, {
  baseThemeName: 'material',
  theme: {
    name: 'material.light',
    gridColor: '#e0e0e0',
    axisColor: LIGHT_LABEL_COLOR,
    primaryTitleColor: LIGHT_TITLE_COLOR,
    legend: {
      font: {
        color: LIGHT_LABEL_COLOR
      }
    },
    chart: {
      scrollBar: {
        color: '#bfbfbf',
        opacity: 0.7
      }
    },
    gauge: {
      rangeContainer: {
        backgroundColor: 'rgba(0,0,0,0.2)'
      }
    },
    barGauge: {
      backgroundColor: '#efefef'
    }
  }
}, {
  baseThemeName: 'material',
  theme: {
    name: 'material.dark',
    gridColor: '#515159',
    backgroundColor: DARK_BACKGROUND_COLOR,
    axisColor: DARK_LABEL_COLOR,
    font: {
      color: DARK_LABEL_COLOR
    },
    primaryTitleColor: DARK_TITLE_COLOR,
    secondaryTitleColor: DARK_TITLE_COLOR,
    tooltip: {
      color: '#000'
    },
    export: {
      backgroundColor: DARK_BACKGROUND_COLOR,
      font: {
        color: '#dbdbdb'
      },
      button: {
        default: {
          color: '#dedede',
          borderColor: '#4d4d4d',
          backgroundColor: DARK_BACKGROUND_COLOR
        },
        hover: {
          color: '#dedede',
          borderColor: '#6c6c6c',
          backgroundColor: '#3f3f4b'
        },
        focus: {
          color: '#dedede',
          borderColor: '#8d8d8d',
          backgroundColor: '#494956'
        },
        active: {
          color: '#dedede',
          borderColor: '#8d8d8d',
          backgroundColor: '#494956'
        }
      },
      shadowColor: '#292929'
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: LABEL_BORDER_COLOR
          }
        },
        valueErrorBar: {
          color: WHITE
        }
      }
    },
    'chart:common:axis': {
      constantLineStyle: {
        color: WHITE
      }
    },
    'chart:common:annotation': {
      border: {
        color: '#000'
      },
      color: '#000'
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: LABEL_BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: BREAK_STYLE_COLOR
        }
      },
      zoomAndPan: {
        dragBoxStyle: {
          color: WHITE
        }
      }
    },
    gauge: {
      rangeContainer: {
        backgroundColor: RANGE_COLOR
      },
      valueIndicators: {
        _default: {
          color: RANGE_COLOR
        },
        rangebar: {
          color: '#84788b'
        },
        // eslint-disable-next-line spellcheck/spell-checker
        twocolorneedle: {
          secondColor: '#ba544d'
        },
        // eslint-disable-next-line spellcheck/spell-checker
        trianglemarker: {
          color: '#b7918f'
        },
        // eslint-disable-next-line spellcheck/spell-checker
        textcloud: {
          color: '#ba544d'
        }
      }
    },
    barGauge: {
      backgroundColor: '#3c3c3c'
    },
    rangeSelector: {
      scale: {
        tick: {
          color: WHITE,
          opacity: 0.32
        },
        minorTick: {
          color: WHITE,
          opacity: 0.1
        },
        breakStyle: {
          color: BREAK_STYLE_COLOR
        }
      },
      selectedRangeColor: RANGE_COLOR,
      sliderMarker: {
        color: RANGE_COLOR,
        font: {
          color: DARK_BACKGROUND_COLOR
        }
      },
      sliderHandle: {
        color: WHITE,
        opacity: 0.2
      },
      shutter: {
        color: WHITE,
        opacity: 0.1
      }
    },
    map: {
      background: {
        borderColor: '#3f3f3f'
      },
      layer: {
        label: {
          stroke: BLACK,
          font: {
            color: WHITE
          }
        }
      },
      'layer:area': {
        borderColor: DARK_BACKGROUND_COLOR,
        color: AREA_LAYER_COLOR,
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:line': {
        color: '#c77244',
        hoveredColor: '#ff5d04',
        selectedColor: '#ff784f'
      },
      'layer:marker:bubble': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:marker:pie': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      legend: {
        border: {
          color: '#3f3f3f'
        },
        font: {
          color: WHITE
        }
      },
      controlBar: {
        borderColor: LINE_COLOR,
        color: DARK_BACKGROUND_COLOR
      }
    },
    treeMap: {
      group: {
        color: '#4c4c4c',
        label: {
          font: {
            color: '#a3a3a3'
          }
        }
      }
    },
    sparkline: {
      lineColor: LINE_COLOR,
      firstLastColor: LINE_COLOR,
      barPositiveColor: POSITIVE_COLOR,
      barNegativeColor: TARGET_COLOR,
      winColor: POSITIVE_COLOR,
      lossColor: TARGET_COLOR,
      pointColor: DARK_BACKGROUND_COLOR
    },
    bullet: {
      targetColor: TARGET_COLOR
    },
    funnel: {
      item: {
        border: {
          color: DARK_BACKGROUND_COLOR
        }
      }
    },
    sankey: {
      label: {
        font: {
          color: WHITE
        }
      }
    }
  }
}];
function getMaterialColorScheme(accentName, themeName, accentColor) {
  return {
    theme: {
      name: `material.${accentName}.${themeName}`,
      rangeSelector: {
        selectedRangeColor: accentColor,
        sliderMarker: {
          color: accentColor
        },
        sliderHandle: {
          color: accentColor
        }
      },
      map: {
        'layer:marker:dot': {
          color: accentColor
        },
        'layer:marker:bubble': {
          color: accentColor
        },
        legend: {
          markerColor: accentColor
        }
      },
      bullet: {
        color: accentColor
      },
      gauge: {
        valueIndicators: {
          rangebar: {
            color: accentColor
          },
          // eslint-disable-next-line spellcheck/spell-checker
          textcloud: {
            color: accentColor
          }
        }
      }
    },
    baseThemeName: `material.${themeName}`
  };
}
const materialAccents = {
  blue: '#03a9f4',
  lime: '#cddc39',
  orange: '#ff5722',
  purple: '#9c27b0',
  teal: '#009688'
};
Object.keys(materialAccents).forEach(accent => {
  const color = materialAccents[accent];
  themes.push(getMaterialColorScheme(accent, 'light', color), getMaterialColorScheme(accent, 'dark', color), {
    theme: {
      name: `material.${accent}.light.compact`
    },
    baseThemeName: `material.${accent}.light`
  }, {
    theme: {
      name: `material.${accent}.dark.compact`
    },
    baseThemeName: `material.${accent}.dark`
  });
});
var _default = exports["default"] = themes;

/***/ }),

/***/ 4096:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _math = __webpack_require__(60810);
var _size = __webpack_require__(58664);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _crosshair = __webpack_require__(97574);
var _layout_manager = __webpack_require__(61189);
var _multi_axes_synchronizer = _interopRequireDefault(__webpack_require__(42597));
var _scroll_bar = __webpack_require__(97882);
var _shutter_zoom = _interopRequireDefault(__webpack_require__(70714));
var _zoom_and_pan = _interopRequireDefault(__webpack_require__(59345));
var _annotations = __webpack_require__(77129);
var _utils = __webpack_require__(19157);
var _range_data_calculator = _interopRequireDefault(__webpack_require__(63407));
var _range = __webpack_require__(21177);
var _utils2 = __webpack_require__(34434);
var _m_advanced_chart = __webpack_require__(41690);
var _m_base_chart = __webpack_require__(14107);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

const DEFAULT_PANE_NAME = 'default';
const VISUAL_RANGE = 'VISUAL_RANGE';
const DEFAULT_PANES = [{
  name: DEFAULT_PANE_NAME,
  border: {}
}];
const DISCRETE = 'discrete';
const {
  isArray
} = Array;
function getFirstAxisNameForPane(axes, paneName, defaultPane) {
  let result;
  for (let i = 0; i < axes.length; i += 1) {
    if (axes[i].pane === paneName || axes[i].pane === undefined && paneName === defaultPane) {
      result = axes[i].name;
      break;
    }
  }
  if (!result) {
    result = axes[0].name;
  }
  return result;
}
function changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility) {
  const gridOpt = axis.getOptions().grid;
  const minorGridOpt = axis.getOptions().minorGrid;
  gridOpt.visible = gridVisibility;
  minorGridOpt && (minorGridOpt.visible = minorGridVisibility);
}
function hideGridsOnNonFirstValueAxisForPane(axesForPane) {
  let axisShown = false;
  const hiddenStubAxis = [];
  const minorGridVisibility = axesForPane.some(axis => {
    const minorGridOptions = axis.getOptions().minorGrid;
    return minorGridOptions === null || minorGridOptions === void 0 ? void 0 : minorGridOptions.visible;
  });
  const gridVisibility = axesForPane.some(axis => {
    const gridOptions = axis.getOptions().grid;
    return gridOptions === null || gridOptions === void 0 ? void 0 : gridOptions.visible;
  });
  if (axesForPane.length > 1) {
    axesForPane.forEach(axis => {
      const gridOpt = axis.getOptions().grid;
      if (axisShown) {
        changeVisibilityAxisGrids(axis, false, false);
      } else if (gridOpt !== null && gridOpt !== void 0 && gridOpt.visible) {
        if (axis.getTranslator().getBusinessRange().isEmpty()) {
          changeVisibilityAxisGrids(axis, false, false);
          hiddenStubAxis.push(axis);
        } else {
          axisShown = true;
          changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility);
        }
      }
    });
    if (!axisShown && hiddenStubAxis.length) {
      changeVisibilityAxisGrids(hiddenStubAxis[0], gridVisibility, minorGridVisibility);
    }
  }
}
function findAxisOptions(valueAxes, valueAxesOptions, axisName) {
  let result;
  let axInd;
  for (axInd = 0; axInd < valueAxesOptions.length; axInd += 1) {
    if (valueAxesOptions[axInd].name === axisName) {
      result = valueAxesOptions[axInd];
      result.priority = axInd;
      break;
    }
  }
  if (!result) {
    for (axInd = 0; axInd < valueAxes.length; axInd += 1) {
      if (valueAxes[axInd].name === axisName) {
        result = valueAxes[axInd].getOptions();
        result.priority = valueAxes[axInd].priority;
        break;
      }
    }
  }
  return result;
}
function findAxis(paneName, axisName, axes) {
  const axisByName = axes.find(axis => axis.name === axisName && axis.pane === paneName);
  if (axisByName) {
    return axisByName;
  }
  if (paneName) {
    return findAxis(undefined, axisName, axes);
  }
}
function compareAxes(a, b) {
  return a.priority - b.priority;
}
// checks if pane with provided name exists in this panes array
function doesPaneExist(panes, paneName) {
  let found = false;
  (0, _iterator.each)(panes, (_, pane) => {
    if (pane.name === paneName) {
      found = true;
      return false;
    }
    return undefined;
  });
  return found;
}
// utilities used in axes rendering
function accumulate(field, src1, src2, auxSpacing) {
  const val1 = src1[field] || 0;
  const val2 = src2[field] || 0;
  return val1 + val2 + (val1 && val2 ? auxSpacing : 0);
}
function pickMax(field, src1, src2) {
  return pickMaxValue(src1[field], src2[field]);
}
function pickMaxValue(val1, val2) {
  return Math.max(val1 || 0, val2 || 0);
}
function getAxisMargins(axis) {
  return axis.getMargins();
}
function getHorizontalAxesMargins(axes, getMarginsFunc) {
  return axes.reduce((margins, axis) => {
    var _axis$getOrthogonalAx;
    const axisMargins = getMarginsFunc(axis);
    const paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};
    const spacing = axis.getMultipleAxesSpacing();
    paneMargins.top = accumulate('top', paneMargins, axisMargins, spacing);
    paneMargins.bottom = accumulate('bottom', paneMargins, axisMargins, spacing);
    paneMargins.left = pickMax('left', paneMargins, axisMargins);
    paneMargins.right = pickMax('right', paneMargins, axisMargins);
    margins.top = pickMax('top', paneMargins, margins);
    margins.bottom = pickMax('bottom', paneMargins, margins);
    margins.left = pickMax('left', paneMargins, margins);
    margins.right = pickMax('right', paneMargins, margins);
    const orthogonalAxis = (_axis$getOrthogonalAx = axis.getOrthogonalAxis) === null || _axis$getOrthogonalAx === void 0 ? void 0 : _axis$getOrthogonalAx.call(axis);
    const shouldResetPositionMargin = (orthogonalAxis === null || orthogonalAxis === void 0 ? void 0 : orthogonalAxis.customPositionIsAvailable()) && (!axis.customPositionIsBoundaryOrthogonalAxis() || !orthogonalAxis.customPositionEqualsToPredefined());
    if (shouldResetPositionMargin) {
      margins[orthogonalAxis.getResolvedBoundaryPosition()] = 0;
    }
    return margins;
  }, {
    panes: {}
  });
}
function getVerticalAxesMargins(axes) {
  return axes.reduce((margins, axis) => {
    const axisMargins = axis.getMargins();
    const paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};
    const spacing = axis.getMultipleAxesSpacing();
    paneMargins.top = pickMax('top', paneMargins, axisMargins);
    paneMargins.bottom = pickMax('bottom', paneMargins, axisMargins);
    paneMargins.left = accumulate('left', paneMargins, axisMargins, spacing);
    paneMargins.right = accumulate('right', paneMargins, axisMargins, spacing);
    margins.top = pickMax('top', paneMargins, margins);
    margins.bottom = pickMax('bottom', paneMargins, margins);
    margins.left = pickMax('left', paneMargins, margins);
    margins.right = pickMax('right', paneMargins, margins);
    return margins;
  }, {
    panes: {}
  });
}
function performActionOnAxes(axes, action, actionArgument1, actionArgument2, actionArgument3) {
  axes.forEach(axis => {
    axis[action](actionArgument1 === null || actionArgument1 === void 0 ? void 0 : actionArgument1[axis.pane], (actionArgument2 === null || actionArgument2 === void 0 ? void 0 : actionArgument2[axis.pane]) || actionArgument2, actionArgument3);
  });
}
function shrinkCanvases(isRotated, canvases, sizes, verticalMargins, horizontalMargins) {
  function getMargin(side, margins, pane) {
    const m = !(isRotated ? ['left', 'right'] : ['top', 'bottom']).includes(side) ? margins : margins.panes[pane] || {};
    return m[side];
  }
  function getMaxMargin(side, margins1, margins2, pane) {
    return pickMaxValue(getMargin(side, margins1, pane), getMargin(side, margins2, pane));
  }
  const getOriginalField = field => `original${field[0].toUpperCase()}${field.slice(1)}`;
  function shrink(canvases, paneNames, sizeField, startMargin, endMargin, oppositeMargins) {
    paneNames = paneNames.sort((p1, p2) => canvases[p2][startMargin] - canvases[p1][startMargin]);
    paneNames.forEach(pane => {
      const canvas = canvases[pane];
      oppositeMargins.forEach(margin => {
        canvas[margin] = canvas[getOriginalField(margin)] + getMaxMargin(margin, verticalMargins, horizontalMargins, pane);
      });
    });
    const firstPane = canvases[paneNames[0]];
    const initialEmptySpace = firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - canvases[paneNames.at(-1)][getOriginalField(startMargin)];
    let emptySpace = paneNames.reduce((space, paneName) => {
      const maxStartMargin = getMaxMargin(startMargin, verticalMargins, horizontalMargins, paneName);
      const maxEndMargin = getMaxMargin(endMargin, verticalMargins, horizontalMargins, paneName);
      return space - maxStartMargin - maxEndMargin;
    }, initialEmptySpace) - _utils.PANE_PADDING * (paneNames.length - 1);
    emptySpace -= Object.keys(sizes).reduce((prev, key) => {
      const currentHeight = !(0, _utils.isRelativeHeightPane)(sizes[key]) ? sizes[key].height : 0;
      return prev + currentHeight;
    }, 0);
    const initialOffset = firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - (emptySpace < 0 ? emptySpace : 0);
    paneNames.reduce((offset, pane) => {
      const canvas = canvases[pane];
      const paneSize = sizes[pane];
      offset -= getMaxMargin(endMargin, verticalMargins, horizontalMargins, pane);
      canvas[endMargin] = firstPane[sizeField] - offset;
      offset -= !(0, _utils.isRelativeHeightPane)(paneSize) ? paneSize.height : Math.floor(emptySpace * paneSize.height);
      canvas[startMargin] = offset;
      offset -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, pane) + _utils.PANE_PADDING;
      return offset;
    }, initialOffset);
  }
  const paneNames = Object.keys(canvases);
  if (!isRotated) {
    shrink(canvases, paneNames, 'height', 'top', 'bottom', ['left', 'right']);
  } else {
    shrink(canvases, paneNames, 'width', 'left', 'right', ['top', 'bottom']);
  }
  return canvases;
}
function drawAxesWithTicks(axes, condition, canvases, panesBorderOptions) {
  if (condition) {
    performActionOnAxes(axes, 'createTicks', canvases);
    _multi_axes_synchronizer.default.synchronize(axes);
  }
  performActionOnAxes(axes, 'draw', !condition && canvases, panesBorderOptions);
}
function shiftAxis(side1, side2) {
  const shifts = {};
  return function (axis) {
    if (!axis.customPositionIsAvailable() || axis.customPositionEqualsToPredefined()) {
      const shift = shifts[axis.pane] = shifts[axis.pane] || {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      };
      const spacing = axis.getMultipleAxesSpacing();
      const margins = axis.getMargins();
      axis.shift(shift);
      shift[side1] = accumulate(side1, shift, margins, spacing);
      shift[side2] = accumulate(side2, shift, margins, spacing);
    } else {
      axis.shift({
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      });
    }
  };
}
function getCommonSize(side, margins) {
  let size = 0;
  let paneMargins;
  Object.keys(margins.panes).forEach(pane => {
    paneMargins = margins.panes[pane];
    size += side === 'height' ? paneMargins.top + paneMargins.bottom : paneMargins.left + paneMargins.right;
  });
  return size;
}
function checkUsedSpace(sizeShortage, side, axes, getMarginFunc) {
  let size = 0;
  if (sizeShortage[side] > 0) {
    size = getCommonSize(side, getMarginFunc(axes, getAxisMargins));
    performActionOnAxes(axes, 'hideTitle');
    sizeShortage[side] -= size - getCommonSize(side, getMarginFunc(axes, getAxisMargins));
  }
  if (sizeShortage[side] > 0) {
    performActionOnAxes(axes, 'hideOuterElements');
  }
}
function axisAnimationEnabled(drawOptions, pointsToAnimation) {
  const pointsCount = pointsToAnimation.reduce((sum, count) => sum + count, 0) / pointsToAnimation.length;
  return drawOptions.animate && pointsCount <= drawOptions.animationPointsLimit;
}
function collectMarkersInfoBySeries(allSeries, filteredSeries, argAxis) {
  const series = [];
  const overloadedSeries = {};
  const argVisualRange = argAxis.visualRange();
  const argTranslator = argAxis.getTranslator();
  const argViewPortFilter = _range_data_calculator.default.getViewPortFilter(argVisualRange || {});
  filteredSeries.forEach(s => {
    const valAxis = s.getValueAxis();
    const valVisualRange = valAxis.getCanvasRange();
    const valTranslator = valAxis.getTranslator();
    const seriesIndex = allSeries.indexOf(s);
    const valViewPortFilter = _range_data_calculator.default.getViewPortFilter(valVisualRange || {});
    overloadedSeries[seriesIndex] = {};
    filteredSeries.forEach(sr => {
      overloadedSeries[seriesIndex][allSeries.indexOf(sr)] = 0;
    });
    const seriesPoints = [];
    const pointsInViewport = s.getPoints().filter(p => p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true))));
    pointsInViewport.forEach(p => {
      const tp = {
        seriesIndex,
        argument: p.argument,
        value: p.getMaxValue(true),
        size: p.bubbleSize || p.getOptions().size,
        x: undefined,
        y: undefined
      };
      if (p.getMinValue(true) !== p.getMaxValue(true)) {
        const mp = (0, _extend2.extend)({}, tp);
        mp.value = p.getMinValue(true);
        mp.x = argTranslator.to(mp.argument, 1);
        mp.y = valTranslator.to(mp.value, 1);
        seriesPoints.push(mp);
      }
      tp.x = argTranslator.to(tp.argument, 1);
      tp.y = valTranslator.to(tp.value, 1);
      seriesPoints.push(tp);
    });
    overloadedSeries[seriesIndex].pointsCount = seriesPoints.length;
    overloadedSeries[seriesIndex].total = 0;
    overloadedSeries[seriesIndex].continuousSeries = 0;
    series.push({
      name: s.name,
      index: seriesIndex,
      points: seriesPoints
    });
  });
  return {
    series,
    overloadedSeries
  };
}
const isOverlay = (currentPoint, overlayPoint, pointRadius) => {
  const pointHitsLeftBorder = overlayPoint.x - pointRadius <= currentPoint.x;
  const pointHitsRightBorder = overlayPoint.x + pointRadius >= currentPoint.x;
  const pointHitsTopBorder = overlayPoint.y - pointRadius <= currentPoint.y;
  const pointHitsBottomBorder = overlayPoint.y + pointRadius >= currentPoint.y;
  const isPointOverlappedHorizontally = pointHitsLeftBorder && pointHitsRightBorder;
  const isPointOverlappedVertically = pointHitsTopBorder && pointHitsBottomBorder;
  return isPointOverlappedHorizontally && isPointOverlappedVertically;
};
const isPointOverlapped = (currentPoint, points, skipSamePointsComparing) => {
  const radiusPoint = currentPoint.getOptions().size / 2;
  for (let i = 0; i < points.length; i += 1) {
    if (!skipSamePointsComparing) {
      const isXCoordinateSame = points[i].x === currentPoint.x;
      const isYCoordinateSame = points[i].y === currentPoint.y;
      if (isXCoordinateSame && isYCoordinateSame) {
        continue;
      }
    }
    if (isOverlay(currentPoint, points[i], radiusPoint)) {
      return true;
    }
  }
  return false;
};
function fastHidingPointMarkersByArea(canvas, markersInfo, series) {
  const area = canvas.width * canvas.height;
  const seriesPoints = markersInfo.series;
  for (let i = seriesPoints.length - 1; i >= 0; i -= 1) {
    const currentSeries = series.filter(s => s.name === seriesPoints[i].name)[0];
    const {
      points
    } = seriesPoints[i];
    const pointSize = points.length ? points[0].size : 0;
    const pointsArea = pointSize * pointSize * points.length;
    if (currentSeries.autoHidePointMarkersEnabled() && pointsArea >= area / seriesPoints.length) {
      const {
        index
      } = seriesPoints[i];
      currentSeries.autoHidePointMarkers = true;
      seriesPoints.splice(i, 1);
      series.splice(series.indexOf(currentSeries), 1);
      markersInfo.overloadedSeries[index] = null;
    }
  }
}
function updateMarkersInfo(points, overloadedSeries) {
  let isContinuousSeries = false;
  for (let i = 0; i < points.length - 1; i += 1) {
    const curPoint = points[i];
    const {
      size
    } = curPoint;
    if ((0, _type.isDefined)(curPoint.x) && (0, _type.isDefined)(curPoint.y)) {
      for (let j = i + 1; j < points.length; j += 1) {
        const nextPoint = points[j];
        const nextX = nextPoint === null || nextPoint === void 0 ? void 0 : nextPoint.x;
        const nextY = nextPoint === null || nextPoint === void 0 ? void 0 : nextPoint.y;
        if (!(0, _type.isDefined)(nextX) || Math.abs(curPoint.x - nextX) >= size) {
          isContinuousSeries = isContinuousSeries && j !== i + 1;
          break;
        } else {
          const distance = (0, _type.isDefined)(nextX) && (0, _type.isDefined)(nextY) && Math.sqrt((curPoint.x - nextX) ** 2 + (curPoint.y - nextY) ** 2);
          if (distance && distance < size) {
            overloadedSeries[curPoint.seriesIndex][nextPoint.seriesIndex] += 1;
            overloadedSeries[curPoint.seriesIndex].total += 1;
            if (!isContinuousSeries) {
              overloadedSeries[curPoint.seriesIndex].continuousSeries += 1;
              isContinuousSeries = true;
            }
          }
        }
      }
    }
  }
}
// utilities used in axes rendering
const dxChart = _m_advanced_chart.AdvancedChart.inherit({
  _themeSection: 'chart',
  _fontFields: ['crosshair.label.font'],
  _initCore() {
    this.paneAxis = {};
    this.callBase();
  },
  _init() {
    this._containerInitialHeight = (0, _window.hasWindow)() ? (0, _size.getHeight)(this._$element) : 0;
    this.callBase();
  },
  _correctAxes() {
    this._correctValueAxes(true);
  },
  _setDeprecatedOptions() {
    this.callBase();
    (0, _extend2.extend)(this._deprecatedOptions, {
      'argumentAxis.aggregateByCategory': {
        since: '23.1',
        message: 'Use the aggregation.enabled property'
      }
    });
  },
  _getExtraOptions: _common.noop,
  _createPanes() {
    let panes = this.option('panes');
    let panesNameCounter = 0;
    let defaultPane;
    if (!panes || isArray(panes) && !panes.length) {
      panes = DEFAULT_PANES;
    }
    this.callBase();
    defaultPane = this.option('defaultPane');
    panes = (0, _extend2.extend)(true, [], isArray(panes) ? panes : [panes]);
    (0, _iterator.each)(panes, (_, pane) => {
      pane.name = !(0, _type.isDefined)(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name;
    });
    if ((0, _type.isDefined)(defaultPane)) {
      if (!doesPaneExist(panes, defaultPane)) {
        this._incidentOccurred('W2101', [defaultPane]);
        defaultPane = panes[panes.length - 1].name;
      }
    } else {
      defaultPane = panes[panes.length - 1].name;
    }
    this.defaultPane = defaultPane;
    panes = this._isRotated() ? panes.reverse() : panes;
    return panes;
  },
  _getAxisRenderingOptions() {
    return {
      axisType: 'xyAxes',
      drawingType: 'linear'
    };
  },
  _prepareAxisOptions(typeSelector, userOptions, rotated) {
    return {
      isHorizontal: typeSelector === 'argumentAxis' !== rotated,
      containerColor: this._themeManager.getOptions('containerBackgroundColor')
    };
  },
  _checkPaneName(seriesTheme) {
    const paneList = (0, _utils.map)(this.panes, pane => pane.name);
    seriesTheme.pane = seriesTheme.pane || this.defaultPane;
    return paneList.includes(seriesTheme.pane);
  },
  _initCustomPositioningAxes() {
    const argumentAxis = this.getArgumentAxis();
    const valueAxisName = argumentAxis.getOptions().customPositionAxis;
    const valueAxis = this._valueAxes.find(v => v.pane === argumentAxis.pane && (!valueAxisName || valueAxisName === v.name));
    this._valueAxes.forEach(v => {
      if (argumentAxis !== v.getOrthogonalAxis()) {
        v.getOrthogonalAxis = () => argumentAxis;
        v.customPositionIsBoundaryOrthogonalAxis = () => argumentAxis.customPositionIsBoundary();
      }
    });
    if ((0, _type.isDefined)(valueAxis) && valueAxis !== argumentAxis.getOrthogonalAxis()) {
      argumentAxis.getOrthogonalAxis = () => valueAxis;
      argumentAxis.customPositionIsBoundaryOrthogonalAxis = () => this._valueAxes.some(v => v.customPositionIsBoundary());
    } else if ((0, _type.isDefined)(argumentAxis.getOrthogonalAxis()) && !(0, _type.isDefined)(valueAxis)) {
      argumentAxis.getOrthogonalAxis = _common.noop;
    }
  },
  _getAllAxes() {
    return this._argumentAxes.concat(this._valueAxes);
  },
  _resetAxesAnimation(isFirstDrawing, isHorizontal) {
    let axes;
    if ((0, _type.isDefined)(isHorizontal)) {
      axes = isHorizontal ^ this._isRotated() ? this._argumentAxes : this._valueAxes;
    } else {
      axes = this._getAllAxes();
    }
    axes.forEach(a => {
      a.resetApplyingAnimation(isFirstDrawing);
    });
  },
  _axesBoundaryPositioning() {
    const allAxes = this._getAllAxes();
    let boundaryStateChanged = false;
    allAxes.forEach(a => {
      if (!a.customPositionIsAvailable()) {
        return;
      }
      const prevBoundaryState = a.customPositionIsBoundary();
      a._customBoundaryPosition = a.getCustomBoundaryPosition();
      boundaryStateChanged = boundaryStateChanged || prevBoundaryState !== a.customPositionIsBoundary();
    });
    return boundaryStateChanged;
  },
  _getCrosshairMargins() {
    const crosshairOptions = this._getCrosshairOptions() || {};
    const crosshairEnabled = crosshairOptions.enabled;
    const margins = (0, _crosshair.getMargins)();
    const horizontalLabel = (0, _extend2.extend)(true, {}, crosshairOptions.label, crosshairOptions.horizontalLine.label);
    const verticalLabel = (0, _extend2.extend)(true, {}, crosshairOptions.label, crosshairOptions.verticalLine.label);
    return {
      x: crosshairEnabled && crosshairOptions.horizontalLine.visible && horizontalLabel.visible ? margins.x : 0,
      y: crosshairEnabled && crosshairOptions.verticalLine.visible && verticalLabel.visible ? margins.y : 0
    };
  },
  _getValueAxis(paneName, axisName) {
    const valueAxes = this._valueAxes;
    const valueAxisOptions = this.option('valueAxis') || {};
    const valueAxesOptions = isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions];
    const rotated = this._isRotated();
    const crosshairMargins = this._getCrosshairMargins();
    let axisOptions;
    let axis;
    axisName = axisName || getFirstAxisNameForPane(valueAxes, paneName, this.defaultPane);
    axis = findAxis(paneName, axisName, valueAxes);
    if (!axis) {
      axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);
      if (!axisOptions) {
        this._incidentOccurred('W2102', [axisName]);
        axisOptions = {
          name: axisName,
          priority: valueAxes.length
        };
      }
      axis = this._createAxis(false, this._populateAxesOptions('valueAxis', axisOptions, {
        pane: paneName,
        name: axisName,
        optionPath: isArray(valueAxisOptions) ? `valueAxis[${axisOptions.priority}]` : 'valueAxis',
        crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x
      }, rotated));
      axis.applyVisualRangeSetter(this._getVisualRangeSetter());
      valueAxes.push(axis);
    }
    axis.setPane(paneName);
    return axis;
  },
  _correctValueAxes(needHideGrids) {
    const synchronizeMultiAxes = this._themeManager.getOptions('synchronizeMultiAxes');
    const valueAxes = this._valueAxes;
    const paneWithAxis = {};
    this.series.forEach(series => {
      const axis = series.getValueAxis();
      paneWithAxis[axis.pane] = true;
    });
    this.panes.forEach(pane => {
      const paneName = pane.name;
      if (!paneWithAxis[paneName]) {
        this._getValueAxis(paneName); // creates an value axis if there is no one for pane
      }
      if (needHideGrids && synchronizeMultiAxes) {
        hideGridsOnNonFirstValueAxisForPane(valueAxes.filter(axis => axis.pane === paneName));
      }
    });
    this._valueAxes = valueAxes.filter(axis => {
      if (!axis.pane) {
        axis.setPane(this.defaultPane);
      }
      const paneExists = doesPaneExist(this.panes, axis.pane);
      if (!paneExists) {
        axis.dispose();
        axis = null;
      }
      return paneExists;
    }).sort(compareAxes);
    const defaultAxis = this.getValueAxis();
    this._valueAxes.forEach(axis => {
      const {
        optionPath
      } = axis.getOptions();
      if (optionPath) {
        const axesWithSamePath = this._valueAxes.filter(a => a.getOptions().optionPath === optionPath);
        if (axesWithSamePath.length > 1) {
          if (axesWithSamePath.some(a => a === defaultAxis)) {
            axesWithSamePath.forEach(a => {
              if (a !== defaultAxis) {
                a.getOptions().optionPath = null;
              }
            });
          } else {
            axesWithSamePath.forEach((a, i) => {
              if (i !== 0) {
                a.getOptions().optionPath = null;
              }
            });
          }
        }
      }
    });
  },
  _getSeriesForPane(paneName) {
    const paneSeries = [];
    (0, _iterator.each)(this.series, (_, oneSeries) => {
      if (oneSeries.pane === paneName) {
        paneSeries.push(oneSeries);
      }
    });
    return paneSeries;
  },
  _createPanesBorderOptions() {
    const commonBorderOptions = this._themeManager.getOptions('commonPaneSettings').border;
    const panesBorderOptions = {};
    this.panes.forEach(pane => {
      panesBorderOptions[pane.name] = (0, _extend2.extend)(true, {}, commonBorderOptions, pane.border);
    });
    return panesBorderOptions;
  },
  _createScrollBar() {
    const scrollBarOptions = this._themeManager.getOptions('scrollBar') || {};
    const scrollBarGroup = this._scrollBarGroup;
    if (scrollBarOptions.visible) {
      scrollBarOptions.rotated = this._isRotated();
      this._scrollBar = (this._scrollBar || new _scroll_bar.ScrollBar(this._renderer, scrollBarGroup)).update(scrollBarOptions);
    } else {
      var _this$_scrollBar;
      scrollBarGroup.linkRemove();
      (_this$_scrollBar = this._scrollBar) === null || _this$_scrollBar === void 0 || _this$_scrollBar.dispose();
      this._scrollBar = null;
    }
  },
  _executeAppendAfterSeries(append) {
    append();
  },
  _prepareToRender() {
    const panesBorderOptions = this._createPanesBorderOptions();
    this._createPanesBackground();
    this._appendAxesGroups();
    this._adjustViewport();
    return panesBorderOptions;
  },
  _adjustViewport() {
    const adjustOnZoom = this._themeManager.getOptions('adjustOnZoom');
    if (!adjustOnZoom) {
      return;
    }
    this._valueAxes.forEach(axis => axis.adjust());
  },
  _recreateSizeDependentObjects(isCanvasChanged) {
    const series = this._getVisibleSeries();
    const useAggregation = series.some(s => s.useAggregation());
    const zoomChanged = this._isZooming();
    if (!useAggregation) {
      return;
    }
    this._argumentAxes.forEach(axis => {
      axis.updateCanvas(this._canvas, true);
    });
    series.forEach(series => {
      if (series.useAggregation() && (isCanvasChanged || zoomChanged || !series._useAllAggregatedPoints)) {
        series.createPoints();
      }
    });
    this._processSeriesFamilies();
  },
  _isZooming() {
    const argumentAxis = this.getArgumentAxis();
    if (!(argumentAxis !== null && argumentAxis !== void 0 && argumentAxis.getTranslator())) {
      return false;
    }
    const businessRange = argumentAxis.getTranslator().getBusinessRange();
    const zoomRange = argumentAxis.getViewport();
    let min = zoomRange ? zoomRange.min : 0;
    let max = zoomRange ? zoomRange.max : 0;
    if (businessRange.axisType === 'logarithmic') {
      min = (0, _utils.getLog)(min, businessRange.base);
      max = (0, _utils.getLog)(max, businessRange.base);
    }
    const viewportDistance = businessRange.axisType === DISCRETE ? (0, _utils.getCategoriesInfo)(businessRange.categories, min, max).categories.length : Math.abs(max - min);
    let precision = (0, _math.getPrecision)(viewportDistance);
    precision = precision > 1 ? 10 ** (precision - 2) : 1;
    const zoomChanged = Math.round((this._zoomLength - viewportDistance) * precision) / precision !== 0;
    this._zoomLength = viewportDistance;
    return zoomChanged;
  },
  _handleSeriesDataUpdated() {
    const viewport = new _range.Range();
    this.series.forEach(s => {
      viewport.addRange(s.getArgumentRange());
    });
    this._argumentAxes.forEach(axis => {
      axis.updateCanvas(this._canvas, true);
      axis.setBusinessRange(viewport, this._axesReinitialized);
    });
    this.callBase();
  },
  _isLegendInside() {
    return this._legend && this._legend.getPosition() === 'inside';
  },
  _isRotated() {
    return this._themeManager.getOptions('rotated');
  },
  _getLayoutTargets() {
    return this.panes;
  },
  _applyClipRects(panesBorderOptions) {
    this._drawPanesBorders(panesBorderOptions);
    this._createClipRectsForPanes();
    this._applyClipRectsForAxes();
    this._fillPanesBackground();
  },
  _updateLegendPosition(drawOptions, legendHasInsidePosition) {
    if (drawOptions.drawLegend && this._legend && legendHasInsidePosition) {
      const {
        panes
      } = this;
      const newCanvas = (0, _extend2.extend)({}, panes[0].canvas);
      const layoutManager = new _layout_manager.LayoutManager();
      newCanvas.right = panes[panes.length - 1].canvas.right;
      newCanvas.bottom = panes[panes.length - 1].canvas.bottom;
      layoutManager.layoutInsideLegend(this._legend, newCanvas);
    }
  },
  _allowLegendInsidePosition() {
    return true;
  },
  _applyExtraSettings(series) {
    const paneIndex = this._getPaneIndex(series.pane);
    const panesClipRects = this._panesClipRects;
    const wideClipRect = panesClipRects.wide[paneIndex];
    series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect === null || wideClipRect === void 0 ? void 0 : wideClipRect.id, this._getPaneBorderVisibility(paneIndex));
  },
  _updatePanesCanvases(drawOptions) {
    if (!drawOptions.recreateCanvas) {
      return;
    }
    (0, _utils.updatePanesCanvases)(this.panes, this._canvas, this._isRotated());
  },
  _normalizePanesHeight() {
    (0, _utils.normalizePanesHeight)(this.panes);
  },
  _renderScaleBreaks() {
    this._valueAxes.concat(this._argumentAxes).forEach(axis => {
      axis.drawScaleBreaks();
    });
  },
  _getArgFilter() {
    return _range_data_calculator.default.getViewPortFilter(this.getArgumentAxis().visualRange() || {});
  },
  _hidePointsForSingleSeriesIfNeeded(series) {
    const seriesPoints = series.getPoints();
    let overlappedPointsCount = 0;
    for (let i = 0; i < seriesPoints.length; i += 1) {
      const currentPoint = seriesPoints[i];
      const overlappingPoints = seriesPoints.slice(i + 1);
      overlappedPointsCount += Number(isPointOverlapped(currentPoint, overlappingPoints));
      if (overlappedPointsCount > seriesPoints.length / 2) {
        series.autoHidePointMarkers = true;
        break;
      }
    }
  },
  _applyAutoHidePointMarkers(filteredSeries) {
    let overlappingPoints = [];
    const overlappedPointsCalculator = (pointsCount, currentPoint) => pointsCount + isPointOverlapped(currentPoint, overlappingPoints, true);
    for (let i = filteredSeries.length - 1; i >= 0; i -= 1) {
      const currentSeries = filteredSeries[i];
      if (!currentSeries.autoHidePointMarkersEnabled()) {
        continue;
      }
      currentSeries.autoHidePointMarkers = false;
      this._hidePointsForSingleSeriesIfNeeded(currentSeries);
      if (!currentSeries.autoHidePointMarkers) {
        const seriesPoints = currentSeries.getPoints();
        const overlappingPointsCount = seriesPoints.reduce(overlappedPointsCalculator, 0);
        if (overlappingPointsCount < seriesPoints.length) {
          overlappingPoints = overlappingPoints.concat(seriesPoints);
        } else {
          currentSeries.autoHidePointMarkers = true;
        }
      }
    }
  },
  _applyPointMarkersAutoHiding() {
    const allSeries = this.series;
    if (!this._themeManager.getOptions('autoHidePointMarkers')) {
      allSeries.forEach(s => {
        s.autoHidePointMarkers = false;
      });
      return;
    }
    this.panes.forEach(_ref => {
      let {
        borderCoords,
        name
      } = _ref;
      const series = allSeries.filter(s => s.pane === name && s.usePointsToDefineAutoHiding());
      series.forEach(singleSeries => {
        singleSeries.prepareCoordinatesForPoints();
      });
      const argAxis = this.getArgumentAxis();
      const markersInfo = collectMarkersInfoBySeries(allSeries, series, argAxis);
      fastHidingPointMarkersByArea(borderCoords, markersInfo, series);
      if (markersInfo.series.length) {
        const argVisualRange = argAxis.visualRange();
        const argAxisIsDiscrete = argAxis.getOptions().type === DISCRETE;
        const sortingCallback = argAxisIsDiscrete ? (p1, p2) => argVisualRange.categories.indexOf(p1.argument) - argVisualRange.categories.indexOf(p2.argument) : (p1, p2) => p1.argument - p2.argument;
        let points = [];
        markersInfo.series.forEach(s => {
          points = points.concat(s.points);
        });
        points.sort(sortingCallback);
        updateMarkersInfo(points, markersInfo.overloadedSeries);
        this._applyAutoHidePointMarkers(series);
      }
    });
  },
  _renderAxes(drawOptions, panesBorderOptions) {
    function calculateTitlesWidth(axes) {
      return axes.map(axis => {
        if (!axis.getTitle) return 0;
        const title = axis.getTitle();
        return title ? title.bBox.width : 0;
      });
    }
    const rotated = this._isRotated();
    const synchronizeMultiAxes = this._themeManager.getOptions('synchronizeMultiAxes');
    const scrollBar = this._scrollBar ? [this._scrollBar] : [];
    const extendedArgAxes = this._isArgumentAxisBeforeScrollBar() ? this._argumentAxes.concat(scrollBar) : scrollBar.concat(this._argumentAxes);
    const verticalAxes = rotated ? this._argumentAxes : this._valueAxes;
    const verticalElements = rotated ? extendedArgAxes : this._valueAxes;
    const horizontalAxes = rotated ? this._valueAxes : this._argumentAxes;
    const horizontalElements = rotated ? this._valueAxes : extendedArgAxes;
    const allAxes = verticalAxes.concat(horizontalAxes);
    const allElements = allAxes.concat(scrollBar);
    const verticalAxesFirstDrawing = verticalAxes.some(v => v.isFirstDrawing());
    this._normalizePanesHeight();
    this._updatePanesCanvases(drawOptions);
    let panesCanvases = this.panes.reduce((canvases, pane) => {
      canvases[pane.name] = (0, _extend2.extend)({}, pane.canvas);
      return canvases;
    }, {});
    const paneSizes = this.panes.reduce((sizes, pane) => {
      sizes[pane.name] = {
        height: pane.height,
        unit: pane.unit
      };
      return sizes;
    }, {});
    const cleanPanesCanvases = (0, _extend2.extend)(true, {}, panesCanvases);
    this._initCustomPositioningAxes();
    const needCustomAdjustAxes = this._axesBoundaryPositioning();
    if (!drawOptions.adjustAxes && !needCustomAdjustAxes) {
      drawAxesWithTicks(verticalAxes, !rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);
      drawAxesWithTicks(horizontalAxes, rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);
      performActionOnAxes(allAxes, 'prepareAnimation');
      this._renderScaleBreaks();
      horizontalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(verticalAxes));
      verticalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(horizontalAxes));
      return false;
    }
    if (needCustomAdjustAxes) {
      allAxes.forEach(a => a.customPositionIsAvailable() && a.shift({
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      }));
    }
    if (this._scrollBar) {
      this._scrollBar.setPane(this.panes);
    }
    let vAxesMargins = {
      panes: {},
      left: 0,
      right: 0
    };
    let hAxesMargins = getHorizontalAxesMargins(horizontalElements, axis => axis.estimateMargins(panesCanvases[axis.pane]));
    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
    const drawAxesAndSetCanvases = isHorizontal => {
      const axes = isHorizontal ? horizontalAxes : verticalAxes;
      const condition = (isHorizontal ? rotated : !rotated) && synchronizeMultiAxes;
      drawAxesWithTicks(axes, condition, panesCanvases, panesBorderOptions);
      if (isHorizontal) {
        hAxesMargins = getHorizontalAxesMargins(horizontalElements, getAxisMargins);
      } else {
        vAxesMargins = getVerticalAxesMargins(verticalElements);
      }
      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
    };
    drawAxesAndSetCanvases(false);
    drawAxesAndSetCanvases(true);
    if (!this._changesApplying && this._estimateTickIntervals(verticalAxes, panesCanvases)) {
      drawAxesAndSetCanvases(false);
    }
    let oldTitlesWidth = calculateTitlesWidth(verticalAxes);
    const visibleSeries = this._getVisibleSeries();
    const pointsToAnimation = this._getPointsToAnimation(visibleSeries);
    const axesIsAnimated = axisAnimationEnabled(drawOptions, pointsToAnimation);
    performActionOnAxes(allElements, 'updateSize', panesCanvases, axesIsAnimated);
    horizontalElements.forEach(shiftAxis('top', 'bottom'));
    verticalElements.forEach(shiftAxis('left', 'right'));
    this._renderScaleBreaks();
    this.panes.forEach(pane => {
      (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name]);
    });
    this._valueAxes.forEach(axis => {
      axis.setInitRange();
    });
    verticalAxes.forEach((axis, i) => {
      var _axis$hasWrap;
      if ((_axis$hasWrap = axis.hasWrap) !== null && _axis$hasWrap !== void 0 && _axis$hasWrap.call(axis)) {
        const title = axis.getTitle();
        const newTitleWidth = title ? title.bBox.width : 0;
        const offset = newTitleWidth - oldTitlesWidth[i];
        if (axis.getOptions().position === 'right') {
          vAxesMargins.right += offset;
        } else {
          vAxesMargins.left += offset;
          this.panes.forEach(_ref2 => {
            let {
              name
            } = _ref2;
            vAxesMargins.panes[name].left += offset;
          });
        }
        panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
        performActionOnAxes(allElements, 'updateSize', panesCanvases, false, false);
        oldTitlesWidth = calculateTitlesWidth(verticalAxes);
      }
    });
    if (verticalAxes.some(v => v.customPositionIsAvailable() && v.getCustomPosition() !== v._axisPosition)) {
      axesIsAnimated && this._resetAxesAnimation(verticalAxesFirstDrawing, false);
      performActionOnAxes(verticalAxes, 'updateSize', panesCanvases, axesIsAnimated);
    }
    horizontalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(verticalAxes));
    verticalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(horizontalAxes));
    return cleanPanesCanvases;
  },
  _getExtraTemplatesItems() {
    const allAxes = (this._argumentAxes || []).concat(this._valueAxes || []);
    const elements = this._collectTemplatesFromItems(allAxes);
    return {
      items: elements.items,
      groups: elements.groups,
      launchRequest() {
        allAxes.forEach(a => {
          a.setRenderedState(true);
        });
      },
      doneRequest() {
        allAxes.forEach(a => {
          a.setRenderedState(false);
        });
      }
    };
  },
  _estimateTickIntervals(axes, canvases) {
    return axes.some(axis => axis.estimateTickInterval(canvases[axis.pane]));
  },
  checkForMoreSpaceForPanesCanvas() {
    const rotated = this._isRotated();
    const panesAreCustomSized = this.panes.filter(p => p.unit).length === this.panes.length;
    let needSpace = false;
    if (panesAreCustomSized) {
      let needHorizontalSpace = 0;
      let needVerticalSpace = 0;
      if (rotated) {
        const argAxisRightMargin = this.getArgumentAxis().getMargins().right;
        const rightPanesIndent = Math.min(...this.panes.map(p => p.canvas.right));
        needHorizontalSpace = this._canvas.right + argAxisRightMargin - rightPanesIndent;
      } else {
        const argAxisBottomMargin = this.getArgumentAxis().getMargins().bottom;
        const bottomPanesIndent = Math.min(...this.panes.map(p => p.canvas.bottom));
        needVerticalSpace = this._canvas.bottom + argAxisBottomMargin - bottomPanesIndent;
      }
      needSpace = needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
        width: needHorizontalSpace,
        height: needVerticalSpace
      } : false;
      if (needVerticalSpace !== 0) {
        const realSize = this.getSize();
        const customSize = this.option('size');
        const container = this._$element[0];
        const containerHasStyledHeight = !!parseInt(container.style.height, 10) || this._containerInitialHeight !== 0;
        if (!rotated && !(customSize !== null && customSize !== void 0 && customSize.height) && !containerHasStyledHeight) {
          this._forceResize(realSize.width, realSize.height + needVerticalSpace);
          needSpace = false;
        }
      }
    } else {
      needSpace = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), rotated, pane => ({
        width: rotated && !!pane.unit,
        height: !rotated && !!pane.unit
      }));
    }
    return needSpace;
  },
  _forceResize(width, height) {
    this._renderer.resize(width, height);
    this._updateSize(true);
    this._setContentSize();
    this._preserveOriginalCanvas();
    this._updateCanvasClipRect(this._canvas);
  },
  _shrinkAxes(sizeShortage, panesCanvases) {
    if (!sizeShortage || !panesCanvases) {
      return;
    }
    this._renderer.stopAllAnimations(true);
    const rotated = this._isRotated();
    const scrollBar = this._scrollBar ? [this._scrollBar] : [];
    const extendedArgAxes = this._isArgumentAxisBeforeScrollBar() ? this._argumentAxes.concat(scrollBar) : scrollBar.concat(this._argumentAxes);
    const verticalAxes = rotated ? extendedArgAxes : this._valueAxes;
    const horizontalAxes = rotated ? this._valueAxes : extendedArgAxes;
    const allAxes = verticalAxes.concat(horizontalAxes);
    if (sizeShortage.width || sizeShortage.height) {
      checkUsedSpace(sizeShortage, 'height', horizontalAxes, getHorizontalAxesMargins);
      checkUsedSpace(sizeShortage, 'width', verticalAxes, getVerticalAxesMargins);
      performActionOnAxes(allAxes, 'updateSize', panesCanvases);
      const paneSizes = this.panes.reduce((sizes, pane) => {
        sizes[pane.name] = {
          height: pane.height,
          unit: pane.unit
        };
        return sizes;
      }, {});
      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, getVerticalAxesMargins(verticalAxes), getHorizontalAxesMargins(horizontalAxes, getAxisMargins));
      performActionOnAxes(allAxes, 'updateSize', panesCanvases);
      horizontalAxes.forEach(shiftAxis('top', 'bottom'));
      verticalAxes.forEach(shiftAxis('left', 'right'));
      this.panes.forEach(pane => (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name]));
    }
  },
  _isArgumentAxisBeforeScrollBar() {
    const argumentAxis = this.getArgumentAxis();
    if (this._scrollBar) {
      var _argumentAxis$getOpti;
      const argAxisPosition = argumentAxis.getResolvedBoundaryPosition();
      const argAxisLabelPosition = (_argumentAxis$getOpti = argumentAxis.getOptions().label) === null || _argumentAxis$getOpti === void 0 ? void 0 : _argumentAxis$getOpti.position;
      const scrollBarPosition = this._scrollBar.getOptions().position;
      return argumentAxis.hasNonBoundaryPosition() || scrollBarPosition === argAxisPosition && argAxisLabelPosition !== scrollBarPosition;
    }
    return false;
  },
  _getPanesParameters() {
    const {
      panes
    } = this;
    const params = [];
    for (let i = 0; i < panes.length; i += 1) {
      if (this._getPaneBorderVisibility(i)) {
        params.push({
          coords: panes[i].borderCoords,
          clipRect: this._panesClipRects.fixed[i]
        });
      }
    }
    return params;
  },
  _createCrosshairCursor() {
    const options = this._themeManager.getOptions('crosshair') || {};
    const argumentAxis = this.getArgumentAxis();
    const axes = this._isRotated() ? [this._valueAxes, [argumentAxis]] : [[argumentAxis], this._valueAxes];
    const parameters = {
      canvas: this._getCommonCanvas(),
      panes: this._getPanesParameters(),
      axes
    };
    if (!(options !== null && options !== void 0 && options.enabled)) {
      return;
    }
    if (this._crosshair) {
      this._crosshair.update(options, parameters);
    } else {
      this._crosshair = new _crosshair.Crosshair(this._renderer, options, parameters, this._crosshairCursorGroup);
    }
    this._crosshair.render();
  },
  _getCommonCanvas() {
    let commonCanvas;
    const {
      panes
    } = this;
    for (let i = 0; i < panes.length; i += 1) {
      const {
        canvas
      } = panes[i];
      if (!commonCanvas) {
        // TODO
        commonCanvas = (0, _extend2.extend)({}, canvas);
      } else {
        commonCanvas.right = canvas.right;
        commonCanvas.bottom = canvas.bottom;
      }
    }
    return commonCanvas;
  },
  _createPanesBackground() {
    const defaultBackgroundColor = this._themeManager.getOptions('commonPaneSettings').backgroundColor;
    const renderer = this._renderer;
    const rects = [];
    this._panesBackgroundGroup.clear();
    for (let i = 0; i < this.panes.length; i += 1) {
      const backgroundColor = this.panes[i].backgroundColor || defaultBackgroundColor;
      if (!backgroundColor || backgroundColor === 'none') {
        rects.push(null);
        continue;
      }
      const rect = renderer.rect(0, 0, 0, 0).attr({
        fill: (0, _utils.extractColor)(backgroundColor),
        'stroke-width': 0
      }).append(this._panesBackgroundGroup);
      rects.push(rect);
    }
    this.panesBackground = rects;
  },
  _fillPanesBackground() {
    (0, _iterator.each)(this.panes, (i, pane) => {
      const bc = pane.borderCoords;
      if (this.panesBackground[i] !== null) {
        this.panesBackground[i].attr({
          x: bc.left,
          y: bc.top,
          width: bc.width,
          height: bc.height
        });
      }
    });
  },
  _calcPaneBorderCoords(pane) {
    const {
      canvas
    } = pane;
    const bc = pane.borderCoords = pane.borderCoords || {};
    bc.left = canvas.left;
    bc.top = canvas.top;
    bc.right = canvas.width - canvas.right;
    bc.bottom = canvas.height - canvas.bottom;
    bc.width = Math.max(bc.right - bc.left, 0);
    bc.height = Math.max(bc.bottom - bc.top, 0);
  },
  _drawPanesBorders(panesBorderOptions) {
    const rotated = this._isRotated();
    this._panesBorderGroup.linkRemove().clear();
    (0, _iterator.each)(this.panes, (i, pane) => {
      const borderOptions = panesBorderOptions[pane.name];
      const attr = {
        fill: 'none',
        stroke: borderOptions.color,
        'stroke-opacity': borderOptions.opacity,
        'stroke-width': borderOptions.width,
        dashStyle: borderOptions.dashStyle,
        'stroke-linecap': 'square'
      };
      this._calcPaneBorderCoords(pane, rotated);
      if (!borderOptions.visible) {
        return;
      }
      const bc = pane.borderCoords;
      const segmentRectParams = (0, _utils2.prepareSegmentRectPoints)(bc.left, bc.top, bc.width, bc.height, borderOptions);
      this._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(this._panesBorderGroup);
    });
    this._panesBorderGroup.linkAppend();
  },
  _createClipRect(clipArray, index, left, top, width, height) {
    let clipRect = clipArray[index];
    if (!clipRect) {
      clipRect = this._renderer.clipRect(left, top, width, height);
      clipArray[index] = clipRect;
    } else {
      clipRect.attr({
        x: left,
        y: top,
        width,
        height
      });
    }
  },
  _createClipRectsForPanes() {
    const canvas = this._canvas;
    (0, _iterator.each)(this.panes, (i, pane) => {
      let needWideClipRect = false;
      const bc = pane.borderCoords;
      let {
        left
      } = bc;
      let {
        top
      } = bc;
      let {
        width
      } = bc;
      let {
        height
      } = bc;
      const panesClipRects = this._panesClipRects;
      this._createClipRect(panesClipRects.fixed, i, left, top, width, height);
      this._createClipRect(panesClipRects.base, i, left, top, width, height);
      (0, _iterator.each)(this.series, (_, series) => {
        if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {
          needWideClipRect = true;
        }
      });
      if (needWideClipRect) {
        if (this._isRotated()) {
          top = 0;
          height = canvas.height;
        } else {
          left = 0;
          width = canvas.width;
        }
        this._createClipRect(panesClipRects.wide, i, left, top, width, height);
      } else {
        panesClipRects.wide[i] = null;
      }
    });
  },
  _applyClipRectsForAxes() {
    const axes = this._getAllAxes();
    const chartCanvasClipRectID = this._getCanvasClipRectID();
    for (let i = 0; i < axes.length; i += 1) {
      const elementsClipRectID = this._getElementsClipRectID(axes[i].pane);
      axes[i].applyClipRects(elementsClipRectID, chartCanvasClipRectID);
    }
  },
  _getPaneBorderVisibility(paneIndex) {
    var _pane$border;
    const commonPaneBorderVisible = this._themeManager.getOptions('commonPaneSettings').border.visible;
    const pane = this.panes[paneIndex];
    const paneVisibility = pane === null || pane === void 0 || (_pane$border = pane.border) === null || _pane$border === void 0 ? void 0 : _pane$border.visible;
    return paneVisibility === undefined ? commonPaneBorderVisible : paneVisibility;
  },
  _getCanvasForPane(paneName) {
    var _this$panes$find;
    return (_this$panes$find = this.panes.find(pane => pane.name === paneName)) === null || _this$panes$find === void 0 ? void 0 : _this$panes$find.canvas;
  },
  _getTrackerSettings() {
    return (0, _extend2.extend)(this.callBase(), {
      chart: this,
      rotated: this._isRotated(),
      crosshair: this._getCrosshairOptions().enabled ? this._crosshair : null,
      stickyHovering: this._themeManager.getOptions('stickyHovering')
    });
  },
  _resolveLabelOverlappingStack() {
    const isRotated = this._isRotated();
    const shiftDirection = isRotated ? (box, length) => ({
      x: box.x - length,
      y: box.y
    }) : (box, length) => ({
      x: box.x,
      y: box.y - length
    });
    const processor = (a, b) => {
      const coordPosition = isRotated ? 1 : 0;
      const figureCenter1 = a.labels[0].getFigureCenter()[coordPosition];
      const figureCenter12 = b.labels[0].getFigureCenter()[coordPosition];
      if (figureCenter1 - figureCenter12 === 0) {
        const translator = a.labels[0].getPoint().series.getValueAxis().getTranslator();
        const direction = translator.isInverted() ? -1 : 1;
        return (a.value() - b.value()) * direction;
      }
      return 0;
    };
    (0, _iterator.each)(this._getStackPoints(), (_, stacks) => {
      (0, _iterator.each)(stacks, (_, points) => {
        const isInverted = points[0].series.getValueAxis().getOptions().inverted;
        _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(points, this._getCommonCanvas(), isRotated, isInverted, shiftDirection, processor);
      });
    });
  },
  _getStackPoints() {
    const stackPoints = {};
    const visibleSeries = this._getVisibleSeries();
    (0, _iterator.each)(visibleSeries, (_, singleSeries) => {
      const points = singleSeries.getPoints();
      const stackName = singleSeries.getStackName() || null;
      (0, _iterator.each)(points, (_, point) => {
        const {
          argument
        } = point;
        if (!stackPoints[argument]) {
          stackPoints[argument] = {};
        }
        if (!stackPoints[argument][stackName]) {
          stackPoints[argument][stackName] = [];
        }
        stackPoints[argument][stackName].push(point);
      });
    });
    return stackPoints;
  },
  _getCrosshairOptions() {
    return this._getOption('crosshair');
  },
  // API
  zoomArgument(min, max) {
    if (!this._initialized || !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {
      return;
    }
    this.getArgumentAxis().visualRange([min, max]);
  },
  resetVisualRange() {
    const axes = this._argumentAxes;
    const nonVirtualArgumentAxis = this.getArgumentAxis();
    axes.forEach(axis => {
      axis.resetVisualRange(nonVirtualArgumentAxis !== axis);
      this._applyCustomVisualRangeOption(axis);
    });
    this.callBase();
  },
  // T218011 for dashboards
  getVisibleArgumentBounds() {
    const translator = this._argumentAxes[0].getTranslator();
    const range = translator.getBusinessRange();
    const isDiscrete = range.axisType === DISCRETE;
    const {
      categories
    } = range;
    return {
      minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,
      maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible
    };
  },
  _change_FULL_RENDER() {
    this.callBase();
    if (this._changes.has(VISUAL_RANGE)) {
      this._raiseZoomEndHandlers();
    }
  },
  _getAxesForScaling() {
    return [this.getArgumentAxis()].concat(this._valueAxes);
  },
  _applyVisualRangeByVirtualAxes(axis, range) {
    if (axis.isArgumentAxis) {
      if (axis !== this.getArgumentAxis()) {
        return true;
      }
      this._argumentAxes.filter(a => a !== axis).forEach(a => a.visualRange(range, {
        start: true,
        end: true
      }));
    }
    return false;
  },
  _raiseZoomEndHandlers() {
    this._argumentAxes.forEach(axis => axis.handleZoomEnd());
    this.callBase();
  },
  _setOptionsByReference() {
    this.callBase();
    (0, _extend2.extend)(this._optionsByReference, {
      'argumentAxis.visualRange': true
    });
  },
  option() {
    const option = this.callBase(...arguments);
    const valueAxis = this._options.silent('valueAxis');
    if ((0, _type.type)(valueAxis) === 'array') {
      for (let i = 0; i < valueAxis.length; i += 1) {
        const optionPath = `valueAxis[${i}].visualRange`;
        this._optionsByReference[optionPath] = true;
      }
    }
    return option;
  },
  _notifyVisualRange() {
    const argAxis = this._argumentAxes[0];
    const argumentVisualRange = (0, _utils.convertVisualRangeObject)(argAxis.visualRange(), !isArray(this.option('argumentAxis.visualRange')));
    if (!argAxis.skipEventRising || !(0, _utils.rangesAreEqual)(argumentVisualRange, this.option('argumentAxis.visualRange'))) {
      this.option('argumentAxis.visualRange', argumentVisualRange);
    } else {
      argAxis.skipEventRising = null;
    }
    this.callBase();
  }
});
dxChart.addPlugin(_shutter_zoom.default);
dxChart.addPlugin(_zoom_and_pan.default);
dxChart.addPlugin(_annotations.plugins.core);
dxChart.addPlugin(_annotations.plugins.chart);
(0, _component_registrator.default)('dxChart', dxChart);
var _default = exports["default"] = dxChart;

/***/ }),

/***/ 88647:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _annotations = __webpack_require__(77129);
var _center_template = __webpack_require__(56672);
var _utils = __webpack_require__(19157);
var _range = __webpack_require__(21177);
var _translator1d = __webpack_require__(17953);
var _m_base_chart = __webpack_require__(14107);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  states
} = _consts.default;
const seriesSpacing = _consts.default.pieSeriesSpacing;
const OPTIONS_FOR_REFRESH_SERIES = ['startAngle', 'innerRadius', 'segmentsDirection', 'type'];
const NORMAL_STATE = states.normalMark;
const HOVER_STATE = states.hoverMark;
const SELECTED_STATE = states.selectedMark;
const MAX_RESOLVE_ITERATION_COUNT = 5;
const LEGEND_ACTIONS = [states.resetItem, states.applyHover, states.applySelected, states.applySelected];
function shiftInColumnFunction(box, length) {
  return {
    x: box.x,
    y: box.y - length
  };
}
function dividePoints(series, points) {
  return series.getVisiblePoints().reduce((r, point) => {
    const angle = (0, _utils.normalizeAngle)(point.middleAngle);
    (angle <= 90 || angle >= 270 ? r.right : r.left).push(point);
    return r;
  }, points || {
    left: [],
    right: []
  });
}
function resolveOverlappedLabels(points, shiftCallback, inverseDirection, canvas) {
  let overlapped = false;
  if (inverseDirection) {
    points.left.reverse();
    points.right.reverse();
  }
  overlapped = _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(points.left, canvas, false, false, shiftCallback);
  return _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(points.right, canvas, false, false, shiftCallback) || overlapped;
}
function getLegendItemAction(points) {
  let state = NORMAL_STATE;
  points.forEach(point => {
    var _point$series;
    const seriesOptions = (_point$series = point.series) === null || _point$series === void 0 ? void 0 : _point$series.getOptions();
    let pointState = point.fullState;
    if ((seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.hoverMode) === 'none') {
      pointState &= ~HOVER_STATE;
    }
    if ((seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.selectionMode) === 'none') {
      pointState &= ~SELECTED_STATE;
    }
    state |= pointState;
  });
  return LEGEND_ACTIONS[state];
}
function correctPercentValue(value) {
  if ((0, _type.isNumeric)(value)) {
    if (value > 1) {
      value = 1;
    } else if (value < 0) {
      value = 0;
    }
  } else {
    value = undefined;
  }
  return value;
}
const pieSizeEqualizer = function () {
  function equalize(group, allPies) {
    const pies = allPies.filter(p => p._isVisible() && p.getSizeGroup() === group);
    const minRadius = Math.min.apply(null, pies.map(p => p.getSizeGroupLayout().radius));
    const minPie = pies.filter(p => p.getSizeGroupLayout().radius === minRadius);
    pies.forEach(p => p.render({
      force: true,
      sizeGroupLayout: minPie.length ? minPie[0].getSizeGroupLayout() : {}
    }));
  }
  function removeFromList(list, item) {
    return list.filter(li => li !== item);
  }
  function addToList(list, item) {
    return removeFromList(list, item).concat(item);
  }
  let pies = [];
  let timers = {};
  return {
    queue(pie) {
      const group = pie.getSizeGroup();
      pies = addToList(pies, pie);
      clearTimeout(timers[group]);
      timers[group] = setTimeout(() => {
        equalize(group, pies);
      });
    },
    remove(pie) {
      pies = removeFromList(pies, pie);
      if (!pies.length) {
        timers = {};
      }
    }
  };
}();
const dxPieChart = _m_base_chart.BaseChart.inherit({
  _themeSection: 'pie',
  _layoutManagerOptions() {
    return (0, _extend2.extend)(true, {}, this.callBase(), {
      piePercentage: correctPercentValue(this._themeManager.getOptions('diameter')),
      minPiePercentage: correctPercentValue(this._themeManager.getOptions('minDiameter'))
    });
  },
  _optionChangesMap: {
    diameter: 'REINIT',
    minDiameter: 'REINIT',
    sizeGroup: 'REINIT'
  },
  _disposeCore() {
    pieSizeEqualizer.remove(this);
    this.callBase();
  },
  _groupSeries() {
    var _series$;
    const {
      series
    } = this;
    this._groupsData = {
      groups: [{
        series,
        valueOptions: {
          valueType: 'numeric'
        }
      }],
      argumentOptions: (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.getOptions()
    };
  },
  getArgumentAxis() {
    return null;
  },
  _getValueAxis() {
    const translator = new _translator1d.Translator1D().setCodomain(360, 0);
    return {
      getTranslator() {
        return translator;
      },
      setBusinessRange(range) {
        translator.setDomain(range.min, range.max);
      }
    };
  },
  _populateBusinessRange() {
    this.series.map(series => {
      const range = new _range.Range();
      range.addRange(series.getRangeData().val);
      series.getValueAxis().setBusinessRange(range);
      return range;
    });
  },
  _specialProcessSeries() {
    (0, _iterator.each)(this.series, (_, singleSeries) => {
      singleSeries.arrangePoints();
    });
  },
  _checkPaneName() {
    return true;
  },
  _processSingleSeries(singleSeries) {
    this.callBase(singleSeries);
    singleSeries.arrangePoints();
  },
  _handleSeriesDataUpdated() {
    let maxPointCount = 0;
    this.series.forEach(s => {
      maxPointCount = Math.max(s.getPointsCount(), maxPointCount);
    });
    this.series.forEach(s => {
      s.setMaxPointsCount(maxPointCount);
    });
    this.callBase();
  },
  _getLegendOptions(item) {
    const legendItem = this.callBase(item);
    const {
      legendData
    } = legendItem;
    legendData.argument = item.argument;
    legendData.argumentIndex = item.argumentIndex;
    legendData.points = [item];
    return legendItem;
  },
  _getLegendTargets() {
    const itemsByArgument = {};
    (this.series || []).forEach(series => {
      series.getPoints().forEach(point => {
        const argument = point.argument.valueOf();
        const index = series.getPointsByArg(argument).indexOf(point);
        const key = argument.valueOf().toString() + index;
        itemsByArgument[key] = itemsByArgument[key] || [];
        const argumentCount = itemsByArgument[key].push(point);
        point.index = itemsByArgument[key][argumentCount - 2] ? itemsByArgument[key][argumentCount - 2].index : Object.keys(itemsByArgument).length - 1;
        point.argumentIndex = index;
      });
    });
    const items = [];
    (0, _iterator.each)(itemsByArgument, (_, points) => {
      points.forEach((point, index) => {
        if (index === 0) {
          items.push(this._getLegendOptions(point));
          return;
        }
        const item = items[items.length - 1];
        item.legendData.points.push(point);
        if (!item.visible) {
          item.visible = point.isVisible();
        }
      });
    });
    return items;
  },
  _getLayoutTargets() {
    return [{
      canvas: this._canvas
    }];
  },
  _getLayoutSeries(series, drawOptions) {
    let layout;
    const canvas = this._canvas;
    let drawnLabels = false;
    layout = this.layoutManager.applyPieChartSeriesLayout(canvas, series, true);
    series.forEach(singleSeries => {
      singleSeries.correctPosition(layout, canvas);
      drawnLabels = singleSeries.drawLabelsWOPoints() || drawnLabels;
    });
    if (drawnLabels) {
      layout = this.layoutManager.applyPieChartSeriesLayout(canvas, series, drawOptions.hideLayoutLabels);
    }
    series.forEach(singleSeries => {
      singleSeries.hideLabels();
    });
    this._sizeGroupLayout = {
      x: layout.centerX,
      y: layout.centerY,
      radius: layout.radiusOuter,
      drawOptions
    };
    return layout;
  },
  _getLayoutSeriesForEqualPies(series, sizeGroupLayout) {
    const canvas = this._canvas;
    const layout = this.layoutManager.applyEqualPieChartLayout(series, sizeGroupLayout);
    series.forEach(s => {
      s.correctPosition(layout, canvas);
      s.drawLabelsWOPoints();
    });
    this.layoutManager.correctPieLabelRadius(series, layout, canvas);
    return layout;
  },
  _updateSeriesDimensions(drawOptions) {
    const visibleSeries = this._getVisibleSeries();
    const lengthVisibleSeries = visibleSeries.length;
    let innerRad;
    let delta;
    let layout;
    const {
      sizeGroupLayout
    } = drawOptions;
    if (lengthVisibleSeries) {
      layout = sizeGroupLayout ? this._getLayoutSeriesForEqualPies(visibleSeries, sizeGroupLayout) : this._getLayoutSeries(visibleSeries, drawOptions);
      delta = (layout.radiusOuter - layout.radiusInner - seriesSpacing * (lengthVisibleSeries - 1)) / lengthVisibleSeries;
      innerRad = layout.radiusInner;
      this._setGeometry(layout);
      visibleSeries.forEach(singleSeries => {
        singleSeries.correctRadius({
          radiusInner: innerRad,
          radiusOuter: innerRad + delta
        });
        innerRad += delta + seriesSpacing;
      });
    }
  },
  _renderSeries(drawOptions, isRotated, isLegendInside) {
    this._calculateSeriesLayout(drawOptions, isRotated);
    if (!drawOptions.sizeGroupLayout && this.getSizeGroup()) {
      pieSizeEqualizer.queue(this);
      this._clearCanvas();
      return;
    }
    this._renderSeriesElements(drawOptions, isLegendInside);
  },
  _getCenter() {
    return this._center;
  },
  getInnerRadius() {
    return this._innerRadius;
  },
  _getLegendCallBack() {
    const legend = this._legend;
    const items = this._getLegendTargets().map(i => i.legendData);
    return target => {
      items.forEach(data => {
        const points = [];
        const callback = legend.getActionCallback({
          index: data.id
        });
        this.series.forEach(series => {
          const seriesPoints = series.getPointsByKeys(data.argument, data.argumentIndex);
          points.push.apply(points, seriesPoints);
        });
        if (target && target.argument === data.argument && target.argumentIndex === data.argumentIndex) {
          points.push(target);
        }
        callback(getLegendItemAction(points));
      });
    };
  },
  _locateLabels(resolveLabelOverlapping) {
    let iterationCount = 0;
    let labelsWereOverlapped;
    let wordWrapApplied;
    do {
      wordWrapApplied = this._adjustSeriesLabels(resolveLabelOverlapping === 'shift');
      labelsWereOverlapped = this._resolveLabelOverlapping(resolveLabelOverlapping);
    } while ((labelsWereOverlapped || wordWrapApplied) && ++iterationCount < MAX_RESOLVE_ITERATION_COUNT);
  },
  _adjustSeriesLabels(moveLabelsFromCenter) {
    return this.series.reduce((r, s) => s.adjustLabels(moveLabelsFromCenter) || r, false);
  },
  _applyExtraSettings: _common.noop,
  _resolveLabelOverlappingShift() {
    const inverseDirection = this.option('segmentsDirection') === 'anticlockwise';
    const seriesByPosition = this.series.reduce((r, s) => {
      (r[s.getOptions().label.position] || r.outside).push(s);
      return r;
    }, {
      inside: [],
      columns: [],
      outside: []
    });
    let labelsOverlapped = false;
    const shiftFunction = (box, length) => (0, _utils.getVerticallyShiftedAngularCoords)(box, -length, this._center);
    if (seriesByPosition.inside.length > 0) {
      const pointsToResolve = seriesByPosition.inside.reduce((r, singleSeries) => {
        const visiblePoints = singleSeries.getVisiblePoints();
        return visiblePoints.reduce((r, point) => {
          r.left.push(point);
          return r;
        }, r);
      }, {
        left: [],
        right: []
      });
      labelsOverlapped = resolveOverlappedLabels(pointsToResolve, shiftInColumnFunction, inverseDirection, this._canvas) || labelsOverlapped;
    }
    labelsOverlapped = seriesByPosition.columns.reduce((r, singleSeries) => resolveOverlappedLabels(dividePoints(singleSeries), shiftInColumnFunction, inverseDirection, this._canvas) || r, labelsOverlapped);
    if (seriesByPosition.outside.length > 0) {
      labelsOverlapped = resolveOverlappedLabels(seriesByPosition.outside.reduce((r, singleSeries) => dividePoints(singleSeries, r), null), shiftFunction, inverseDirection, this._canvas) || labelsOverlapped;
    }
    return labelsOverlapped;
  },
  _setGeometry(_ref) {
    let {
      centerX: x,
      centerY: y,
      radiusInner
    } = _ref;
    this._center = {
      x,
      y
    };
    this._innerRadius = radiusInner;
  },
  _disposeSeries() {
    this.callBase.apply(this, arguments);
    this._abstractSeries = null;
  },
  _legendDataField: 'point',
  _legendItemTextField: 'argument',
  _applyPointMarkersAutoHiding: _common.noop,
  _renderTrackers: _common.noop,
  _trackerType: 'PieTracker',
  _createScrollBar: _common.noop,
  _updateAxesLayout: _common.noop,
  _applyClipRects: _common.noop,
  _appendAdditionalSeriesGroups: _common.noop,
  _prepareToRender: _common.noop,
  _isLegendInside: _common.noop,
  _renderAxes: _common.noop,
  _shrinkAxes: _common.noop,
  _isRotated: _common.noop,
  _seriesPopulatedHandlerCore: _common.noop,
  _reinitAxes: _common.noop,
  _correctAxes: _common.noop,
  _getExtraOptions() {
    return {
      startAngle: this.option('startAngle'),
      innerRadius: this.option('innerRadius'),
      segmentsDirection: this.option('segmentsDirection'),
      type: this.option('type')
    };
  },
  getSizeGroup() {
    return this._themeManager.getOptions('sizeGroup');
  },
  getSizeGroupLayout() {
    return this._sizeGroupLayout || {};
  }
});
(0, _iterator.each)(OPTIONS_FOR_REFRESH_SERIES, (_, name) => {
  dxPieChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_DATA_INIT';
});
dxPieChart.addPlugin(_center_template.plugins.pieChart);
dxPieChart.addPlugin(_annotations.plugins.core);
dxPieChart.addPlugin(_annotations.plugins.pieChart);
(0, _component_registrator.default)('dxPieChart', dxPieChart);
var _default = exports["default"] = dxPieChart;

/***/ }),

/***/ 86139:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _annotations = __webpack_require__(77129);
var _utils = __webpack_require__(19157);
var _m_advanced_chart = __webpack_require__(41690);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_PANE_NAME = 'default';
const DOUBLE_PI_ANGLE = 360;
const dxPolarChart = _m_advanced_chart.AdvancedChart.inherit({
  _themeSection: 'polar',
  _createPanes() {
    this.callBase();
    return [{
      name: DEFAULT_PANE_NAME
    }];
  },
  _checkPaneName() {
    return true;
  },
  _getAxisRenderingOptions(typeSelector) {
    const isArgumentAxis = typeSelector === 'argumentAxis';
    let type = isArgumentAxis ? 'circular' : 'linear';
    const useSpiderWeb = this.option('useSpiderWeb');
    if (useSpiderWeb) {
      type += 'Spider';
    }
    return {
      axisType: 'polarAxes',
      drawingType: type
    };
  },
  _executeAppendBeforeSeries(append) {
    append();
  },
  _prepareAxisOptions(typeSelector, axisOptions) {
    const isArgumentAxis = typeSelector === 'argumentAxis';
    const themeManager = this._themeManager;
    const axisUserOptions = this.option('argumentAxis');
    const argumentAxisOptions = themeManager.getOptions('argumentAxis', axisUserOptions) || {};
    const startAngle = isFinite(argumentAxisOptions.startAngle) ? (0, _utils.normalizeAngle)(argumentAxisOptions.startAngle) : 0;
    return {
      type: this.option('useSpiderWeb') && isArgumentAxis ? 'discrete' : axisOptions.type,
      isHorizontal: true,
      showCustomBoundaryTicks: isArgumentAxis,
      startAngle,
      endAngle: startAngle + 360
    };
  },
  _optionChangesMap: {
    useSpiderWeb: 'USE_SPIDER_WEB'
  },
  _change_USE_SPIDER_WEB() {
    this._disposeAxes();
    this._requestChange(['AXES_AND_PANES']);
  },
  _getExtraOptions() {
    return {
      spiderWidget: this.option('useSpiderWeb')
    };
  },
  _prepareToRender() {
    this._appendAxesGroups();
    return {};
  },
  _calcCanvas() {
    const canvas = (0, _extend.extend)({}, this._canvas);
    const argumentAxis = this.getArgumentAxis();
    const margins = argumentAxis.getMargins();
    Object.keys(margins).forEach(margin => {
      canvas[margin] = canvas[`original${margin[0].toUpperCase()}${margin.slice(1)}`] + margins[margin];
    });
    return canvas;
  },
  _renderAxes() {
    const valueAxis = this._getValueAxis();
    const argumentAxis = this.getArgumentAxis();
    argumentAxis.draw(this._canvas);
    valueAxis.setSpiderTicks(argumentAxis.getSpiderTicks());
    const canvas = this._calcCanvas();
    argumentAxis.updateSize(canvas);
    valueAxis.draw(canvas);
    return canvas;
  },
  _getValueAxis() {
    return this._valueAxes[0];
  },
  _shrinkAxes(sizeStorage) {
    const valueAxis = this._getValueAxis();
    const argumentAxis = this.getArgumentAxis();
    if (sizeStorage && (sizeStorage.width || sizeStorage.height)) {
      argumentAxis.hideOuterElements();
      const canvas = this._calcCanvas();
      argumentAxis.updateSize(canvas);
      valueAxis.updateSize(canvas);
    }
  },
  checkForMoreSpaceForPanesCanvas() {
    return this.layoutManager.needMoreSpaceForPanesCanvas([{
      canvas: this.getArgumentAxis().getCanvas()
    }], this._isRotated());
  },
  _getLayoutTargets() {
    return [{
      canvas: this._canvas
    }];
  },
  _getSeriesForPane() {
    return this.series;
  },
  _applyClipRects() {
    const canvasClipRectID = this._getCanvasClipRectID();
    this._createClipPathForPane();
    this.getArgumentAxis().applyClipRects(this._getElementsClipRectID(), canvasClipRectID);
    this._getValueAxis().applyClipRects(this._getElementsClipRectID(), canvasClipRectID);
  },
  _createClipPathForPane() {
    const valueAxis = this._getValueAxis();
    let center = valueAxis.getCenter();
    const radius = valueAxis.getRadius();
    const panesClipRects = this._panesClipRects;
    center = {
      x: Math.round(center.x),
      y: Math.round(center.y)
    };
    this._createClipCircle(panesClipRects.fixed, center.x, center.y, radius);
    this._createClipCircle(panesClipRects.base, center.x, center.y, radius);
    if (this.series.some(s => s.areErrorBarsVisible())) {
      this._createClipCircle(panesClipRects.wide, center.x, center.y, radius);
    } else {
      panesClipRects.wide[0] = null;
    }
  },
  _createClipCircle(clipArray, left, top, radius) {
    let clipCircle = clipArray[0];
    if (!clipCircle) {
      clipCircle = this._renderer.clipCircle(left, top, radius);
      clipArray[0] = clipCircle;
    } else {
      clipCircle.attr({
        cx: left,
        cy: top,
        r: radius
      });
    }
  },
  _applyExtraSettings(series) {
    const wideClipRect = this._panesClipRects.wide[0];
    series.setClippingParams(this._panesClipRects.base[0].id, wideClipRect && wideClipRect.id, false, false);
  },
  getActualAngle(angle) {
    return this.getArgumentAxis().getOptions().inverted ? DOUBLE_PI_ANGLE - angle : angle;
  },
  getXYFromPolar(angle, radius, argument, value) {
    const layoutInfo = {
      angle: undefined,
      radius: undefined,
      x: undefined,
      y: undefined
    };
    if (!(0, _type.isDefined)(angle) && !(0, _type.isDefined)(radius) && !(0, _type.isDefined)(argument) && !(0, _type.isDefined)(value)) {
      return layoutInfo;
    }
    const argAxis = this.getArgumentAxis();
    const startAngle = argAxis.getAngles()[0];
    let argAngle;
    let translatedRadius;
    if ((0, _type.isDefined)(argument)) {
      argAngle = argAxis.getTranslator().translate(argument);
    } else if (isFinite(angle)) {
      argAngle = this.getActualAngle(angle);
    } else if (!(0, _type.isDefined)(angle)) {
      argAngle = 0;
    }
    if ((0, _type.isDefined)(value)) {
      translatedRadius = this.getValueAxis().getTranslator().translate(value);
    } else if (isFinite(radius)) {
      translatedRadius = radius;
    } else if (!(0, _type.isDefined)(radius)) {
      translatedRadius = argAxis.getRadius();
    }
    if ((0, _type.isDefined)(argAngle) && (0, _type.isDefined)(translatedRadius)) {
      const coords = (0, _utils.convertPolarToXY)(argAxis.getCenter(), startAngle, argAngle, translatedRadius);
      (0, _extend.extend)(layoutInfo, coords, {
        angle: argAxis.getTranslatedAngle(argAngle),
        radius: translatedRadius
      });
    }
    return layoutInfo;
  },
  _applyPointMarkersAutoHiding: _common.noop,
  _createScrollBar: _common.noop,
  _isRotated: _common.noop,
  _getCrosshairOptions: _common.noop,
  _isLegendInside: _common.noop
});
dxPolarChart.addPlugin(_annotations.plugins.core);
dxPolarChart.addPlugin(_annotations.plugins.polarChart);
(0, _component_registrator.default)('dxPolarChart', dxPolarChart);
var _default = exports["default"] = dxPolarChart;

/***/ }),

/***/ 23908:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.convertTransitionTimingFuncToEasing = void 0;
exports.getEasing = getEasing;
exports.setEasing = setEasing;
var _type = __webpack_require__(35922);
const CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
const TransitionTimingFuncMap = {
  'linear': 'cubic-bezier(0, 0, 1, 1)',
  'swing': 'cubic-bezier(0.445, 0.05, 0.55, 0.95)',
  'ease': 'cubic-bezier(0.25, 0.1, 0.25, 1)',
  'ease-in': 'cubic-bezier(0.42, 0, 1, 1)',
  'ease-out': 'cubic-bezier(0, 0, 0.58, 1)',
  'ease-in-out': 'cubic-bezier(0.42, 0, 0.58, 1)'
};
const polynomBezier = function (x1, y1, x2, y2) {
  const Cx = 3 * x1;
  const Bx = 3 * (x2 - x1) - Cx;
  const Ax = 1 - Cx - Bx;
  const Cy = 3 * y1;
  const By = 3 * (y2 - y1) - Cy;
  const Ay = 1 - Cy - By;
  const bezierX = function (t) {
    return t * (Cx + t * (Bx + t * Ax));
  };
  const bezierY = function (t) {
    return t * (Cy + t * (By + t * Ay));
  };
  const derivativeX = function (t) {
    return Cx + t * (2 * Bx + t * 3 * Ax);
  };
  const findXFor = function (t) {
    let x = t;
    let i = 0;
    let z;
    while (i < 14) {
      z = bezierX(x) - t;
      if (Math.abs(z) < 1e-3) {
        break;
      }
      x = x - z / derivativeX(x);
      i++;
    }
    return x;
  };
  return function (t) {
    return bezierY(findXFor(t));
  };
};
let easing = {};
const convertTransitionTimingFuncToEasing = function (cssTransitionEasing) {
  cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
  let coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
  let forceName;
  if (!coeffs) {
    forceName = 'linear';
    coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
  }
  coeffs = coeffs.slice(1, 5);
  for (let i = 0; i < coeffs.length; i++) {
    coeffs[i] = parseFloat(coeffs[i]);
  }
  const easingName = forceName || 'cubicbezier_' + coeffs.join('_').replace(/\./g, 'p');
  if (!(0, _type.isFunction)(easing[easingName])) {
    easing[easingName] = function (x, t, b, c, d) {
      return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
    };
  }
  return easingName;
};
exports.convertTransitionTimingFuncToEasing = convertTransitionTimingFuncToEasing;
function setEasing(value) {
  easing = value;
}
function getEasing(name) {
  return easing[name];
}

/***/ }),

/***/ 90057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.cancelAnimationFrame = cancelAnimationFrame;
exports.requestAnimationFrame = requestAnimationFrame;
var _window = __webpack_require__(58201);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.hasWindow)() ? (0, _window.getWindow)() : {};
const FRAME_ANIMATION_STEP_TIME = 1000 / 60;
let request = function (callback) {
  return setTimeout(callback, FRAME_ANIMATION_STEP_TIME);
};
let cancel = function (requestID) {
  clearTimeout(requestID);
};
const setAnimationFrameMethods = (0, _call_once.default)(function () {
  const nativeRequest = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
  const nativeCancel = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
  if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel;
  }
});
function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window, arguments);
}
function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window, arguments);
}

/***/ }),

/***/ 87209:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _element = __webpack_require__(6415);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _translator = __webpack_require__(31648);
var _easing = __webpack_require__(23908);
var _frame = __webpack_require__(90057);
var _support = __webpack_require__(60137);
var _position = _interopRequireDefault(__webpack_require__(49387));
var _remove = __webpack_require__(29007);
var _index = __webpack_require__(39611);
var _deferred = __webpack_require__(62754);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const removeEventName = (0, _index.addNamespace)(_remove.removeEvent, 'dxFX');
const RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
const ANIM_DATA_KEY = 'dxAnimData';
const ANIM_QUEUE_KEY = 'dxAnimQueue';
const TRANSFORM_PROP = 'transform';
const TransitionAnimationStrategy = {
  initAnimation: function ($element, config) {
    $element.css({
      'transitionProperty': 'none'
    });
    if (typeof config.from === 'string') {
      $element.addClass(config.from);
    } else {
      setProps($element, config.from);
    }
    const that = this;
    const deferred = new _deferred.Deferred();
    const cleanupWhen = config.cleanupWhen;
    config.transitionAnimation = {
      deferred: deferred,
      finish: function () {
        that._finishTransition($element);
        if (cleanupWhen) {
          (0, _deferred.when)(deferred, cleanupWhen).always(function () {
            that._cleanup($element, config);
          });
        } else {
          that._cleanup($element, config);
        }
        deferred.resolveWith($element, [config, $element]);
      }
    };
    this._completeAnimationCallback($element, config).done(function () {
      config.transitionAnimation.finish();
    }).fail(function () {
      deferred.rejectWith($element, [config, $element]);
    });
    if (!config.duration) {
      config.transitionAnimation.finish();
    }

    // NOTE: Hack for setting 'from' css by browser before run animation
    //       Do not move this hack to initAnimation since some css props can be changed in the 'start' callback (T231434)
    //       Unfortunately this can't be unit tested
    // TODO: find better way if possible
    $element.css('transform');
  },
  animate: function ($element, config) {
    this._startAnimation($element, config);
    return config.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function ($element, config) {
    const that = this;
    const startTime = Date.now() + config.delay;
    const deferred = new _deferred.Deferred();
    const transitionEndFired = new _deferred.Deferred();
    const simulatedTransitionEndFired = new _deferred.Deferred();
    let simulatedEndEventTimer;
    const transitionEndEventFullName = (0, _support.transitionEndEventName)() + '.dxFX';
    config.transitionAnimation.cleanup = function () {
      clearTimeout(simulatedEndEventTimer);
      clearTimeout(waitForJSCompleteTimer);
      _events_engine.default.off($element, transitionEndEventFullName);
      _events_engine.default.off($element, removeEventName);
    };
    _events_engine.default.one($element, transitionEndEventFullName, function () {
      // NOTE: prevent native transitionEnd event from previous animation in queue (Chrome)
      if (Date.now() - startTime >= config.duration) {
        transitionEndFired.reject();
      }
    });
    _events_engine.default.off($element, removeEventName);
    _events_engine.default.on($element, removeEventName, function () {
      that.stop($element, config);
      deferred.reject();
    });
    const waitForJSCompleteTimer = setTimeout(function () {
      // Fix for a visual bug (T244514): do not setup the timer until all js code has finished working
      simulatedEndEventTimer = setTimeout(function () {
        simulatedTransitionEndFired.reject();
      }, config.duration + config.delay + fx._simulatedTransitionEndDelay /* T255863 */);
      (0, _deferred.when)(transitionEndFired, simulatedTransitionEndFired).fail(function () {
        deferred.resolve();
      }.bind(this));
    });
    return deferred.promise();
  },
  _startAnimation: function ($element, config) {
    $element.css({
      'transitionProperty': 'all',
      'transitionDelay': config.delay + 'ms',
      'transitionDuration': config.duration + 'ms',
      'transitionTimingFunction': config.easing
    });
    if (typeof config.to === 'string') {
      $element[0].className += ' ' + config.to;
      // Do not uncomment: performance critical
      // $element.addClass(config.to);
    } else if (config.to) {
      setProps($element, config.to);
    }
  },
  _finishTransition: function ($element) {
    $element.css('transition', 'none');
  },
  _cleanup: function ($element, config) {
    config.transitionAnimation.cleanup();
    if (typeof config.from === 'string') {
      $element.removeClass(config.from);
      $element.removeClass(config.to);
    }
  },
  stop: function ($element, config, jumpToEnd) {
    if (!config) {
      return;
    }
    if (jumpToEnd) {
      config.transitionAnimation.finish();
    } else {
      if ((0, _type.isPlainObject)(config.to)) {
        (0, _iterator.each)(config.to, function (key) {
          $element.css(key, $element.css(key));
        });
      }
      this._finishTransition($element);
      this._cleanup($element, config);
    }
  }
};
const FrameAnimationStrategy = {
  initAnimation: function ($element, config) {
    setProps($element, config.from);
  },
  animate: function ($element, config) {
    const deferred = new _deferred.Deferred();
    const that = this;
    if (!config) {
      return deferred.reject().promise();
    }
    (0, _iterator.each)(config.to, function (prop) {
      if (config.from[prop] === undefined) {
        config.from[prop] = that._normalizeValue($element.css(prop));
      }
    });
    if (config.to[TRANSFORM_PROP]) {
      config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
      config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP]);
    }
    config.frameAnimation = {
      to: config.to,
      from: config.from,
      currentValue: config.from,
      easing: (0, _easing.convertTransitionTimingFuncToEasing)(config.easing),
      duration: config.duration,
      startTime: new Date().valueOf(),
      finish: function () {
        this.currentValue = this.to;
        this.draw();
        (0, _frame.cancelAnimationFrame)(config.frameAnimation.animationFrameId);
        deferred.resolve();
      },
      draw: function () {
        if (config.draw) {
          config.draw(this.currentValue);
          return;
        }
        const currentValue = (0, _extend.extend)({}, this.currentValue);
        if (currentValue[TRANSFORM_PROP]) {
          currentValue[TRANSFORM_PROP] = (0, _iterator.map)(currentValue[TRANSFORM_PROP], function (value, prop) {
            if (prop === 'translate') {
              return (0, _translator.getTranslateCss)(value);
            } else if (prop === 'scale') {
              return 'scale(' + value + ')';
            } else if (prop.substr(0, prop.length - 1) === 'rotate') {
              return prop + '(' + value + 'deg)';
            }
          }).join(' ');
        }
        $element.css(currentValue);
      }
    };
    if (config.delay) {
      config.frameAnimation.startTime += config.delay;
      config.frameAnimation.delayTimeout = setTimeout(function () {
        that._startAnimation($element, config);
      }, config.delay);
    } else {
      that._startAnimation($element, config);
    }
    return deferred.promise();
  },
  _startAnimation: function ($element, config) {
    _events_engine.default.off($element, removeEventName);
    _events_engine.default.on($element, removeEventName, function () {
      if (config.frameAnimation) {
        (0, _frame.cancelAnimationFrame)(config.frameAnimation.animationFrameId);
      }
    });
    this._animationStep($element, config);
  },
  _parseTransform: function (transformString) {
    const result = {};
    (0, _iterator.each)(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function (i, part) {
      const translateData = (0, _translator.parseTranslate)(part);
      const scaleData = part.match(/scale\((.+?)\)/);
      const rotateData = part.match(/(rotate.)\((.+)deg\)/);
      if (translateData) {
        result.translate = translateData;
      }
      if (scaleData && scaleData[1]) {
        result.scale = parseFloat(scaleData[1]);
      }
      if (rotateData && rotateData[1]) {
        result[rotateData[1]] = parseFloat(rotateData[2]);
      }
    });
    return result;
  },
  stop: function ($element, config, jumpToEnd) {
    const frameAnimation = config && config.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    (0, _frame.cancelAnimationFrame)(frameAnimation.animationFrameId);
    clearTimeout(frameAnimation.delayTimeout);
    if (jumpToEnd) {
      frameAnimation.finish();
    }
    delete config.frameAnimation;
  },
  _animationStep: function ($element, config) {
    const frameAnimation = config && config.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    const now = new Date().valueOf();
    if (now >= frameAnimation.startTime + frameAnimation.duration) {
      frameAnimation.finish();
      return;
    }
    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
    frameAnimation.draw();
    const that = this;
    frameAnimation.animationFrameId = (0, _frame.requestAnimationFrame)(function () {
      that._animationStep($element, config);
    });
  },
  _calcStepValue: function (frameAnimation, currentDuration) {
    const calcValueRecursively = function (from, to) {
      const result = Array.isArray(to) ? [] : {};
      const calcEasedValue = function (propName) {
        const x = currentDuration / frameAnimation.duration;
        const t = currentDuration;
        const b = 1 * from[propName];
        const c = to[propName] - from[propName];
        const d = frameAnimation.duration;
        return (0, _easing.getEasing)(frameAnimation.easing)(x, t, b, c, d);
      };
      (0, _iterator.each)(to, function (propName, endPropValue) {
        if (typeof endPropValue === 'string' && parseFloat(endPropValue) === false) {
          return true;
        }
        result[propName] = typeof endPropValue === 'object' ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName);
      });
      return result;
    };
    return calcValueRecursively(frameAnimation.from, frameAnimation.to);
  },
  _normalizeValue: function (value) {
    const numericValue = parseFloat(value);
    if (numericValue === false) {
      return value;
    }
    return numericValue;
  }
};
const FallbackToNoAnimationStrategy = {
  initAnimation: function () {},
  animate: function () {
    return new _deferred.Deferred().resolve().promise();
  },
  stop: _common.noop,
  isSynchronous: true
};
const getAnimationStrategy = function (config) {
  config = config || {};
  const animationStrategies = {
    'transition': (0, _support.transition)() ? TransitionAnimationStrategy : FrameAnimationStrategy,
    'frame': FrameAnimationStrategy,
    'noAnimation': FallbackToNoAnimationStrategy
  };
  let strategy = config.strategy || 'transition';
  if (config.type === 'css' && !(0, _support.transition)()) {
    strategy = 'noAnimation';
  }
  return animationStrategies[strategy];
};
const baseConfigValidator = function (config, animationType, validate, typeMessage) {
  (0, _iterator.each)(['from', 'to'], function () {
    if (!validate(config[this])) {
      throw _errors.default.Error('E0010', animationType, this, typeMessage);
    }
  });
};
const isObjectConfigValidator = function (config, animationType) {
  return baseConfigValidator(config, animationType, function (target) {
    return (0, _type.isPlainObject)(target);
  }, 'a plain object');
};
const isStringConfigValidator = function (config, animationType) {
  return baseConfigValidator(config, animationType, function (target) {
    return typeof target === 'string';
  }, 'a string');
};
const CustomAnimationConfigurator = {
  setup: function () {}
};
const CssAnimationConfigurator = {
  validateConfig: function (config) {
    isStringConfigValidator(config, 'css');
  },
  setup: function () {}
};
const positionAliases = {
  'top': {
    my: 'bottom center',
    at: 'top center'
  },
  'bottom': {
    my: 'top center',
    at: 'bottom center'
  },
  'right': {
    my: 'left center',
    at: 'right center'
  },
  'left': {
    my: 'right center',
    at: 'left center'
  }
};
const SlideAnimationConfigurator = {
  validateConfig: function (config) {
    isObjectConfigValidator(config, 'slide');
  },
  setup: function ($element, config) {
    const location = (0, _translator.locate)($element);
    if (config.type !== 'slide') {
      const positioningConfig = config.type === 'slideIn' ? config.from : config.to;
      positioningConfig.position = (0, _extend.extend)({
        of: window
      }, positionAliases[config.direction]);
      setupPosition($element, positioningConfig);
    }
    this._setUpConfig(location, config.from);
    this._setUpConfig(location, config.to);
    (0, _translator.clearCache)($element);
  },
  _setUpConfig: function (location, config) {
    config.left = 'left' in config ? config.left : '+=0';
    config.top = 'top' in config ? config.top : '+=0';
    this._initNewPosition(location, config);
  },
  _initNewPosition: function (location, config) {
    const position = {
      left: config.left,
      top: config.top
    };
    delete config.left;
    delete config.top;
    let relativeValue = this._getRelativeValue(position.left);
    if (relativeValue !== undefined) {
      position.left = relativeValue + location.left;
    } else {
      config.left = 0;
    }
    relativeValue = this._getRelativeValue(position.top);
    if (relativeValue !== undefined) {
      position.top = relativeValue + location.top;
    } else {
      config.top = 0;
    }
    config[TRANSFORM_PROP] = (0, _translator.getTranslateCss)({
      x: position.left,
      y: position.top
    });
  },
  _getRelativeValue: function (value) {
    let relativeValue;
    if (typeof value === 'string' && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {
      return parseInt(relativeValue[1] + '1') * relativeValue[2];
    }
  }
};
const FadeAnimationConfigurator = {
  setup: function ($element, config) {
    const from = config.from;
    const to = config.to;
    const defaultFromOpacity = config.type === 'fadeOut' ? 1 : 0;
    const defaultToOpacity = config.type === 'fadeOut' ? 0 : 1;
    let fromOpacity = (0, _type.isPlainObject)(from) ? String(from.opacity ?? defaultFromOpacity) : String(from);
    let toOpacity = (0, _type.isPlainObject)(to) ? String(to.opacity ?? defaultToOpacity) : String(to);
    if (!config.skipElementInitialStyles) {
      fromOpacity = $element.css('opacity');
    }
    switch (config.type) {
      case 'fadeIn':
        toOpacity = 1;
        break;
      case 'fadeOut':
        toOpacity = 0;
        break;
    }
    config.from = {
      visibility: 'visible',
      opacity: fromOpacity
    };
    config.to = {
      opacity: toOpacity
    };
  }
};
const PopAnimationConfigurator = {
  validateConfig: function (config) {
    isObjectConfigValidator(config, 'pop');
  },
  setup: function ($element, config) {
    const from = config.from;
    const to = config.to;
    const fromOpacity = 'opacity' in from ? from.opacity : $element.css('opacity');
    const toOpacity = 'opacity' in to ? to.opacity : 1;
    const fromScale = 'scale' in from ? from.scale : 0;
    const toScale = 'scale' in to ? to.scale : 1;
    config.from = {
      opacity: fromOpacity
    };
    const translate = (0, _translator.getTranslate)($element);
    config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
    config.to = {
      opacity: toOpacity
    };
    config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale);
  },
  _getCssTransform: function (translate, scale) {
    return (0, _translator.getTranslateCss)(translate) + 'scale(' + scale + ')';
  }
};
const animationConfigurators = {
  'custom': CustomAnimationConfigurator,
  'slide': SlideAnimationConfigurator,
  'slideIn': SlideAnimationConfigurator,
  'slideOut': SlideAnimationConfigurator,
  'fade': FadeAnimationConfigurator,
  'fadeIn': FadeAnimationConfigurator,
  'fadeOut': FadeAnimationConfigurator,
  'pop': PopAnimationConfigurator,
  'css': CssAnimationConfigurator
};
const getAnimationConfigurator = function (config) {
  const result = animationConfigurators[config.type];
  if (!result) {
    throw _errors.default.Error('E0011', config.type);
  }
  return result;
};
const defaultJSConfig = {
  type: 'custom',
  from: {},
  to: {},
  duration: 400,
  start: _common.noop,
  complete: _common.noop,
  easing: 'ease',
  delay: 0
};
const defaultCssConfig = {
  duration: 400,
  easing: 'ease',
  delay: 0
};
function setupAnimationOnElement() {
  const animation = this;
  const $element = animation.element;
  const config = animation.config;
  setupPosition($element, config.from);
  setupPosition($element, config.to);
  animation.configurator.setup($element, config);
  $element.data(ANIM_DATA_KEY, animation);
  if (fx.off) {
    config.duration = 0;
    config.delay = 0;
  }
  animation.strategy.initAnimation($element, config);
  if (config.start) {
    const element = (0, _element.getPublicElement)($element);
    config.start.apply(this, [element, config]);
  }
}
const onElementAnimationComplete = function (animation) {
  const $element = animation.element;
  const config = animation.config;
  $element.removeData(ANIM_DATA_KEY);
  if (config.complete) {
    const element = (0, _element.getPublicElement)($element);
    config.complete.apply(this, [element, config]);
  }
  animation.deferred.resolveWith(this, [$element, config]);
};
const startAnimationOnElement = function () {
  const animation = this;
  const $element = animation.element;
  const config = animation.config;
  animation.isStarted = true;
  return animation.strategy.animate($element, config).done(function () {
    onElementAnimationComplete(animation);
  }).fail(function () {
    animation.deferred.rejectWith(this, [$element, config]);
  });
};
const stopAnimationOnElement = function (jumpToEnd) {
  const animation = this;
  const $element = animation.element;
  const config = animation.config;
  clearTimeout(animation.startTimeout);
  if (!animation.isStarted) {
    animation.start();
  }
  animation.strategy.stop($element, config, jumpToEnd);
};
const scopedRemoveEvent = (0, _index.addNamespace)(_remove.removeEvent, 'dxFXStartAnimation');
const subscribeToRemoveEvent = function (animation) {
  _events_engine.default.off(animation.element, scopedRemoveEvent);
  _events_engine.default.on(animation.element, scopedRemoveEvent, function () {
    fx.stop(animation.element);
  });
  animation.deferred.always(function () {
    _events_engine.default.off(animation.element, scopedRemoveEvent);
  });
};
const createAnimation = function (element, initialConfig) {
  const defaultConfig = initialConfig.type === 'css' ? defaultCssConfig : defaultJSConfig;
  const config = (0, _extend.extend)(true, {}, defaultConfig, initialConfig);
  const configurator = getAnimationConfigurator(config);
  const strategy = getAnimationStrategy(config);
  const animation = {
    element: (0, _renderer.default)(element),
    config: config,
    configurator: configurator,
    strategy: strategy,
    isSynchronous: strategy.isSynchronous,
    setup: setupAnimationOnElement,
    start: startAnimationOnElement,
    stop: stopAnimationOnElement,
    deferred: new _deferred.Deferred()
  };
  if ((0, _type.isFunction)(configurator.validateConfig)) {
    configurator.validateConfig(config);
  }
  subscribeToRemoveEvent(animation);
  return animation;
};
const animate = function (element, config) {
  const $element = (0, _renderer.default)(element);
  if (!$element.length) {
    return new _deferred.Deferred().resolve().promise();
  }
  const animation = createAnimation($element, config);
  pushInAnimationQueue($element, animation);
  return animation.deferred.promise();
};
function pushInAnimationQueue($element, animation) {
  const queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation);
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}
function getAnimQueueData($element) {
  return $element.data(ANIM_QUEUE_KEY) || [];
}
function writeAnimQueueData($element, queueData) {
  $element.data(ANIM_QUEUE_KEY, queueData);
}
const destroyAnimQueueData = function ($element) {
  $element.removeData(ANIM_QUEUE_KEY);
};
function isAnimating($element) {
  return !!$element.data(ANIM_DATA_KEY);
}
function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);
  if (!queueData.length) {
    return;
  }
  const animation = queueData.shift();
  if (queueData.length === 0) {
    destroyAnimQueueData($element);
  }
  executeAnimation(animation).done(function () {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}
function executeAnimation(animation) {
  animation.setup();
  if (fx.off || animation.isSynchronous) {
    animation.start();
  } else {
    animation.startTimeout = setTimeout(function () {
      animation.start();
    });
  }
  return animation.deferred.promise();
}
function setupPosition($element, config) {
  if (!config || !config.position) {
    return;
  }
  const win = (0, _renderer.default)(window);
  let left = 0;
  let top = 0;
  const position = _position.default.calculate($element, config.position);
  const offset = $element.offset();
  const currentPosition = $element.position();
  if (currentPosition.top > offset.top) {
    top = win.scrollTop();
  }
  if (currentPosition.left > offset.left) {
    left = win.scrollLeft();
  }
  (0, _extend.extend)(config, {
    left: position.h.location - offset.left + currentPosition.left - left,
    top: position.v.location - offset.top + currentPosition.top - top
  });
  delete config.position;
}
function setProps($element, props) {
  (0, _iterator.each)(props, function (key, value) {
    try {
      $element.css(key, (0, _type.isFunction)(value) ? value() : value);
    } catch (e) {}
  });
}
const stop = function (element, jumpToEnd) {
  const $element = (0, _renderer.default)(element);
  const queueData = getAnimQueueData($element);

  // TODO: think about complete all animation in queue
  (0, _iterator.each)(queueData, function (_, animation) {
    animation.config.delay = 0;
    animation.config.duration = 0;
    animation.isSynchronous = true;
  });
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
  const animation = $element.data(ANIM_DATA_KEY);
  if (animation) {
    animation.stop(jumpToEnd);
  }
  $element.removeData(ANIM_DATA_KEY);
  destroyAnimQueueData($element);
};
const fx = {
  off: false,
  animationTypes: animationConfigurators,
  animate: animate,
  createAnimation: createAnimation,
  isAnimating: isAnimating,
  stop: stop,
  _simulatedTransitionEndDelay: 100
};
var _default = exports["default"] = fx;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 49387:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _position = __webpack_require__(37518);
var _browser = _interopRequireDefault(__webpack_require__(47810));
var _translator = __webpack_require__(31648);
var _support = __webpack_require__(60137);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _style = __webpack_require__(80968);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const horzRe = /left|right/;
const vertRe = /top|bottom/;
const collisionRe = /fit|flip|none/;
const scaleRe = /scale\(.+?\)/;
const IS_SAFARI = _browser.default.safari;
const normalizeAlign = function (raw) {
  const result = {
    h: 'center',
    v: 'center'
  };
  const pair = (0, _common.splitPair)(raw);
  if (pair) {
    (0, _iterator.each)(pair, function () {
      const w = String(this).toLowerCase();
      if (horzRe.test(w)) {
        result.h = w;
      } else if (vertRe.test(w)) {
        result.v = w;
      }
    });
  }
  return result;
};
const normalizeOffset = function (raw, preventRound) {
  return (0, _common.pairToObject)(raw, preventRound);
};
const normalizeCollision = function (raw) {
  const pair = (0, _common.splitPair)(raw);
  let h = String(pair && pair[0]).toLowerCase();
  let v = String(pair && pair[1]).toLowerCase();
  if (!collisionRe.test(h)) {
    h = 'none';
  }
  if (!collisionRe.test(v)) {
    v = h;
  }
  return {
    h: h,
    v: v
  };
};
const getAlignFactor = function (align) {
  switch (align) {
    case 'center':
      return 0.5;
    case 'right':
    case 'bottom':
      return 1;
    default:
      return 0;
  }
};
const inverseAlign = function (align) {
  switch (align) {
    case 'left':
      return 'right';
    case 'right':
      return 'left';
    case 'top':
      return 'bottom';
    case 'bottom':
      return 'top';
    default:
      return align;
  }
};
const calculateOversize = function (data, bounds) {
  let oversize = 0;
  if (data.myLocation < bounds.min) {
    oversize += bounds.min - data.myLocation;
  }
  if (data.myLocation > bounds.max) {
    oversize += data.myLocation - bounds.max;
  }
  return oversize;
};
const collisionSide = function (direction, data, bounds) {
  if (data.myLocation < bounds.min) {
    return direction === 'h' ? 'left' : 'top';
  }
  if (data.myLocation > bounds.max) {
    return direction === 'h' ? 'right' : 'bottom';
  }
  return 'none';
};

// TODO: rename?
const initMyLocation = function (data) {
  data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset;
};
const collisionResolvers = {
  'fit': function (data, bounds) {
    let result = false;
    if (data.myLocation > bounds.max) {
      data.myLocation = bounds.max;
      result = true;
    }
    if (data.myLocation < bounds.min) {
      data.myLocation = bounds.min;
      result = true;
    }
    data.fit = result;
  },
  'flip': function (data, bounds) {
    data.flip = false;
    if (data.myAlign === 'center' && data.atAlign === 'center') {
      return;
    }
    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
      const inverseData = (0, _extend.extend)({}, data, {
        myAlign: inverseAlign(data.myAlign),
        atAlign: inverseAlign(data.atAlign),
        offset: -data.offset
      });
      initMyLocation(inverseData);
      inverseData.oversize = calculateOversize(inverseData, bounds);
      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
        data.myLocation = inverseData.myLocation;
        data.oversize = inverseData.oversize;
        data.flip = true;
      }
    }
  },
  'flipfit': function (data, bounds) {
    this.flip(data, bounds);
    this.fit(data, bounds);
  },
  'none': function (data) {
    data.oversize = 0;
  }
};
let scrollbarWidth;
const calculateScrollbarWidth = function () {
  const $scrollDiv = (0, _renderer.default)('<div>').css({
    width: 100,
    height: 100,
    overflow: 'scroll',
    position: 'absolute',
    top: -9999
  }).appendTo((0, _renderer.default)('body'));
  const result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
  $scrollDiv.remove();
  scrollbarWidth = result;
};
const defaultPositionResult = {
  h: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  },
  v: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  }
};
const calculatePosition = function (what, options) {
  const $what = (0, _renderer.default)(what);
  const currentOffset = $what.offset();
  const result = (0, _extend.extend)(true, {}, defaultPositionResult, {
    h: {
      location: currentOffset.left
    },
    v: {
      location: currentOffset.top
    }
  });
  if (!options) {
    return result;
  }
  const my = normalizeAlign(options.my);
  const at = normalizeAlign(options.at);
  let of = (0, _renderer.default)(options.of).length && options.of || window;
  const offset = normalizeOffset(options.offset, options.precise);
  const collision = normalizeCollision(options.collision);
  const boundary = options.boundary;
  const boundaryOffset = normalizeOffset(options.boundaryOffset, options.precise);
  const h = {
    mySize: (0, _size.getOuterWidth)($what),
    myAlign: my.h,
    atAlign: at.h,
    offset: offset.h,
    collision: collision.h,
    boundaryOffset: boundaryOffset.h
  };
  const v = {
    mySize: (0, _size.getOuterHeight)($what),
    myAlign: my.v,
    atAlign: at.v,
    offset: offset.v,
    collision: collision.v,
    boundaryOffset: boundaryOffset.v
  };
  if (of.preventDefault) {
    h.atLocation = of.pageX;
    v.atLocation = of.pageY;
    h.atSize = 0;
    v.atSize = 0;
  } else {
    of = (0, _renderer.default)(of);
    if ((0, _type.isWindow)(of[0])) {
      h.atLocation = of.scrollLeft();
      v.atLocation = of.scrollTop();
      if (_devices.default.real().deviceType === 'phone' && of[0].visualViewport) {
        h.atLocation = Math.max(h.atLocation, of[0].visualViewport.offsetLeft);
        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
        h.atSize = of[0].visualViewport.width;
        v.atSize = of[0].visualViewport.height;
      } else {
        h.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : (0, _size.getWidth)(of);
        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : (0, _size.getHeight)(of);
      }
    } else if (of[0].nodeType === 9) {
      h.atLocation = 0;
      v.atLocation = 0;
      h.atSize = (0, _size.getWidth)(of);
      v.atSize = (0, _size.getHeight)(of);
    } else {
      const ofRect = (0, _position.getBoundingRect)(of.get(0));
      const o = getOffsetWithoutScale(of);
      h.atLocation = o.left;
      v.atLocation = o.top;
      h.atSize = Math.max(ofRect.width, (0, _size.getOuterWidth)(of));
      v.atSize = Math.max(ofRect.height, (0, _size.getOuterHeight)(of));
    }
  }
  initMyLocation(h);
  initMyLocation(v);
  const bounds = function () {
    const win = (0, _renderer.default)(window);
    const windowWidth = (0, _size.getWidth)(win);
    const windowHeight = (0, _size.getHeight)(win);
    let left = win.scrollLeft();
    let top = win.scrollTop();
    const documentElement = _dom_adapter.default.getDocumentElement();
    const hZoomLevel = _support.touch ? documentElement.clientWidth / windowWidth : 1;
    const vZoomLevel = _support.touch ? documentElement.clientHeight / windowHeight : 1;
    if (scrollbarWidth === undefined) {
      calculateScrollbarWidth();
    }
    let boundaryWidth = windowWidth;
    let boundaryHeight = windowHeight;
    if (boundary && !(0, _type.isWindow)(boundary)) {
      const $boundary = (0, _renderer.default)(boundary);
      const boundaryPosition = $boundary.offset();
      left = boundaryPosition.left;
      top = boundaryPosition.top;
      boundaryWidth = (0, _size.getWidth)($boundary);
      boundaryHeight = (0, _size.getHeight)($boundary);
    }
    return {
      h: {
        min: left + h.boundaryOffset,
        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
      },
      v: {
        min: top + v.boundaryOffset,
        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
      }
    };
  }();
  h.oversize = calculateOversize(h, bounds.h);
  v.oversize = calculateOversize(v, bounds.v);
  h.collisionSide = collisionSide('h', h, bounds.h);
  v.collisionSide = collisionSide('v', v, bounds.v);
  if (collisionResolvers[h.collision]) {
    collisionResolvers[h.collision](h, bounds.h);
  }
  if (collisionResolvers[v.collision]) {
    collisionResolvers[v.collision](v, bounds.v);
  }
  const preciser = function (number) {
    return options.precise ? number : Math.round(number);
  };
  (0, _extend.extend)(true, result, {
    h: {
      location: preciser(h.myLocation),
      oversize: preciser(h.oversize),
      fit: h.fit,
      flip: h.flip,
      collisionSide: h.collisionSide
    },
    v: {
      location: preciser(v.myLocation),
      oversize: preciser(v.oversize),
      fit: v.fit,
      flip: v.flip,
      collisionSide: v.collisionSide
    },
    precise: options.precise
  });
  return result;
};
// NOTE: Setting the 'element.style' requires creating attributeNode when both of the conditions met:
//       - a form contains an input with the name property set to "style";
//       - a form contains a dx-validator (or other popup widget).
//       T941581
const setScaleProperty = function (element, scale, styleAttr, isEmpty) {
  const stylePropIsValid = (0, _type.isDefined)(element.style) && !_dom_adapter.default.isNode(element.style);
  const newStyleValue = isEmpty ? styleAttr.replace(scale, '') : styleAttr;
  if (stylePropIsValid) {
    (0, _style.setStyle)(element, newStyleValue, false);
  } else {
    const styleAttributeNode = _dom_adapter.default.createAttribute('style');
    styleAttributeNode.value = newStyleValue;
    element.setAttributeNode(styleAttributeNode);
  }
};
const getOffsetWithoutScale = function ($startElement) {
  var _currentElement$getAt, _style$match;
  let $currentElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $startElement;
  const currentElement = $currentElement.get(0);
  if (!currentElement) {
    return $startElement.offset();
  }
  const style = ((_currentElement$getAt = currentElement.getAttribute) === null || _currentElement$getAt === void 0 ? void 0 : _currentElement$getAt.call(currentElement, 'style')) || '';
  const scale = (_style$match = style.match(scaleRe)) === null || _style$match === void 0 ? void 0 : _style$match[0];
  let offset;
  if (scale) {
    setScaleProperty(currentElement, scale, style, true);
    offset = getOffsetWithoutScale($startElement, $currentElement.parent());
    setScaleProperty(currentElement, scale, style, false);
  } else {
    offset = getOffsetWithoutScale($startElement, $currentElement.parent());
  }
  return offset;
};
const position = function (what, options) {
  const $what = (0, _renderer.default)(what);
  if (!options) {
    return $what.offset();
  }
  (0, _translator.resetPosition)($what, true);
  const offset = getOffsetWithoutScale($what);
  const targetPosition = options.h && options.v ? options : calculatePosition($what, options);
  const preciser = function (number) {
    return options.precise ? number : Math.round(number);
  };
  (0, _translator.move)($what, {
    left: targetPosition.h.location - preciser(offset.left),
    top: targetPosition.v.location - preciser(offset.top)
  });
  return targetPosition;
};
const offset = function (element) {
  element = (0, _renderer.default)(element).get(0);
  if ((0, _type.isWindow)(element)) {
    return null;
  } else if (element && 'pageY' in element && 'pageX' in element) {
    return {
      top: element.pageY,
      left: element.pageX
    };
  }
  return (0, _renderer.default)(element).offset();
};
if (!position.inverseAlign) {
  position.inverseAlign = inverseAlign;
}
if (!position.normalizeAlign) {
  position.normalizeAlign = normalizeAlign;
}
var _default = exports["default"] = {
  calculateScrollbarWidth: calculateScrollbarWidth,
  calculate: calculatePosition,
  setup: position,
  offset: offset
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 42814:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.presets = exports.PresetCollection = void 0;
var _size = __webpack_require__(58664);
var _component = __webpack_require__(44297);
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _fx = _interopRequireDefault(__webpack_require__(87209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const directionPostfixes = {
  forward: ' dx-forward',
  backward: ' dx-backward',
  none: ' dx-no-direction',
  undefined: ' dx-no-direction'
};
const optionPrefix = 'preset_';
const AnimationPresetCollection = exports.PresetCollection = _component.Component.inherit({
  ctor: function () {
    this.callBase.apply(this, arguments);
    this._registeredPresets = [];
    this.resetToDefaults();
  },
  _getDefaultOptions: function () {
    return (0, _extend.extend)(this.callBase(), {
      defaultAnimationDuration: 400,
      defaultAnimationDelay: 0,
      defaultStaggerAnimationDuration: 300,
      defaultStaggerAnimationDelay: 40,
      defaultStaggerAnimationStartDelay: 500 // hack for better animations on ipad mini
    });
  },
  _defaultOptionsRules: function () {
    return this.callBase().concat([{
      device: function (device) {
        return device.phone;
      },
      options: {
        defaultStaggerAnimationDuration: 350,
        defaultStaggerAnimationDelay: 50,
        defaultStaggerAnimationStartDelay: 0
      }
    }, {
      // T254756
      device: function () {
        return _devices.default.current().android || _devices.default.real.android;
      },
      options: {
        defaultAnimationDelay: 100
      }
    }]);
  },
  _getPresetOptionName: function (animationName) {
    return optionPrefix + animationName;
  },
  // T257755
  _createAndroidSlideAnimationConfig: function (throughOpacity, widthMultiplier) {
    const that = this;
    const createBaseConfig = function (configModifier) {
      return {
        type: 'slide',
        delay: configModifier.delay === undefined ? that.option('defaultAnimationDelay') : configModifier.delay,
        duration: configModifier.duration === undefined ? that.option('defaultAnimationDuration') : configModifier.duration
      };
    };
    return {
      enter: function ($element, configModifier) {
        const width = (0, _size.getWidth)($element.parent()) * widthMultiplier;
        const direction = configModifier.direction;
        const config = createBaseConfig(configModifier);
        config.to = {
          left: 0,
          opacity: 1
        };
        if (direction === 'forward') {
          config.from = {
            left: width,
            opacity: throughOpacity
          };
        } else if (direction === 'backward') {
          config.from = {
            left: -width,
            opacity: throughOpacity
          };
        } else {
          config.from = {
            left: 0,
            opacity: 0
          };
        }
        return _fx.default.createAnimation($element, config);
      },
      leave: function ($element, configModifier) {
        const width = (0, _size.getWidth)($element.parent()) * widthMultiplier;
        const direction = configModifier.direction;
        const config = createBaseConfig(configModifier);
        config.from = {
          left: 0,
          opacity: 1
        };
        if (direction === 'forward') {
          config.to = {
            left: -width,
            opacity: throughOpacity
          };
        } else if (direction === 'backward') {
          config.to = {
            left: width,
            opacity: throughOpacity
          };
        } else {
          config.to = {
            left: 0,
            opacity: 0
          };
        }
        return _fx.default.createAnimation($element, config);
      }
    };
  },
  _createOpenDoorConfig: function () {
    const that = this;
    const createBaseConfig = function (configModifier) {
      return {
        type: 'css',
        extraCssClasses: 'dx-opendoor-animation',
        delay: configModifier.delay === undefined ? that.option('defaultAnimationDelay') : configModifier.delay,
        duration: configModifier.duration === undefined ? that.option('defaultAnimationDuration') : configModifier.duration
      };
    };
    return {
      enter: function ($element, configModifier) {
        const direction = configModifier.direction;
        const config = createBaseConfig(configModifier);
        config.delay = direction === 'none' ? config.delay : config.duration;
        config.from = 'dx-enter dx-opendoor-animation' + directionPostfixes[direction];
        config.to = 'dx-enter-active';
        return _fx.default.createAnimation($element, config);
      },
      leave: function ($element, configModifier) {
        const direction = configModifier.direction;
        const config = createBaseConfig(configModifier);
        config.from = 'dx-leave dx-opendoor-animation' + directionPostfixes[direction];
        config.to = 'dx-leave-active';
        return _fx.default.createAnimation($element, config);
      }
    };
  },
  _createWinPopConfig: function () {
    const that = this;
    const baseConfig = {
      type: 'css',
      extraCssClasses: 'dx-win-pop-animation',
      duration: that.option('defaultAnimationDuration')
    };
    return {
      enter: function ($element, configModifier) {
        const config = baseConfig;
        const direction = configModifier.direction;
        config.delay = direction === 'none' ? that.option('defaultAnimationDelay') : that.option('defaultAnimationDuration') / 2;
        config.from = 'dx-enter dx-win-pop-animation' + directionPostfixes[direction];
        config.to = 'dx-enter-active';
        return _fx.default.createAnimation($element, config);
      },
      leave: function ($element, configModifier) {
        const config = baseConfig;
        const direction = configModifier.direction;
        config.delay = that.option('defaultAnimationDelay');
        config.from = 'dx-leave dx-win-pop-animation' + directionPostfixes[direction];
        config.to = 'dx-leave-active';
        return _fx.default.createAnimation($element, config);
      }
    };
  },
  resetToDefaults: function () {
    this.clear();
    this.registerDefaultPresets();
    this.applyChanges();
  },
  clear: function (name) {
    const that = this;
    const newRegisteredPresets = [];
    (0, _iterator.each)(this._registeredPresets, function (index, preset) {
      if (!name || name === preset.name) {
        that.option(that._getPresetOptionName(preset.name), undefined);
      } else {
        newRegisteredPresets.push(preset);
      }
    });
    this._registeredPresets = newRegisteredPresets;
    this.applyChanges();
  },
  registerPreset: function (name, config) {
    this._registeredPresets.push({
      name: name,
      config: config
    });
  },
  applyChanges: function () {
    const that = this;
    const customRules = [];
    (0, _iterator.each)(this._registeredPresets, function (index, preset) {
      const rule = {
        device: preset.config.device,
        options: {}
      };
      rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
      customRules.push(rule);
    });
    this._setOptionsByDevice(customRules);
  },
  getPreset: function (name) {
    let result = name;
    while (typeof result === 'string') {
      result = this.option(this._getPresetOptionName(result));
    }
    return result;
  },
  registerDefaultPresets: function () {
    this.registerPreset('pop', {
      animation: {
        extraCssClasses: 'dx-android-pop-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('openDoor', {
      animation: this._createOpenDoorConfig()
    });
    this.registerPreset('win-pop', {
      animation: this._createWinPopConfig()
    });
    this.registerPreset('fade', {
      animation: {
        extraCssClasses: 'dx-fade-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('slide', {
      device: function () {
        return _devices.default.current().android || _devices.default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(1, 1)
    });
    this.registerPreset('slide', {
      device: function () {
        return !_devices.default.current().android && !_devices.default.real.android;
      },
      animation: {
        extraCssClasses: 'dx-slide-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-slide', {
      animation: {
        extraCssClasses: 'dx-ios7-slide-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('overflow', {
      animation: {
        extraCssClasses: 'dx-overflow-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-toolbar', {
      device: function () {
        return !_devices.default.current().android && !_devices.default.real.android;
      },
      animation: {
        extraCssClasses: 'dx-ios7-toolbar-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-toolbar', {
      device: function () {
        return _devices.default.current().android || _devices.default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(0, 0.4)
    });
    this.registerPreset('stagger-fade', {
      animation: {
        extraCssClasses: 'dx-fade-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-slide', {
      animation: {
        extraCssClasses: 'dx-slide-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-slide', {
      animation: {
        extraCssClasses: 'dx-fade-slide-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-drop', {
      animation: {
        extraCssClasses: 'dx-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-drop', {
      animation: {
        extraCssClasses: 'dx-fade-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-rise', {
      animation: {
        extraCssClasses: 'dx-fade-rise-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-3d-drop', {
      animation: {
        extraCssClasses: 'dx-3d-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-zoom', {
      animation: {
        extraCssClasses: 'dx-fade-zoom-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
  }
});
const animationPresets = exports.presets = new AnimationPresetCollection();

/***/ }),

/***/ 52431:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.TransitionExecutor = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend = __webpack_require__(13306);
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _fx = _interopRequireDefault(__webpack_require__(87209));
var _presets = __webpack_require__(42814);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const directionPostfixes = {
  forward: ' dx-forward',
  backward: ' dx-backward',
  none: ' dx-no-direction',
  undefined: ' dx-no-direction'
};
const DX_ANIMATING_CLASS = 'dx-animating';
const TransitionExecutor = exports.TransitionExecutor = _class.default.inherit({
  ctor: function () {
    this._accumulatedDelays = {
      enter: 0,
      leave: 0
    };
    this._animations = [];
    this.reset();
  },
  _createAnimations: function ($elements, initialConfig, configModifier, type) {
    $elements = (0, _renderer.default)($elements);
    const that = this;
    const result = [];
    configModifier = configModifier || {};
    const animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);
    if (animationConfig) {
      $elements.each(function () {
        const animation = that._createAnimation((0, _renderer.default)(this), animationConfig, configModifier);
        if (animation) {
          animation.element.addClass(DX_ANIMATING_CLASS);
          animation.setup();
          result.push(animation);
        }
      });
    }
    return result;
  },
  _prepareElementAnimationConfig: function (config, configModifier, type) {
    let result;
    if (typeof config === 'string') {
      const presetName = config;
      config = _presets.presets.getPreset(presetName);
    }
    if (!config) {
      result = undefined;
    } else if ((0, _type.isFunction)(config[type])) {
      result = config[type];
    } else {
      result = (0, _extend.extend)({
        skipElementInitialStyles: true,
        cleanupWhen: this._completePromise
      }, config, configModifier);
      if (!result.type || result.type === 'css') {
        const cssClass = 'dx-' + type;
        const extraCssClasses = (result.extraCssClasses ? ' ' + result.extraCssClasses : '') + directionPostfixes[result.direction];
        result.type = 'css';
        result.from = (result.from || cssClass) + extraCssClasses;
        result.to = result.to || cssClass + '-active';
      }
      result.staggerDelay = result.staggerDelay || 0;
      result.delay = result.delay || 0;
      if (result.staggerDelay) {
        result.delay += this._accumulatedDelays[type];
        this._accumulatedDelays[type] += result.staggerDelay;
      }
    }
    return result;
  },
  _createAnimation: function ($element, animationConfig, configModifier) {
    let result;
    if ((0, _type.isPlainObject)(animationConfig)) {
      result = _fx.default.createAnimation($element, animationConfig);
    } else if ((0, _type.isFunction)(animationConfig)) {
      result = animationConfig($element, configModifier);
    }
    return result;
  },
  _startAnimations: function () {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].start();
    }
  },
  _stopAnimations: function (jumpToEnd) {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].stop(jumpToEnd);
    }
  },
  _clearAnimations: function () {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].element.removeClass(DX_ANIMATING_CLASS);
    }
    this._animations.length = 0;
  },
  reset: function () {
    this._accumulatedDelays.enter = 0;
    this._accumulatedDelays.leave = 0;
    this._clearAnimations();
    this._completeDeferred = new _deferred.Deferred();
    this._completePromise = this._completeDeferred.promise();
  },
  enter: function ($elements, animationConfig, configModifier) {
    const animations = this._createAnimations($elements, animationConfig, configModifier, 'enter');
    this._animations.push.apply(this._animations, animations);
  },
  leave: function ($elements, animationConfig, configModifier) {
    const animations = this._createAnimations($elements, animationConfig, configModifier, 'leave');
    this._animations.push.apply(this._animations, animations);
  },
  start: function () {
    const that = this;
    let result;
    if (!this._animations.length) {
      that.reset();
      result = new _deferred.Deferred().resolve().promise();
    } else {
      const animationDeferreds = (0, _iterator.map)(this._animations, function (animation) {
        const result = new _deferred.Deferred();
        animation.deferred.always(function () {
          result.resolve();
        });
        return result.promise();
      });
      result = _deferred.when.apply(_renderer.default, animationDeferreds).always(function () {
        that._completeDeferred.resolve();
        that.reset();
      });
      (0, _common.executeAsync)(function () {
        that._startAnimations();
      });
    }
    return result;
  },
  stop: function (jumpToEnd) {
    this._stopAnimations(jumpToEnd);
  }
});

/***/ }),

/***/ 31648:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.resetPosition = exports.parseTranslate = exports.move = exports.locate = exports.getTranslateCss = exports.getTranslate = exports.clearCache = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _element_data = __webpack_require__(97906);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRANSLATOR_DATA_KEY = 'dxTranslator';
const TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
const TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
const locate = function ($element) {
  $element = (0, _renderer.default)($element);
  const translate = getTranslate($element);
  return {
    left: translate.x,
    top: translate.y
  };
};
exports.locate = locate;
function isPercentValue(value) {
  return (0, _type.type)(value) === 'string' && value[value.length - 1] === '%';
}
function cacheTranslate($element, translate) {
  if ($element.length) {
    (0, _element_data.data)($element.get(0), TRANSLATOR_DATA_KEY, translate);
  }
}
const clearCache = function ($element) {
  if ($element.length) {
    (0, _element_data.removeData)($element.get(0), TRANSLATOR_DATA_KEY);
  }
};
exports.clearCache = clearCache;
const getTranslateCss = function (translate) {
  translate.x = translate.x || 0;
  translate.y = translate.y || 0;
  const xValueString = isPercentValue(translate.x) ? translate.x : translate.x + 'px';
  const yValueString = isPercentValue(translate.y) ? translate.y : translate.y + 'px';
  return 'translate(' + xValueString + ', ' + yValueString + ')';
};
exports.getTranslateCss = getTranslateCss;
const getTranslate = function ($element) {
  let result = $element.length ? (0, _element_data.data)($element.get(0), TRANSLATOR_DATA_KEY) : null;
  if (!result) {
    const transformValue = $element.css('transform') || getTranslateCss({
      x: 0,
      y: 0
    });
    let matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
    const is3D = matrix && matrix[1];
    if (matrix) {
      matrix = matrix[2].split(',');
      if (is3D === '3d') {
        matrix = matrix.slice(12, 15);
      } else {
        matrix.push(0);
        matrix = matrix.slice(4, 7);
      }
    } else {
      matrix = [0, 0, 0];
    }
    result = {
      x: parseFloat(matrix[0]),
      y: parseFloat(matrix[1]),
      z: parseFloat(matrix[2])
    };
    cacheTranslate($element, result);
  }
  return result;
};
exports.getTranslate = getTranslate;
const move = function ($element, position) {
  $element = (0, _renderer.default)($element);
  const left = position.left;
  const top = position.top;
  let translate;
  if (left === undefined) {
    translate = getTranslate($element);
    translate.y = top || 0;
  } else if (top === undefined) {
    translate = getTranslate($element);
    translate.x = left || 0;
  } else {
    translate = {
      x: left || 0,
      y: top || 0,
      z: 0
    };
    cacheTranslate($element, translate);
  }
  $element.css({
    transform: getTranslateCss(translate)
  });
  if (isPercentValue(left) || isPercentValue(top)) {
    clearCache($element);
  }
};
exports.move = move;
const resetPosition = function ($element, finishTransition) {
  $element = (0, _renderer.default)($element);
  let originalTransition;
  const stylesConfig = {
    left: 0,
    top: 0,
    transform: 'none'
  };
  if (finishTransition) {
    originalTransition = $element.css('transition');
    stylesConfig.transition = 'none';
  }
  $element.css(stylesConfig);
  clearCache($element);
  if (finishTransition) {
    $element.get(0).offsetHeight;
    $element.css('transition', originalTransition);
  }
};
exports.resetPosition = resetPosition;
const parseTranslate = function (translateString) {
  let result = translateString.match(TRANSLATE_REGEX);
  if (!result || !result[1]) {
    return;
  }
  result = result[1].split(',');
  result = {
    x: parseFloat(result[0]),
    y: parseFloat(result[1]),
    z: parseFloat(result[2])
  };
  return result;
};
exports.parseTranslate = parseTranslate;

/***/ }),

/***/ 72505:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
const DevExpress = __webpack_require__(36991);
DevExpress.common = DevExpress.common || {};
DevExpress.common.charts = __webpack_require__(29932);
module.exports = DevExpress.common.charts;

/***/ }),

/***/ 36991:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
const windowUtils = __webpack_require__(58201);
const window = windowUtils.getWindow();
const DevExpress = window.DevExpress = window.DevExpress || {};
const errors = DevExpress.errors = __webpack_require__(17381);
if (DevExpress._DEVEXTREME_BUNDLE_INITIALIZED) {
  throw errors.Error('E0024');
}
DevExpress._DEVEXTREME_BUNDLE_INITIALIZED = true;
DevExpress.clientExporter = __webpack_require__(78292);
DevExpress.excelExporter = __webpack_require__(2994);
DevExpress.pdfExporter = __webpack_require__(44194);
DevExpress.VERSION = (__webpack_require__(36739).version);
DevExpress.assertDevExtremeVersion = (__webpack_require__(66507)/* .assertDevExtremeVersion */ .e);
DevExpress.Class = __webpack_require__(38377);
DevExpress.DOMComponent = __webpack_require__(13046);
DevExpress.Component = (__webpack_require__(44297).Component);
DevExpress.registerComponent = __webpack_require__(99393);
DevExpress.devices = __webpack_require__(20530);
DevExpress.trial = __webpack_require__(82713);
DevExpress.Color = __webpack_require__(52752);
const animationFrame = __webpack_require__(90057);

/**
 * @name utils
 * @namespace DevExpress
 */
DevExpress.utils = {};
DevExpress.utils.requestAnimationFrame = animationFrame.requestAnimationFrame;
DevExpress.utils.cancelAnimationFrame = animationFrame.cancelAnimationFrame;
DevExpress.utils.initMobileViewport = (__webpack_require__(88185)/* .initMobileViewport */ .p);
DevExpress.utils.getTimeZones = (__webpack_require__(88673)/* .getTimeZones */ .Z);

// TODO: MODULARITY: Remove this
DevExpress.utils.extendFromObject = (__webpack_require__(13306).extendFromObject);
DevExpress.utils.triggerShownEvent = (__webpack_require__(80506).triggerShownEvent);
DevExpress.utils.triggerHidingEvent = (__webpack_require__(80506).triggerHidingEvent);
DevExpress.utils.resetActiveElement = (__webpack_require__(3532).resetActiveElement);
DevExpress.utils.findBestMatches = (__webpack_require__(20576).findBestMatches);
DevExpress.createQueue = (__webpack_require__(59504).create);
DevExpress.utils.dom = __webpack_require__(3532);
DevExpress.utils.common = __webpack_require__(20576);
DevExpress.utils.date = __webpack_require__(91198);
DevExpress.utils.browser = __webpack_require__(47810);
DevExpress.utils.inflector = __webpack_require__(78008);
DevExpress.utils.iterator = __webpack_require__(95479);
DevExpress.utils.readyCallbacks = __webpack_require__(24311);
DevExpress.utils.resizeCallbacks = __webpack_require__(55814);
DevExpress.utils.console = __webpack_require__(30869);
DevExpress.utils.string = __webpack_require__(68752);
DevExpress.utils.support = __webpack_require__(60137);
DevExpress.utils.ajax = __webpack_require__(37208);
DevExpress.viewPort = (__webpack_require__(77695).value);
DevExpress.hideTopOverlay = __webpack_require__(60628);
DevExpress.formatHelper = __webpack_require__(30343);
DevExpress.config = __webpack_require__(80209);
DevExpress.animationPresets = (__webpack_require__(42814).presets);
DevExpress.fx = __webpack_require__(87209);
DevExpress.TransitionExecutor = (__webpack_require__(52431).TransitionExecutor);
DevExpress.AnimationPresetCollection = (__webpack_require__(42814).PresetCollection);
DevExpress.events = __webpack_require__(66365);
DevExpress.events.click = __webpack_require__(95429);
DevExpress.events.utils = __webpack_require__(39611);
DevExpress.events.GestureEmitter = __webpack_require__(98621);
DevExpress.localization = __webpack_require__(94484);
DevExpress.templateRendered = (__webpack_require__(81033).renderedCallbacks);
DevExpress.setTemplateEngine = (__webpack_require__(72987).setTemplateEngine);
module.exports = DevExpress;

/***/ }),

/***/ 86635:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
const DevExpress = __webpack_require__(36991);
const errors = __webpack_require__(17381);
module.exports = DevExpress.data = DevExpress.data || {};
Object.defineProperty(DevExpress.data, 'errorHandler', {
  get: function () {
    return (__webpack_require__(18438).errorHandler);
  },
  set: function (value) {
    errors.log('W0003', 'DevExpress.data', 'errorHandler', '21.1', 'Use the \'setErrorHandler\' method instead');
    (__webpack_require__(18438).setErrorHandler)(value);
  }
});

// TODO: try remove (plugins failed without this)
Object.defineProperty(DevExpress.data, '_errorHandler', {
  get: function () {
    return (__webpack_require__(18438).handleError);
  },
  set: function (value) {
    errors.log('W0003', 'DevExpress.data', '_errorHandler', '21.1', 'Use the \'setErrorHandler\' method instead');
    (__webpack_require__(18438).setErrorHandler)(value);
  }
});
DevExpress.data.setErrorHandler = (__webpack_require__(18438).setErrorHandler);
DevExpress.data.DataSource = __webpack_require__(33546);
DevExpress.data.query = __webpack_require__(96687);
DevExpress.data.Store = __webpack_require__(67403);
DevExpress.data.ArrayStore = __webpack_require__(26562);
DevExpress.data.CustomStore = __webpack_require__(88036);
DevExpress.data.LocalStore = __webpack_require__(82837);
DevExpress.data.base64_encode = (__webpack_require__(16454).base64_encode);
DevExpress.data.applyChanges = __webpack_require__(36893);
DevExpress.data.Guid = __webpack_require__(73176);
DevExpress.data.utils = {};
DevExpress.data.utils.compileGetter = (__webpack_require__(47617).compileGetter);
DevExpress.data.utils.compileSetter = (__webpack_require__(47617).compileSetter);
DevExpress.EndpointSelector = __webpack_require__(8162);
DevExpress.data.queryImpl = (__webpack_require__(77549).queryImpl);
DevExpress.data.queryAdapters = __webpack_require__(16135);
const dataUtils = __webpack_require__(16454);
DevExpress.data.utils.normalizeBinaryCriterion = dataUtils.normalizeBinaryCriterion;
DevExpress.data.utils.normalizeSortingInfo = dataUtils.normalizeSortingInfo;
DevExpress.data.utils.errorMessageFromXhr = dataUtils.errorMessageFromXhr;
DevExpress.data.utils.aggregators = dataUtils.aggregators;
DevExpress.data.utils.keysEqual = dataUtils.keysEqual;
DevExpress.data.utils.isDisjunctiveOperator = dataUtils.isDisjunctiveOperator;
DevExpress.data.utils.isConjunctiveOperator = dataUtils.isConjunctiveOperator;
DevExpress.data.utils.processRequestResultLock = dataUtils.processRequestResultLock;
DevExpress.data.utils.toComparable = (__webpack_require__(47617).toComparable);
DevExpress.data.utils.multiLevelGroup = (__webpack_require__(99236).multiLevelGroup);
DevExpress.data.utils.arrangeSortingInfo = (__webpack_require__(99236).arrangeSortingInfo);
DevExpress.data.utils.normalizeDataSourceOptions = (__webpack_require__(9234).normalizeDataSourceOptions);

/***/ }),

/***/ 72343:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



/* global DevExpress */
/* eslint-disable import/no-commonjs */
__webpack_require__(86635);
DevExpress.data.ODataStore = __webpack_require__(341);
DevExpress.data.ODataContext = __webpack_require__(47256);
DevExpress.data.utils = DevExpress.data.utils || {};
DevExpress.data.utils.odata = {};
DevExpress.data.utils.odata.keyConverters = (__webpack_require__(77869).keyConverters);
DevExpress.data.EdmLiteral = (__webpack_require__(77869).EdmLiteral);
const ODataUtilsModule = __webpack_require__(77869);
DevExpress.data.utils.odata.serializePropName = ODataUtilsModule.serializePropName;
DevExpress.data.utils.odata.serializeValue = ODataUtilsModule.serializeValue;
DevExpress.data.utils.odata.serializeKey = ODataUtilsModule.serializeKey;
DevExpress.data.utils.odata.sendRequest = ODataUtilsModule.sendRequest;
DevExpress.data.queryAdapters = DevExpress.data.queryAdapters || {};
DevExpress.data.queryAdapters.odata = (__webpack_require__(54263).odata);

/***/ }),

/***/ 85357:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/// BUNDLER_PARTS

/* Core (dx.module-core.js) */
/* eslint-disable import/no-commonjs */
const DevExpress = __webpack_require__(36991);

/* Integrations (dx.module-core.js) */

__webpack_require__(78475);
__webpack_require__(49281);
__webpack_require__(74872);
__webpack_require__(46949);
__webpack_require__(908);
__webpack_require__(60316);
__webpack_require__(7239);

/* Events (dx.module-core.js) */

__webpack_require__(95429);
__webpack_require__(49166);
__webpack_require__(85272);
__webpack_require__(23174);
__webpack_require__(11699);
__webpack_require__(24028);
__webpack_require__(93786);
__webpack_require__(34309);
__webpack_require__(91093);
/// BUNDLER_PARTS_END

module.exports = DevExpress;

/***/ }),

/***/ 94620:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
const DevExpress = __webpack_require__(85357);

/// BUNDLER_PARTS
/* Data (dx.module-core.js) */

const data = DevExpress.data = __webpack_require__(86635);
data.odata = __webpack_require__(72343);
/// BUNDLER_PARTS_END

module.exports = data;

/***/ }),

/***/ 66312:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
const DevExpress = __webpack_require__(85357);
__webpack_require__(94620);

/// BUNDLER_PARTS

/* Chart common */
__webpack_require__(72505);

/* Viz core (dx.module-viz-core.js) */

const viz = DevExpress.viz = __webpack_require__(20802);
viz.currentTheme = (__webpack_require__(86231).currentTheme);
viz.registerTheme = (__webpack_require__(86231).registerTheme);
viz.exportFromMarkup = (__webpack_require__(5259).exportFromMarkup);
viz.getMarkup = (__webpack_require__(5259).getMarkup);
viz.exportWidgets = (__webpack_require__(5259).exportWidgets);
viz.currentPalette = (__webpack_require__(23696).currentPalette);
viz.getPalette = (__webpack_require__(23696).getPalette);
viz.generateColors = (__webpack_require__(23696).generateColors);
viz.registerPalette = (__webpack_require__(23696).registerPalette);
viz.refreshTheme = (__webpack_require__(86231).refreshTheme);

/* Charts (dx.module-viz-charts.js) */
viz.dxChart = __webpack_require__(99511);
viz.dxPieChart = __webpack_require__(72111);
viz.dxPolarChart = __webpack_require__(80919);

/* Gauges (dx.module-viz-gauges.js) */
viz.dxLinearGauge = __webpack_require__(99630);
viz.dxCircularGauge = __webpack_require__(39847);
viz.dxBarGauge = __webpack_require__(45888);

/* Range selector (dx.module-viz-rangeselector.js) */
viz.dxRangeSelector = __webpack_require__(82879);

/* Vector map (dx.module-viz-vectormap.js) */
viz.dxVectorMap = __webpack_require__(81849);
viz.map = {};
viz.map.sources = {};
viz.map.projection = (__webpack_require__(102).projection);

/* Sparklines (dx.module-viz-sparklines.js) */
viz.dxSparkline = __webpack_require__(43759);
viz.dxBullet = __webpack_require__(88950);

/* Treemap */
viz.dxTreeMap = __webpack_require__(15584);

/* Funnel */
viz.dxFunnel = __webpack_require__(30187);

/* Sankey */
viz.dxSankey = __webpack_require__(34377);

/// BUNDLER_PARTS_END

viz.getTheme = (__webpack_require__(86231).getTheme);
// Keep it for backward compatibility after renaming findTheme to getTheme
viz.findTheme = (__webpack_require__(86231).getTheme);
// We need to keep this method as we suggested it to users
viz.refreshAll = (__webpack_require__(86231).refreshTheme);
viz.refreshPaths = (__webpack_require__(34434).refreshPaths);
viz.gauges = {
  __internals: {}
};
viz._dashboard = {};
viz._dashboard.Renderer = (__webpack_require__(56453).Renderer);
viz._dashboard.SvgElement = (__webpack_require__(56453).SvgElement);
viz._dashboard.patchFontOptions = (__webpack_require__(19157).patchFontOptions);
module.exports = viz;

/***/ }),

/***/ 20802:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(36991);
/* global DevExpress */
/* eslint-disable import/no-commonjs */

module.exports = DevExpress.viz = DevExpress.viz || {};

/***/ }),

/***/ 52752:
/***/ (function(module, exports) {



exports["default"] = void 0;
const standardColorNames = {
  'aliceblue': 'f0f8ff',
  'antiquewhite': 'faebd7',
  'aqua': '00ffff',
  'aquamarine': '7fffd4',
  'azure': 'f0ffff',
  'beige': 'f5f5dc',
  'bisque': 'ffe4c4',
  'black': '000000',
  'blanchedalmond': 'ffebcd',
  'blue': '0000ff',
  'blueviolet': '8a2be2',
  'brown': 'a52a2a',
  'burlywood': 'deb887',
  'cadetblue': '5f9ea0',
  'chartreuse': '7fff00',
  'chocolate': 'd2691e',
  'coral': 'ff7f50',
  'cornflowerblue': '6495ed',
  'cornsilk': 'fff8dc',
  'crimson': 'dc143c',
  'cyan': '00ffff',
  'darkblue': '00008b',
  'darkcyan': '008b8b',
  'darkgoldenrod': 'b8860b',
  'darkgray': 'a9a9a9',
  'darkgreen': '006400',
  'darkgrey': 'a9a9a9',
  'darkkhaki': 'bdb76b',
  'darkmagenta': '8b008b',
  'darkolivegreen': '556b2f',
  'darkorange': 'ff8c00',
  'darkorchid': '9932cc',
  'darkred': '8b0000',
  'darksalmon': 'e9967a',
  'darkseagreen': '8fbc8f',
  'darkslateblue': '483d8b',
  'darkslategray': '2f4f4f',
  'darkslategrey': '2f4f4f',
  'darkturquoise': '00ced1',
  'darkviolet': '9400d3',
  'deeppink': 'ff1493',
  'deepskyblue': '00bfff',
  'dimgray': '696969',
  'dimgrey': '696969',
  'dodgerblue': '1e90ff',
  'feldspar': 'd19275',
  'firebrick': 'b22222',
  'floralwhite': 'fffaf0',
  'forestgreen': '228b22',
  'fuchsia': 'ff00ff',
  'gainsboro': 'dcdcdc',
  'ghostwhite': 'f8f8ff',
  'gold': 'ffd700',
  'goldenrod': 'daa520',
  'gray': '808080',
  'green': '008000',
  'greenyellow': 'adff2f',
  'grey': '808080',
  'honeydew': 'f0fff0',
  'hotpink': 'ff69b4',
  'indianred': 'cd5c5c',
  'indigo': '4b0082',
  'ivory': 'fffff0',
  'khaki': 'f0e68c',
  'lavender': 'e6e6fa',
  'lavenderblush': 'fff0f5',
  'lawngreen': '7cfc00',
  'lemonchiffon': 'fffacd',
  'lightblue': 'add8e6',
  'lightcoral': 'f08080',
  'lightcyan': 'e0ffff',
  'lightgoldenrodyellow': 'fafad2',
  'lightgray': 'd3d3d3',
  'lightgreen': '90ee90',
  'lightgrey': 'd3d3d3',
  'lightpink': 'ffb6c1',
  'lightsalmon': 'ffa07a',
  'lightseagreen': '20b2aa',
  'lightskyblue': '87cefa',
  'lightslateblue': '8470ff',
  'lightslategray': '778899',
  'lightslategrey': '778899',
  'lightsteelblue': 'b0c4de',
  'lightyellow': 'ffffe0',
  'lime': '00ff00',
  'limegreen': '32cd32',
  'linen': 'faf0e6',
  'magenta': 'ff00ff',
  'maroon': '800000',
  'mediumaquamarine': '66cdaa',
  'mediumblue': '0000cd',
  'mediumorchid': 'ba55d3',
  'mediumpurple': '9370d8',
  'mediumseagreen': '3cb371',
  'mediumslateblue': '7b68ee',
  'mediumspringgreen': '00fa9a',
  'mediumturquoise': '48d1cc',
  'mediumvioletred': 'c71585',
  'midnightblue': '191970',
  'mintcream': 'f5fffa',
  'mistyrose': 'ffe4e1',
  'moccasin': 'ffe4b5',
  'navajowhite': 'ffdead',
  'navy': '000080',
  'oldlace': 'fdf5e6',
  'olive': '808000',
  'olivedrab': '6b8e23',
  'orange': 'ffa500',
  'orangered': 'ff4500',
  'orchid': 'da70d6',
  'palegoldenrod': 'eee8aa',
  'palegreen': '98fb98',
  'paleturquoise': 'afeeee',
  'palevioletred': 'd87093',
  'papayawhip': 'ffefd5',
  'peachpuff': 'ffdab9',
  'peru': 'cd853f',
  'pink': 'ffc0cb',
  'plum': 'dda0dd',
  'powderblue': 'b0e0e6',
  'purple': '800080',
  'rebeccapurple': '663399',
  'red': 'ff0000',
  'rosybrown': 'bc8f8f',
  'royalblue': '4169e1',
  'saddlebrown': '8b4513',
  'salmon': 'fa8072',
  'sandybrown': 'f4a460',
  'seagreen': '2e8b57',
  'seashell': 'fff5ee',
  'sienna': 'a0522d',
  'silver': 'c0c0c0',
  'skyblue': '87ceeb',
  'slateblue': '6a5acd',
  'slategray': '708090',
  'slategrey': '708090',
  'snow': 'fffafa',
  'springgreen': '00ff7f',
  'steelblue': '4682b4',
  'tan': 'd2b48c',
  'teal': '008080',
  'thistle': 'd8bfd8',
  'tomato': 'ff6347',
  'turquoise': '40e0d0',
  'violet': 'ee82ee',
  'violetred': 'd02090',
  'wheat': 'f5deb3',
  'white': 'ffffff',
  'whitesmoke': 'f5f5f5',
  'yellow': 'ffff00',
  'yellowgreen': '9acd32'
};

// array of color definition objects
const standardColorTypes = [{
  re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function (colorString) {
    return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)];
  }
}, {
  re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
  process: function (colorString) {
    return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])];
  }
}, {
  re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
  process: function (colorString) {
    return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)];
  }
}, {
  re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
  process: function (colorString) {
    return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16), Number((parseInt(colorString[4], 16) / 255).toFixed(2))];
  }
}, {
  re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
  process: function (colorString) {
    return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16), Number((parseInt(colorString[4] + colorString[4], 16) / 255).toFixed(2))];
  }
}, {
  re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
  process: function (colorString) {
    return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)];
  }
}, {
  re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function (colorString) {
    const h = parseInt(colorString[1], 10);
    const s = parseInt(colorString[2], 10);
    const v = parseInt(colorString[3], 10);
    const rgb = hsvToRgb(h, s, v);
    return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]];
  }
}, {
  re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function (colorString) {
    const h = parseInt(colorString[1], 10);
    const s = parseInt(colorString[2], 10);
    const l = parseInt(colorString[3], 10);
    const rgb = hslToRgb(h, s, l);
    return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]];
  }
}];
const _round = Math.round;
function Color(value) {
  this.baseColor = value;
  let color;
  if (value) {
    color = String(value).toLowerCase().replace(/ /g, '');
    color = standardColorNames[color] ? '#' + standardColorNames[color] : color;
    color = parseColor(color);
  }
  if (!color) {
    this.colorIsInvalid = true;
  }
  color = color || {};
  this.r = normalize(color[0]);
  this.g = normalize(color[1]);
  this.b = normalize(color[2]);
  this.a = normalize(color[3], 1, 1);
  if (color[4]) {
    this.hsv = {
      h: color[4][0],
      s: color[4][1],
      v: color[4][2]
    };
  } else {
    this.hsv = toHsvFromRgb(this.r, this.g, this.b);
  }
  if (color[5]) {
    this.hsl = {
      h: color[5][0],
      s: color[5][1],
      l: color[5][2]
    };
  } else {
    this.hsl = toHslFromRgb(this.r, this.g, this.b);
  }
}
function parseColor(color) {
  if (color === 'transparent') {
    return [0, 0, 0, 0];
  }
  let i = 0;
  const ii = standardColorTypes.length;
  let str;
  for (; i < ii; ++i) {
    str = standardColorTypes[i].re.exec(color);
    if (str) {
      return standardColorTypes[i].process(str);
    }
  }
  return null;
}
function normalize(colorComponent, def, max) {
  def = def || 0;
  max = max || 255;
  return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent;
}
function toHexFromRgb(r, g, b) {
  return '#' + (0X01000000 | r << 16 | g << 8 | b).toString(16).slice(1);
}
function toHsvFromRgb(r, g, b) {
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const delta = max - min;
  let H;
  let S;
  let V = max;
  S = max === 0 ? 0 : 1 - min / max;
  if (max === min) {
    H = 0;
  } else {
    switch (max) {
      case r:
        H = 60 * ((g - b) / delta);
        if (g < b) {
          H = H + 360;
        }
        break;
      case g:
        H = 60 * ((b - r) / delta) + 120;
        break;
      case b:
        H = 60 * ((r - g) / delta) + 240;
        break;
    }
  }
  S *= 100;
  V *= 100 / 255;
  return {
    h: Math.round(H),
    s: Math.round(S),
    v: Math.round(V)
  };
}
function hsvToRgb(h, s, v) {
  const index = Math.floor(h % 360 / 60);
  const vMin = (100 - s) * v / 100;
  const a = (v - vMin) * (h % 60 / 60);
  const vInc = vMin + a;
  const vDec = v - a;
  let r;
  let g;
  let b;
  switch (index) {
    /* eslint-disable no-multi-spaces */
    case 0:
      r = v;
      g = vInc;
      b = vMin;
      break;
    case 1:
      r = vDec;
      g = v;
      b = vMin;
      break;
    case 2:
      r = vMin;
      g = v;
      b = vInc;
      break;
    case 3:
      r = vMin;
      g = vDec;
      b = v;
      break;
    case 4:
      r = vInc;
      g = vMin;
      b = v;
      break;
    case 5:
      r = v;
      g = vMin;
      b = vDec;
      break;
    /* eslint-enable no-multi-spaces */
  }
  return [Math.round(r * 2.55), Math.round(g * 2.55), Math.round(b * 2.55)];
}
function calculateHue(r, g, b, delta) {
  const max = Math.max(r, g, b);
  switch (max) {
    case r:
      return (g - b) / delta + (g < b ? 6 : 0);
    case g:
      return (b - r) / delta + 2;
    case b:
      return (r - g) / delta + 4;
  }
}
function toHslFromRgb(r, g, b) {
  r = convertTo01Bounds(r, 255);
  g = convertTo01Bounds(g, 255);
  b = convertTo01Bounds(b, 255);
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const maxMinSum = max + min;
  let h;
  let s;
  const l = maxMinSum / 2;
  if (max === min) {
    h = s = 0;
  } else {
    const delta = max - min;
    if (l > 0.5) {
      s = delta / (2 - maxMinSum);
    } else {
      s = delta / maxMinSum;
    }
    h = calculateHue(r, g, b, delta);
    h /= 6;
  }
  return {
    h: _round(h * 360),
    s: _round(s * 100),
    l: _round(l * 100)
  };
}
function makeColorTint(colorPart, h) {
  let colorTint = h;
  if (colorPart === 'r') {
    colorTint = h + 1 / 3;
  }
  if (colorPart === 'b') {
    colorTint = h - 1 / 3;
  }
  return colorTint;
}
function modifyColorTint(colorTint) {
  if (colorTint < 0) {
    colorTint += 1;
  }
  if (colorTint > 1) {
    colorTint -= 1;
  }
  return colorTint;
}
function hueToRgb(p, q, colorTint) {
  colorTint = modifyColorTint(colorTint);
  if (colorTint < 1 / 6) {
    return p + (q - p) * 6 * colorTint;
  }
  if (colorTint < 1 / 2) {
    return q;
  }
  if (colorTint < 2 / 3) {
    return p + (q - p) * (2 / 3 - colorTint) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  let r;
  let g;
  let b;
  h = convertTo01Bounds(h, 360);
  s = convertTo01Bounds(s, 100);
  l = convertTo01Bounds(l, 100);
  if (s === 0) {
    r = g = b = l;
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hueToRgb(p, q, makeColorTint('r', h));
    g = hueToRgb(p, q, makeColorTint('g', h));
    b = hueToRgb(p, q, makeColorTint('b', h));
  }
  return [_round(r * 255), _round(g * 255), _round(b * 255)];
}
function convertTo01Bounds(n, max) {
  n = Math.min(max, Math.max(0, parseFloat(n)));
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }
  return n % max / parseFloat(max);
}
function isIntegerBetweenMinAndMax(number, min, max) {
  min = min || 0;
  max = max || 255;
  if (number % 1 !== 0 || number < min || number > max || typeof number !== 'number' || isNaN(number)) {
    return false;
  }
  return true;
}
Color.prototype = {
  constructor: Color,
  highlight: function (step) {
    step = step || 10;
    return this.alter(step).toHex();
  },
  darken: function (step) {
    step = step || 10;
    return this.alter(-step).toHex();
  },
  alter: function (step) {
    const result = new Color();
    result.r = normalize(this.r + step);
    result.g = normalize(this.g + step);
    result.b = normalize(this.b + step);
    return result;
  },
  blend: function (blendColor, opacity) {
    const other = blendColor instanceof Color ? blendColor : new Color(blendColor);
    const result = new Color();
    result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
    result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
    result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
    return result;
  },
  toHex: function () {
    return toHexFromRgb(this.r, this.g, this.b);
  },
  getPureColor: function () {
    const rgb = hsvToRgb(this.hsv.h, 100, 100);
    return new Color('rgb(' + rgb.join(',') + ')');
  },
  isValidHex: function (hex) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  },
  isValidRGB: function (r, g, b) {
    if (!isIntegerBetweenMinAndMax(r) || !isIntegerBetweenMinAndMax(g) || !isIntegerBetweenMinAndMax(b)) {
      return false;
    }
    return true;
  },
  isValidAlpha: function (a) {
    if (isNaN(a) || a < 0 || a > 1 || typeof a !== 'number') {
      return false;
    }
    return true;
  },
  colorIsInvalid: false,
  fromHSL: function (hsl) {
    const color = new Color();
    const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    color.r = rgb[0];
    color.g = rgb[1];
    color.b = rgb[2];
    return color;
  }
};
var _default = exports["default"] = Color;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 29932:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "registerGradient", ({
  enumerable: true,
  get: function () {
    return _m_charts.registerGradient;
  }
}));
Object.defineProperty(exports, "registerPattern", ({
  enumerable: true,
  get: function () {
    return _m_charts.registerPattern;
  }
}));
var _m_charts = __webpack_require__(66798);

/***/ }),

/***/ 62414:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _window = __webpack_require__(58201);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Action {
  constructor(action, config) {
    config = config || {};
    this._action = action;
    this._context = config.context || (0, _window.getWindow)();
    this._beforeExecute = config.beforeExecute;
    this._afterExecute = config.afterExecute;
    this._component = config.component;
    this._validatingTargetName = config.validatingTargetName;
    const excludeValidators = this._excludeValidators = {};
    if (config.excludeValidators) {
      for (let i = 0; i < config.excludeValidators.length; i++) {
        excludeValidators[config.excludeValidators[i]] = true;
      }
    }
  }
  execute() {
    const e = {
      action: this._action,
      args: Array.prototype.slice.call(arguments),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: false,
      handled: false
    };
    const beforeExecute = this._beforeExecute;
    const afterExecute = this._afterExecute;
    const argsBag = e.args[0] || {};
    if (!this._validateAction(e)) {
      return;
    }
    beforeExecute === null || beforeExecute === void 0 || beforeExecute.call(this._context, e);
    if (e.cancel) {
      return;
    }
    const result = this._executeAction(e);
    if (argsBag.cancel) {
      return;
    }
    afterExecute === null || afterExecute === void 0 || afterExecute.call(this._context, e);
    return result;
  }
  _validateAction(e) {
    const excludeValidators = this._excludeValidators;
    const {
      executors
    } = Action;
    for (const name in executors) {
      if (!excludeValidators[name]) {
        var _executor$validate;
        const executor = executors[name];
        (_executor$validate = executor.validate) === null || _executor$validate === void 0 || _executor$validate.call(executor, e);
        if (e.cancel) {
          return false;
        }
      }
    }
    return true;
  }
  _executeAction(e) {
    let result;
    const {
      executors
    } = Action;
    for (const name in executors) {
      var _executor$execute;
      const executor = executors[name];
      (_executor$execute = executor.execute) === null || _executor$execute === void 0 || _executor$execute.call(executor, e);
      if (e.handled) {
        result = e.result;
        break;
      }
    }
    return result;
  }
  static registerExecutor(name, executor) {
    if ((0, _type.isPlainObject)(name)) {
      (0, _iterator.each)(name, Action.registerExecutor);
      return;
    }
    Action.executors[name] = executor;
  }
  static unregisterExecutor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    (0, _iterator.each)(args, function () {
      delete Action.executors[this];
    });
  }
}
exports["default"] = Action;
Action.executors = {};
const createValidatorByTargetElement = condition => e => {
  if (!e.args.length) {
    return;
  }
  const args = e.args[0];
  const element = args[e.validatingTargetName] || args.element;
  if (element && condition((0, _renderer.default)(element))) {
    e.cancel = true;
  }
};
Action.registerExecutor({
  'disabled': {
    validate: createValidatorByTargetElement($target => $target.is('.dx-state-disabled, .dx-state-disabled *'))
  },
  'readOnly': {
    validate: createValidatorByTargetElement($target => $target.is('.dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)'))
  },
  'undefined': {
    execute: e => {
      if (!e.action) {
        e.result = undefined;
        e.handled = true;
      }
    }
  },
  'func': {
    execute: e => {
      if ((0, _type.isFunction)(e.action)) {
        e.result = e.action.call(e.context, e.args[0]);
        e.handled = true;
      }
    }
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 38377:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const wrapOverridden = function (baseProto, methodName, method) {
  return function () {
    const prevCallBase = this.callBase;
    this.callBase = baseProto[methodName];
    try {
      return method.apply(this, arguments);
    } finally {
      this.callBase = prevCallBase;
    }
  };
};
const clonePrototype = function (obj) {
  const func = function () {};
  func.prototype = obj.prototype;
  return new func();
};
const redefine = function (members) {
  const that = this;
  let overridden;
  let memberName;
  let member;
  if (!members) {
    return that;
  }
  for (memberName in members) {
    member = members[memberName];
    overridden = typeof that.prototype[memberName] === 'function' && typeof member === 'function';
    that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member;
  }
  return that;
};
const include = function () {
  const classObj = this;
  let argument;
  let name;
  let i;

  // NOTE: For ES6 classes. They don't have _includedCtors/_includedPostCtors
  // properties and get them from the ancestor class.
  const hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
  const isES6Class = !hasClassObjOwnProperty('_includedCtors') && !hasClassObjOwnProperty('_includedPostCtors');
  if (isES6Class) {
    classObj._includedCtors = classObj._includedCtors.slice(0);
    classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
  }
  for (i = 0; i < arguments.length; i++) {
    argument = arguments[i];
    if (argument.ctor) {
      classObj._includedCtors.push(argument.ctor);
    }
    if (argument.postCtor) {
      classObj._includedPostCtors.push(argument.postCtor);
    }
    for (name in argument) {
      if (name === 'ctor' || name === 'postCtor' || name === 'default') {
        continue;
      }
      classObj.prototype[name] = argument[name];
    }
  }
  return classObj;
};
const subclassOf = function (parentClass) {
  const hasParentProperty = Object.prototype.hasOwnProperty.bind(this)('parent');
  const isES6Class = !hasParentProperty && this.parent;
  if (isES6Class) {
    const baseClass = Object.getPrototypeOf(this);
    return baseClass === parentClass || baseClass.subclassOf(parentClass);
  } else {
    if (this.parent === parentClass) {
      return true;
    }
    if (!this.parent || !this.parent.subclassOf) {
      return false;
    }
    return this.parent.subclassOf(parentClass);
  }
};
const abstract = function () {
  throw _errors.default.Error('E0001');
};
const classImpl = function () {};
classImpl.inherit = function (members) {
  const inheritor = function () {
    if (!this || (0, _type.isWindow)(this) || typeof this.constructor !== 'function') {
      throw _errors.default.Error('E0003');
    }
    const instance = this;
    const ctor = instance.ctor;
    const includedCtors = instance.constructor._includedCtors;
    const includedPostCtors = instance.constructor._includedPostCtors;
    let i;
    for (i = 0; i < includedCtors.length; i++) {
      includedCtors[i].call(instance);
    }
    if (ctor) {
      ctor.apply(instance, arguments);
    }
    for (i = 0; i < includedPostCtors.length; i++) {
      includedPostCtors[i].call(instance);
    }
  };
  inheritor.prototype = clonePrototype(this);
  Object.setPrototypeOf(inheritor, this);
  inheritor.inherit = this.inherit;
  inheritor.abstract = abstract;
  inheritor.redefine = redefine;
  inheritor.include = include;
  inheritor.subclassOf = subclassOf;
  inheritor.parent = this;
  inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
  inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
  inheritor.prototype.constructor = inheritor;
  inheritor.redefine(members);
  return inheritor;
};
classImpl.abstract = abstract;
var _default = exports["default"] = classImpl;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 44297:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _component = __webpack_require__(55634);
Object.keys(_component).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _component[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _component[key];
    }
  });
});

/***/ }),

/***/ 99393:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(5554));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _public_component = __webpack_require__(9321);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const registerComponent = function (name, namespace, componentClass) {
  if (!componentClass) {
    componentClass = namespace;
  } else {
    namespace[name] = componentClass;
  }
  (0, _public_component.name)(componentClass, name);
  _component_registrator_callbacks.default.fire(name, componentClass);
};
const registerRendererComponent = function (name, componentClass) {
  _renderer.default.fn[name] = function (options) {
    const isMemberInvoke = typeof options === 'string';
    let result;
    if (isMemberInvoke) {
      const memberName = options;
      const memberArgs = [].slice.call(arguments).slice(1);
      this.each(function () {
        const instance = componentClass.getInstance(this);
        if (!instance) {
          throw _errors.default.Error('E0009', name);
        }
        const member = instance[memberName];
        const memberValue = member.apply(instance, memberArgs);
        if (result === undefined) {
          result = memberValue;
        }
      });
    } else {
      this.each(function () {
        const instance = componentClass.getInstance(this);
        if (instance) {
          instance.option(options);
        } else {
          new componentClass(this, options);
        }
      });
      result = this;
    }
    return result;
  };
};
_component_registrator_callbacks.default.add(registerRendererComponent);
var _default = exports["default"] = registerComponent;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 5554:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _memorized_callbacks = _interopRequireDefault(__webpack_require__(83358));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = new _memorized_callbacks.default();
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 80209:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global DevExpress */

const config = {
  rtlEnabled: false,
  defaultCurrency: 'USD',
  defaultUseCurrencyAccountingStyle: true,
  oDataFilterToLower: true,
  serverDecimalSeparator: '.',
  decimalSeparator: '.',
  thousandsSeparator: ',',
  forceIsoDateParsing: true,
  wrapActionsBeforeExecute: true,
  useLegacyStoreResult: false,
  /**
  * @name GlobalConfig.useJQuery
  * @type boolean
  * @hidden
  */
  useJQuery: undefined,
  editorStylingMode: undefined,
  useLegacyVisibleIndex: false,
  floatingActionButtonConfig: {
    icon: 'add',
    closeIcon: 'close',
    label: '',
    position: {
      at: 'right bottom',
      my: 'right bottom',
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: false,
    direction: 'auto'
  },
  optionsParser: optionsString => {
    if (optionsString.trim().charAt(0) !== '{') {
      optionsString = '{' + optionsString + '}';
    }
    try {
      return JSON.parse(optionsString);
    } catch (ex) {
      try {
        return JSON.parse(normalizeToJSONString(optionsString));
      } catch (exNormalize) {
        throw _errors.default.Error('E3018', ex, optionsString);
      }
    }
  }
};
const normalizeToJSONString = optionsString => {
  return optionsString.replace(/'/g, '"') // replace all ' to "
  .replace(/,\s*([\]}])/g, '$1') // remove trailing commas
  .replace(/([{,])\s*([^":\s]+)\s*:/g, '$1"$2":'); // add quotes for unquoted keys
};
const deprecatedFields = ['decimalSeparator', 'thousandsSeparator'];
const configMethod = function () {
  if (!arguments.length) {
    return config;
  }
  const newConfig = arguments.length <= 0 ? undefined : arguments[0];
  deprecatedFields.forEach(deprecatedField => {
    if (newConfig[deprecatedField]) {
      const message = `Now, the ${deprecatedField} is selected based on the specified locale.`;
      _errors.default.log('W0003', 'config', deprecatedField, '19.2', message);
    }
  });
  (0, _extend.extend)(config, newConfig);
};
if (typeof DevExpress !== 'undefined' && DevExpress.config) {
  configMethod(DevExpress.config);
}
var _default = exports["default"] = configMethod;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 20530:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _window = __webpack_require__(58201);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _resize_callbacks = _interopRequireDefault(__webpack_require__(55814));
var _events_strategy = __webpack_require__(80566);
var _storage = __webpack_require__(36613);
var _view_port = __webpack_require__(77695);
var _config = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const KNOWN_UA_TABLE = {
  'iPhone': 'iPhone',
  'iPhone5': 'iPhone',
  'iPhone6': 'iPhone',
  'iPhone6plus': 'iPhone',
  'iPad': 'iPad',
  'iPadMini': 'iPad Mini',
  'androidPhone': 'Android Mobile',
  'androidTablet': 'Android',
  'msSurface': 'Windows ARM Tablet PC',
  'desktop': 'desktop'
};
const DEFAULT_DEVICE = {
  deviceType: 'desktop',
  platform: 'generic',
  version: [],
  phone: false,
  tablet: false,
  android: false,
  ios: false,
  generic: true,
  grade: 'A',
  // TODO: For internal use (draft, do not document these options!)
  mac: false
};
const UA_PARSERS = {
  generic(userAgent) {
    const isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
    const isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
    const isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
    const isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
    if (!(isPhone || isTablet || isDesktop || isMac)) {
      return null;
    }
    return {
      deviceType: isPhone ? 'phone' : isTablet ? 'tablet' : 'desktop',
      platform: 'generic',
      version: [],
      grade: 'A',
      mac: isMac
    };
  },
  appleTouchDevice(userAgent) {
    const navigator = (0, _window.getNavigator)();
    const isIpadOs = /Macintosh/i.test(userAgent) && (navigator === null || navigator === void 0 ? void 0 : navigator.maxTouchPoints) > 2;
    const isAppleDevice = /ip(hone|od|ad)/i.test(userAgent);
    if (!isAppleDevice && !isIpadOs) {
      return null;
    }
    const isPhone = /ip(hone|od)/i.test(userAgent);
    const matches = userAgent.match(/os\s{0,}X? (\d+)_(\d+)_?(\d+)?/i);
    const version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
    const isIPhone4 = window.screen.height === 960 / 2;
    const grade = isIPhone4 ? 'B' : 'A';
    return {
      deviceType: isPhone ? 'phone' : 'tablet',
      platform: 'ios',
      version,
      grade
    };
  },
  android(userAgent) {
    // TODO: Check this RegExp.
    //  It looks like there may be missing android user agents.
    const isAndroid = /android|htc_|silk/i.test(userAgent);
    const isWinPhone = /windows phone/i.test(userAgent);
    if (!isAndroid || isWinPhone) {
      return null;
    }
    const isPhone = /mobile/i.test(userAgent);
    const matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
    const version = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
    const worseThan4_4 = version.length > 1 && (version[0] < 4 || version[0] === 4 && version[1] < 4);
    const grade = worseThan4_4 ? 'B' : 'A';
    return {
      deviceType: isPhone ? 'phone' : 'tablet',
      platform: 'android',
      version,
      grade
    };
  }
};
const UA_PARSERS_ARRAY = [UA_PARSERS.appleTouchDevice, UA_PARSERS.android, UA_PARSERS.generic];
class Devices {
  /**
  * @name DevicesObject.ctor
  * @publicName ctor(options)
  * @param1 options:object
  * @param1_field1 window:Window
  * @hidden
  */
  constructor(options) {
    this._window = (options === null || options === void 0 ? void 0 : options.window) || window;
    this._realDevice = this._getDevice();
    this._currentDevice = undefined;
    this._currentOrientation = undefined;
    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
    this.changed = (0, _callbacks.default)();
    if ((0, _window.hasWindow)()) {
      _ready_callbacks.default.add(this._recalculateOrientation.bind(this));
      _resize_callbacks.default.add(this._recalculateOrientation.bind(this));
    }
  }
  current(deviceOrName) {
    if (deviceOrName) {
      this._currentDevice = this._getDevice(deviceOrName);
      this._forced = true;
      this.changed.fire();
      return;
    }
    if (!this._currentDevice) {
      deviceOrName = undefined;
      try {
        deviceOrName = this._getDeviceOrNameFromWindowScope();
      } catch (e) {
        deviceOrName = this._getDeviceNameFromSessionStorage();
      } finally {
        if (!deviceOrName) {
          deviceOrName = this._getDeviceNameFromSessionStorage();
        }
        if (deviceOrName) {
          this._forced = true;
        }
      }
      this._currentDevice = this._getDevice(deviceOrName);
    }
    return this._currentDevice;
  }
  real(forceDevice) {
    return (0, _extend.extend)({}, this._realDevice);
  }
  orientation() {
    return this._currentOrientation;
  }
  isForced() {
    return this._forced;
  }
  isRippleEmulator() {
    return !!this._window.tinyHippos;
  }
  _getCssClasses(device) {
    const result = [];
    const realDevice = this._realDevice;
    device = device || this.current();

    // TODO: use real device here?
    if (device.deviceType) {
      result.push(`dx-device-${device.deviceType}`);
      if (device.deviceType !== 'desktop') {
        result.push('dx-device-mobile');
      }
    }
    result.push(`dx-device-${realDevice.platform}`);
    if (realDevice.version && realDevice.version.length) {
      result.push(`dx-device-${realDevice.platform}-${realDevice.version[0]}`);
    }
    if (this.isSimulator()) {
      result.push('dx-simulator');
    }
    if ((0, _config.default)().rtlEnabled) {
      result.push('dx-rtl');
    }
    return result;
  }
  attachCssClasses(element, device) {
    this._deviceClasses = this._getCssClasses(device).join(' ');
    (0, _renderer.default)(element).addClass(this._deviceClasses);
  }
  detachCssClasses(element) {
    (0, _renderer.default)(element).removeClass(this._deviceClasses);
  }
  isSimulator() {
    // NOTE: error may happen due to same-origin policy
    try {
      return this._isSimulator || (0, _window.hasWindow)() && this._window.top !== this._window.self && this._window.top['dx-force-device'] || this.isRippleEmulator();
    } catch (e) {
      return false;
    }
  }
  forceSimulator() {
    this._isSimulator = true;
  }
  _getDevice(deviceName) {
    if (deviceName === 'genericPhone') {
      deviceName = {
        deviceType: 'phone',
        platform: 'generic',
        generic: true
      };
    }
    if ((0, _type.isPlainObject)(deviceName)) {
      return this._fromConfig(deviceName);
    } else {
      let ua;
      if (deviceName) {
        ua = KNOWN_UA_TABLE[deviceName];
        if (!ua) {
          throw _errors.default.Error('E0005');
        }
      } else {
        const navigator = (0, _window.getNavigator)();
        ua = navigator.userAgent;
      }
      return this._fromUA(ua);
    }
  }
  _getDeviceOrNameFromWindowScope() {
    let result;
    if ((0, _window.hasWindow)() && (this._window.top['dx-force-device-object'] || this._window.top['dx-force-device'])) {
      result = this._window.top['dx-force-device-object'] || this._window.top['dx-force-device'];
    }
    return result;
  }
  _getDeviceNameFromSessionStorage() {
    const sessionStorage = (0, _storage.sessionStorage)();
    if (!sessionStorage) {
      return;
    }
    const deviceOrName = sessionStorage.getItem('dx-force-device');
    try {
      return JSON.parse(deviceOrName);
    } catch (ex) {
      return deviceOrName;
    }
  }
  _fromConfig(config) {
    const result = (0, _extend.extend)({}, DEFAULT_DEVICE, this._currentDevice, config);
    const shortcuts = {
      phone: result.deviceType === 'phone',
      tablet: result.deviceType === 'tablet',
      android: result.platform === 'android',
      ios: result.platform === 'ios',
      generic: result.platform === 'generic'
    };
    return (0, _extend.extend)(result, shortcuts);
  }
  _fromUA(ua) {
    for (let idx = 0; idx < UA_PARSERS_ARRAY.length; idx += 1) {
      const parser = UA_PARSERS_ARRAY[idx];
      const config = parser(ua);
      if (config) {
        return this._fromConfig(config);
      }
    }
    return DEFAULT_DEVICE;
  }
  _changeOrientation() {
    const $window = (0, _renderer.default)(this._window);
    const orientation = (0, _size.getHeight)($window) > (0, _size.getWidth)($window) ? 'portrait' : 'landscape';
    if (this._currentOrientation === orientation) {
      return;
    }
    this._currentOrientation = orientation;
    this._eventsStrategy.fireEvent('orientationChanged', [{
      orientation: orientation
    }]);
  }
  _recalculateOrientation() {
    const windowWidth = (0, _size.getWidth)(this._window);
    if (this._currentWidth === windowWidth) {
      return;
    }
    this._currentWidth = windowWidth;
    this._changeOrientation();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
}
const devices = new Devices();
const viewPortElement = (0, _view_port.value)();
if (viewPortElement) {
  devices.attachCssClasses(viewPortElement);
}
_view_port.changeCallback.add((viewPort, prevViewport) => {
  devices.detachCssClasses(prevViewport);
  devices.attachCssClasses(viewPort);
});
var _default = exports["default"] = devices;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 73349:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _common = __webpack_require__(20576);
var _shadow_dom = __webpack_require__(90330);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global document */

const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const DOCUMENT_NODE = 9;
const DOCUMENT_FRAGMENT_NODE = 11;
const nativeDOMAdapterStrategy = {
  querySelectorAll(element, selector) {
    return element.querySelectorAll(selector);
  },
  elementMatches(element, selector) {
    const matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || (selector => {
      const doc = element.document || element.ownerDocument;
      if (!doc) {
        return false;
      }
      const items = this.querySelectorAll(doc, selector);
      for (let i = 0; i < items.length; i++) {
        if (items[i] === element) {
          return true;
        }
      }
    });
    return matches.call(element, selector);
  },
  createElement(tagName, context) {
    context = context || this._document;
    return context.createElement(tagName);
  },
  createElementNS(ns, tagName, context) {
    context = context || this._document;
    return context.createElementNS(ns, tagName);
  },
  createTextNode(text, context) {
    context = context || this._document;
    return context.createTextNode(text);
  },
  createAttribute(text, context) {
    context = context || this._document;
    return context.createAttribute(text);
  },
  isNode(element) {
    return element && typeof element === 'object' && 'nodeType' in element && 'nodeName' in element;
  },
  isElementNode(element) {
    return element && element.nodeType === ELEMENT_NODE;
  },
  isTextNode(element) {
    return element && element.nodeType === TEXT_NODE;
  },
  isDocument(element) {
    return element && element.nodeType === DOCUMENT_NODE;
  },
  isDocumentFragment(element) {
    return element && element.nodeType === DOCUMENT_FRAGMENT_NODE;
  },
  removeElement(element) {
    const parentNode = element && element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  },
  insertElement(parentElement, newElement, nextSiblingElement) {
    if (parentElement && newElement && parentElement !== newElement) {
      if (nextSiblingElement) {
        parentElement.insertBefore(newElement, nextSiblingElement);
      } else {
        parentElement.appendChild(newElement);
      }
    }
  },
  getAttribute(element, name) {
    return element.getAttribute(name);
  },
  setAttribute(element, name, value) {
    if (name === 'style') {
      element.style.cssText = value;
    } else {
      element.setAttribute(name, value);
    }
  },
  removeAttribute(element, name) {
    element.removeAttribute(name);
  },
  setProperty(element, name, value) {
    element[name] = value;
  },
  setText(element, text) {
    if (element) {
      element.textContent = text;
    }
  },
  setClass(element, className, isAdd) {
    if (element.nodeType === 1 && className) {
      isAdd ? element.classList.add(className) : element.classList.remove(className);
    }
  },
  setStyle(element, name, value) {
    element.style[name] = value || '';
  },
  _document: typeof document === 'undefined' ? undefined : document,
  getDocument() {
    return this._document;
  },
  getActiveElement(element) {
    const activeElementHolder = this.getRootNode(element);
    return activeElementHolder.activeElement;
  },
  getRootNode(element) {
    var _element$getRootNode;
    return (element === null || element === void 0 || (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element)) ?? this._document;
  },
  getBody() {
    return this._document.body;
  },
  createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation() {
    return this._document.location;
  },
  getSelection() {
    return this._document.selection;
  },
  getReadyState() {
    return this._document.readyState;
  },
  getHead() {
    return this._document.head;
  },
  hasDocumentProperty(property) {
    return property in this._document;
  },
  listen(element, event, callback, options) {
    if (!element || !('addEventListener' in element)) {
      return _common.noop;
    }
    element.addEventListener(event, callback, options);
    return () => {
      element.removeEventListener(event, callback);
    };
  },
  elementsFromPoint(x, y, element) {
    const activeElementHolder = this.getRootNode(element);
    if (activeElementHolder.host) {
      return (0, _shadow_dom.getShadowElementsFromPoint)(x, y, activeElementHolder);
    }
    return activeElementHolder.elementsFromPoint(x, y);
  }
};
var _default = exports["default"] = (0, _dependency_injector.default)(nativeDOMAdapterStrategy);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 13046:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dom_component = _interopRequireDefault(__webpack_require__(29783));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _dom_component.default;
/**
 * @name DOMComponent.ctor
 * @publicName ctor(element,options)
 * @param1 element:Element|JQuery
 * @param2 options:DOMComponentOptions|undefined
 * @hidden
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 6415:
/***/ (function(__unused_webpack_module, exports) {



exports.getPublicElement = getPublicElement;
exports.getPublicElementNonJquery = getPublicElementNonJquery;
exports.setPublicElementWrapper = setPublicElementWrapper;
function getPublicElementNonJquery(element) {
  if (element && element.get) {
    return element.get(0);
  }
  return element;
}
let strategy = getPublicElementNonJquery;
function getPublicElement(element) {
  return strategy(element);
}
function setPublicElementWrapper(newStrategy) {
  strategy = newStrategy;
}

/***/ }),

/***/ 97906:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.afterCleanData = afterCleanData;
exports.beforeCleanData = beforeCleanData;
exports.cleanData = cleanData;
exports.cleanDataRecursive = cleanDataRecursive;
exports.data = data;
exports.getDataStrategy = getDataStrategy;
exports.removeData = removeData;
exports.strategyChanging = exports.setDataStrategy = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _memorized_callbacks = _interopRequireDefault(__webpack_require__(83358));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const dataMap = new WeakMap();
let strategy;
const strategyChanging = exports.strategyChanging = new _memorized_callbacks.default();
let beforeCleanDataFunc = function () {};
let afterCleanDataFunc = function () {};
const setDataStrategy = function (value) {
  strategyChanging.fire(value);
  strategy = value;
  const cleanData = strategy.cleanData;
  strategy.cleanData = function (nodes) {
    beforeCleanDataFunc(nodes);
    const result = cleanData.call(this, nodes);
    afterCleanDataFunc(nodes);
    return result;
  };
};
exports.setDataStrategy = setDataStrategy;
setDataStrategy({
  data: function () {
    const element = arguments[0];
    const key = arguments[1];
    const value = arguments[2];
    if (!element) return;
    let elementData = dataMap.get(element);
    if (!elementData) {
      elementData = {};
      dataMap.set(element, elementData);
    }
    if (key === undefined) {
      return elementData;
    }
    if (arguments.length === 2) {
      return elementData[key];
    }
    elementData[key] = value;
    return value;
  },
  removeData: function (element, key) {
    if (!element) return;
    if (key === undefined) {
      dataMap.delete(element);
    } else {
      const elementData = dataMap.get(element);
      if (elementData) {
        delete elementData[key];
      }
    }
  },
  cleanData: function (elements) {
    for (let i = 0; i < elements.length; i++) {
      _events_engine.default.off(elements[i]);
      dataMap.delete(elements[i]);
    }
  }
});
function getDataStrategy() {
  return strategy;
}
function data() {
  return strategy.data.apply(this, arguments);
}
function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}
function afterCleanData(callback) {
  afterCleanDataFunc = callback;
}
function cleanData(nodes) {
  return strategy.cleanData.call(this, nodes);
}
function removeData(element, key) {
  return strategy.removeData.call(this, element, key);
}
function cleanDataRecursive(element, cleanSelf) {
  if (!_dom_adapter.default.isElementNode(element)) {
    return;
  }
  const childElements = element.getElementsByTagName('*');
  strategy.cleanData(childElements);
  if (cleanSelf) {
    strategy.cleanData([element]);
  }
}

/***/ }),

/***/ 17381:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _error = _interopRequireDefault(__webpack_require__(95640));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
* @docid
* @name ErrorsCore
*/
var _default = exports["default"] = (0, _error.default)({
  /**
  * @name ErrorsCore.E0001
  */
  E0001: 'Method is not implemented',
  /**
  * @name ErrorsCore.E0002
  */
  E0002: 'Member name collision: {0}',
  /**
  * @name ErrorsCore.E0003
  */
  E0003: 'A class must be instantiated using the \'new\' keyword',
  /**
  * @name ErrorsCore.E0004
  */
  E0004: 'The NAME property of the component is not specified',
  /**
  * @name ErrorsCore.E0005
  */
  E0005: 'Unknown device',
  /**
  * @name ErrorsCore.E0006
  */
  E0006: 'Unknown endpoint key is requested',
  /**
  * @name ErrorsCore.E0007
  */
  E0007: '\'Invalidate\' method is called outside the update transaction',
  /**
  * @name ErrorsCore.E0008
  */
  E0008: 'Type of the option name is not appropriate to create an action',
  /**
  * @name ErrorsCore.E0009
  */
  E0009: 'Component \'{0}\' has not been initialized for an element',
  /**
  * @name ErrorsCore.E0010
  */
  E0010: 'Animation configuration with the \'{0}\' type requires \'{1}\' configuration as {2}',
  /**
  * @name ErrorsCore.E0011
  */
  E0011: 'Unknown animation type \'{0}\'',
  /**
  * @name ErrorsCore.E0012
  */
  E0012: 'jQuery version is too old. Please upgrade jQuery to 1.10.0 or later',
  /**
  * @name ErrorsCore.E0013
  */
  E0013: 'KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later',
  /**
  * @name ErrorsCore.E0014
  */
  E0014: 'The \'release\' method shouldn\'t be called for an unlocked Lock object',
  /**
  * @name ErrorsCore.E0015
  */
  E0015: 'Queued task returned an unexpected result',
  /**
  * @name ErrorsCore.E0017
  */
  E0017: 'Event namespace is not defined',
  /**
  * @name ErrorsCore.E0018
  */
  E0018: 'DevExpress.ui.DevExpressPopup widget is required',
  /**
  * @name ErrorsCore.E0020
  */
  E0020: 'Template engine \'{0}\' is not supported',
  /**
  * @name ErrorsCore.E0021
  */
  E0021: 'Unknown theme is set: {0}',
  /**
  * @name ErrorsCore.E0022
  */
  E0022: 'LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts',
  /**
  * @name ErrorsCore.E0023
  */
  E0023: 'Template name is not specified',
  /**
  * @name ErrorsCore.E0024
  */
  E0024: 'DevExtreme bundle already included',
  /**
  * @name ErrorsCore.E0025
  */
  E0025: 'Unexpected argument type',
  /**
  * @name ErrorsCore.E0100
  */
  E0100: 'Unknown validation type is detected',
  /**
  * @name ErrorsCore.E0101
  */
  E0101: 'Misconfigured range validation rule is detected',
  /**
  * @name ErrorsCore.E0102
  */
  E0102: 'Misconfigured comparison validation rule is detected',
  /**
  * @name ErrorsCore.E0103
  */
  E0103: 'validationCallback of an asynchronous rule should return a jQuery or a native promise',
  /**
  * @name ErrorsCore.E0110
  */
  E0110: 'Unknown validation group is detected',
  /**
  * @name ErrorsCore.E0120
  */
  E0120: 'Adapter for a DevExpressValidator component cannot be configured',
  /**
  * @name ErrorsCore.E0121
  */
  E0121: 'The \'customItem\' parameter of the \'onCustomItemCreating\' function is empty or contains invalid data. Assign a custom object or a Promise that is resolved after the item is created.',
  /**
  * @name ErrorsCore.W0000
  */
  W0000: '\'{0}\' is deprecated in {1}. {2}',
  /**
  * @name ErrorsCore.W0001
  */
  W0001: '{0} - \'{1}\' option is deprecated in {2}. {3}',
  /**
  * @name ErrorsCore.W0002
  */
  W0002: '{0} - \'{1}\' method is deprecated in {2}. {3}',
  /**
  * @name ErrorsCore.W0003
  */
  W0003: '{0} - \'{1}\' property is deprecated in {2}. {3}',
  /**
  * @name ErrorsCore.W0004
  */
  W0004: 'Timeout for theme loading is over: {0}',
  /**
  * @name ErrorsCore.W0005
  */
  W0005: '\'{0}\' event is deprecated in {1}. {2}',
  /**
  * @name ErrorsCore.W0006
  */
  W0006: 'Invalid recurrence rule: \'{0}\'',
  /**
  * @name ErrorsCore.W0007
  */
  W0007: '\'{0}\' Globalize culture is not defined',
  /**
  * @name ErrorsCore.W0008
  */
  W0008: 'Invalid view name: \'{0}\'',
  /**
  * @name ErrorsCore.W0009
  */
  W0009: 'Invalid time zone name: \'{0}\'',
  /**
  * @name ErrorsCore.W0010
  */
  W0010: '{0} is deprecated in {1}. {2}',
  /**
  * @name ErrorsCore.W0011
  */
  W0011: 'Number parsing is invoked while the parser is not defined',
  /**
  * @name ErrorsCore.W0012
  */
  W0012: 'Date parsing is invoked while the parser is not defined',
  /**
  * @name ErrorsCore.W0013
  */
  W0013: '\'{0}\' file is deprecated in {1}. {2}',
  /**
  * @name ErrorsCore.W0014
  */
  W0014: '{0} - \'{1}\' type is deprecated in {2}. {3}',
  /**
  * @name ErrorsCore.W0015
  */
  W0015: 'Instead of returning a value from the \'{0}\' function, write it into the \'{1}\' field of the function\'s parameter.',
  /**
  * @name ErrorsCore.W0016
  */
  W0016: 'The "{0}" option does not accept the "{1}" value since v{2}. {3}.',
  /**
  * @name ErrorsCore.W0017
  */
  W0017: 'Setting the "{0}" property with a function is deprecated since v21.2',
  /**
  * @name ErrorsCore.W0018
  */
  W0018: 'Setting the "position" property with a function is deprecated since v21.2',
  /**
  * @name ErrorsCore.W0019
  */
  W0019: 'DevExtreme: Unable to Locate a Valid License Key.\n\n' + 'If you are using a 30-day trial version of DevExtreme, you must uninstall all copies of DevExtreme once your 30-day trial period expires. For terms and conditions that govern use of DevExtreme UI components/libraries, please refer to the DevExtreme End User License Agreement: https://js.devexpress.com/EULAs/DevExtremeComplete.\n\n' + 'To use DevExtreme in a commercial project, you must purchase a license. For pricing/licensing options, please visit: https://js.devexpress.com/Buy.\n\n' + 'If you have licensing-related questions or need help with a purchase, please email clientservices@devexpress.com.\n\n',
  /**
   * @name ErrorsCore.W0020
   */
  W0020: 'DevExtreme: License Key Has Expired.\n\n' + 'A mismatch exists between the license key used and the DevExtreme version referenced in this project.\n\n' + 'To proceed, you can:\n' + ' use a version of DevExtreme linked to your license key: https://www.devexpress.com/ClientCenter/DownloadManager\n' + ' renew your DevExpress Subscription: https://www.devexpress.com/buy/renew (once you renew your subscription, you will be entitled to product updates and support service as defined in the DevExtreme End User License Agreement)\n\n' + 'If you have licensing-related questions or need help with a renewal, please email clientservices@devexpress.com.\n\n',
  /**
   * @name ErrorsCore.W0021
   */
  W0021: 'DevExtreme: License Key Verification Has Failed.\n\n' + 'To verify your DevExtreme license, make certain to specify a correct key in the GlobalConfig. If you continue to encounter this error, please visit https://www.devexpress.com/ClientCenter/DownloadManager to obtain a valid license key.\n\n' + 'If you have a valid license and this problem persists, please submit a support ticket via the DevExpress Support Center. We will be happy to follow-up: https://supportcenter.devexpress.com/ticket/create.\n\n',
  /**
   * @name ErrorsCore.W0022
   */
  W0022: 'DevExtreme: Pre-release software. Not suitable for commercial use.\n\n' + 'Pre-release software may contain deficiencies and as such, should not be considered for use or integrated in any mission critical application.\n\n',
  /**
   * @name ErrorsCore.W0023
   */
  W0023: 'DevExtreme: the following \'devextreme\' package version does not match versions of other DevExpress products used in this application:\n\n' + '{0}\n\n' + 'Interoperability between different versions of the products listed herein cannot be guaranteed.\n\n'
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 80566:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.EventsStrategy = void 0;
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class EventsStrategy {
  constructor(owner) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this._events = {};
    this._owner = owner;
    this._options = options;
  }
  static create(owner, strategy) {
    if (strategy) {
      return (0, _type.isFunction)(strategy) ? strategy(owner) : strategy;
    } else {
      return new EventsStrategy(owner);
    }
  }
  hasEvent(eventName) {
    const callbacks = this._events[eventName];
    return callbacks ? callbacks.has() : false;
  }
  fireEvent(eventName, eventArgs) {
    const callbacks = this._events[eventName];
    if (callbacks) {
      callbacks.fireWith(this._owner, eventArgs);
    }
    return this._owner;
  }
  on(eventName, eventHandler) {
    if ((0, _type.isPlainObject)(eventName)) {
      (0, _iterator.each)(eventName, (e, h) => {
        this.on(e, h);
      });
    } else {
      let callbacks = this._events[eventName];
      if (!callbacks) {
        callbacks = (0, _callbacks.default)({
          syncStrategy: this._options.syncStrategy
        });
        this._events[eventName] = callbacks;
      }
      const addFn = callbacks.originalAdd || callbacks.add;
      addFn.call(callbacks, eventHandler);
    }
  }
  off(eventName, eventHandler) {
    const callbacks = this._events[eventName];
    if (callbacks) {
      if ((0, _type.isFunction)(eventHandler)) {
        callbacks.remove(eventHandler);
      } else {
        callbacks.empty();
      }
    }
  }
  dispose() {
    (0, _iterator.each)(this._events, (eventName, event) => {
      event.empty();
    });
  }
}
exports.EventsStrategy = EventsStrategy;

/***/ }),

/***/ 73176:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const Guid = _class.default.inherit({
  /**
  * @name Guid.ctor
  * @publicName ctor()
  */
  /**
  * @name Guid.ctor
  * @publicName ctor(value)
  * @param1 value:string
  */
  ctor: function (value) {
    if (value) {
      value = String(value);
    }
    this._value = this._normalize(value || this._generate());
  },
  _normalize: function (value) {
    value = value.replace(/[^a-f0-9]/ig, '').toLowerCase();
    while (value.length < 32) {
      value += '0';
    }
    return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join('-');
  },
  _generate: function () {
    let value = '';
    for (let i = 0; i < 32; i++) {
      value += Math.round(Math.random() * 15).toString(16);
    }
    return value;
  },
  toString: function () {
    return this._value;
  },
  valueOf: function () {
    return this._value;
  },
  toJSON: function () {
    return this._value;
  }
});
var _default = exports["default"] = Guid;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 83448:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _window = __webpack_require__(58201);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const nativeXMLHttpRequest = {
  getXhr: function () {
    return new window.XMLHttpRequest();
  }
};
var _default = exports["default"] = (0, _dependency_injector.default)(nativeXMLHttpRequest);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 15334:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _inferno = __webpack_require__(78089);
var _inferno2 = __webpack_require__(33791);
var _infernoCreateElement = __webpack_require__(50477);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _element_data = __webpack_require__(97906);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const remove = element => {
  const {
    parentNode
  } = element;
  if (parentNode) {
    const nextSibling = element.nextSibling;
    (0, _element_data.cleanDataRecursive)(element);
    parentNode.$V = element.$V;
    (0, _inferno.render)(null, parentNode);
    parentNode.insertBefore(element, nextSibling);
    element.innerHTML = '';
    delete parentNode.$V;
  }
  delete element.$V;
};
var _default = exports["default"] = (0, _dependency_injector.default)({
  createElement: (component, props) => (0, _infernoCreateElement.createElement)(component, props),
  remove,
  onAfterRender: () => {
    _inferno2.InfernoEffectHost.callEffects();
  },
  onPreRender: () => {
    _inferno2.InfernoEffectHost.lock();
  },
  render: (component, props, container, replace) => {
    if (!replace) {
      const {
        parentNode
      } = container;
      const nextNode = container === null || container === void 0 ? void 0 : container.nextSibling;
      const rootNode = _dom_adapter.default.createElement('div');
      rootNode.appendChild(container);
      const mountNode = _dom_adapter.default.createDocumentFragment().appendChild(rootNode);
      const vNodeAlreadyExists = !!container.$V;
      vNodeAlreadyExists && remove(container);
      (0, _inferno2.hydrate)((0, _infernoCreateElement.createElement)(component, props), mountNode);
      container.$V = mountNode.$V;
      if (parentNode) {
        parentNode.insertBefore(container, nextNode);
      }
    } else {
      (0, _inferno.render)((0, _infernoCreateElement.createElement)(component, props), container);
    }
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 83358:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class MemorizedCallbacks {
  constructor() {
    this.memory = [];
    this.callbacks = (0, _callbacks.default)();
  }
  add(fn) {
    (0, _iterator.each)(this.memory, (_, item) => fn.apply(fn, item));
    this.callbacks.add(fn);
  }
  remove(fn) {
    this.callbacks.remove(fn);
  }
  fire() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.memory.push(args);
    this.callbacks.fire.apply(this.callbacks, args);
  }
}
exports["default"] = MemorizedCallbacks;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 95683:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Options = void 0;
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _option_manager = __webpack_require__(9030);
var _data = __webpack_require__(47617);
var _utils = __webpack_require__(45434);
var _extend = __webpack_require__(13306);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
class Options {
  constructor(options, defaultOptions, optionsByReference, deprecatedOptions) {
    this._deprecatedCallback;
    this._startChangeCallback;
    this._endChangeCallback;
    this._default = defaultOptions;
    this._deprecated = deprecatedOptions;
    this._deprecatedNames = [];
    this._initDeprecatedNames();
    this._optionManager = new _option_manager.OptionManager(options, optionsByReference);
    this._optionManager.onRelevantNamesPrepared((options, name, value, silent) => this._setRelevantNames(options, name, value, silent));
    this._cachedOptions = {};
    this._rules = [];
  }
  set _initial(value) {
    this._initialOptions = value;
  }
  get _initial() {
    if (!this._initialOptions) {
      const rulesOptions = this._getByRules(this.silent('defaultOptionsRules'));
      this._initialOptions = this._default;
      this._optionManager._setByReference(this._initialOptions, rulesOptions);
    }
    return this._initialOptions;
  }
  _initDeprecatedNames() {
    for (const optionName in this._deprecated) {
      this._deprecatedNames.push(optionName);
    }
  }
  _getByRules(rules) {
    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
    return (0, _utils.convertRulesToOptions)(rules);
  }
  _notifyDeprecated(option) {
    const info = this._deprecated[option];
    if (info) {
      this._deprecatedCallback(option, info);
    }
  }
  _setRelevantNames(options, name, value, silent) {
    if (name) {
      const normalizedName = this._normalizeName(name, silent);
      if (normalizedName && normalizedName !== name) {
        this._setField(options, normalizedName, value);
        this._clearField(options, name);
      }
    }
  }
  _setField(options, fullName, value) {
    let fieldName = '';
    let fieldObject = null;
    do {
      fieldName = fieldName ? `.${fieldName}` : '';
      fieldName = (0, _utils.getFieldName)(fullName) + fieldName;
      fullName = (0, _utils.getParentName)(fullName);
      fieldObject = fullName ? this._optionManager.get(options, fullName, false) : options;
    } while (!fieldObject);
    fieldObject[fieldName] = value;
  }
  _clearField(options, name) {
    delete options[name];
    const previousFieldName = (0, _utils.getParentName)(name);
    const fieldObject = previousFieldName ? this._optionManager.get(options, previousFieldName, false) : options;
    if (fieldObject) {
      delete fieldObject[(0, _utils.getFieldName)(name)];
    }
  }
  _normalizeName(name, silent) {
    if (this._deprecatedNames.length && name) {
      for (let i = 0; i < this._deprecatedNames.length; i++) {
        if (this._deprecatedNames[i] === name) {
          const deprecate = this._deprecated[name];
          if (deprecate) {
            !silent && this._notifyDeprecated(name);
            return deprecate.alias || name;
          }
        }
      }
    }
    return name;
  }
  addRules(rules) {
    this._rules = rules.concat(this._rules);
  }
  applyRules(rules) {
    const options = this._getByRules(rules);
    this.silent(options);
  }
  dispose() {
    this._deprecatedCallback = _common.noop;
    this._startChangeCallback = _common.noop;
    this._endChangeCallback = _common.noop;
    this._optionManager.dispose();
  }
  onChanging(callBack) {
    this._optionManager.onChanging(callBack);
  }
  onChanged(callBack) {
    this._optionManager.onChanged(callBack);
  }
  onDeprecated(callBack) {
    this._deprecatedCallback = callBack;
  }
  onStartChange(callBack) {
    this._startChangeCallback = callBack;
  }
  onEndChange(callBack) {
    this._endChangeCallback = callBack;
  }
  isInitial(name) {
    const value = this.silent(name);
    const initialValue = this.initial(name);
    const areFunctions = (0, _type.isFunction)(value) && (0, _type.isFunction)(initialValue);
    return areFunctions ? value.toString() === initialValue.toString() : (0, _common.equalByValue)(value, initialValue);
  }
  initial(name) {
    return (0, _utils.getNestedOptionValue)(this._initial, name);
  }
  option(options, value) {
    const isGetter = arguments.length < 2 && (0, _type.type)(options) !== 'object';
    if (isGetter) {
      return this._optionManager.get(undefined, this._normalizeName(options));
    } else {
      this._startChangeCallback();
      try {
        this._optionManager.set(options, value);
      } finally {
        this._endChangeCallback();
      }
    }
  }
  silent(options, value) {
    const isGetter = arguments.length < 2 && (0, _type.type)(options) !== 'object';
    if (isGetter) {
      return this._optionManager.get(undefined, options, undefined, true);
    } else {
      this._optionManager.set(options, value, undefined, true);
    }
  }
  reset(name) {
    if (name) {
      const fullPath = (0, _data.getPathParts)(name);
      const value = fullPath.reduce((value, field) => value ? value[field] : this.initial(field), null);
      const defaultValue = (0, _type.isObject)(value) ? _extends({}, value) : value;
      this._optionManager.set(name, defaultValue, false);
    }
  }
  getAliasesByName(name) {
    return Object.keys(this._deprecated).filter(aliasName => name === this._deprecated[aliasName].alias);
  }
  isDeprecated(name) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, name);
  }
  cache(name, options) {
    const isGetter = arguments.length < 2;
    if (isGetter) {
      return this._cachedOptions[name];
    } else {
      this._cachedOptions[name] = (0, _extend.extend)(this._cachedOptions[name], options);
    }
  }
}
exports.Options = Options;

/***/ }),

/***/ 9030:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.OptionManager = void 0;
var _data = __webpack_require__(47617);
var _common = __webpack_require__(20576);
var _comparator = __webpack_require__(49036);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(45434);
const cachedGetters = {};
const cachedSetters = {};
class OptionManager {
  constructor(options, optionsByReference) {
    this._options = options;
    this._optionsByReference = optionsByReference;
    this._changingCallback;
    this._changedCallback;
    this._namePreparedCallbacks;
  }
  _setByReference(options, rulesOptions) {
    (0, _extend.extend)(true, options, rulesOptions);
    for (const fieldName in this._optionsByReference) {
      if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
        options[fieldName] = rulesOptions[fieldName];
      }
    }
  }
  _setPreparedValue(name, value, merge, silent) {
    const previousValue = this.get(this._options, name, false);
    if (!(0, _comparator.equals)(previousValue, value)) {
      const path = (0, _data.getPathParts)(name);
      !silent && this._changingCallback(name, previousValue, value);
      cachedSetters[name] = cachedSetters[name] || (0, _data.compileSetter)(name);
      cachedSetters[name](this._options, value, {
        functionsAsIs: true,
        merge: (0, _type.isDefined)(merge) ? merge : !this._optionsByReference[name],
        unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
      });
      !silent && this._changedCallback(name, value, previousValue);
    }
  }
  _prepareRelevantNames(options, name, value, silent) {
    if ((0, _type.isPlainObject)(value)) {
      for (const valueName in value) {
        this._prepareRelevantNames(options, `${name}.${valueName}`, value[valueName]);
      }
    }
    this._namePreparedCallbacks(options, name, value, silent);
  }
  get() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._options;
    let name = arguments.length > 1 ? arguments[1] : undefined;
    let unwrapObservables = arguments.length > 2 ? arguments[2] : undefined;
    cachedGetters[name] = cachedGetters[name] || (0, _data.compileGetter)(name);
    return cachedGetters[name](options, {
      functionsAsIs: true,
      unwrapObservables
    });
  }
  set(options, value, merge, silent) {
    options = (0, _utils.normalizeOptions)(options, value);
    for (const name in options) {
      this._prepareRelevantNames(options, name, options[name], silent);
    }
    for (const name in options) {
      this._setPreparedValue(name, options[name], merge, silent);
    }
  }
  onRelevantNamesPrepared(callBack) {
    this._namePreparedCallbacks = callBack;
  }
  onChanging(callBack) {
    this._changingCallback = callBack;
  }
  onChanged(callBack) {
    this._changedCallback = callBack;
  }
  dispose() {
    this._changingCallback = _common.noop;
    this._changedCallback = _common.noop;
  }
}
exports.OptionManager = OptionManager;

/***/ }),

/***/ 45434:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.normalizeOptions = exports.getParentName = exports.getNestedOptionValue = exports.getFieldName = exports.deviceMatch = exports.createDefaultOptionRules = exports.convertRulesToOptions = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _data = __webpack_require__(47617);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const cachedGetters = {};
const convertRulesToOptions = rules => {
  const currentDevice = _devices.default.current();
  return rules.reduce((options, _ref) => {
    let {
      device,
      options: ruleOptions
    } = _ref;
    const deviceFilter = device || {};
    const match = (0, _type.isFunction)(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
    if (match) {
      (0, _extend.extend)(true, options, ruleOptions);
    }
    return options;
  }, {});
};
exports.convertRulesToOptions = convertRulesToOptions;
const normalizeOptions = (options, value) => {
  return typeof options !== 'string' ? options : {
    [options]: value
  };
};
exports.normalizeOptions = normalizeOptions;
const deviceMatch = (device, filter) => (0, _type.isEmptyObject)(filter) || (0, _common.findBestMatches)(device, [filter]).length > 0;
exports.deviceMatch = deviceMatch;
const getFieldName = fullName => fullName.substr(fullName.lastIndexOf('.') + 1);
exports.getFieldName = getFieldName;
const getParentName = fullName => fullName.substr(0, fullName.lastIndexOf('.'));
exports.getParentName = getParentName;
const getNestedOptionValue = function (optionsObject, name) {
  cachedGetters[name] = cachedGetters[name] || (0, _data.compileGetter)(name);
  return cachedGetters[name](optionsObject, {
    functionsAsIs: true
  });
};
exports.getNestedOptionValue = getNestedOptionValue;
const createDefaultOptionRules = function () {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return options;
};
exports.createDefaultOptionRules = createDefaultOptionRules;

/***/ }),

/***/ 90889:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.PostponedOperations = void 0;
var _deferred = __webpack_require__(62754);
var _type = __webpack_require__(35922);
class PostponedOperations {
  constructor() {
    this._postponedOperations = {};
  }
  add(key, fn, postponedPromise) {
    if (key in this._postponedOperations) {
      postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
    } else {
      const completePromise = new _deferred.Deferred();
      this._postponedOperations[key] = {
        fn: fn,
        completePromise: completePromise,
        promises: postponedPromise ? [postponedPromise] : []
      };
    }
    return this._postponedOperations[key].completePromise.promise();
  }
  callPostponedOperations() {
    for (const key in this._postponedOperations) {
      const operation = this._postponedOperations[key];
      if ((0, _type.isDefined)(operation)) {
        if (operation.promises && operation.promises.length) {
          (0, _deferred.when)(...operation.promises).done(operation.fn).then(operation.completePromise.resolve);
        } else {
          operation.fn().done(operation.completePromise.resolve);
        }
      }
    }
    this._postponedOperations = {};
  }
}
exports.PostponedOperations = PostponedOperations;

/***/ }),

/***/ 68374:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer_base = _interopRequireDefault(__webpack_require__(82981));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _renderer_base.default.get();
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82981:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _element_data = __webpack_require__(97906);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _type = __webpack_require__(35922);
var _style = __webpack_require__(80968);
var _size = __webpack_require__(58664);
var _html_parser = __webpack_require__(61371);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
let renderer;
const initRender = function (selector, context) {
  if (!selector) {
    this.length = 0;
    return this;
  }
  if (typeof selector === 'string') {
    if (selector === 'body') {
      this[0] = context ? context.body : _dom_adapter.default.getBody();
      this.length = 1;
      return this;
    }
    context = context || _dom_adapter.default.getDocument();
    if (selector[0] === '<') {
      this[0] = _dom_adapter.default.createElement(selector.slice(1, -1), context);
      this.length = 1;
      return this;
    }
    [].push.apply(this, _dom_adapter.default.querySelectorAll(context, selector));
    return this;
  } else if (_dom_adapter.default.isNode(selector) || (0, _type.isWindow)(selector)) {
    this[0] = selector;
    this.length = 1;
    return this;
  } else if (Array.isArray(selector)) {
    [].push.apply(this, selector);
    return this;
  }
  return renderer(selector.toArray ? selector.toArray() : [selector]);
};
renderer = function (selector, context) {
  return new initRender(selector, context);
};
renderer.fn = {
  dxRenderer: true
};
initRender.prototype = renderer.fn;
const repeatMethod = function (methodName, args) {
  for (let i = 0; i < this.length; i++) {
    const item = renderer(this[i]);
    item[methodName].apply(item, args);
  }
  return this;
};
const setAttributeValue = function (element, attrName, value) {
  if (value !== undefined && value !== null && value !== false) {
    _dom_adapter.default.setAttribute(element, attrName, value);
  } else {
    _dom_adapter.default.removeAttribute(element, attrName);
  }
};
initRender.prototype.show = function () {
  return this.toggle(true);
};
initRender.prototype.hide = function () {
  return this.toggle(false);
};
initRender.prototype.toggle = function (value) {
  if (this[0]) {
    this.toggleClass('dx-state-invisible', !value);
  }
  return this;
};
initRender.prototype.attr = function (attrName, value) {
  if (this.length > 1 && arguments.length > 1) return repeatMethod.call(this, 'attr', arguments);
  if (!this[0]) {
    if ((0, _type.isObject)(attrName) || value !== undefined) {
      return this;
    } else {
      return undefined;
    }
  }
  if (!this[0].getAttribute) {
    return this.prop(attrName, value);
  }
  if (typeof attrName === 'string' && arguments.length === 1) {
    const result = this[0].getAttribute(attrName);
    return result == null ? undefined : result;
  } else if ((0, _type.isPlainObject)(attrName)) {
    for (const key in attrName) {
      this.attr(key, attrName[key]);
    }
  } else {
    setAttributeValue(this[0], attrName, value);
  }
  return this;
};
initRender.prototype.removeAttr = function (attrName) {
  this[0] && _dom_adapter.default.removeAttribute(this[0], attrName);
  return this;
};
initRender.prototype.prop = function (propName, value) {
  if (!this[0]) return this;
  if (typeof propName === 'string' && arguments.length === 1) {
    return this[0][propName];
  } else if ((0, _type.isPlainObject)(propName)) {
    for (const key in propName) {
      this.prop(key, propName[key]);
    }
  } else {
    _dom_adapter.default.setProperty(this[0], propName, value);
  }
  return this;
};
initRender.prototype.addClass = function (className) {
  return this.toggleClass(className, true);
};
initRender.prototype.removeClass = function (className) {
  return this.toggleClass(className, false);
};
initRender.prototype.hasClass = function (className) {
  if (!this[0] || this[0].className === undefined) return false;
  const classNames = className.split(' ');
  for (let i = 0; i < classNames.length; i++) {
    if (this[0].classList) {
      if (this[0].classList.contains(classNames[i])) return true;
    } else {
      // IE9
      const className = (0, _type.isString)(this[0].className) ? this[0].className : _dom_adapter.default.getAttribute(this[0], 'class');
      if ((className || '').split(' ').indexOf(classNames[i]) >= 0) return true;
    }
  }
  return false;
};
initRender.prototype.toggleClass = function (className, value) {
  if (this.length > 1) {
    return repeatMethod.call(this, 'toggleClass', arguments);
  }
  if (!this[0] || !className) return this;
  value = value === undefined ? !this.hasClass(className) : value;
  const classNames = className.split(' ');
  for (let i = 0; i < classNames.length; i++) {
    _dom_adapter.default.setClass(this[0], classNames[i], value);
  }
  return this;
};
initRender.prototype.html = function (value) {
  if (!arguments.length) {
    return this[0].innerHTML;
  }
  this.empty();
  if (typeof value === 'string' && !(0, _html_parser.isTablePart)(value) || typeof value === 'number') {
    this[0].innerHTML = value;
    return this;
  }
  return this.append((0, _html_parser.parseHTML)(value));
};
const appendElements = function (element, nextSibling) {
  if (!this[0] || !element) return;
  if (typeof element === 'string') {
    element = (0, _html_parser.parseHTML)(element);
  } else if (element.nodeType) {
    element = [element];
  } else if ((0, _type.isNumeric)(element)) {
    element = [_dom_adapter.default.createTextNode(element)];
  }
  for (let i = 0; i < element.length; i++) {
    const item = element[i];
    let container = this[0];
    const wrapTR = container.tagName === 'TABLE' && item.tagName === 'TR';
    if (wrapTR && container.tBodies && container.tBodies.length) {
      container = container.tBodies[0];
    }
    _dom_adapter.default.insertElement(container, item.nodeType ? item : item[0], nextSibling);
  }
};
const setCss = function (name, value) {
  if (!this[0] || !this[0].style) return;
  if (value === null || typeof value === 'number' && isNaN(value)) {
    return;
  }
  name = (0, _style.styleProp)(name);
  for (let i = 0; i < this.length; i++) {
    this[i].style[name] = (0, _style.normalizeStyleProp)(name, value);
  }
};
initRender.prototype.css = function (name, value) {
  if ((0, _type.isString)(name)) {
    if (arguments.length === 2) {
      setCss.call(this, name, value);
    } else {
      if (!this[0]) return;
      name = (0, _style.styleProp)(name);
      const result = window.getComputedStyle(this[0])[name] || this[0].style[name];
      return (0, _type.isNumeric)(result) ? result.toString() : result;
    }
  } else if ((0, _type.isPlainObject)(name)) {
    for (const key in name) {
      setCss.call(this, key, name[key]);
    }
  }
  return this;
};
initRender.prototype.prepend = function (element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.prepend(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element, this[0].firstChild]);
  return this;
};
initRender.prototype.append = function (element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.append(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element]);
  return this;
};
initRender.prototype.prependTo = function (element) {
  if (this.length > 1) {
    for (let i = this.length - 1; i >= 0; i--) {
      renderer(this[i]).prependTo(element);
    }
    return this;
  }
  element = renderer(element);
  if (element[0]) {
    _dom_adapter.default.insertElement(element[0], this[0], element[0].firstChild);
  }
  return this;
};
initRender.prototype.appendTo = function (element) {
  if (this.length > 1) {
    return repeatMethod.call(this, 'appendTo', arguments);
  }
  _dom_adapter.default.insertElement(renderer(element)[0], this[0]);
  return this;
};
initRender.prototype.insertBefore = function (element) {
  if (element && element[0]) {
    _dom_adapter.default.insertElement(element[0].parentNode, this[0], element[0]);
  }
  return this;
};
initRender.prototype.insertAfter = function (element) {
  if (element && element[0]) {
    _dom_adapter.default.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
  }
  return this;
};
initRender.prototype.before = function (element) {
  if (this[0]) {
    _dom_adapter.default.insertElement(this[0].parentNode, element[0], this[0]);
  }
  return this;
};
initRender.prototype.after = function (element) {
  if (this[0]) {
    _dom_adapter.default.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
  }
  return this;
};
initRender.prototype.wrap = function (wrapper) {
  if (this[0]) {
    const wrap = renderer(wrapper);
    wrap.insertBefore(this);
    wrap.append(this);
  }
  return this;
};
initRender.prototype.wrapInner = function (wrapper) {
  const contents = this.contents();
  if (contents.length) {
    contents.wrap(wrapper);
  } else {
    this.append(wrapper);
  }
  return this;
};
initRender.prototype.replaceWith = function (element) {
  if (!(element && element[0])) return;
  if (element.is(this)) return this;
  element.insertBefore(this);
  this.remove();
  return element;
};
initRender.prototype.remove = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'remove', arguments);
  }
  (0, _element_data.cleanDataRecursive)(this[0], true);
  _dom_adapter.default.removeElement(this[0]);
  return this;
};
initRender.prototype.detach = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'detach', arguments);
  }
  _dom_adapter.default.removeElement(this[0]);
  return this;
};
initRender.prototype.empty = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'empty', arguments);
  }
  (0, _element_data.cleanDataRecursive)(this[0]);
  _dom_adapter.default.setText(this[0], '');
  return this;
};
initRender.prototype.clone = function () {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result.push(this[i].cloneNode(true));
  }
  return renderer(result);
};
initRender.prototype.text = function (value) {
  if (!arguments.length) {
    let result = '';
    for (let i = 0; i < this.length; i++) {
      result += this[i] && this[i].textContent || '';
    }
    return result;
  }
  const text = (0, _type.isFunction)(value) ? value() : value;
  (0, _element_data.cleanDataRecursive)(this[0], false);
  _dom_adapter.default.setText(this[0], (0, _type.isDefined)(text) ? text : '');
  return this;
};
initRender.prototype.val = function (value) {
  if (arguments.length === 1) {
    return this.prop('value', (0, _type.isDefined)(value) ? value : '');
  }
  return this.prop('value');
};
initRender.prototype.contents = function () {
  if (!this[0]) return renderer();
  const result = [];
  result.push.apply(result, this[0].childNodes);
  return renderer(result);
};
initRender.prototype.find = function (selector) {
  const result = renderer();
  if (!selector) {
    return result;
  }
  const nodes = [];
  let i;
  if (typeof selector === 'string') {
    selector = selector.trim();
    for (i = 0; i < this.length; i++) {
      const element = this[i];
      if (_dom_adapter.default.isElementNode(element)) {
        const elementId = element.getAttribute('id');
        let queryId = elementId || 'dx-query-children';
        if (!elementId) {
          setAttributeValue(element, 'id', queryId);
        }
        queryId = '[id=\'' + queryId + '\'] ';
        const querySelector = queryId + selector.replace(/([^\\])(,)/g, '$1, ' + queryId);
        nodes.push.apply(nodes, _dom_adapter.default.querySelectorAll(element, querySelector));
        setAttributeValue(element, 'id', elementId);
      } else if (_dom_adapter.default.isDocument(element) || _dom_adapter.default.isDocumentFragment(element)) {
        nodes.push.apply(nodes, _dom_adapter.default.querySelectorAll(element, selector));
      }
    }
  } else {
    for (i = 0; i < this.length; i++) {
      selector = _dom_adapter.default.isNode(selector) ? selector : selector[0];
      if (this[i] !== selector && this[i].contains(selector)) {
        nodes.push(selector);
      }
    }
  }
  return result.add(nodes);
};
const isVisible = function (_, element) {
  element = element.host ?? element;
  if (!element.nodeType) return true;
  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
};
initRender.prototype.filter = function (selector) {
  if (!selector) return renderer();
  if (selector === ':visible') {
    return this.filter(isVisible);
  } else if (selector === ':hidden') {
    return this.filter(function (_, element) {
      return !isVisible(_, element);
    });
  }
  const result = [];
  for (let i = 0; i < this.length; i++) {
    const item = this[i];
    if (_dom_adapter.default.isElementNode(item) && (0, _type.type)(selector) === 'string') {
      _dom_adapter.default.elementMatches(item, selector) && result.push(item);
    } else if (_dom_adapter.default.isNode(selector) || (0, _type.isWindow)(selector)) {
      selector === item && result.push(item);
    } else if ((0, _type.isFunction)(selector)) {
      selector.call(item, i, item) && result.push(item);
    } else {
      for (let j = 0; j < selector.length; j++) {
        selector[j] === item && result.push(item);
      }
    }
  }
  return renderer(result);
};
initRender.prototype.not = function (selector) {
  const result = [];
  const nodes = this.filter(selector).toArray();
  for (let i = 0; i < this.length; i++) {
    if (nodes.indexOf(this[i]) === -1) {
      result.push(this[i]);
    }
  }
  return renderer(result);
};
initRender.prototype.is = function (selector) {
  return !!this.filter(selector).length;
};
initRender.prototype.children = function (selector) {
  let result = [];
  for (let i = 0; i < this.length; i++) {
    const nodes = this[i] ? this[i].childNodes : [];
    for (let j = 0; j < nodes.length; j++) {
      if (_dom_adapter.default.isElementNode(nodes[j])) {
        result.push(nodes[j]);
      }
    }
  }
  result = renderer(result);
  return selector ? result.filter(selector) : result;
};
initRender.prototype.siblings = function () {
  const element = this[0];
  if (!element || !element.parentNode) {
    return renderer();
  }
  const result = [];
  const parentChildNodes = element.parentNode.childNodes || [];
  for (let i = 0; i < parentChildNodes.length; i++) {
    const node = parentChildNodes[i];
    if (_dom_adapter.default.isElementNode(node) && node !== element) {
      result.push(node);
    }
  }
  return renderer(result);
};
initRender.prototype.each = function (callback) {
  for (let i = 0; i < this.length; i++) {
    if (callback.call(this[i], i, this[i]) === false) {
      break;
    }
  }
};
initRender.prototype.index = function (element) {
  if (!element) {
    return this.parent().children().index(this);
  }
  element = renderer(element);
  return this.toArray().indexOf(element[0]);
};
initRender.prototype.get = function (index) {
  return this[index < 0 ? this.length + index : index];
};
initRender.prototype.eq = function (index) {
  index = index < 0 ? this.length + index : index;
  return renderer(this[index]);
};
initRender.prototype.first = function () {
  return this.eq(0);
};
initRender.prototype.last = function () {
  return this.eq(-1);
};
initRender.prototype.select = function () {
  for (let i = 0; i < this.length; i += 1) {
    this[i].select && this[i].select();
  }
  return this;
};
initRender.prototype.parent = function (selector) {
  if (!this[0]) return renderer();
  const result = renderer(this[0].parentNode);
  return !selector || result.is(selector) ? result : renderer();
};
initRender.prototype.parents = function (selector) {
  const result = [];
  let parent = this.parent();
  while (parent && parent[0] && !_dom_adapter.default.isDocument(parent[0])) {
    if (_dom_adapter.default.isElementNode(parent[0])) {
      if (!selector || parent.is(selector)) {
        result.push(parent.get(0));
      }
    }
    parent = parent.parent();
  }
  return renderer(result);
};
initRender.prototype.closest = function (selector) {
  if (this.is(selector)) {
    return this;
  }
  let parent = this.parent();
  while (parent && parent.length) {
    if (parent.is(selector)) {
      return parent;
    }
    parent = parent.parent();
  }
  return renderer();
};
initRender.prototype.next = function (selector) {
  if (!this[0]) return renderer();
  let next = renderer(this[0].nextSibling);
  if (!arguments.length) {
    return next;
  }
  while (next && next.length) {
    if (next.is(selector)) return next;
    next = next.next();
  }
  return renderer();
};
initRender.prototype.prev = function () {
  if (!this[0]) return renderer();
  return renderer(this[0].previousSibling);
};
initRender.prototype.add = function (selector) {
  const targets = renderer(selector);
  const result = this.toArray();
  for (let i = 0; i < targets.length; i++) {
    const target = targets[i];
    if (result.indexOf(target) === -1) {
      result.push(target);
    }
  }
  return renderer(result);
};
const emptyArray = [];
initRender.prototype.splice = function () {
  return renderer(emptyArray.splice.apply(this, arguments));
};
initRender.prototype.slice = function () {
  return renderer(emptyArray.slice.apply(this, arguments));
};
initRender.prototype.toArray = function () {
  return emptyArray.slice.call(this);
};
initRender.prototype.offset = function () {
  if (!this[0]) return;
  return (0, _size.getOffset)(this[0]);
};
initRender.prototype.offsetParent = function () {
  if (!this[0]) return renderer();
  let offsetParent = renderer(this[0].offsetParent);
  while (offsetParent[0] && offsetParent.css('position') === 'static') {
    offsetParent = renderer(offsetParent[0].offsetParent);
  }
  offsetParent = offsetParent[0] ? offsetParent : renderer(_dom_adapter.default.getDocumentElement());
  return offsetParent;
};
initRender.prototype.position = function () {
  if (!this[0]) return;
  let offset;
  const marginTop = parseFloat(this.css('marginTop'));
  const marginLeft = parseFloat(this.css('marginLeft'));
  if (this.css('position') === 'fixed') {
    offset = this[0].getBoundingClientRect();
    return {
      top: offset.top - marginTop,
      left: offset.left - marginLeft
    };
  }
  offset = this.offset();
  const offsetParent = this.offsetParent();
  let parentOffset = {
    top: 0,
    left: 0
  };
  if (offsetParent[0].nodeName !== 'HTML') {
    parentOffset = offsetParent.offset();
  }
  parentOffset = {
    top: parentOffset.top + parseFloat(offsetParent.css('borderTopWidth')),
    left: parentOffset.left + parseFloat(offsetParent.css('borderLeftWidth'))
  };
  return {
    top: offset.top - parentOffset.top - marginTop,
    left: offset.left - parentOffset.left - marginLeft
  };
};
[{
  name: 'scrollLeft',
  offsetProp: 'pageXOffset',
  scrollWindow: function (win, value) {
    win.scrollTo(value, win.pageYOffset);
  }
}, {
  name: 'scrollTop',
  offsetProp: 'pageYOffset',
  scrollWindow: function (win, value) {
    win.scrollTo(win.pageXOffset, value);
  }
}].forEach(function (directionStrategy) {
  const propName = directionStrategy.name;
  initRender.prototype[propName] = function (value) {
    if (!this[0]) {
      return;
    }
    const window = (0, _size.getWindowByElement)(this[0]);
    if (value === undefined) {
      return window ? window[directionStrategy.offsetProp] : this[0][propName];
    }
    if (window) {
      directionStrategy.scrollWindow(window, value);
    } else {
      this[0][propName] = value;
    }
    return this;
  };
});
initRender.prototype.data = function (key, value) {
  if (!this[0]) return;
  if (arguments.length < 2) {
    return _element_data.data.call(renderer, this[0], key);
  }
  _element_data.data.call(renderer, this[0], key, value);
  return this;
};
initRender.prototype.removeData = function (key) {
  this[0] && (0, _element_data.removeData)(this[0], key);
  return this;
};
const rendererWrapper = function () {
  return renderer.apply(this, arguments);
};
Object.defineProperty(rendererWrapper, 'fn', {
  enumerable: true,
  configurable: true,
  get: function () {
    return renderer.fn;
  },
  set: function (value) {
    renderer.fn = value;
  }
});
var _default = exports["default"] = {
  set: function (strategy) {
    renderer = strategy;
  },
  get: function () {
    return rendererWrapper;
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 91784:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _window = __webpack_require__(58201);
const window = (0, _window.getWindow)();
const ResizeObserverMock = {
  observe: _common.noop,
  unobserve: _common.noop,
  disconnect: _common.noop
};
class ResizeObserverSingleton {
  constructor() {
    if (!(0, _window.hasWindow)() || !window.ResizeObserver) {
      return ResizeObserverMock;
    }
    this._callbacksMap = new Map();
    this._observer = new window.ResizeObserver(entries => {
      entries.forEach(entry => {
        var _this$_callbacksMap$g;
        (_this$_callbacksMap$g = this._callbacksMap.get(entry.target)) === null || _this$_callbacksMap$g === void 0 || _this$_callbacksMap$g(entry);
      });
    });
  }
  observe(element, callback) {
    this._callbacksMap.set(element, callback);
    this._observer.observe(element);
  }
  unobserve(element) {
    this._callbacksMap.delete(element);
    this._observer.unobserve(element);
  }
  disconnect() {
    this._callbacksMap.clear();
    this._observer.disconnect();
  }
}
const resizeObserverSingleton = new ResizeObserverSingleton();
var _default = exports["default"] = resizeObserverSingleton;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 14192:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.TemplateManager = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _function_template = __webpack_require__(68494);
var _empty_template = __webpack_require__(10688);
var _template_manager = __webpack_require__(69697);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TEXT_NODE = 3;
const ANONYMOUS_TEMPLATE_NAME = 'template';
const TEMPLATE_OPTIONS_NAME = 'dxTemplate';
const TEMPLATE_WRAPPER_CLASS = 'dx-template-wrapper';
const DX_POLYMORPH_WIDGET_TEMPLATE = new _function_template.FunctionTemplate(_ref => {
  let {
    model,
    parent
  } = _ref;
  const widgetName = model.widget;
  if (!widgetName) return (0, _renderer.default)();
  const widgetElement = (0, _renderer.default)('<div>');
  const widgetOptions = model.options || {};
  if (parent) {
    parent._createComponent(widgetElement, widgetName, widgetOptions);
  } else {
    widgetElement[widgetName](widgetOptions);
  }
  return widgetElement;
});
class TemplateManager {
  constructor(createElement, anonymousTemplateName) {
    this._tempTemplates = [];
    this._defaultTemplates = {};
    this._anonymousTemplateName = anonymousTemplateName || ANONYMOUS_TEMPLATE_NAME;
    this._createElement = createElement || _template_manager.defaultCreateElement;
    this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }
  static createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function (fn, callback) {
          let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          if (!options.skipImmediate) {
            callback(fn());
          }
          return _common.noop;
        },
        templates: {
          'dx-polymorph-widget': DX_POLYMORPH_WIDGET_TEMPLATE
        },
        useDeferUpdateForTemplates: true
      }
    };
  }
  get anonymousTemplateName() {
    return this._anonymousTemplateName;
  }
  addDefaultTemplates(templates) {
    this._defaultTemplates = (0, _extend.extend)({}, this._defaultTemplates, templates);
  }
  dispose() {
    this._tempTemplates.forEach(tempTemplate => {
      tempTemplate.template.dispose && tempTemplate.template.dispose();
    });
    this._tempTemplates = [];
  }
  extractTemplates($el) {
    const templates = this._extractTemplates($el);
    const anonymousTemplateMeta = this._extractAnonymousTemplate($el);
    return {
      templates,
      anonymousTemplateMeta
    };
  }
  _extractTemplates($el) {
    const templates = (0, _template_manager.findTemplates)($el, TEMPLATE_OPTIONS_NAME);
    const suitableTemplates = (0, _template_manager.suitableTemplatesByName)(templates);
    templates.forEach(_ref2 => {
      let {
        element,
        options: {
          name
        }
      } = _ref2;
      if (element === suitableTemplates[name]) {
        (0, _renderer.default)(element).addClass(TEMPLATE_WRAPPER_CLASS).detach();
      } else {
        (0, _renderer.default)(element).remove();
      }
    });
    return Object.keys(suitableTemplates).map(name => {
      return {
        name,
        template: this._createTemplate(suitableTemplates[name])
      };
    });
  }
  _extractAnonymousTemplate($el) {
    const $anonymousTemplate = $el.contents().detach();
    const $notJunkTemplateContent = $anonymousTemplate.filter((_, element) => {
      const isTextNode = element.nodeType === TEXT_NODE;
      const isEmptyText = (0, _renderer.default)(element).text().trim().length < 1;
      return !(isTextNode && isEmptyText);
    });
    return $notJunkTemplateContent.length > 0 ? {
      template: this._createTemplate($anonymousTemplate),
      name: this._anonymousTemplateName
    } : {};
  }
  _createTemplateIfNeeded(templateSource) {
    const cachedTemplate = this._tempTemplates.filter(tempTemplate => tempTemplate.source === (0, _template_manager.templateKey)(templateSource))[0];
    if (cachedTemplate) return cachedTemplate.template;
    const template = this._createTemplate(templateSource);
    this._tempTemplates.push({
      template,
      source: (0, _template_manager.templateKey)(templateSource)
    });
    return template;
  }
  _createTemplate(templateSource) {
    return this._createElement((0, _template_manager.validateTemplateSource)(templateSource));
  }
  getTemplate(templateSource, templates, _ref3, context) {
    let {
      isAsyncTemplate,
      skipTemplates
    } = _ref3;
    if (!(0, _type.isFunction)(templateSource)) {
      return (0, _template_manager.acquireTemplate)(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
    }
    return new _function_template.FunctionTemplate(options => {
      const templateSourceResult = templateSource.apply(context, (0, _template_manager.getNormalizedTemplateArgs)(options));
      if (!(0, _type.isDefined)(templateSourceResult)) {
        return new _empty_template.EmptyTemplate();
      }
      let dispose = false;
      const template = (0, _template_manager.acquireTemplate)(templateSourceResult, templateSource => {
        if (templateSource.nodeType || (0, _type.isRenderer)(templateSource) && !(0, _renderer.default)(templateSource).is('script')) {
          return new _function_template.FunctionTemplate(() => templateSource);
        }
        dispose = true;
        return this._createTemplate(templateSource);
      }, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
      const result = template.render(options);
      dispose && template.dispose && template.dispose();
      return result;
    });
  }
}
exports.TemplateManager = TemplateManager;

/***/ }),

/***/ 91627:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ChildDefaultTemplate = void 0;
var _template_base = __webpack_require__(81033);
class ChildDefaultTemplate extends _template_base.TemplateBase {
  constructor(name) {
    super();
    this.name = name;
  }
}
exports.ChildDefaultTemplate = ChildDefaultTemplate;

/***/ }),

/***/ 10688:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.EmptyTemplate = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _template_base = __webpack_require__(81033);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class EmptyTemplate extends _template_base.TemplateBase {
  _renderCore() {
    return (0, _renderer.default)();
  }
}
exports.EmptyTemplate = EmptyTemplate;

/***/ }),

/***/ 68494:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.FunctionTemplate = void 0;
var _template_base = __webpack_require__(81033);
var _dom = __webpack_require__(3532);
class FunctionTemplate extends _template_base.TemplateBase {
  constructor(render) {
    super();
    this._render = render;
  }
  _renderCore(options) {
    return (0, _dom.normalizeTemplateElement)(this._render(options));
  }
}
exports.FunctionTemplate = FunctionTemplate;

/***/ }),

/***/ 9545:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Template = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _template_base = __webpack_require__(81033);
var _dom = __webpack_require__(3532);
var _template_engine_registry = __webpack_require__(72987);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
(0, _template_engine_registry.registerTemplateEngine)('default', {
  compile: element => (0, _dom.normalizeTemplateElement)(element),
  render: (template, model, index) => template.clone()
});
(0, _template_engine_registry.setTemplateEngine)('default');
class Template extends _template_base.TemplateBase {
  constructor(element) {
    super();
    this._element = element;
  }
  _renderCore(options) {
    const transclude = options.transclude;
    if (!transclude && !this._compiledTemplate) {
      this._compiledTemplate = (0, _template_engine_registry.getCurrentTemplateEngine)().compile(this._element);
    }
    return (0, _renderer.default)('<div>').append(transclude ? this._element : (0, _template_engine_registry.getCurrentTemplateEngine)().render(this._compiledTemplate, options.model, options.index)).contents();
  }
  source() {
    return (0, _renderer.default)(this._element).clone();
  }
}
exports.Template = Template;

/***/ }),

/***/ 81033:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.renderedCallbacks = exports.TemplateBase = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _dom = __webpack_require__(3532);
var _visibility_change = __webpack_require__(80506);
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const renderedCallbacks = exports.renderedCallbacks = (0, _callbacks.default)({
  syncStrategy: true
});
class TemplateBase {
  render(options) {
    options = options || {};
    const onRendered = options.onRendered;
    delete options.onRendered;
    let $result;
    if (options.renovated && options.transclude && this._element) {
      $result = (0, _renderer.default)('<div>').append(this._element).contents();
    } else {
      $result = this._renderCore(options);
    }
    this._ensureResultInContainer($result, options.container);
    renderedCallbacks.fire($result, options.container);
    onRendered && onRendered();
    return $result;
  }
  _ensureResultInContainer($result, container) {
    if (!container) {
      return;
    }
    const $container = (0, _renderer.default)(container);
    const resultInContainer = (0, _dom.contains)($container.get(0), $result.get(0));
    $container.append($result);
    if (resultInContainer) {
      return;
    }
    const resultInBody = (0, _dom.contains)(_dom_adapter.default.getBody(), $container.get(0));
    if (!resultInBody) {
      return;
    }
    (0, _visibility_change.triggerShownEvent)($result);
  }
  _renderCore() {
    throw _errors.default.Error('E0001');
  }
}
exports.TemplateBase = TemplateBase;

/***/ }),

/***/ 72987:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getCurrentTemplateEngine = getCurrentTemplateEngine;
exports.registerTemplateEngine = registerTemplateEngine;
exports.setTemplateEngine = setTemplateEngine;
var _type = __webpack_require__(35922);
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const templateEngines = {};
let currentTemplateEngine;
function registerTemplateEngine(name, templateEngine) {
  templateEngines[name] = templateEngine;
}
function setTemplateEngine(templateEngine) {
  if ((0, _type.isString)(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];
    if (!currentTemplateEngine) {
      throw _errors.default.Error('E0020', templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}
function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}

/***/ }),

/***/ 82713:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _trial_panel = __webpack_require__(84814);
var _default = exports["default"] = {
  registerTrialPanelComponents: _trial_panel.registerTrialPanelComponents,
  showTrialPanel: _trial_panel.showTrialPanel
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 37208:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _deferred = __webpack_require__(62754);
var _http_request = _interopRequireDefault(__webpack_require__(83448));
var _window = __webpack_require__(58201);
var _type = __webpack_require__(35922);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _ajax_utils = __webpack_require__(36944);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const SUCCESS = 'success';
const ERROR = 'error';
const TIMEOUT = 'timeout';
const NO_CONTENT = 'nocontent';
const PARSER_ERROR = 'parsererror';
const isStatusSuccess = function (status) {
  return 200 <= status && status < 300;
};
const hasContent = function (status) {
  return status !== 204;
};
const getDataFromResponse = function (xhr) {
  return xhr.responseType && xhr.responseType !== 'text' || typeof xhr.responseText !== 'string' ? xhr.response : xhr.responseText;
};
const postProcess = function (deferred, xhr, dataType) {
  const data = getDataFromResponse(xhr);
  switch (dataType) {
    case 'jsonp':
      (0, _ajax_utils.evalScript)(data);
      break;
    case 'script':
      (0, _ajax_utils.evalScript)(data);
      deferred.resolve(data, SUCCESS, xhr);
      break;
    case 'json':
      try {
        deferred.resolve(JSON.parse(data), SUCCESS, xhr);
      } catch (e) {
        deferred.reject(xhr, PARSER_ERROR, e);
      }
      break;
    default:
      deferred.resolve(data, SUCCESS, xhr);
  }
};
const setHttpTimeout = function (timeout, xhr) {
  return timeout && setTimeout(function () {
    xhr.customStatus = TIMEOUT;
    xhr.abort();
  }, timeout);
};
const sendRequest = function (options) {
  const xhr = _http_request.default.getXhr();
  const d = new _deferred.Deferred();
  const result = d.promise();
  const async = (0, _type.isDefined)(options.async) ? options.async : true;
  const dataType = options.dataType;
  const timeout = options.timeout || 0;
  let timeoutId;
  options.crossDomain = (0, _ajax_utils.isCrossDomain)(options.url);
  const needScriptEvaluation = dataType === 'jsonp' || dataType === 'script';
  if (options.cache === undefined) {
    options.cache = !needScriptEvaluation;
  }
  const callbackName = (0, _ajax_utils.getJsonpCallbackName)(options);
  const headers = (0, _ajax_utils.getRequestHeaders)(options);
  const requestOptions = (0, _ajax_utils.getRequestOptions)(options, headers);
  const url = requestOptions.url;
  const parameters = requestOptions.parameters;
  if (callbackName) {
    window[callbackName] = function (data) {
      d.resolve(data, SUCCESS, xhr);
    };
  }
  if (options.crossDomain && needScriptEvaluation) {
    const reject = function () {
      d.reject(xhr, ERROR);
    };
    const resolve = function () {
      if (dataType === 'jsonp') return;
      d.resolve(null, SUCCESS, xhr);
    };
    (0, _ajax_utils.evalCrossDomainScript)(url).then(resolve, reject);
    return result;
  }
  if (options.crossDomain && !('withCredentials' in xhr)) {
    d.reject(xhr, ERROR);
    return result;
  }
  xhr.open((0, _ajax_utils.getMethod)(options), url, async, options.username, options.password);
  if (async) {
    xhr.timeout = timeout;
    timeoutId = setHttpTimeout(timeout, xhr);
  }
  xhr['onreadystatechange'] = function (e) {
    if (xhr.readyState === 4) {
      clearTimeout(timeoutId);
      if (isStatusSuccess(xhr.status)) {
        if (hasContent(xhr.status)) {
          postProcess(d, xhr, dataType);
        } else {
          d.resolve(null, NO_CONTENT, xhr);
        }
      } else {
        d.reject(xhr, xhr.customStatus || ERROR);
      }
    }
  };
  if (options.upload) {
    xhr.upload['onprogress'] = options.upload['onprogress'];
    xhr.upload['onloadstart'] = options.upload['onloadstart'];
    xhr.upload['onabort'] = options.upload['onabort'];
  }
  if (options.xhrFields) {
    for (const field in options.xhrFields) {
      xhr[field] = options.xhrFields[field];
    }
  }
  if (options.responseType === 'arraybuffer') {
    xhr.responseType = options.responseType;
  }
  for (const name in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name) && (0, _type.isDefined)(headers[name])) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }
  if (options.beforeSend) {
    options.beforeSend(xhr);
  }
  xhr.send(parameters);
  result.abort = function () {
    xhr.abort();
  };
  return result;
};
var _default = exports["default"] = (0, _dependency_injector.default)({
  sendRequest: sendRequest
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 36944:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getJsonpCallbackName = exports.getAcceptHeader = exports.evalScript = exports.evalCrossDomainScript = void 0;
exports.getMethod = getMethod;
exports.isCrossDomain = exports.getRequestOptions = exports.getRequestHeaders = void 0;
var _extend = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const createScript = function (options) {
  const script = _dom_adapter.default.createElement('script');
  for (const name in options) {
    script[name] = options[name];
  }
  return script;
};
const appendToHead = function (element) {
  return _dom_adapter.default.getHead().appendChild(element);
};
const removeScript = function (scriptNode) {
  scriptNode.parentNode.removeChild(scriptNode);
};
const evalScript = function (code) {
  const script = createScript({
    text: code
  });
  appendToHead(script);
  removeScript(script);
};
exports.evalScript = evalScript;
const evalCrossDomainScript = function (url) {
  const script = createScript({
    src: url
  });
  return new Promise(function (resolve, reject) {
    const events = {
      'load': resolve,
      'error': reject
    };
    const loadHandler = function (e) {
      events[e.type]();
      removeScript(script);
    };
    for (const event in events) {
      _dom_adapter.default.listen(script, event, loadHandler);
    }
    appendToHead(script);
  });
};
exports.evalCrossDomainScript = evalCrossDomainScript;
function getMethod(options) {
  return (options.method || 'GET').toUpperCase();
}
const paramsConvert = function (params) {
  const result = [];
  for (const name in params) {
    let value = params[name];
    if (value === undefined) {
      continue;
    }
    if (value === null) {
      value = '';
    }
    if (typeof value === 'function') {
      value = value();
    }
    result.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
  }
  return result.join('&');
};
const getContentTypeHeader = function (options) {
  let defaultContentType;
  if (options.data && !options.upload && getMethod(options) !== 'GET') {
    defaultContentType = 'application/x-www-form-urlencoded;charset=utf-8';
  }
  return options.contentType || defaultContentType;
};
const getAcceptHeader = function (options) {
  const dataType = options.dataType || '*';
  const scriptAccept = 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript';
  const accepts = {
    '*': '*/*',
    text: 'text/plain',
    html: 'text/html',
    xml: 'application/xml, text/xml',
    json: 'application/json, text/javascript',
    jsonp: scriptAccept,
    script: scriptAccept
  };
  (0, _extend.extendFromObject)(accepts, options.accepts, true);
  return accepts[dataType] ? accepts[dataType] + (dataType !== '*' ? ', */*; q=0.01' : '') : accepts['*'];
};
exports.getAcceptHeader = getAcceptHeader;
const getRequestHeaders = function (options) {
  const headers = options.headers || {};
  headers['Content-Type'] = headers['Content-Type'] || getContentTypeHeader(options);
  headers['Accept'] = headers['Accept'] || getAcceptHeader(options);
  if (!options.crossDomain && !headers['X-Requested-With']) {
    headers['X-Requested-With'] = 'XMLHttpRequest';
  }
  return headers;
};
exports.getRequestHeaders = getRequestHeaders;
const getJsonpOptions = function (options) {
  if (options.dataType === 'jsonp') {
    const random = Math.random().toString().replace(/\D/g, '');
    const callbackName = options.jsonpCallback || 'dxCallback' + Date.now() + '_' + random;
    const callbackParameter = options.jsonp || 'callback';
    options.data = options.data || {};
    options.data[callbackParameter] = callbackName;
    return callbackName;
  }
};
exports.getJsonpCallbackName = getJsonpOptions;
const getRequestOptions = function (options, headers) {
  let params = options.data;
  const paramsAlreadyString = typeof params === 'string';
  let url = options.url || window.location.href;
  if (!paramsAlreadyString && !options.cache) {
    params = params || {};
    params['_'] = Date.now();
  }
  if (params && !options.upload) {
    if (!paramsAlreadyString) {
      params = paramsConvert(params);
    }
    if (getMethod(options) === 'GET') {
      if (params !== '') {
        url += (url.indexOf('?') > -1 ? '&' : '?') + params;
      }
      params = null;
    } else if (headers['Content-Type'] && headers['Content-Type'].indexOf('application/x-www-form-urlencoded') > -1) {
      params = params.replace(/%20/g, '+');
    }
  }
  return {
    url: url,
    parameters: params
  };
};
exports.getRequestOptions = getRequestOptions;
const isCrossDomain = function (url) {
  if (!(0, _window.hasWindow)()) {
    return true;
  }
  let crossDomain = false;
  const originAnchor = _dom_adapter.default.createElement('a');
  const urlAnchor = _dom_adapter.default.createElement('a');
  originAnchor.href = window.location.href;
  try {
    urlAnchor.href = url;

    // NOTE: IE11
    // eslint-disable-next-line no-self-assign
    urlAnchor.href = urlAnchor.href;
    crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
  } catch (e) {
    crossDomain = true;
  }
  return crossDomain;
};
exports.isCrossDomain = isCrossDomain;

/***/ }),

/***/ 89386:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.wrapToArray = exports.removeDuplicates = exports.normalizeIndexes = exports.groupBy = exports.getUniqueValues = exports.getIntersection = void 0;
var _type = __webpack_require__(35922);
var _object = __webpack_require__(48013);
var _config = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function createOccurrenceMap(array) {
  return array.reduce((map, value) => {
    const count = (map.get(value) ?? 0) + 1;
    map.set(value, count);
    return map;
  }, new Map());
}
const wrapToArray = function (item) {
  return Array.isArray(item) ? item : [item];
};
exports.wrapToArray = wrapToArray;
const getUniqueValues = function (values) {
  return [...new Set(values)];
};
exports.getUniqueValues = getUniqueValues;
const getIntersection = function (firstArray, secondArray) {
  const toRemoveMap = createOccurrenceMap(secondArray);
  return firstArray.filter(value => {
    const occurrencesCount = toRemoveMap.get(value);
    occurrencesCount && toRemoveMap.set(value, occurrencesCount - 1);
    return occurrencesCount;
  });
};
exports.getIntersection = getIntersection;
const removeDuplicates = function () {
  let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let toRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const toRemoveMap = createOccurrenceMap(toRemove);
  return from.filter(value => {
    const occurrencesCount = toRemoveMap.get(value);
    occurrencesCount && toRemoveMap.set(value, occurrencesCount - 1);
    return !occurrencesCount;
  });
};
exports.removeDuplicates = removeDuplicates;
const normalizeIndexes = function (items, indexPropName, currentItem, needIndexCallback) {
  const indexedItems = {};
  const {
    useLegacyVisibleIndex
  } = (0, _config.default)();
  let currentIndex = 0;
  const shouldUpdateIndex = item => !(0, _type.isDefined)(item[indexPropName]) && (!needIndexCallback || needIndexCallback(item));
  items.forEach(item => {
    const index = item[indexPropName];
    if (index >= 0) {
      indexedItems[index] = indexedItems[index] || [];
      if (item === currentItem) {
        indexedItems[index].unshift(item);
      } else {
        indexedItems[index].push(item);
      }
    } else {
      item[indexPropName] = undefined;
    }
  });
  if (!useLegacyVisibleIndex) {
    items.forEach(item => {
      if (shouldUpdateIndex(item)) {
        while (indexedItems[currentIndex]) {
          currentIndex++;
        }
        indexedItems[currentIndex] = [item];
        currentIndex++;
      }
    });
  }
  currentIndex = 0;
  (0, _object.orderEach)(indexedItems, function (index, items) {
    items.forEach(item => {
      if (index >= 0) {
        item[indexPropName] = currentIndex++;
      }
    });
  });
  if (useLegacyVisibleIndex) {
    items.forEach(item => {
      if (shouldUpdateIndex(item)) {
        item[indexPropName] = currentIndex++;
      }
    });
  }
};
exports.normalizeIndexes = normalizeIndexes;
const groupBy = (array, getGroupName) => {
  return array.reduce((groupedResult, item) => {
    const groupName = getGroupName(item);
    groupedResult[groupName] = groupedResult[groupName] ?? [];
    groupedResult[groupName].push(item);
    return groupedResult;
  }, {});
};
exports.groupBy = groupBy;

/***/ }),

/***/ 47810:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _window = __webpack_require__(58201);
const navigator = (0, _window.getNavigator)();
const webkitRegExp = /(webkit)[ /]([\w.]+)/;
const mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
const browserFromUA = ua => {
  ua = ua.toLowerCase();
  const result = {};
  const matches = webkitRegExp.exec(ua) || ua.indexOf('compatible') < 0 && mozillaRegExp.exec(ua) || [];
  let browserName = matches[1];
  let browserVersion = matches[2];
  if (browserName === 'webkit') {
    result['webkit'] = true;
    if (ua.indexOf('chrome') >= 0 || ua.indexOf('crios') >= 0) {
      browserName = 'chrome';
      browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf('fxios') >= 0) {
      browserName = 'mozilla';
      browserVersion = /fxios\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf('safari') >= 0 && /version|phantomjs/.test(ua)) {
      browserName = 'safari';
      browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else {
      browserName = 'unknown';
      browserVersion = /applewebkit\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    }
  }
  if (browserName) {
    result[browserName] = true;
    result.version = browserVersion;
  }
  return result;
};
var _default = exports["default"] = (0, _extend.extend)({
  _fromUA: browserFromUA
}, browserFromUA(navigator.userAgent));
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 39618:
/***/ (function(module, exports) {



exports["default"] = void 0;
const callOnce = function (handler) {
  let result;
  let wrappedHandler = function () {
    result = handler.apply(this, arguments);
    wrappedHandler = function () {
      return result;
    };
    return result;
  };
  return function () {
    return wrappedHandler.apply(this, arguments);
  };
};
var _default = exports["default"] = callOnce;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 44504:
/***/ (function(module, exports) {



exports["default"] = void 0;
const Callback = function (options) {
  this._options = options || {};
  this._list = [];
  this._queue = [];
  this._firing = false;
  this._fired = false;
  this._firingIndexes = [];
};
Callback.prototype._fireCore = function (context, args) {
  const firingIndexes = this._firingIndexes;
  const list = this._list;
  const stopOnFalse = this._options.stopOnFalse;
  const step = firingIndexes.length;
  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
    const result = list[firingIndexes[step]].apply(context, args);
    if (result === false && stopOnFalse) {
      break;
    }
  }
  firingIndexes.pop();
};
Callback.prototype.add = function (fn) {
  if (typeof fn === 'function' && (!this._options.unique || !this.has(fn))) {
    this._list.push(fn);
  }
  return this;
};
Callback.prototype.remove = function (fn) {
  const list = this._list;
  const firingIndexes = this._firingIndexes;
  const index = list.indexOf(fn);
  if (index > -1) {
    list.splice(index, 1);
    if (this._firing && firingIndexes.length) {
      for (let step = 0; step < firingIndexes.length; step++) {
        if (index <= firingIndexes[step]) {
          firingIndexes[step]--;
        }
      }
    }
  }
  return this;
};
Callback.prototype.has = function (fn) {
  const list = this._list;
  return fn ? list.indexOf(fn) > -1 : !!list.length;
};
Callback.prototype.empty = function (fn) {
  this._list = [];
  return this;
};
Callback.prototype.fireWith = function (context, args) {
  const queue = this._queue;
  args = args || [];
  args = args.slice ? args.slice() : args;
  if (this._options.syncStrategy) {
    this._firing = true;
    this._fireCore(context, args);
  } else {
    queue.push([context, args]);
    if (this._firing) {
      return;
    }
    this._firing = true;
    while (queue.length) {
      const memory = queue.shift();
      this._fireCore(memory[0], memory[1]);
    }
  }
  this._firing = false;
  this._fired = true;
  return this;
};
Callback.prototype.fire = function () {
  this.fireWith(this, arguments);
};
Callback.prototype.fired = function () {
  return this._fired;
};
const Callbacks = function (options) {
  return new Callback(options);
};
var _default = exports["default"] = Callbacks;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 20576:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.splitPair = exports.pairToObject = exports.normalizeKey = exports.noop = exports.grep = exports.getKeyHash = exports.findBestMatches = exports.executeAsync = exports.escapeRegExp = exports.equalByValue = exports.ensureDefined = exports.denormalizeKey = exports.deferUpdater = exports.deferUpdate = exports.deferRenderer = exports.deferRender = exports.asyncNoop = exports.applyServerDecimalSeparator = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _deferred = __webpack_require__(62754);
var _data = __webpack_require__(47617);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const ensureDefined = function (value, defaultValue) {
  return (0, _type.isDefined)(value) ? value : defaultValue;
};
exports.ensureDefined = ensureDefined;
const executeAsync = function (action, context /* , internal */) {
  const deferred = new _deferred.Deferred();
  const normalizedContext = context || this;
  const task = {
    promise: deferred.promise(),
    abort: function () {
      clearTimeout(timerId);
      deferred.rejectWith(normalizedContext);
    }
  };
  const callback = function () {
    const result = action.call(normalizedContext);
    if (result && result.done && (0, _type.isFunction)(result.done)) {
      result.done(function () {
        deferred.resolveWith(normalizedContext);
      });
    } else {
      deferred.resolveWith(normalizedContext);
    }
  };
  const timerId = (arguments[2] || setTimeout)(callback, typeof context === 'number' ? context : 0);
  return task;
};
exports.executeAsync = executeAsync;
const delayedFuncs = [];
const delayedNames = [];
const delayedDeferreds = [];
let executingName;
const deferExecute = function (name, func, deferred) {
  if (executingName && executingName !== name) {
    delayedFuncs.push(func);
    delayedNames.push(name);
    deferred = deferred || new _deferred.Deferred();
    delayedDeferreds.push(deferred);
    return deferred;
  } else {
    const oldExecutingName = executingName;
    const currentDelayedCount = delayedDeferreds.length;
    executingName = name;
    let result = func();
    if (!result) {
      if (delayedDeferreds.length > currentDelayedCount) {
        result = _deferred.when.apply(this, delayedDeferreds.slice(currentDelayedCount));
      } else if (deferred) {
        deferred.resolve();
      }
    }
    executingName = oldExecutingName;
    if (deferred && result && result.done) {
      result.done(deferred.resolve).fail(deferred.reject);
    }
    if (!executingName && delayedFuncs.length) {
      (delayedNames.shift() === 'render' ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
    }
    return result || (0, _deferred.when)();
  }
};
const deferRender = function (func, deferred) {
  return deferExecute('render', func, deferred);
};
exports.deferRender = deferRender;
const deferUpdate = function (func, deferred) {
  return deferExecute('update', func, deferred);
};
exports.deferUpdate = deferUpdate;
const deferRenderer = function (func) {
  return function () {
    const that = this;
    return deferExecute('render', function () {
      return func.call(that);
    });
  };
};
exports.deferRenderer = deferRenderer;
const deferUpdater = function (func) {
  return function () {
    const that = this;
    return deferExecute('update', function () {
      return func.call(that);
    });
  };
};
exports.deferUpdater = deferUpdater;
const findBestMatches = function (targetFilter, items, mapFn) {
  const bestMatches = [];
  let maxMatchCount = 0;
  (0, _iterator.each)(items, (index, itemSrc) => {
    let matchCount = 0;
    const item = mapFn ? mapFn(itemSrc) : itemSrc;
    (0, _iterator.each)(targetFilter, (paramName, targetValue) => {
      const value = item[paramName];
      if (value === undefined) {
        return;
      }
      if (match(value, targetValue)) {
        matchCount++;
        return;
      }
      matchCount = -1;
      return false;
    });
    if (matchCount < maxMatchCount) {
      return;
    }
    if (matchCount > maxMatchCount) {
      bestMatches.length = 0;
      maxMatchCount = matchCount;
    }
    bestMatches.push(itemSrc);
  });
  return bestMatches;
};
exports.findBestMatches = findBestMatches;
const match = function (value, targetValue) {
  if (Array.isArray(value) && Array.isArray(targetValue)) {
    let mismatch = false;
    (0, _iterator.each)(value, (index, valueItem) => {
      if (valueItem !== targetValue[index]) {
        mismatch = true;
        return false;
      }
    });
    if (mismatch) {
      return false;
    }
    return true;
  }
  if (value === targetValue) {
    return true;
  }
  return false;
};
const splitPair = function (raw) {
  switch ((0, _type.type)(raw)) {
    case 'string':
      return raw.split(/\s+/, 2);
    case 'object':
      return [raw.x ?? raw.h, raw.y ?? raw.v];
    case 'number':
      return [raw];
    case 'array':
      return raw;
    default:
      return null;
  }
};
exports.splitPair = splitPair;
const normalizeKey = function (id) {
  let key = (0, _type.isString)(id) ? id : id.toString();
  const arr = key.match(/[^a-zA-Z0-9_]/g);
  arr && (0, _iterator.each)(arr, (_, sign) => {
    key = key.replace(sign, '__' + sign.charCodeAt() + '__');
  });
  return key;
};
exports.normalizeKey = normalizeKey;
const denormalizeKey = function (key) {
  const arr = key.match(/__\d+__/g);
  arr && arr.forEach(char => {
    const charCode = parseInt(char.replace('__', ''));
    key = key.replace(char, String.fromCharCode(charCode));
  });
  return key;
};
exports.denormalizeKey = denormalizeKey;
const pairToObject = function (raw, preventRound) {
  const pair = splitPair(raw);
  let h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
  let v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
  if (!isFinite(h)) {
    h = 0;
  }
  if (!isFinite(v)) {
    v = h;
  }
  return {
    h,
    v
  };
};
exports.pairToObject = pairToObject;
const getKeyHash = function (key) {
  if (key instanceof _guid.default) {
    return key.toString();
  } else if ((0, _type.isObject)(key) || Array.isArray(key)) {
    try {
      const keyHash = JSON.stringify(key);
      return keyHash === '{}' ? key : keyHash;
    } catch (e) {
      return key;
    }
  }
  return key;
};
exports.getKeyHash = getKeyHash;
const escapeRegExp = function (string) {
  return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, '\\$&');
};
exports.escapeRegExp = escapeRegExp;
const applyServerDecimalSeparator = function (value) {
  const separator = (0, _config.default)().serverDecimalSeparator;
  if ((0, _type.isDefined)(value)) {
    value = value.toString().replace('.', separator);
  }
  return value;
};
exports.applyServerDecimalSeparator = applyServerDecimalSeparator;
const noop = function () {};
exports.noop = noop;
const asyncNoop = function () {
  return new _deferred.Deferred().resolve().promise();
};
exports.asyncNoop = asyncNoop;
const grep = function (elements, checkFunction, invert) {
  const result = [];
  let check;
  const expectedCheck = !invert;
  for (let i = 0; i < elements.length; i++) {
    check = !!checkFunction(elements[i], i);
    if (check === expectedCheck) {
      result.push(elements[i]);
    }
  }
  return result;
};
exports.grep = grep;
const compareArrays = (array1, array2, depth, options) => {
  if (array1.length !== array2.length) {
    return false;
  }
  return !array1.some((item, idx) => !compareByValue(item, array2[idx], depth + 1, _extends({}, options, {
    strict: true
  })));
};
const compareObjects = (object1, object2, depth, options) => {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  const keys2Set = new Set(keys2);
  return !keys1.some(key => !keys2Set.has(key) || !compareByValue(object1[key], object2[key], depth + 1, options));
};
const DEFAULT_EQUAL_BY_VALUE_OPTS = {
  maxDepth: 3,
  strict: true
};
const compareByValue = (value1, value2, depth, options) => {
  const {
    strict,
    maxDepth
  } = options;
  const comparable1 = (0, _data.toComparable)(value1, true);
  const comparable2 = (0, _data.toComparable)(value2, true);
  const comparisonResult = strict ? comparable1 === comparable2
  // eslint-disable-next-line eqeqeq
  : comparable1 == comparable2;
  switch (true) {
    case comparisonResult:
    case depth >= maxDepth:
      return true;
    case (0, _type.isObject)(comparable1) && (0, _type.isObject)(comparable2):
      return compareObjects(comparable1, comparable2, depth, options);
    case Array.isArray(comparable1) && Array.isArray(comparable2):
      return compareArrays(comparable1, comparable2, depth, options);
    default:
      return false;
  }
};
const equalByValue = function (value1, value2) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_EQUAL_BY_VALUE_OPTS;
  const compareOptions = _extends({}, DEFAULT_EQUAL_BY_VALUE_OPTS, options);
  return compareByValue(value1, value2, 0, compareOptions);
};
exports.equalByValue = equalByValue;

/***/ }),

/***/ 49036:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.equals = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _data = __webpack_require__(47617);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const hasNegation = function (oldValue, newValue) {
  return 1 / oldValue === 1 / newValue;
};
const equals = function (oldValue, newValue) {
  oldValue = (0, _data.toComparable)(oldValue, true);
  newValue = (0, _data.toComparable)(newValue, true);
  if (oldValue && newValue && (0, _type.isRenderer)(oldValue) && (0, _type.isRenderer)(newValue)) {
    return newValue.is(oldValue);
  }
  const oldValueIsNaN = oldValue !== oldValue;
  const newValueIsNaN = newValue !== newValue;
  if (oldValueIsNaN && newValueIsNaN) {
    return true;
  }
  if (oldValue === 0 && newValue === 0) {
    return hasNegation(oldValue, newValue);
  }
  if (oldValue === null || typeof oldValue !== 'object' || _dom_adapter.default.isElementNode(oldValue)) {
    return oldValue === newValue;
  }
  return false;
};
exports.equals = equals;

/***/ }),

/***/ 30869:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.logger = exports.debug = void 0;
var _type = __webpack_require__(35922);
/* global console */
/* eslint no-console: off */

const noop = function () {};
const getConsoleMethod = function (method) {
  if (typeof console === 'undefined' || !(0, _type.isFunction)(console[method])) {
    return noop;
  }
  return console[method].bind(console);
};
const logger = exports.logger = {
  log: getConsoleMethod('log'),
  info: getConsoleMethod('info'),
  warn: getConsoleMethod('warn'),
  error: getConsoleMethod('error')
};
const debug = exports.debug = function () {
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  function assertParam(parameter, message) {
    assert(parameter !== null && parameter !== undefined, message);
  }
  return {
    assert: assert,
    assertParam: assertParam
  };
}();

/***/ }),

/***/ 47617:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.toComparable = exports.getPathParts = exports.compileSetter = exports.compileGetter = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _object = __webpack_require__(48013);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _variable_wrapper = _interopRequireDefault(__webpack_require__(26974));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const unwrapVariable = _variable_wrapper.default.unwrap;
const isWrapped = _variable_wrapper.default.isWrapped;
const assign = _variable_wrapper.default.assign;
const bracketsToDots = function (expr) {
  return expr.replace(/\[/g, '.').replace(/\]/g, '');
};
const getPathParts = function (name) {
  return bracketsToDots(name).split('.');
};
exports.getPathParts = getPathParts;
const readPropValue = function (obj, propName, options) {
  options = options || {};
  if (propName === 'this') {
    return unwrap(obj, options);
  }
  return unwrap(obj[propName], options);
};
const assignPropValue = function (obj, propName, value, options) {
  if (propName === 'this') {
    throw new _errors.default.Error('E4016');
  }
  const propValue = obj[propName];
  if (options.unwrapObservables && isWrapped(propValue)) {
    assign(propValue, value);
  } else {
    obj[propName] = value;
  }
};
const prepareOptions = function (options) {
  options = options || {};
  options.unwrapObservables = options.unwrapObservables !== undefined ? options.unwrapObservables : true;
  return options;
};
function unwrap(value, options) {
  return options.unwrapObservables ? unwrapVariable(value) : value;
}
const compileGetter = function (expr) {
  if (arguments.length > 1) {
    expr = [].slice.call(arguments);
  }
  if (!expr || expr === 'this') {
    return function (obj) {
      return obj;
    };
  }
  if (typeof expr === 'string') {
    const path = getPathParts(expr);
    return function (obj, options) {
      options = prepareOptions(options);
      const functionAsIs = options.functionsAsIs;
      const hasDefaultValue = ('defaultValue' in options);
      let current = unwrap(obj, options);
      for (let i = 0; i < path.length; i++) {
        if (!current) {
          if (current == null && hasDefaultValue) {
            return options.defaultValue;
          }
          break;
        }
        const pathPart = path[i];
        if (hasDefaultValue && (0, _type.isObject)(current) && !(pathPart in current)) {
          return options.defaultValue;
        }
        let next = unwrap(current[pathPart], options);
        if (!functionAsIs && (0, _type.isFunction)(next)) {
          next = next.call(current);
        }
        current = next;
      }
      return current;
    };
  }
  if (Array.isArray(expr)) {
    return combineGetters(expr);
  }
  if ((0, _type.isFunction)(expr)) {
    return expr;
  }
};
exports.compileGetter = compileGetter;
function combineGetters(getters) {
  const compiledGetters = {};
  for (let i = 0, l = getters.length; i < l; i++) {
    const getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }
  return function (obj, options) {
    let result;
    (0, _iterator.each)(compiledGetters, function (name) {
      const value = this(obj, options);
      if (value === undefined) {
        return;
      }
      let current = result || (result = {});
      const path = name.split('.');
      const last = path.length - 1;
      for (let i = 0; i < last; i++) {
        const pathItem = path[i];
        if (!(pathItem in current)) {
          current[pathItem] = {};
        }
        current = current[pathItem];
      }
      current[path[last]] = value;
    });
    return result;
  };
}
function toLowerCase(value, options) {
  return options !== null && options !== void 0 && options.locale ? value.toLocaleLowerCase(options.locale) : value.toLowerCase();
}
const ensurePropValueDefined = function (obj, propName, value, options) {
  if ((0, _type.isDefined)(value)) {
    return value;
  }
  const newValue = {};
  assignPropValue(obj, propName, newValue, options);
  return newValue;
};
const compileSetter = function (expr) {
  expr = getPathParts(expr || 'this');
  const lastLevelIndex = expr.length - 1;
  return function (obj, value, options) {
    options = prepareOptions(options);
    let currentValue = unwrap(obj, options);
    expr.forEach(function (propertyName, levelIndex) {
      let propertyValue = readPropValue(currentValue, propertyName, options);
      const isPropertyFunc = !options.functionsAsIs && (0, _type.isFunction)(propertyValue) && !isWrapped(propertyValue);
      if (levelIndex === lastLevelIndex) {
        if (options.merge && (0, _type.isPlainObject)(value) && (!(0, _type.isDefined)(propertyValue) || (0, _type.isPlainObject)(propertyValue))) {
          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
          (0, _object.deepExtendArraySafe)(propertyValue, value, false, true);
        } else if (isPropertyFunc) {
          currentValue[propertyName](value);
        } else {
          assignPropValue(currentValue, propertyName, value, options);
        }
      } else {
        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
        if (isPropertyFunc) {
          propertyValue = propertyValue.call(currentValue);
        }
        currentValue = propertyValue;
      }
    });
  };
};
exports.compileSetter = compileSetter;
const toComparable = function (value, caseSensitive) {
  var _options$collatorOpti;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (value instanceof Date) {
    return value.getTime();
  }
  if (value && value instanceof _class.default && value.valueOf) {
    return value.valueOf();
  }
  const isCaseSensitive = (options === null || options === void 0 || (_options$collatorOpti = options.collatorOptions) === null || _options$collatorOpti === void 0 ? void 0 : _options$collatorOpti.sensitivity) === 'case' || caseSensitive;
  if (!isCaseSensitive && typeof value === 'string') {
    var _options$collatorOpti2;
    if ((options === null || options === void 0 || (_options$collatorOpti2 = options.collatorOptions) === null || _options$collatorOpti2 === void 0 ? void 0 : _options$collatorOpti2.sensitivity) === 'base') {
      const REMOVE_DIACRITICAL_MARKS_REGEXP = /[\u0300-\u036f]/g;
      value = toLowerCase(value, options).normalize('NFD').replace(REMOVE_DIACRITICAL_MARKS_REGEXP, '');
      return value;
    }
    return toLowerCase(value, options);
  }
  return value;
};
exports.toComparable = toComparable;

/***/ }),

/***/ 91198:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
var _iterator = __webpack_require__(95479);
var _inflector = __webpack_require__(78008);
var _index = __webpack_require__(25050);
/* globals Intl */
// TODO refactoring: Review all date utils functions and move useful to __internal/core/utils/date.ts

const DAYS_IN_WEEK = 7;
const THURSDAY_WEEK_NUMBER = 4;
const SUNDAY_WEEK_NUMBER = 7;
const USUAL_WEEK_COUNT_IN_YEAR = 52;
const dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];
const getDatesInterval = function (startDate, endDate, intervalUnit) {
  const delta = endDate.getTime() - startDate.getTime();
  const millisecondCount = (0, _index.toMilliseconds)(intervalUnit) || 1;
  return Math.floor(delta / millisecondCount);
};
const getNextDateUnit = function (unit, withWeeks) {
  const interval = getDateUnitInterval(unit);
  switch (interval) {
    case 'millisecond':
      return 'second';
    case 'second':
      return 'minute';
    case 'minute':
      return 'hour';
    case 'hour':
      return 'day';
    case 'day':
      return withWeeks ? 'week' : 'month';
    case 'week':
      return 'month';
    case 'month':
      return 'quarter';
    case 'quarter':
      return 'year';
    case 'year':
      return 'year';
    default:
      return 0;
  }
};
const convertMillisecondsToDateUnits = function (value) {
  let i;
  let dateUnitCount;
  let dateUnitInterval;
  const dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];
  const result = {};
  for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
    dateUnitInterval = dateUnitIntervals[i];
    dateUnitCount = Math.floor(value / (0, _index.toMilliseconds)(dateUnitInterval));
    if (dateUnitCount > 0) {
      result[dateUnitInterval + 's'] = dateUnitCount;
      value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
    }
  }
  return result;
};
const dateToMilliseconds = function (tickInterval) {
  let milliseconds = 0;
  if ((0, _type.isObject)(tickInterval)) {
    (0, _iterator.each)(tickInterval, function (key, value) {
      milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value);
    });
  }
  if ((0, _type.isString)(tickInterval)) {
    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
  }
  return milliseconds;
};
function convertDateUnitToMilliseconds(dateUnit, count) {
  return (0, _index.toMilliseconds)(dateUnit) * count;
}

// refactor for performance
function getDateUnitInterval(tickInterval) {
  let maxInterval = -1;
  let i;
  if ((0, _type.isString)(tickInterval)) {
    return tickInterval;
  }
  if ((0, _type.isObject)(tickInterval)) {
    (0, _iterator.each)(tickInterval, function (key, value) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value && (key === dateUnitIntervals[i] + 's' || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }
  return '';
}

// T375972
const tickIntervalToFormatMap = {
  millisecond: 'millisecond',
  second: 'longtime',
  minute: 'shorttime',
  hour: 'shorttime',
  day: 'day',
  week: 'day',
  month: 'month',
  quarter: 'quarter',
  year: 'year'
};

// Because of changes in formatting (Globalize has been updated) common date formatting has been changed.
// The purpose of the following method is to preserve original dates formatting in axes and range selector slider markers.
function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || '';
}
const getQuarter = function (month) {
  return Math.floor(month / 3);
};
const getFirstQuarterMonth = function (month) {
  return getQuarter(month) * 3;
};
function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  const oldDate = new Date(date.getTime());
  let firstQuarterMonth;
  let month;
  const dateUnitInterval = getDateUnitInterval(dateInterval);
  switch (dateUnitInterval) {
    case 'second':
      date = new Date(Math.floor(oldDate.getTime() / 1000) * 1000);
      break;
    case 'minute':
      date = new Date(Math.floor(oldDate.getTime() / 60000) * 60000);
      break;
    case 'hour':
      date = new Date(Math.floor(oldDate.getTime() / 3600000) * 3600000);
      break;
    case 'year':
      date.setMonth(0);
    /* falls through */
    case 'month':
      date.setDate(1);
    /* falls through */
    case 'day':
      date.setHours(0, 0, 0, 0);
      break;
    case 'week':
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;
    case 'quarter':
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }
      break;
  }
  if (withCorrection && dateUnitInterval !== 'hour' && dateUnitInterval !== 'minute' && dateUnitInterval !== 'second') {
    fixTimezoneGap(oldDate, date);
  }
  return date;
}
function trimTime(date) {
  return correctDateWithUnitBeginning(date, 'day');
}
const setToDayEnd = function (date) {
  const result = trimTime(date);
  result.setDate(result.getDate() + 1);
  return new Date(result.getTime() - 1);
};
const getDatesDifferences = function (date1, date2) {
  let counter = 0;
  const differences = {
    year: date1.getFullYear() !== date2.getFullYear(),
    month: date1.getMonth() !== date2.getMonth(),
    day: date1.getDate() !== date2.getDate(),
    hour: date1.getHours() !== date2.getHours(),
    minute: date1.getMinutes() !== date2.getMinutes(),
    second: date1.getSeconds() !== date2.getSeconds(),
    millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
  };
  (0, _iterator.each)(differences, function (key, value) {
    if (value) {
      counter++;
    }
  });
  if (counter === 0 && getTimezonesDifference(date1, date2) !== 0) {
    differences.hour = true;
    counter++;
  }
  differences.count = counter;
  return differences;
};
function addDateInterval(value, interval, dir) {
  const result = new Date(value.getTime());
  const intervalObject = (0, _type.isString)(interval) ? getDateIntervalByString(interval.toLowerCase()) : (0, _type.isNumeric)(interval) ? convertMillisecondsToDateUnits(interval) : interval;
  if (intervalObject.years) {
    result.setFullYear(result.getFullYear() + intervalObject.years * dir);
  }
  if (intervalObject.quarters) {
    result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir);
  }
  if (intervalObject.months) {
    result.setMonth(result.getMonth() + intervalObject.months * dir);
  }
  if (intervalObject.weeks) {
    result.setDate(result.getDate() + 7 * intervalObject.weeks * dir);
  }
  if (intervalObject.days) {
    result.setDate(result.getDate() + intervalObject.days * dir);
  }
  if (intervalObject.hours) {
    result.setTime(result.getTime() + intervalObject.hours * 3600000 * dir);
  }
  if (intervalObject.minutes) {
    result.setTime(result.getTime() + intervalObject.minutes * 60000 * dir);
  }
  if (intervalObject.seconds) {
    result.setTime(result.getTime() + intervalObject.seconds * 1000 * dir);
  }
  if (intervalObject.milliseconds) {
    result.setTime(result.getTime() + intervalObject.milliseconds * dir);
  }
  return result;
}
const addInterval = function (value, interval, isNegative) {
  const dir = isNegative ? -1 : +1;
  return (0, _type.isDate)(value) ? addDateInterval(value, interval, dir) : (0, _math.adjust)(value + interval * dir, interval);
};
const getSequenceByInterval = function (min, max, interval) {
  const intervals = [];
  let cur;
  intervals.push((0, _type.isDate)(min) ? new Date(min.getTime()) : min);
  cur = min;
  while (cur < max) {
    cur = addInterval(cur, interval);
    intervals.push(cur);
  }
  return intervals;
};
const getViewFirstCellDate = function (viewType, date) {
  if (viewType === 'month') {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  }
  if (viewType === 'year') {
    return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
  }
  if (viewType === 'decade') {
    return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
  }
  if (viewType === 'century') {
    return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
  }
};
const getViewLastCellDate = function (viewType, date) {
  if (viewType === 'month') {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
  }
  if (viewType === 'year') {
    return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
  }
  if (viewType === 'decade') {
    return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
  }
  if (viewType === 'century') {
    return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
  }
};
const getViewMinBoundaryDate = function (viewType, date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  if (viewType === 'month') {
    return resultDate;
  }
  resultDate.setMonth(0);
  if (viewType === 'year') {
    return resultDate;
  }
  if (viewType === 'decade') {
    resultDate.setFullYear(getFirstYearInDecade(date));
  }
  if (viewType === 'century') {
    resultDate.setFullYear(getFirstDecadeInCentury(date));
  }
  return resultDate;
};
const getViewMaxBoundaryDate = function (viewType, date) {
  const resultDate = new Date(date);
  resultDate.setDate(getLastMonthDay(date));
  if (viewType === 'month') {
    return resultDate;
  }
  resultDate.setMonth(11);
  resultDate.setDate(getLastMonthDay(resultDate));
  if (viewType === 'year') {
    return resultDate;
  }
  if (viewType === 'decade') {
    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
  }
  if (viewType === 'century') {
    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
  }
  return resultDate;
};
function getLastMonthDay(date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}
const getViewUp = function (typeView) {
  switch (typeView) {
    case 'month':
      return 'year';
    case 'year':
      return 'decade';
    case 'decade':
      return 'century';
    default:
      break;
  }
};
const getViewDown = function (typeView) {
  switch (typeView) {
    case 'century':
      return 'decade';
    case 'decade':
      return 'year';
    case 'year':
      return 'month';
    default:
      break;
  }
};
const getDifferenceInMonth = function (typeView) {
  let difference = 1;
  if (typeView === 'year') {
    difference = 12;
  }
  if (typeView === 'decade') {
    difference = 12 * 10;
  }
  if (typeView === 'century') {
    difference = 12 * 100;
  }
  return difference;
};
const getDifferenceInMonthForCells = function (typeView) {
  let difference = 1;
  if (typeView === 'decade') {
    difference = 12;
  }
  if (typeView === 'century') {
    difference = 12 * 10;
  }
  return difference;
};
function getDateIntervalByString(intervalString) {
  const result = {};
  switch (intervalString) {
    case 'year':
      result.years = 1;
      break;
    case 'month':
      result.months = 1;
      break;
    case 'quarter':
      result.months = 3;
      break;
    case 'week':
      result.weeks = 1;
      break;
    case 'day':
      result.days = 1;
      break;
    case 'hour':
      result.hours = 1;
      break;
    case 'minute':
      result.minutes = 1;
      break;
    case 'second':
      result.seconds = 1;
      break;
    case 'millisecond':
      result.milliseconds = 1;
      break;
  }
  return result;
}
function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}
function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}
function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}
function sameHoursAndMinutes(date1, date2) {
  return date1 && date2 && date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes();
}
const sameDecade = function (date1, date2) {
  if (!(0, _type.isDefined)(date1) || !(0, _type.isDefined)(date2)) return;
  const startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
  const startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
  return date1 && date2 && startDecadeDate1 === startDecadeDate2;
};
const sameCentury = function (date1, date2) {
  if (!(0, _type.isDefined)(date1) || !(0, _type.isDefined)(date2)) return;
  const startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
  const startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
  return date1 && date2 && startCenturyDate1 === startCenturyDate2;
};
function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}
function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}
const getShortDateFormat = function () {
  return 'yyyy/MM/dd';
};
const getFirstMonthDate = function (date) {
  if (!(0, _type.isDefined)(date)) return;
  return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
};
const getLastMonthDate = function (date) {
  if (!(0, _type.isDefined)(date)) return;
  return createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
};
function getFirstWeekDate(date, firstDayOfWeek) {
  const delta = (date.getDay() - firstDayOfWeek + DAYS_IN_WEEK) % DAYS_IN_WEEK;
  const result = new Date(date);
  result.setDate(date.getDate() - delta);
  return result;
}
function getUTCTime(date) {
  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
}
function getDayNumber(date) {
  const ms = getUTCTime(date) - getUTCTime(getFirstDateInYear(date.getFullYear()));
  return 1 + Math.floor(ms / (0, _index.toMilliseconds)('day'));
}
function getFirstDateInYear(year) {
  return new Date(year, 0, 1);
}
function getLastDateInYear(year) {
  return new Date(year, 11, 31);
}
function getDayWeekNumber(date, firstDayOfWeek) {
  let day = date.getDay() - firstDayOfWeek + 1;
  if (day <= 0) {
    day += DAYS_IN_WEEK;
  }
  return day;
}
function getWeekNumber(date, firstDayOfWeek, rule) {
  const firstWeekDayInYear = getDayWeekNumber(getFirstDateInYear(date.getFullYear()), firstDayOfWeek);
  const lastWeekDayInYear = getDayWeekNumber(getLastDateInYear(date.getFullYear()), firstDayOfWeek);
  const daysInFirstWeek = DAYS_IN_WEEK - firstWeekDayInYear + 1;
  let weekNumber = Math.ceil((getDayNumber(date) - daysInFirstWeek) / 7);
  switch (rule) {
    case 'fullWeek':
      {
        if (daysInFirstWeek === DAYS_IN_WEEK) {
          weekNumber++;
        }
        if (weekNumber === 0) {
          const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
          return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
        }
        return weekNumber;
      }
    case 'firstDay':
      {
        if (daysInFirstWeek > 0) {
          weekNumber++;
        }
        const isSunday = firstWeekDayInYear === SUNDAY_WEEK_NUMBER || lastWeekDayInYear === SUNDAY_WEEK_NUMBER;
        if (weekNumber > USUAL_WEEK_COUNT_IN_YEAR && !isSunday || weekNumber === 54) {
          weekNumber = 1;
        }
        return weekNumber;
      }
    case 'firstFourDays':
      {
        if (daysInFirstWeek > 3) {
          weekNumber++;
        }
        const isThursday = firstWeekDayInYear === THURSDAY_WEEK_NUMBER || lastWeekDayInYear === THURSDAY_WEEK_NUMBER;
        if (weekNumber > USUAL_WEEK_COUNT_IN_YEAR && !isThursday) {
          weekNumber = 1;
        }
        if (weekNumber === 0) {
          const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
          return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
        }
        return weekNumber;
      }
    default:
      break;
  }
}
const normalizeDateByWeek = function (date, currentDate) {
  const differenceInDays = dateUtils.getDatesInterval(date, currentDate, 'day');
  let resultDate = new Date(date);
  if (differenceInDays >= 6) {
    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
  }
  return resultDate;
};
const dateInRange = function (date, min, max, format) {
  if (format === 'date') {
    min = min && dateUtils.correctDateWithUnitBeginning(min, 'day');
    max = max && dateUtils.correctDateWithUnitBeginning(max, 'day');
    date = date && dateUtils.correctDateWithUnitBeginning(date, 'day');
  }
  return normalizeDate(date, min, max) === date;
};
const intervalsOverlap = function (options) {
  const {
    firstMin,
    firstMax,
    secondMin,
    secondMax
  } = options;
  return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
};
const dateTimeFromDecimal = function (number) {
  const hours = Math.floor(number);
  const minutes = number % 1 * 60;
  return {
    hours: hours,
    minutes: minutes
  };
};
const roundDateByStartDayHour = function (date, startDayHour) {
  const startTime = this.dateTimeFromDecimal(startDayHour);
  const result = new Date(date);
  if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
    result.setHours(startTime.hours, startTime.minutes, 0, 0);
  }
  return result;
};
function normalizeDate(date, min, max) {
  let normalizedDate = date;
  if (!(0, _type.isDefined)(date)) {
    return date;
  }
  if ((0, _type.isDefined)(min) && date < min) {
    normalizedDate = min;
  }
  if ((0, _type.isDefined)(max) && date > max) {
    normalizedDate = max;
  }
  return normalizedDate;
}
function fixTimezoneGap(oldDate, newDate) {
  // NOTE: T182866
  if (!(0, _type.isDefined)(oldDate)) {
    return;
  }
  const diff = newDate.getHours() - oldDate.getHours();
  if (diff === 0) {
    return;
  }
  const sign = diff === 1 || diff === -23 ? -1 : 1;
  const trial = new Date(newDate.getTime() + sign * 3600000);
  if (sign > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}
const roundToHour = function (date) {
  const result = new Date(date.getTime());
  result.setHours(result.getHours() + 1);
  result.setMinutes(0);
  return result;
};
function getTimezonesDifference(min, max) {
  return (max.getTimezoneOffset() - min.getTimezoneOffset()) * 60 * 1000;
}
const makeDate = function (date) {
  // TODO: will be useful later for work with different timezones
  return new Date(date);
};
const getDatesOfInterval = function (startDate, endDate, step) {
  const result = [];
  let currentDate = new Date(startDate.getTime());
  while (currentDate < endDate) {
    result.push(new Date(currentDate.getTime()));
    currentDate = this.addInterval(currentDate, step);
  }
  return result;
};
const createDateWithFullYear = function (year) {
  const result = new Date(...arguments);
  result.setFullYear(year);
  return result;
};
const getMachineTimezoneName = () => {
  const hasIntl = typeof Intl !== 'undefined';
  return hasIntl ? Intl.DateTimeFormat().resolvedOptions().timeZone : null;
};
const dateUtils = {
  dateUnitIntervals: dateUnitIntervals,
  convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
  dateToMilliseconds: dateToMilliseconds,
  getNextDateUnit: getNextDateUnit,
  convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
  getDateUnitInterval: getDateUnitInterval,
  getDateFormatByTickInterval: getDateFormatByTickInterval,
  // T375972
  getDatesDifferences: getDatesDifferences,
  correctDateWithUnitBeginning: correctDateWithUnitBeginning,
  trimTime: trimTime,
  setToDayEnd: setToDayEnd,
  roundDateByStartDayHour: roundDateByStartDayHour,
  dateTimeFromDecimal: dateTimeFromDecimal,
  addDateInterval: addDateInterval,
  addInterval: addInterval,
  getSequenceByInterval: getSequenceByInterval,
  getDateIntervalByString: getDateIntervalByString,
  sameHoursAndMinutes: sameHoursAndMinutes,
  sameDate: sameDate,
  sameMonthAndYear: sameMonthAndYear,
  sameMonth: sameMonthAndYear,
  sameYear: sameYear,
  sameDecade: sameDecade,
  sameCentury: sameCentury,
  getDifferenceInMonth: getDifferenceInMonth,
  getDifferenceInMonthForCells: getDifferenceInMonthForCells,
  getFirstYearInDecade: getFirstYearInDecade,
  getFirstDecadeInCentury: getFirstDecadeInCentury,
  getShortDateFormat: getShortDateFormat,
  getViewFirstCellDate: getViewFirstCellDate,
  getViewLastCellDate: getViewLastCellDate,
  getViewDown: getViewDown,
  getViewUp: getViewUp,
  getLastMonthDay: getLastMonthDay,
  getLastMonthDate: getLastMonthDate,
  getFirstMonthDate: getFirstMonthDate,
  getFirstWeekDate: getFirstWeekDate,
  getWeekNumber: getWeekNumber,
  normalizeDateByWeek: normalizeDateByWeek,
  getQuarter: getQuarter,
  getFirstQuarterMonth: getFirstQuarterMonth,
  dateInRange: dateInRange,
  intervalsOverlap: intervalsOverlap,
  roundToHour: roundToHour,
  normalizeDate: normalizeDate,
  getViewMinBoundaryDate: getViewMinBoundaryDate,
  getViewMaxBoundaryDate: getViewMaxBoundaryDate,
  fixTimezoneGap: fixTimezoneGap,
  getTimezonesDifference: getTimezonesDifference,
  makeDate: makeDate,
  getDatesInterval: getDatesInterval,
  getDatesOfInterval: getDatesOfInterval,
  createDateWithFullYear: createDateWithFullYear,
  getMachineTimezoneName: getMachineTimezoneName
};
dateUtils.sameView = function (view, date1, date2) {
  return dateUtils[(0, _inflector.camelize)('same ' + view)](date1, date2);
};
var _default = exports["default"] = dateUtils;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 69434:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _date = __webpack_require__(40594);
var _default_date_names = _interopRequireDefault(__webpack_require__(15564));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NUMBER_SERIALIZATION_FORMAT = 'number';
const DATE_SERIALIZATION_FORMAT = 'yyyy/MM/dd';
const DATETIME_SERIALIZATION_FORMAT = 'yyyy/MM/dd HH:mm:ss';
const ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
const ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
const ISO8601_PATTERN_PARTS = ['', 'yyyy', '', 'MM', '', 'dd', 'THH', '', 'mm', '', 'ss', '.SSS'];
const DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
const MILLISECOND_LENGHT = 3;
const dateParser = function (text, skipISO8601Parsing) {
  let result;
  if ((0, _type.isString)(text) && !skipISO8601Parsing) {
    result = parseISO8601String(text);
  }
  return result || parseDate(text);
};
function getTimePart(part) {
  return +part || 0;
}
function parseDate(text) {
  const isDefaultSerializationFormat = getDateSerializationFormat(text) === DATE_SERIALIZATION_FORMAT;
  const parsedValue = !(0, _type.isDate)(text) && Date.parse(text);
  if (!parsedValue && isDefaultSerializationFormat) {
    const parts = text.match(DATE_SERIALIZATION_PATTERN);
    if (parts) {
      const newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }
  return (0, _type.isNumeric)(parsedValue) ? new Date(parsedValue) : text;
}
function parseISO8601String(text) {
  let parts = text.match(ISO8601_PATTERN);
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }
    return;
  }
  const year = getTimePart(parts[1]);
  const month = --parts[3];
  const day = parts[5];
  let timeZoneHour = 0;
  let timeZoneMinute = 0;
  const correctYear = d => {
    year < 100 && d.setFullYear(year);
    return d;
  };
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);
  if (parts[13] === '-') {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }
  const hour = getTimePart(parts[6]) - timeZoneHour;
  const minute = getTimePart(parts[8]) - timeZoneMinute;
  const second = getTimePart(parts[10]);
  const parseMilliseconds = function (part) {
    part = part || '';
    return getTimePart(part) * Math.pow(10, MILLISECOND_LENGHT - part.length);
  };
  const millisecond = parseMilliseconds(parts[11]);
  if (parts[12]) {
    return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)));
  }
  return correctYear(new Date(year, month, day, hour, minute, second, millisecond));
}
const getIso8601Format = function (text, useUtc) {
  let parts = text.match(ISO8601_PATTERN);
  let result = '';
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return parts[3] ? 'HH:mm:ss' : 'HH:mm';
    }
    return;
  }
  for (let i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
    if (parts[i]) {
      result += ISO8601_PATTERN_PARTS[i] || parts[i];
    }
  }
  if (parts[12] === 'Z') {
    result += '\'Z\'';
  }
  if (parts[14]) {
    if (parts[15]) {
      result += 'xxx';
    } else if (parts[16]) {
      result += 'xx';
    } else {
      result += 'x';
    }
  }
  return result;
};
const deserializeDate = function (value) {
  if (typeof value === 'number') {
    return new Date(value);
  }
  return dateParser(value, !(0, _config.default)().forceIsoDateParsing);
};
const serializeDate = function (value, serializationFormat) {
  if (!serializationFormat) {
    return value;
  }
  if (!(0, _type.isDate)(value)) {
    return null;
  }
  if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
    return value && value.valueOf ? value.valueOf() : null;
  }
  return (0, _date.getFormatter)(serializationFormat, _default_date_names.default)(value);
};
const getDateSerializationFormat = function (value) {
  if (typeof value === 'number') {
    return NUMBER_SERIALIZATION_FORMAT;
  } else if ((0, _type.isString)(value)) {
    let format;
    if ((0, _config.default)().forceIsoDateParsing) {
      format = getIso8601Format(value);
    }
    if (format) {
      return format;
    } else if (value.indexOf(':') >= 0) {
      return DATETIME_SERIALIZATION_FORMAT;
    } else {
      return DATE_SERIALIZATION_FORMAT;
    }
  } else if (value) {
    return null;
  }
};
var _default = exports["default"] = {
  dateParser: dateParser,
  deserializeDate: deserializeDate,
  serializeDate: serializeDate,
  getDateSerializationFormat: getDateSerializationFormat
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 62754:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Deferred = Deferred;
exports.fromPromise = fromPromise;
exports.setStrategy = setStrategy;
exports.when = when;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const deferredConfig = [{
  method: 'resolve',
  handler: 'done',
  state: 'resolved'
}, {
  method: 'reject',
  handler: 'fail',
  state: 'rejected'
}, {
  method: 'notify',
  handler: 'progress'
}];
let DeferredObj = function () {
  const that = this;
  this._state = 'pending';
  this._promise = {};
  deferredConfig.forEach(function (config) {
    const methodName = config.method;
    this[methodName + 'Callbacks'] = (0, _callbacks.default)();
    this[methodName] = function () {
      return this[methodName + 'With'](this._promise, arguments);
    }.bind(this);
    this._promise[config.handler] = function (handler) {
      if (!handler) return this;
      const callbacks = that[methodName + 'Callbacks'];
      if (callbacks.fired()) {
        handler.apply(that[methodName + 'Context'], that[methodName + 'Args']);
      } else {
        callbacks.add(function (context, args) {
          handler.apply(context, args);
        }.bind(this));
      }
      return this;
    };
  }.bind(this));
  this._promise.always = function (handler) {
    return this.done(handler).fail(handler);
  };
  this._promise.catch = function (handler) {
    return this.then(null, handler);
  };
  this._promise.then = function (resolve, reject) {
    const result = new DeferredObj();
    ['done', 'fail'].forEach(function (method) {
      const callback = method === 'done' ? resolve : reject;
      this[method](function () {
        if (!callback) {
          result[method === 'done' ? 'resolve' : 'reject'].apply(this, arguments);
          return;
        }
        const callbackResult = callback && callback.apply(this, arguments);
        if ((0, _type.isDeferred)(callbackResult)) {
          callbackResult.done(result.resolve).fail(result.reject);
        } else if ((0, _type.isPromise)(callbackResult)) {
          callbackResult.then(result.resolve, result.reject);
        } else {
          result.resolve.apply(this, (0, _type.isDefined)(callbackResult) ? [callbackResult] : arguments);
        }
      });
    }.bind(this));
    return result.promise();
  };
  this._promise.state = function () {
    return that._state;
  };
  this._promise.promise = function (args) {
    return args ? (0, _extend.extend)(args, that._promise) : that._promise;
  };
  this._promise.promise(this);
};
deferredConfig.forEach(function (config) {
  const methodName = config.method;
  const state = config.state;
  DeferredObj.prototype[methodName + 'With'] = function (context, args) {
    const callbacks = this[methodName + 'Callbacks'];
    if (this.state() === 'pending') {
      this[methodName + 'Args'] = args;
      this[methodName + 'Context'] = context;
      if (state) this._state = state;
      callbacks.fire(context, args);
      if (state !== 'pending') {
        this.resolveCallbacks.empty();
        this.rejectCallbacks.empty();
      }
    }
    return this;
  };
});
function fromPromise(promise, context) {
  if ((0, _type.isDeferred)(promise)) {
    return promise;
  } else if ((0, _type.isPromise)(promise)) {
    const d = new DeferredObj();
    promise.then(function () {
      d.resolveWith.apply(d, [context].concat([[].slice.call(arguments)]));
    }, function () {
      d.rejectWith.apply(d, [context].concat([[].slice.call(arguments)]));
    });
    return d;
  }
  return new DeferredObj().resolveWith(context, [promise]);
}
let whenFunc = function () {
  if (arguments.length === 1) {
    return fromPromise(arguments[0]);
  }
  const values = [].slice.call(arguments);
  const contexts = [];
  let resolvedCount = 0;
  const deferred = new DeferredObj();
  const updateState = function (i) {
    return function (value) {
      contexts[i] = this;
      values[i] = arguments.length > 1 ? [].slice.call(arguments) : value;
      resolvedCount++;
      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
    };
  };
  for (let i = 0; i < values.length; i++) {
    if ((0, _type.isDeferred)(values[i])) {
      values[i].promise().done(updateState(i)).fail(deferred.reject);
    } else {
      resolvedCount++;
    }
  }
  if (resolvedCount === values.length) {
    deferred.resolveWith(contexts, values);
  }
  return deferred.promise();
};
function setStrategy(value) {
  DeferredObj = value.Deferred;
  whenFunc = value.when;
}
function Deferred() {
  return new DeferredObj();
}
function when() {
  return whenFunc.apply(this, arguments);
}

/***/ }),

/***/ 20476:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _class = _interopRequireDefault(__webpack_require__(38377));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(object) {
  const BaseClass = _class.default.inherit(object);
  let InjectedClass = BaseClass;
  let instance = new InjectedClass(object);
  const initialFields = {};
  const injectFields = function (injectionObject, initial) {
    (0, _iterator.each)(injectionObject, function (key) {
      if ((0, _type.isFunction)(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function () {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }
        object[key] = instance[key];
      }
    });
  };
  injectFields(object, true);
  object.inject = function (injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };
  object.resetInjection = function () {
    (0, _extend.extend)(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };
  return object;
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 3532:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.resetActiveElement = exports.replaceWith = exports.normalizeTemplateElement = exports.isElementInDom = exports.insertBefore = exports.extractTemplateMarkup = exports.createTextElementHiddenCopy = exports.contains = exports.closestCommonParent = exports.clipboardText = exports.clearSelection = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const getRootNodeHost = element => {
  if (!element.getRootNode) {
    return undefined;
  }
  const host = element.getRootNode().host;

  // NOTE: getRootNode().host can return a string if element is detached "a" element
  if ((0, _type.isString)(host)) {
    return undefined;
  }
  return host;
};
const resetActiveElement = () => {
  const activeElement = _dom_adapter.default.getActiveElement();
  if (activeElement && activeElement !== _dom_adapter.default.getBody()) {
    var _activeElement$blur;
    (_activeElement$blur = activeElement.blur) === null || _activeElement$blur === void 0 || _activeElement$blur.call(activeElement);
  }
};
exports.resetActiveElement = resetActiveElement;
const clearSelection = () => {
  const selection = window.getSelection();
  if (!selection) return;
  if (selection.type === 'Caret') return;
  if (selection.empty) {
    selection.empty();
  } else if (selection.removeAllRanges) {
    // T522811
    try {
      selection.removeAllRanges();
    } catch (e) {}
  }
};
exports.clearSelection = clearSelection;
const closestCommonParent = (startTarget, endTarget) => {
  const $startTarget = (0, _renderer.default)(startTarget);
  const $endTarget = (0, _renderer.default)(endTarget);
  if ($startTarget[0] === $endTarget[0]) {
    return $startTarget[0];
  }
  const $startParents = $startTarget.parents();
  const $endParents = $endTarget.parents();
  const startingParent = Math.min($startParents.length, $endParents.length);
  for (let i = -startingParent; i < 0; i++) {
    if ($startParents.get(i) === $endParents.get(i)) {
      return $startParents.get(i);
    }
  }
};
exports.closestCommonParent = closestCommonParent;
const extractTemplateMarkup = element => {
  element = (0, _renderer.default)(element);
  const templateTag = element.length && element.filter(function isNotExecutableScript() {
    const $node = (0, _renderer.default)(this);
    return $node.is('script[type]') && $node.attr('type').indexOf('script') < 0;
  });
  if (templateTag.length) {
    return templateTag.eq(0).html();
  } else {
    element = (0, _renderer.default)('<div>').append(element);
    return element.html();
  }
};
exports.extractTemplateMarkup = extractTemplateMarkup;
const normalizeTemplateElement = element => {
  let $element = (0, _type.isDefined)(element) && (element.nodeType || (0, _type.isRenderer)(element)) ? (0, _renderer.default)(element) : (0, _renderer.default)('<div>').html(element).contents();
  if ($element.length === 1) {
    if ($element.is('script')) {
      $element = normalizeTemplateElement($element.html().trim());
    } else if ($element.is('table')) {
      $element = $element.children('tbody').contents();
    }
  }
  return $element;
};
exports.normalizeTemplateElement = normalizeTemplateElement;
const clipboardText = (event, text) => {
  const clipboard = event.originalEvent && event.originalEvent.clipboardData || window.clipboardData;
  if (!text) {
    return clipboard && clipboard.getData('Text');
  }
  clipboard && clipboard.setData('Text', text);
};
exports.clipboardText = clipboardText;
const contains = (container, element) => {
  if (!element) {
    return false;
  }
  if ((0, _type.isWindow)(container)) {
    return contains(container.document, element);
  }
  return container.contains(element) || contains(container, getRootNodeHost(element));
};
exports.contains = contains;
const createTextElementHiddenCopy = (element, text, options) => {
  const elementStyles = window.getComputedStyle((0, _renderer.default)(element).get(0));
  const includePaddings = options && options.includePaddings;
  return (0, _renderer.default)('<div>').text(text).css({
    'fontStyle': elementStyles.fontStyle,
    'fontVariant': elementStyles.fontVariant,
    'fontWeight': elementStyles.fontWeight,
    'fontSize': elementStyles.fontSize,
    'fontFamily': elementStyles.fontFamily,
    'letterSpacing': elementStyles.letterSpacing,
    'border': elementStyles.border,
    'paddingTop': includePaddings ? elementStyles.paddingTop : '',
    'paddingRight': includePaddings ? elementStyles.paddingRight : '',
    'paddingBottom': includePaddings ? elementStyles.paddingBottom : '',
    'paddingLeft': includePaddings ? elementStyles.paddingLeft : '',
    'visibility': 'hidden',
    'whiteSpace': 'pre',
    'position': 'absolute',
    'float': 'left'
  });
};
exports.createTextElementHiddenCopy = createTextElementHiddenCopy;
const insertBefore = (element, newElement) => {
  if (newElement) {
    _dom_adapter.default.insertElement(element.parentNode, newElement, element);
  }
  return element;
};
exports.insertBefore = insertBefore;
const replaceWith = (element, newElement) => {
  if (!(newElement && newElement[0])) return;
  if (newElement.is(element)) return element;
  (0, _iterator.each)(newElement, (_, currentElement) => {
    insertBefore(element[0], currentElement);
  });
  element.remove();
  return newElement;
};
exports.replaceWith = replaceWith;
const isElementInDom = $element => {
  const element = $element === null || $element === void 0 ? void 0 : $element.get(0);
  const shadowHost = element === null || element === void 0 ? void 0 : element.getRootNode().host;
  return !!(0, _renderer.default)(shadowHost || element).closest((0, _window.getWindow)().document).length;
};
exports.isElementInDom = isElementInDom;

/***/ }),

/***/ 95640:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _extend = __webpack_require__(13306);
var _console = __webpack_require__(30869);
var _string = __webpack_require__(68752);
var _version = __webpack_require__(36739);
/* eslint-disable import/no-commonjs */

const ERROR_URL = 'https://js.devexpress.com/error/' + _version.version.split('.').slice(0, 2).join('_') + '/';
function _default(baseErrors, errors) {
  const exports = {
    ERROR_MESSAGES: (0, _extend.extend)(errors, baseErrors),
    Error: function () {
      return makeError([].slice.call(arguments));
    },
    log: function (id) {
      let method = 'log';
      if (/^E\d+$/.test(id)) {
        method = 'error';
      } else if (/^W\d+$/.test(id)) {
        method = 'warn';
      }
      _console.logger[method](method === 'log' ? id : combineMessage([].slice.call(arguments)));
    }
  };
  function combineMessage(args) {
    const id = args[0];
    args = args.slice(1);
    return formatMessage(id, formatDetails(id, args));
  }
  function formatDetails(id, args) {
    args = [exports.ERROR_MESSAGES[id]].concat(args);
    return _string.format.apply(this, args).replace(/\.*\s*?$/, '');
  }
  function formatMessage(id, details) {
    const kind = id !== null && id !== void 0 && id.startsWith('W') ? 'warning' : 'error';
    return _string.format.apply(this, ['{0} - {1}.\n\nFor additional information on this {2} message, see: {3}', id, details, kind, getErrorUrl(id)]);
  }
  function makeError(args) {
    const id = args[0];
    args = args.slice(1);
    const details = formatDetails(id, args);
    const url = getErrorUrl(id);
    const message = formatMessage(id, details);
    return (0, _extend.extend)(new Error(message), {
      __id: id,
      __details: details,
      url: url
    });
  }
  function getErrorUrl(id) {
    return ERROR_URL + id;
  }
  return exports;
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 13306:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.extendFromObject = exports.extend = void 0;
var _type = __webpack_require__(35922);
const extendFromObject = function (target, source, overrideExistingValues) {
  target = target || {};
  for (const prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      const value = source[prop];
      if (!(prop in target) || overrideExistingValues) {
        target[prop] = value;
      }
    }
  }
  return target;
};
exports.extendFromObject = extendFromObject;
const extend = function (target) {
  target = target || {};
  let i = 1;
  let deep = false;
  if (typeof target === 'boolean') {
    deep = target;
    target = arguments[1] || {};
    i++;
  }
  for (; i < arguments.length; i++) {
    const source = arguments[i];
    if (source == null) {
      continue;
    }
    for (const key in source) {
      const targetValue = target[key];
      const sourceValue = source[key];
      let sourceValueIsArray = false;
      let clone;
      if (key === '__proto__' || key === 'constructor' || target === sourceValue) {
        continue;
      }
      if (deep && sourceValue && ((0, _type.isPlainObject)(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
        if (sourceValueIsArray) {
          clone = targetValue && Array.isArray(targetValue) ? targetValue : [];
        } else {
          clone = targetValue && (0, _type.isPlainObject)(targetValue) ? targetValue : {};
        }
        target[key] = extend(deep, clone, sourceValue);
      } else if (sourceValue !== undefined) {
        target[key] = sourceValue;
      }
    }
  }
  return target;
};
exports.extend = extend;

/***/ }),

/***/ 61371:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.parseHTML = exports.isTablePart = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
const tagWrappers = {
  default: {
    tagsCount: 0,
    startTags: '',
    endTags: ''
  },
  thead: {
    tagsCount: 1,
    startTags: '<table>',
    endTags: '</table>'
  },
  td: {
    tagsCount: 3,
    startTags: '<table><tbody><tr>',
    endTags: '</tr></tbody></table>'
  },
  col: {
    tagsCount: 2,
    startTags: '<table><colgroup>',
    endTags: '</colgroup></table>'
  },
  tr: {
    tagsCount: 2,
    startTags: '<table><tbody>',
    endTags: '</tbody></table>'
  }
};
tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
tagWrappers.th = tagWrappers.td;
const parseHTML = function (html) {
  if (typeof html !== 'string') {
    return null;
  }
  const fragment = _dom_adapter.default.createDocumentFragment();
  let container = fragment.appendChild(_dom_adapter.default.createElement('div'));
  const tags = isTagName.exec(html);
  const firstRootTag = tags && tags[1].toLowerCase();
  const tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
  container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
  for (let i = 0; i < tagWrapper.tagsCount; i++) {
    container = container.lastChild;
  }
  return [...container.childNodes];
};
exports.parseHTML = parseHTML;
const isTablePart = function (html) {
  const tags = isTagName.exec(html);
  return tags && tags[1] in tagWrappers;
};
exports.isTablePart = isTablePart;

/***/ }),

/***/ 44899:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getImageSourceType = exports.getImageContainer = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ICON_CLASS = 'dx-icon';
const SVG_ICON_CLASS = 'dx-svg-icon';
const getImageSourceType = source => {
  if (!source || typeof source !== 'string') {
    return false;
  }
  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return 'svg';
  }
  if (/data:.*base64|\.|[^<\s]\/{1,1}/.test(source)) {
    return 'image';
  }
  if (/^[\w-_]+$/.test(source)) {
    return 'dxIcon';
  }
  if (/^\s?([\w-_:]\s?)+$/.test(source)) {
    return 'fontIcon';
  }
  return false;
};
exports.getImageSourceType = getImageSourceType;
const getImageContainer = source => {
  switch (getImageSourceType(source)) {
    case 'image':
      return (0, _renderer.default)('<img>').attr('src', source).addClass(ICON_CLASS);
    case 'fontIcon':
      return (0, _renderer.default)('<i>').addClass(`${ICON_CLASS} ${source}`);
    case 'dxIcon':
      return (0, _renderer.default)('<i>').addClass(`${ICON_CLASS} ${ICON_CLASS}-${source}`);
    case 'svg':
      return (0, _renderer.default)('<i>').addClass(`${ICON_CLASS} ${SVG_ICON_CLASS}`).append(source);
    default:
      return null;
  }
};
exports.getImageContainer = getImageContainer;

/***/ }),

/***/ 78008:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.underscore = exports.titleize = exports.humanize = exports.dasherize = exports.captionize = exports.camelize = void 0;
var _iterator = __webpack_require__(95479);
const _normalize = function (text) {
  if (text === undefined || text === null) {
    return '';
  }
  return String(text);
};
const _upperCaseFirst = function (text) {
  return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
};
const _chop = function (text) {
  return _normalize(text).replace(/([a-z\d])([A-Z])/g, '$1 $2').split(/[\s_-]+/);
};
const dasherize = function (text) {
  return (0, _iterator.map)(_chop(text), function (p) {
    return p.toLowerCase();
  }).join('-');
};
exports.dasherize = dasherize;
const underscore = function (text) {
  return dasherize(text).replace(/-/g, '_');
};
exports.underscore = underscore;
const camelize = function (text, upperFirst) {
  return (0, _iterator.map)(_chop(text), function (p, i) {
    p = p.toLowerCase();
    if (upperFirst || i > 0) {
      p = _upperCaseFirst(p);
    }
    return p;
  }).join('');
};
exports.camelize = camelize;
const humanize = function (text) {
  return _upperCaseFirst(dasherize(text).replace(/-/g, ' '));
};
exports.humanize = humanize;
const titleize = function (text) {
  return (0, _iterator.map)(_chop(text), function (p) {
    return _upperCaseFirst(p.toLowerCase());
  }).join(' ');
};
exports.titleize = titleize;
const DIGIT_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
const captionize = function (name) {
  const captionList = [];
  let i;
  let char;
  let isPrevCharNewWord = false;
  let isNewWord = false;
  for (i = 0; i < name.length; i++) {
    char = name.charAt(i);
    isNewWord = char === char.toUpperCase() && char !== '-' && char !== ')' && char !== '/' || char in DIGIT_CHARS;
    if (char === '_' || char === '.') {
      char = ' ';
      isNewWord = true;
    } else if (i === 0) {
      char = char.toUpperCase();
      isNewWord = true;
    } else if (!isPrevCharNewWord && isNewWord) {
      if (captionList.length > 0) {
        captionList.push(' ');
      }
    }
    captionList.push(char);
    isPrevCharNewWord = isNewWord;
  }
  return captionList.join('');
};
exports.captionize = captionize;

/***/ }),

/***/ 95479:
/***/ (function(__unused_webpack_module, exports) {



exports.reverseEach = exports.map = exports.each = void 0;
const map = (values, callback) => {
  if (Array.isArray(values)) {
    return values.map(callback);
  }
  const result = [];
  for (const key in values) {
    result.push(callback(values[key], key));
  }
  return result;
};

/**
 * @type {{
 *   <T>(values: readonly T[], callback: (this: T,          index: number,  value: T)          => void | boolean): T[],
 *   <T>(values: T,            callback: (this: T[keyof T], index: keyof T, value: T[keyof T]) => void | boolean): T,
 * }}
 */
exports.map = map;
const each = (values, callback) => {
  if (!values) return;
  if ('length' in values) {
    for (let i = 0; i < values.length; i++) {
      if (callback.call(values[i], i, values[i]) === false) {
        break;
      }
    }
  } else {
    for (const key in values) {
      if (callback.call(values[key], key, values[key]) === false) {
        break;
      }
    }
  }
  return values;
};
exports.each = each;
const reverseEach = (array, callback) => {
  if (!array || !('length' in array) || array.length === 0) return;
  for (let i = array.length - 1; i >= 0; i--) {
    if (callback.call(array[i], i, array[i]) === false) {
      break;
    }
  }
};
exports.reverseEach = reverseEach;

/***/ }),

/***/ 88933:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const Locker = function () {
  const info = {};
  const currentCount = function (lockName) {
    return info[lockName] || 0;
  };
  return {
    obtain: function (lockName) {
      info[lockName] = currentCount(lockName) + 1;
    },
    release: function (lockName) {
      const count = currentCount(lockName);
      if (count < 1) {
        throw _errors.default.Error('E0014');
      }
      if (count === 1) {
        delete info[lockName];
      } else {
        info[lockName] = count - 1;
      }
    },
    locked: function (lockName) {
      return currentCount(lockName) > 0;
    }
  };
};
var _default = exports["default"] = Locker;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 60810:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.adjust = adjust;
exports.fitIntoRange = void 0;
exports.getExponent = getExponent;
exports.getExponentLength = getExponentLength;
exports.getPrecision = getPrecision;
exports.getRemainderByDivision = getRemainderByDivision;
exports.getRoot = getRoot;
exports.inRange = void 0;
exports.multiplyInExponentialForm = multiplyInExponentialForm;
exports.roundFloatPart = roundFloatPart;
exports.sign = void 0;
exports.solveCubicEquation = solveCubicEquation;
exports.trunc = trunc;
var _type = __webpack_require__(35922);
const sign = function (value) {
  if (value === 0) {
    return 0;
  }
  return value / Math.abs(value);
};
exports.sign = sign;
const fitIntoRange = function (value, minValue, maxValue) {
  const isMinValueUndefined = !minValue && minValue !== 0;
  const isMaxValueUndefined = !maxValue && maxValue !== 0;
  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value, maxValue) : value);
  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value, minValue) : value);
  return Math.min(Math.max(value, minValue), maxValue);
};
exports.fitIntoRange = fitIntoRange;
const inRange = function (value, minValue, maxValue) {
  return value >= minValue && value <= maxValue;
};
exports.inRange = inRange;
function getExponent(value) {
  return Math.abs(parseInt(value.toExponential().split('e')[1]));
}
function getExponentialNotation(value) {
  const parts = value.toExponential().split('e');
  const mantissa = parseFloat(parts[0]);
  const exponent = parseInt(parts[1]);
  return {
    exponent,
    mantissa
  };
}
function multiplyInExponentialForm(value, exponentShift) {
  const exponentialNotation = getExponentialNotation(value);
  return parseFloat(`${exponentialNotation.mantissa}e${exponentialNotation.exponent + exponentShift}`);
}

// T570217
function _isEdgeBug() {
  const value = 0.0003;
  const correctValue = '0.000300';
  const precisionValue = 3;
  return correctValue !== value.toPrecision(precisionValue);
}
function adjust(value, interval) {
  let precision = getPrecision(interval || 0) + 2;
  const separatedValue = value.toString().split('.');
  const sourceValue = value;
  const absValue = Math.abs(value);
  let separatedAdjustedValue;
  const isExponentValue = (0, _type.isExponential)(value);
  const integerPart = absValue > 1 ? 10 : 0;
  if (separatedValue.length === 1) {
    return value;
  }
  if (!isExponentValue) {
    if ((0, _type.isExponential)(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }
    value = absValue;
    value = value - Math.floor(value) + integerPart;
  }
  precision = _isEdgeBug() && getExponent(value) > 6 || precision > 7 ? 15 : 7; // fix toPrecision() bug in Edge (T570217)

  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value.toPrecision(precision)).toString().split('.');
    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(separatedValue[0] + '.' + separatedAdjustedValue[1]);
    }
  }
  return parseFloat(sourceValue.toPrecision(precision));
}
function getPrecision(value) {
  const str = value.toString();
  if (str.indexOf('.') < 0) {
    return 0;
  }
  const mantissa = str.split('.');
  const positionOfDelimiter = mantissa[1].indexOf('e');
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}
function getRoot(x, n) {
  if (x < 0 && n % 2 !== 1) {
    return NaN;
  }
  const y = Math.pow(Math.abs(x), 1 / n);
  return n % 2 === 1 && x < 0 ? -y : y;
}
function solveCubicEquation(a, b, c, d) {
  const min = 1e-8;
  if (Math.abs(a) < min) {
    a = b;
    b = c;
    c = d;
    if (Math.abs(a) < min) {
      a = b;
      b = c;
      if (Math.abs(a) < min) {
        return [];
      }
      return [-b / a];
    }
    const D2 = b * b - 4 * a * c;
    if (Math.abs(D2) < min) {
      return [-b / (2 * a)];
    } else if (D2 > 0) {
      return [(-b + Math.sqrt(D2)) / (2 * a), (-b - Math.sqrt(D2)) / (2 * a)];
    }
    return [];
  }
  const p = (3 * a * c - b * b) / (3 * a * a);
  const q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a);
  let roots;
  let u;
  if (Math.abs(p) < min) {
    roots = [getRoot(-q, 3)];
  } else if (Math.abs(q) < min) {
    roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : []);
  } else {
    const D3 = q * q / 4 + p * p * p / 27;
    if (Math.abs(D3) < min) {
      roots = [-1.5 * q / p, 3 * q / p];
    } else if (D3 > 0) {
      u = getRoot(-q / 2 - Math.sqrt(D3), 3);
      roots = [u - p / (3 * u)];
    } else {
      u = 2 * Math.sqrt(-p / 3);
      const t = Math.acos(3 * q / p / u) / 3;
      const k = 2 * Math.PI / 3;
      roots = [u * Math.cos(t), u * Math.cos(t - k), u * Math.cos(t - 2 * k)];
    }
  }
  for (let i = 0; i < roots.length; i++) {
    roots[i] -= b / (3 * a);
  }
  return roots;
}
function trunc(value) {
  return Math.trunc ? Math.trunc(value) : value > 0 ? Math.floor(value) : Math.ceil(value);
}
function getRemainderByDivision(dividend, divider, digitsCount) {
  if (divider === parseInt(divider)) {
    return dividend % divider;
  }
  const quotient = roundFloatPart(dividend / divider, digitsCount);
  return (quotient - parseInt(quotient)) * divider;
}
function getExponentLength(value) {
  var _valueString$split$;
  const valueString = value.toString();
  return ((_valueString$split$ = valueString.split('.')[1]) === null || _valueString$split$ === void 0 ? void 0 : _valueString$split$.length) || parseInt(valueString.split('e-')[1]) || 0;
}
function roundFloatPart(value) {
  let digitsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return parseFloat(value.toFixed(digitsCount));
}

/***/ }),

/***/ 48013:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.orderEach = exports.deepExtendArraySafe = exports.clone = void 0;
var _type = __webpack_require__(35922);
var _variable_wrapper = _interopRequireDefault(__webpack_require__(26974));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const clone = exports.clone = function () {
  function Clone() {}
  return function (obj) {
    Clone.prototype = obj;
    return new Clone();
  };
}();
const orderEach = function (map, func) {
  const keys = [];
  let key;
  let i;
  for (key in map) {
    if (Object.prototype.hasOwnProperty.call(map, key)) {
      keys.push(key);
    }
  }
  keys.sort(function (x, y) {
    const isNumberX = (0, _type.isNumeric)(x);
    const isNumberY = (0, _type.isNumeric)(y);
    if (isNumberX && isNumberY) return x - y;
    if (isNumberX && !isNumberY) return -1;
    if (!isNumberX && isNumberY) return 1;
    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
  });
  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    func(key, map[key]);
  }
};
exports.orderEach = orderEach;
const assignValueToProperty = function (target, property, value, assignByReference) {
  if (!assignByReference && _variable_wrapper.default.isWrapped(target[property])) {
    _variable_wrapper.default.assign(target[property], value);
  } else {
    target[property] = value;
  }
};

// B239679, http://bugs.jquery.com/ticket/9477
const deepExtendArraySafe = function (target, changes, extendComplexObject, assignByReference) {
  let prevValue;
  let newValue;
  for (const name in changes) {
    prevValue = target[name];
    newValue = changes[name];
    if (name === '__proto__' || name === 'constructor' || target === newValue) {
      continue;
    }
    if ((0, _type.isPlainObject)(newValue)) {
      const goDeeper = extendComplexObject ? (0, _type.isObject)(prevValue) : (0, _type.isPlainObject)(prevValue);
      newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference);
    }
    if (newValue !== undefined && prevValue !== newValue) {
      assignValueToProperty(target, name, newValue, assignByReference);
    }
  }
  return target;
};
exports.deepExtendArraySafe = deepExtendArraySafe;

/***/ }),

/***/ 37518:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getDefaultAlignment = exports.getBoundingRect = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const getDefaultAlignment = isRtlEnabled => {
  const rtlEnabled = isRtlEnabled ?? (0, _config.default)().rtlEnabled;
  return rtlEnabled ? 'right' : 'left';
};
exports.getDefaultAlignment = getDefaultAlignment;
const getBoundingRect = element => {
  if ((0, _type.isWindow)(element)) {
    return {
      width: element.outerWidth,
      height: element.outerHeight
    };
  }
  return element.getBoundingClientRect();
};
exports.getBoundingRect = getBoundingRect;

/***/ }),

/***/ 9321:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.attachInstanceToElement = attachInstanceToElement;
exports.getInstanceByElement = getInstanceByElement;
exports.name = void 0;
var _element_data = __webpack_require__(97906);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _type = __webpack_require__(35922);
var _remove = __webpack_require__(29007);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const COMPONENT_NAMES_DATA_KEY = 'dxComponents';
const ANONYMOUS_COMPONENT_DATA_KEY = 'dxPrivateComponent';
const componentNames = new WeakMap();
let nextAnonymousComponent = 0;
const getName = function (componentClass, newName) {
  if ((0, _type.isDefined)(newName)) {
    componentNames.set(componentClass, newName);
    return;
  }
  if (!componentNames.has(componentClass)) {
    const generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
    componentNames.set(componentClass, generatedName);
    return generatedName;
  }
  return componentNames.get(componentClass);
};
exports.name = getName;
function attachInstanceToElement($element, componentInstance, disposeFn) {
  const data = (0, _element_data.data)($element.get(0));
  const name = getName(componentInstance.constructor);
  data[name] = componentInstance;
  if (disposeFn) {
    _events_engine.default.one($element, _remove.removeEvent, function () {
      disposeFn.call(componentInstance);
    });
  }
  if (!data[COMPONENT_NAMES_DATA_KEY]) {
    data[COMPONENT_NAMES_DATA_KEY] = [];
  }
  data[COMPONENT_NAMES_DATA_KEY].push(name);
}
function getInstanceByElement($element, componentClass) {
  const name = getName(componentClass);
  return (0, _element_data.data)($element.get(0), name);
}

/***/ }),

/***/ 59504:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.create = createQueue;
exports.enqueue = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function createQueue(discardPendingTasks) {
  let _tasks = [];
  let _busy = false;
  function exec() {
    while (_tasks.length) {
      _busy = true;
      const task = _tasks.shift();
      const result = task();
      if (result === undefined) {
        continue;
      }
      if (result.then) {
        // NOTE: immediate "then" on the next line can reset it back to false
        (0, _deferred.when)(result).always(exec);
        return;
      }
      throw _errors.default.Error('E0015');
    }
    _busy = false;
  }
  function add(task, removeTaskCallback) {
    if (!discardPendingTasks) {
      _tasks.push(task);
    } else {
      if (_tasks[0] && removeTaskCallback) {
        removeTaskCallback(_tasks[0]);
      }
      _tasks = [task];
    }
    if (!_busy) {
      exec();
    }
  }
  function busy() {
    return _busy;
  }
  return {
    add: add,
    busy: busy
  };
}
const enqueue = exports.enqueue = createQueue().add; // Default global queue for UI sync, consider renaming

/***/ }),

/***/ 24311:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _window = __webpack_require__(58201);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let callbacks = [];
const subscribeReady = (0, _call_once.default)(() => {
  const removeListener = _dom_adapter.default.listen(_dom_adapter.default.getDocument(), 'DOMContentLoaded', () => {
    readyCallbacks.fire();
    removeListener();
  });
});
const readyCallbacks = {
  add: callback => {
    const windowExists = (0, _window.hasWindow)();
    if (windowExists && _dom_adapter.default.getReadyState() !== 'loading') {
      callback();
    } else {
      callbacks.push(callback);
      windowExists && subscribeReady();
    }
  },
  fire: () => {
    callbacks.forEach(callback => callback());
    callbacks = [];
  }
};
var _default = exports["default"] = (0, _dependency_injector.default)(readyCallbacks);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 55814:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _call_once = _interopRequireDefault(__webpack_require__(39618));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const resizeCallbacks = function () {
  let prevSize;
  const callbacks = (0, _callbacks.default)();
  const originalCallbacksAdd = callbacks.add;
  const originalCallbacksRemove = callbacks.remove;
  if (!(0, _window.hasWindow)()) {
    return callbacks;
  }
  const formatSize = function () {
    const window = (0, _window.getWindow)();
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  };
  const handleResize = function () {
    const now = formatSize();
    if (now.width === prevSize.width && now.height === prevSize.height) {
      return;
    }
    let changedDimension;
    if (now.width === prevSize.width) {
      changedDimension = 'height';
    }
    if (now.height === prevSize.height) {
      changedDimension = 'width';
    }
    prevSize = now;
    callbacks.fire(changedDimension);
  };
  const setPrevSize = (0, _call_once.default)(function () {
    prevSize = formatSize();
  });
  let removeListener;
  callbacks.add = function () {
    const result = originalCallbacksAdd.apply(callbacks, arguments);
    setPrevSize();
    _ready_callbacks.default.add(function () {
      if (!removeListener && callbacks.has()) {
        removeListener = _dom_adapter.default.listen((0, _window.getWindow)(), 'resize', handleResize);
      }
    });
    return result;
  };
  callbacks.remove = function () {
    const result = originalCallbacksRemove.apply(callbacks, arguments);
    if (!callbacks.has() && removeListener) {
      removeListener();
      removeListener = undefined;
    }
    return result;
  };
  return callbacks;
}();
var _default = exports["default"] = resizeCallbacks;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 90330:
/***/ (function(__unused_webpack_module, exports) {



exports.addShadowDomStyles = addShadowDomStyles;
exports.getShadowElementsFromPoint = getShadowElementsFromPoint;
const DX_RULE_PREFIX = 'dx-';
let ownerDocumentStyleSheet = null;
function createConstructedStyleSheet(rootNode) {
  try {
    // eslint-disable-next-line no-undef
    return new CSSStyleSheet();
  } catch (err) {
    const styleElement = rootNode.ownerDocument.createElement('style');
    rootNode.appendChild(styleElement);
    return styleElement.sheet;
  }
}
function processRules(targetStyleSheet, styleSheets, needApplyAllStyles) {
  for (let i = 0; i < styleSheets.length; i++) {
    const sheet = styleSheets[i];
    try {
      for (let j = 0; j < sheet.cssRules.length; j++) {
        insertRule(targetStyleSheet, sheet.cssRules[j], needApplyAllStyles);
      }
    } catch (err) {
      // NOTE: need try/catch block for not-supported cross-domain css
    }
  }
}
function insertRule(targetStyleSheet, rule, needApplyAllStyles) {
  var _rule$selectorText, _rule$cssRules, _rule$name, _rule$style;
  const isDxRule = needApplyAllStyles || ((_rule$selectorText = rule.selectorText) === null || _rule$selectorText === void 0 ? void 0 : _rule$selectorText.includes(DX_RULE_PREFIX)) || ((_rule$cssRules = rule.cssRules) === null || _rule$cssRules === void 0 || (_rule$cssRules = _rule$cssRules[0]) === null || _rule$cssRules === void 0 || (_rule$cssRules = _rule$cssRules.selectorText) === null || _rule$cssRules === void 0 ? void 0 : _rule$cssRules.includes(DX_RULE_PREFIX)) || ((_rule$name = rule.name) === null || _rule$name === void 0 ? void 0 : _rule$name.startsWith(DX_RULE_PREFIX)) || ((_rule$style = rule.style) === null || _rule$style === void 0 ? void 0 : _rule$style.fontFamily) === 'DXIcons';
  if (isDxRule) {
    targetStyleSheet.insertRule(rule.cssText, targetStyleSheet.cssRules.length);
  }
}
function addShadowDomStyles($element) {
  var _el$getRootNode;
  const el = $element.get(0);
  const root = (_el$getRootNode = el.getRootNode) === null || _el$getRootNode === void 0 ? void 0 : _el$getRootNode.call(el);
  if (!(root !== null && root !== void 0 && root.host)) {
    return;
  }
  if (!ownerDocumentStyleSheet) {
    ownerDocumentStyleSheet = createConstructedStyleSheet(root);
    processRules(ownerDocumentStyleSheet, el.ownerDocument.styleSheets, false);
  }
  const currentShadowDomStyleSheet = createConstructedStyleSheet(root);
  processRules(currentShadowDomStyleSheet, root.styleSheets, true);
  root.adoptedStyleSheets = [ownerDocumentStyleSheet, currentShadowDomStyleSheet];
}
function isPositionInElementRectangle(element, x, y) {
  const rect = element.getBoundingClientRect();
  return rect && x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom;
}
function createQueue() {
  let shiftIndex = 0;
  const items = [];
  return {
    push(item) {
      items.push(item);
      return this;
    },
    shift() {
      shiftIndex++;
      return items[shiftIndex - 1];
    },
    get length() {
      return items.length - shiftIndex;
    },
    get items() {
      return items;
    }
  };
}
function getShadowElementsFromPoint(x, y, root) {
  const elementQueue = createQueue().push(root);
  while (elementQueue.length) {
    const el = elementQueue.shift();
    for (let i = 0; i < el.childNodes.length; i++) {
      const childNode = el.childNodes[i];

      // eslint-disable-next-line no-undef
      if (childNode.nodeType === Node.ELEMENT_NODE && isPositionInElementRectangle(childNode, x, y) &&
      // eslint-disable-next-line no-undef
      getComputedStyle(childNode).pointerEvents !== 'none') {
        elementQueue.push(childNode);
      }
    }
  }
  const result = elementQueue.items.reverse();
  result.pop();
  return result;
}

/***/ }),

/***/ 58664:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.setWidth = exports.setOuterWidth = exports.setOuterHeight = exports.setInnerWidth = exports.setInnerHeight = exports.setHeight = exports.parseHeight = exports.implementationsMap = exports.getWindowByElement = exports.getWidth = exports.getVisibleHeight = exports.getVerticalOffsets = exports.getSize = exports.getOuterWidth = exports.getOuterHeight = exports.getOffset = exports.getInnerWidth = exports.getInnerHeight = exports.getHeight = exports.getElementBoxParams = exports.addOffsetToMinHeight = exports.addOffsetToMaxHeight = void 0;
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const SPECIAL_HEIGHT_VALUES = ['auto', 'none', 'inherit', 'initial'];
const getSizeByStyles = function (elementStyles, styles) {
  let result = 0;
  styles.forEach(function (style) {
    result += parseFloat(elementStyles[style]) || 0;
  });
  return result;
};
const getElementBoxParams = function (name, elementStyles) {
  const beforeName = name === 'width' ? 'Left' : 'Top';
  const afterName = name === 'width' ? 'Right' : 'Bottom';
  return {
    padding: getSizeByStyles(elementStyles, ['padding' + beforeName, 'padding' + afterName]),
    border: getSizeByStyles(elementStyles, ['border' + beforeName + 'Width', 'border' + afterName + 'Width']),
    margin: getSizeByStyles(elementStyles, ['margin' + beforeName, 'margin' + afterName])
  };
};
exports.getElementBoxParams = getElementBoxParams;
const getElementComputedStyle = function (element) {
  var _element$ownerDocumen;
  const view = (element === null || element === void 0 || (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.defaultView) || window;
  return view.getComputedStyle && view.getComputedStyle(element);
};
const getCSSProperty = function (element, styles, name, defaultValue) {
  var _element$style;
  return (styles === null || styles === void 0 ? void 0 : styles[name]) || ((_element$style = element.style) === null || _element$style === void 0 ? void 0 : _element$style[name]) || defaultValue;
};
const boxIndices = {
  content: 0,
  padding: 1,
  border: 2,
  margin: 3,
  'content-box': 0,
  'border-box': 2
};
const dimensionComponents = {
  width: ['left', 'right'],
  height: ['top', 'bottom']
};
function getComponentThickness(elem, dimension, component, styles) {
  const get = (elem, styles, field) => parseFloat(getCSSProperty(elem, styles, field, '0')) || 0;
  const suffix = component === 'border' ? '-width' : '';
  return get(elem, styles, `${component}-${dimensionComponents[dimension][0]}${suffix}`) + get(elem, styles, `${component}-${dimensionComponents[dimension][1]}${suffix}`);
}
const getSize = function (element, dimension, box) {
  const offsetFieldName = dimension === 'width' ? 'offsetWidth' : 'offsetHeight';
  const styles = getElementComputedStyle(element);
  let result = getCSSProperty(element, styles, dimension);
  if (result === '' || result === 'auto') {
    result = element[offsetFieldName];
  }
  result = parseFloat(result) || 0;
  const currentBox = getCSSProperty(element, styles, 'boxSizing', 'content-box');
  const targetBox = box || currentBox;
  let targetBoxIndex = boxIndices[targetBox];
  let currentBoxIndex = boxIndices[currentBox];
  if (targetBoxIndex === undefined || currentBoxIndex === undefined) {
    throw new Error();
  }
  if (currentBoxIndex === targetBoxIndex) {
    return result;
  }
  const coeff = Math.sign(targetBoxIndex - currentBoxIndex);
  let padding = false;
  let border = false;
  let margin = false;
  let scrollThickness = false;
  if (coeff === 1) {
    targetBoxIndex += 1;
    currentBoxIndex += 1;
  }
  for (let boxPart = currentBoxIndex; boxPart !== targetBoxIndex; boxPart += coeff) {
    switch (boxPart) {
      case boxIndices.content:
        break;
      case boxIndices.padding:
        padding = coeff * getComponentThickness(element, dimension, 'padding', styles);
        break;
      case boxIndices.border:
        border = coeff * getComponentThickness(element, dimension, 'border', styles);
        break;
      case boxIndices.margin:
        margin = coeff * getComponentThickness(element, dimension, 'margin', styles);
        break;
    }
  }
  if (padding || border) {
    const paddingAndBorder = (padding === false ? coeff * getComponentThickness(element, dimension, 'padding', styles) : padding) + (border === false ? coeff * getComponentThickness(element, dimension, 'border', styles) : border);
    scrollThickness = coeff * Math.max(0, Math.floor(element[offsetFieldName] - result - coeff * paddingAndBorder)) || 0;
  }
  return result + margin + padding + border + scrollThickness;
};
exports.getSize = getSize;
const getContainerHeight = function (container) {
  return (0, _type.isWindow)(container) ? container.innerHeight : container.offsetHeight;
};
const parseHeight = function (value, container, element) {
  if (value.indexOf('px') > 0) {
    value = parseInt(value.replace('px', ''));
  } else if (value.indexOf('%') > 0) {
    value = parseInt(value.replace('%', '')) * getContainerHeight(container) / 100;
  } else if (!isNaN(value)) {
    value = parseInt(value);
  } else if (value.indexOf('vh') > 0) {
    value = window.innerHeight / 100 * parseInt(value.replace('vh', ''));
  } else if (element && value.indexOf('em') > 0) {
    value = parseFloat(value.replace('em', '')) * parseFloat(window.getComputedStyle(element).fontSize);
  }
  return value;
};
exports.parseHeight = parseHeight;
const getHeightWithOffset = function (value, offset, container) {
  if (!value) {
    return null;
  }
  if (SPECIAL_HEIGHT_VALUES.indexOf(value) > -1) {
    return offset ? null : value;
  }
  if ((0, _type.isString)(value)) {
    value = parseHeight(value, container);
  }
  if ((0, _type.isNumeric)(value)) {
    return Math.max(0, value + offset);
  }
  const operationString = offset < 0 ? ' - ' : ' ';
  return 'calc(' + value + operationString + Math.abs(offset) + 'px)';
};
const addOffsetToMaxHeight = function (value, offset, container) {
  const maxHeight = getHeightWithOffset(value, offset, container);
  return maxHeight !== null ? maxHeight : 'none';
};
exports.addOffsetToMaxHeight = addOffsetToMaxHeight;
const addOffsetToMinHeight = function (value, offset, container) {
  const minHeight = getHeightWithOffset(value, offset, container);
  return minHeight !== null ? minHeight : 0;
};
exports.addOffsetToMinHeight = addOffsetToMinHeight;
const getVerticalOffsets = function (element, withMargins) {
  if (!element) {
    return 0;
  }
  const boxParams = getElementBoxParams('height', window.getComputedStyle(element));
  return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
};
exports.getVerticalOffsets = getVerticalOffsets;
const getVisibleHeight = function (element) {
  if (element) {
    const boundingClientRect = element.getBoundingClientRect();
    if (boundingClientRect.height) {
      return boundingClientRect.height;
    }
  }
  return 0;
};

// TODO: remove when we'll start mocking named exports
exports.getVisibleHeight = getVisibleHeight;
const implementationsMap = exports.implementationsMap = {
  getWidth: function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return elementSizeHelper('width', ...args);
  },
  setWidth: function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return elementSizeHelper('width', ...args);
  },
  getHeight: function () {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return elementSizeHelper('height', ...args);
  },
  setHeight: function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return elementSizeHelper('height', ...args);
  },
  getOuterWidth: function () {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return elementSizeHelper('outerWidth', ...args);
  },
  setOuterWidth: function () {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return elementSizeHelper('outerWidth', ...args);
  },
  getOuterHeight: function () {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return elementSizeHelper('outerHeight', ...args);
  },
  setOuterHeight: function () {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return elementSizeHelper('outerHeight', ...args);
  },
  getInnerWidth: function () {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return elementSizeHelper('innerWidth', ...args);
  },
  setInnerWidth: function () {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return elementSizeHelper('innerWidth', ...args);
  },
  getInnerHeight: function () {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return elementSizeHelper('innerHeight', ...args);
  },
  setInnerHeight: function () {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return elementSizeHelper('innerHeight', ...args);
  }
};
function elementSizeHelper(sizeProperty, el, value) {
  return arguments.length === 2 ? elementSize(el, sizeProperty) : elementSize(el, sizeProperty, value);
}
const getWidth = el => implementationsMap.getWidth(el);
exports.getWidth = getWidth;
const setWidth = (el, value) => implementationsMap.setWidth(el, value);
exports.setWidth = setWidth;
const getHeight = el => implementationsMap.getHeight(el);
exports.getHeight = getHeight;
const setHeight = (el, value) => implementationsMap.setHeight(el, value);
exports.setHeight = setHeight;
const getOuterWidth = (el, includeMargin) => implementationsMap.getOuterWidth(el, includeMargin || false);
exports.getOuterWidth = getOuterWidth;
const setOuterWidth = (el, value) => implementationsMap.setOuterWidth(el, value);
exports.setOuterWidth = setOuterWidth;
const getOuterHeight = (el, includeMargin) => implementationsMap.getOuterHeight(el, includeMargin || false);
exports.getOuterHeight = getOuterHeight;
const setOuterHeight = (el, value) => implementationsMap.setOuterHeight(el, value);
exports.setOuterHeight = setOuterHeight;
const getInnerWidth = el => implementationsMap.getInnerWidth(el);
exports.getInnerWidth = getInnerWidth;
const setInnerWidth = (el, value) => implementationsMap.setInnerWidth(el, value);
exports.setInnerWidth = setInnerWidth;
const getInnerHeight = el => implementationsMap.getInnerHeight(el);
exports.getInnerHeight = getInnerHeight;
const setInnerHeight = (el, value) => implementationsMap.setInnerHeight(el, value);
exports.setInnerHeight = setInnerHeight;
const elementSize = function (el, sizeProperty, value) {
  const partialName = sizeProperty.toLowerCase().indexOf('width') >= 0 ? 'Width' : 'Height';
  const propName = partialName.toLowerCase();
  const isOuter = sizeProperty.indexOf('outer') === 0;
  const isInner = sizeProperty.indexOf('inner') === 0;
  const isGetter = arguments.length === 2 || typeof value === 'boolean';
  if ((0, _type.isRenderer)(el)) {
    if (el.length > 1 && !isGetter) {
      for (let i = 0; i < el.length; i++) {
        elementSize(el[i], sizeProperty, value);
      }
      return;
    }
    el = el[0];
  }
  if (!el) return;
  if ((0, _type.isWindow)(el)) {
    return isOuter ? el['inner' + partialName] : _dom_adapter.default.getDocumentElement()['client' + partialName];
  }
  if (_dom_adapter.default.isDocument(el)) {
    const documentElement = _dom_adapter.default.getDocumentElement();
    const body = _dom_adapter.default.getBody();
    return Math.max(body['scroll' + partialName], body['offset' + partialName], documentElement['scroll' + partialName], documentElement['offset' + partialName], documentElement['client' + partialName]);
  }
  if (isGetter) {
    let box = 'content';
    if (isOuter) {
      box = value ? 'margin' : 'border';
    }
    if (isInner) {
      box = 'padding';
    }
    return getSize(el, propName, box);
  }
  if ((0, _type.isNumeric)(value)) {
    const elementStyles = getElementComputedStyle(el);
    const sizeAdjustment = getElementBoxParams(propName, elementStyles);
    const isBorderBox = elementStyles.boxSizing === 'border-box';
    value = Number(value);
    if (isOuter) {
      value -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
    } else if (isInner) {
      value += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
    } else if (isBorderBox) {
      value += sizeAdjustment.border + sizeAdjustment.padding;
    }
  }
  value += (0, _type.isNumeric)(value) ? 'px' : '';
  _dom_adapter.default.setStyle(el, propName, value);
  return null;
};
const getWindowByElement = el => {
  return (0, _type.isWindow)(el) ? el : el.defaultView;
};
exports.getWindowByElement = getWindowByElement;
const getOffset = el => {
  if (!el.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }
  const rect = el.getBoundingClientRect();
  const win = getWindowByElement(el.ownerDocument);
  const docElem = el.ownerDocument.documentElement;
  return {
    top: rect.top + win.pageYOffset - docElem.clientTop,
    left: rect.left + win.pageXOffset - docElem.clientLeft
  };
};
exports.getOffset = getOffset;

/***/ }),

/***/ 36613:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.sessionStorage = void 0;
var _window = __webpack_require__(58201);
const window = (0, _window.getWindow)();
const getSessionStorage = function () {
  let sessionStorage;
  try {
    sessionStorage = window.sessionStorage;
  } catch (e) {}
  return sessionStorage;
};
exports.sessionStorage = getSessionStorage;

/***/ }),

/***/ 68752:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.encodeHtml = void 0;
exports.format = format;
exports.quadToObject = exports.isEmpty = void 0;
var _type = __webpack_require__(35922);
const encodeHtml = exports.encodeHtml = function () {
  const encodeRegExp = [new RegExp('&', 'g'), new RegExp('"', 'g'), new RegExp('\'', 'g'), new RegExp('<', 'g'), new RegExp('>', 'g')];
  return function (str) {
    return String(str).replace(encodeRegExp[0], '&amp;').replace(encodeRegExp[1], '&quot;').replace(encodeRegExp[2], '&#39;').replace(encodeRegExp[3], '&lt;').replace(encodeRegExp[4], '&gt;');
  };
}();
const splitQuad = function (raw) {
  switch (typeof raw) {
    case 'string':
      return raw.split(/\s+/, 4);
    case 'object':
      return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
    case 'number':
      return [raw];
    default:
      return raw;
  }
};
const quadToObject = function (raw) {
  const quad = splitQuad(raw);
  let left = parseInt(quad && quad[0], 10);
  let top = parseInt(quad && quad[1], 10);
  let right = parseInt(quad && quad[2], 10);
  let bottom = parseInt(quad && quad[3], 10);
  if (!isFinite(left)) {
    left = 0;
  }
  if (!isFinite(top)) {
    top = left;
  }
  if (!isFinite(right)) {
    right = left;
  }
  if (!isFinite(bottom)) {
    bottom = top;
  }
  return {
    top: top,
    right: right,
    bottom: bottom,
    left: left
  };
};
exports.quadToObject = quadToObject;
function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if ((0, _type.isFunction)(template)) {
    return template(...values);
  }
  values.forEach((value, index) => {
    if ((0, _type.isString)(value)) {
      value = value.replace(/\$/g, '$$$$');
    }
    const placeholderReg = new RegExp('\\{' + index + '\\}', 'gm');
    template = template.replace(placeholderReg, value);
  });
  return template;
}
const isEmpty = exports.isEmpty = function () {
  const SPACE_REGEXP = /\s/g;
  return function (text) {
    return !text || !text.replace(SPACE_REGEXP, '');
  };
}();

/***/ }),

/***/ 80968:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.stylePropPrefix = exports.styleProp = exports.setWidth = exports.setStyle = exports.setHeight = exports.parsePixelValue = exports.normalizeStyleProp = void 0;
var _inflector = __webpack_require__(78008);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _type = __webpack_require__(35922);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const jsPrefixes = ['', 'Webkit', 'Moz', 'O', 'Ms'];
const cssPrefixes = {
  '': '',
  'Webkit': '-webkit-',
  'Moz': '-moz-',
  'O': '-o-',
  'ms': '-ms-'
};
const getStyles = (0, _call_once.default)(function () {
  return _dom_adapter.default.createElement('dx').style;
});
const forEachPrefixes = function (prop, callBack) {
  prop = (0, _inflector.camelize)(prop, true);
  let result;
  for (let i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
    const jsPrefix = jsPrefixes[i];
    const prefixedProp = jsPrefix + prop;
    const lowerPrefixedProp = (0, _inflector.camelize)(prefixedProp);
    result = callBack(lowerPrefixedProp, jsPrefix);
    if (result === undefined) {
      result = callBack(prefixedProp, jsPrefix);
    }
    if (result !== undefined) {
      break;
    }
  }
  return result || '';
};
const styleProp = function (name) {
  if (name in getStyles()) {
    return name;
  }
  const originalName = name;
  name = name.charAt(0).toUpperCase() + name.substr(1);
  for (let i = 1; i < jsPrefixes.length; i++) {
    const prefixedProp = jsPrefixes[i].toLowerCase() + name;
    if (prefixedProp in getStyles()) {
      return prefixedProp;
    }
  }
  return originalName;
};
exports.styleProp = styleProp;
const stylePropPrefix = function (prop) {
  return forEachPrefixes(prop, function (specific, jsPrefix) {
    if (specific in getStyles()) {
      return cssPrefixes[jsPrefix];
    }
  });
};
exports.stylePropPrefix = stylePropPrefix;
const pxExceptions = ['fillOpacity', 'columnCount', 'flexGrow', 'flexShrink', 'fontWeight', 'lineHeight', 'opacity', 'zIndex', 'zoom'];
const parsePixelValue = function (value) {
  if ((0, _type.isNumeric)(value)) {
    return value;
  } else if ((0, _type.isString)(value)) {
    return Number(value.replace('px', ''));
  }
  return NaN;
};
exports.parsePixelValue = parsePixelValue;
const normalizeStyleProp = function (prop, value) {
  if ((0, _type.isNumeric)(value) && pxExceptions.indexOf(prop) === -1) {
    value += 'px';
  }
  return value;
};
exports.normalizeStyleProp = normalizeStyleProp;
const setDimensionProperty = function (elements, propertyName, value) {
  if (elements) {
    value = (0, _type.isNumeric)(value) ? value += 'px' : value;
    for (let i = 0; i < elements.length; ++i) {
      elements[i].style[propertyName] = value;
    }
  }
};
const setWidth = function (elements, value) {
  setDimensionProperty(elements, 'width', value);
};
exports.setWidth = setWidth;
const setHeight = function (elements, value) {
  setDimensionProperty(elements, 'height', value);
};
exports.setHeight = setHeight;
const setStyle = function (element, styleString) {
  let resetStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (resetStyle) {
    const styleList = [].slice.call(element.style);
    styleList.forEach(propertyName => {
      element.style.removeProperty(propertyName);
    });
  }
  styleString.split(';').forEach(style => {
    const parts = style.split(':').map(stylePart => stylePart.trim());
    if (parts.length === 2) {
      const [property, value] = parts;
      element.style[property] = value;
    }
  });
};
exports.setStyle = setStyle;

/***/ }),

/***/ 60137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.pointerEvents = exports.nativeScrolling = exports.inputType = exports.animation = void 0;
Object.defineProperty(exports, "styleProp", ({
  enumerable: true,
  get: function () {
    return _style.styleProp;
  }
}));
Object.defineProperty(exports, "stylePropPrefix", ({
  enumerable: true,
  get: function () {
    return _style.stylePropPrefix;
  }
}));
exports.transitionEndEventName = exports.transition = exports.touchEvents = exports.touch = exports.supportProp = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _window = __webpack_require__(58201);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _style = __webpack_require__(80968);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  maxTouchPoints
} = (0, _window.getNavigator)();
const transitionEndEventNames = {
  'webkitTransition': 'webkitTransitionEnd',
  'MozTransition': 'transitionend',
  'OTransition': 'oTransitionEnd',
  'transition': 'transitionend'
};
const supportProp = function (prop) {
  return !!(0, _style.styleProp)(prop);
};
exports.supportProp = supportProp;
const isNativeScrollingSupported = function () {
  const {
    platform,
    mac: isMac
  } = _devices.default.real();
  const isNativeScrollDevice = platform === 'ios' || platform === 'android' || isMac;
  return isNativeScrollDevice;
};
const inputType = function (type) {
  if (type === 'text') {
    return true;
  }
  const input = _dom_adapter.default.createElement('input');
  try {
    input.setAttribute('type', type);
    input.value = 'wrongValue';
    return !input.value;
  } catch (e) {
    return false;
  }
};
exports.inputType = inputType;
const detectTouchEvents = function (hasWindowProperty, maxTouchPoints) {
  return (hasWindowProperty('ontouchstart') || !!maxTouchPoints) && !hasWindowProperty('callPhantom');
};
const detectPointerEvent = function (hasWindowProperty) {
  return hasWindowProperty('PointerEvent');
};
const touchEvents = exports.touchEvents = detectTouchEvents(_window.hasProperty, maxTouchPoints);
const pointerEvents = exports.pointerEvents = detectPointerEvent(_window.hasProperty);
const touchPointersPresent = !!maxTouchPoints;
const touch = exports.touch = touchEvents || pointerEvents && touchPointersPresent;
const transition = exports.transition = (0, _call_once.default)(function () {
  return supportProp('transition');
});
const transitionEndEventName = exports.transitionEndEventName = (0, _call_once.default)(function () {
  return transitionEndEventNames[(0, _style.styleProp)('transition')];
});
const animation = exports.animation = (0, _call_once.default)(function () {
  return supportProp('animation');
});
const nativeScrolling = exports.nativeScrolling = isNativeScrollingSupported();

/***/ }),

/***/ 19155:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.HIDDEN_FOR_EXPORT = void 0;
exports.getSvgElement = getSvgElement;
exports.getSvgMarkup = getSvgMarkup;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
function getMarkup(element, backgroundColor) {
  const temp = _dom_adapter.default.createElement('div');
  const clone = element.cloneNode(true);
  if (backgroundColor) {
    (0, _renderer.default)(clone).css('backgroundColor', backgroundColor);
  }
  temp.appendChild(clone);
  return temp.innerHTML;
}
function fixNamespaces(markup) {
  let first = true;
  if (markup.indexOf('xmlns:xlink') === -1) {
    markup = markup.replace('<svg', '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
  }
  markup = markup.replace(/xmlns="[\s\S]*?"/gi, function (match) {
    if (!first) return '';
    first = false;
    return match;
  });
  return markup.replace(/xmlns:NS1="[\s\S]*?"/gi, '').replace(/NS1:xmlns:xlink="([\s\S]*?)"/gi, 'xmlns:xlink="$1"');
}

// T428345 we decode only restricted HTML entities, looks like other entities do not cause problems
// as they presented as symbols itself, not named entities
function decodeHtmlEntities(markup) {
  return markup.replace(/&quot;/gi, '&#34;').replace(/&amp;/gi, '&#38;').replace(/&apos;/gi, '&#39;').replace(/&lt;/gi, '&#60;').replace(/&gt;/gi, '&#62;').replace(/&nbsp;/gi, '&#160;').replace(/&shy;/gi, '&#173;');
}
const HIDDEN_FOR_EXPORT = exports.HIDDEN_FOR_EXPORT = 'hidden-for-export';
function getSvgMarkup(element, backgroundColor) {
  return fixNamespaces(decodeHtmlEntities(getMarkup(element, backgroundColor)));
}
function getSvgElement(markup) {
  if ((0, _type.isString)(markup)) {
    const parsedMarkup = new window.DOMParser().parseFromString(markup, 'image/svg+xml').childNodes[0];
    return parsedMarkup;
  } else if (_dom_adapter.default.isNode(markup)) {
    return markup;
  } else if ((0, _type.isRenderer)(markup)) {
    return markup.get(0);
  }
}

/***/ }),

/***/ 69697:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.validateTemplateSource = exports.templateKey = exports.suitableTemplatesByName = exports.getNormalizedTemplateArgs = exports.findTemplates = exports.defaultCreateElement = exports.addPublicElementNormalization = exports.addOneRenderedCall = exports.acquireTemplate = exports.acquireIntegrationTemplate = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _element = __webpack_require__(6415);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _child_default_template = __webpack_require__(91627);
var _empty_template = __webpack_require__(10688);
var _template = __webpack_require__(9545);
var _template_base = __webpack_require__(81033);
var _array = __webpack_require__(89386);
var _common = __webpack_require__(20576);
var _dom = __webpack_require__(3532);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const findTemplates = (element, name) => {
  const optionsAttributeName = 'data-options';
  const templates = (0, _renderer.default)(element).contents().filter(`[${optionsAttributeName}*="${name}"]`);
  return [].slice.call(templates).map(element => {
    const optionsString = (0, _renderer.default)(element).attr(optionsAttributeName) || '';
    return {
      element,
      options: (0, _config.default)().optionsParser(optionsString)[name]
    };
  }).filter(template => !!template.options);
};
exports.findTemplates = findTemplates;
const suitableTemplatesByName = rawTemplates => {
  const templatesMap = (0, _array.groupBy)(rawTemplates, template => template.options.name);
  if (templatesMap['undefined']) {
    throw _errors.default.Error('E0023');
  }
  const result = {};
  Object.keys(templatesMap).forEach(name => {
    var _findBestMatches$;
    const suitableTemplate = (_findBestMatches$ = (0, _common.findBestMatches)(_devices.default.current(), templatesMap[name], template => template.options)[0]) === null || _findBestMatches$ === void 0 ? void 0 : _findBestMatches$.element;
    if (suitableTemplate) {
      result[name] = suitableTemplate;
    }
  });
  return result;
};
exports.suitableTemplatesByName = suitableTemplatesByName;
const addOneRenderedCall = template => {
  const render = template.render.bind(template);
  return (0, _extend.extend)({}, template, {
    render(options) {
      const templateResult = render(options);
      options && options.onRendered && options.onRendered();
      return templateResult;
    }
  });
};
exports.addOneRenderedCall = addOneRenderedCall;
const addPublicElementNormalization = template => {
  const render = template.render.bind(template);
  return (0, _extend.extend)({}, template, {
    render(options) {
      const $container = (0, _renderer.default)(options.container);
      return render(_extends({}, options, {
        container: (0, _element.getPublicElement)($container)
      }));
    }
  });
};
exports.addPublicElementNormalization = addPublicElementNormalization;
const getNormalizedTemplateArgs = options => {
  const args = [];
  if ('model' in options) {
    args.push(options.model);
  }
  if ('index' in options) {
    args.push(options.index);
  }
  args.push(options.container);
  return args;
};
exports.getNormalizedTemplateArgs = getNormalizedTemplateArgs;
const validateTemplateSource = templateSource => {
  return typeof templateSource === 'string' ? (0, _dom.normalizeTemplateElement)(templateSource) : templateSource;
};
exports.validateTemplateSource = validateTemplateSource;
const templateKey = templateSource => {
  return (0, _type.isRenderer)(templateSource) && templateSource[0] || templateSource;
};
exports.templateKey = templateKey;
const defaultCreateElement = element => new _template.Template(element);
exports.defaultCreateElement = defaultCreateElement;
const acquireIntegrationTemplate = (templateSource, templates, isAsyncTemplate, skipTemplates) => {
  let integrationTemplate = null;
  if (!skipTemplates || skipTemplates.indexOf(templateSource) === -1) {
    integrationTemplate = templates[templateSource];
    if (integrationTemplate && !(integrationTemplate instanceof _template_base.TemplateBase)) {
      if ((0, _type.isFunction)(integrationTemplate.render)) {
        integrationTemplate = addPublicElementNormalization(integrationTemplate);
      }
      if (!isAsyncTemplate) {
        integrationTemplate = addOneRenderedCall(integrationTemplate);
      }
    }
  }
  return integrationTemplate;
};
exports.acquireIntegrationTemplate = acquireIntegrationTemplate;
const acquireTemplate = (templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) => {
  if (templateSource == null) {
    return new _empty_template.EmptyTemplate();
  }
  if (templateSource instanceof _child_default_template.ChildDefaultTemplate) {
    return defaultTemplates[templateSource.name];
  }
  if (templateSource instanceof _template_base.TemplateBase) {
    return templateSource;
  }

  // TODO: templateSource.render is needed for angular2 integration. Try to remove it after supporting TypeScript modules.
  if ((0, _type.isFunction)(templateSource.render) && !(0, _type.isRenderer)(templateSource)) {
    return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
  }
  if (templateSource.nodeType || (0, _type.isRenderer)(templateSource)) {
    return createTemplate((0, _renderer.default)(templateSource));
  }
  return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
};
exports.acquireTemplate = acquireTemplate;

/***/ }),

/***/ 35922:
/***/ (function(__unused_webpack_module, exports) {



exports.type = exports.isWindow = exports.isString = exports.isRenderer = exports.isPromise = exports.isPrimitive = exports.isPlainObject = exports.isObject = exports.isNumeric = exports.isFunction = exports.isExponential = exports.isEvent = exports.isEmptyObject = exports.isDefined = exports.isDeferred = exports.isDate = exports.isBoolean = void 0;
const types = {
  '[object Array]': 'array',
  '[object Date]': 'date',
  '[object Object]': 'object',
  '[object String]': 'string'
};
const type = function (object) {
  if (object === null) {
    return 'null';
  }
  const typeOfObject = Object.prototype.toString.call(object);
  return typeof object === 'object' ? types[typeOfObject] || 'object' : typeof object;
};
exports.type = type;
const isBoolean = function (object) {
  return typeof object === 'boolean';
};
exports.isBoolean = isBoolean;
const isExponential = function (value) {
  return isNumeric(value) && value.toString().indexOf('e') !== -1;
};
exports.isExponential = isExponential;
const isDate = function (object) {
  return type(object) === 'date';
};
exports.isDate = isDate;
const isDefined = function (object) {
  return object !== null && object !== undefined;
};
exports.isDefined = isDefined;
const isFunction = function (object) {
  return typeof object === 'function';
};
exports.isFunction = isFunction;
const isString = function (object) {
  return typeof object === 'string';
};
exports.isString = isString;
const isNumeric = function (object) {
  return typeof object === 'number' && isFinite(object) || !isNaN(object - parseFloat(object));
};
exports.isNumeric = isNumeric;
const isObject = function (object) {
  return type(object) === 'object';
};
exports.isObject = isObject;
const isEmptyObject = function (object) {
  let property;
  for (property in object) {
    return false;
  }
  return true;
};
exports.isEmptyObject = isEmptyObject;
const isPlainObject = function (object) {
  if (!object || type(object) !== 'object') {
    return false;
  }
  const proto = Object.getPrototypeOf(object);
  if (!proto) {
    return true;
  }
  const ctor = Object.hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof ctor === 'function' && Object.toString.call(ctor) === Object.toString.call(Object);
};
exports.isPlainObject = isPlainObject;
const isPrimitive = function (value) {
  return ['object', 'array', 'function'].indexOf(type(value)) === -1;
};
exports.isPrimitive = isPrimitive;
const isWindow = function (object) {
  return object != null && object === object.window;
};
exports.isWindow = isWindow;
const isRenderer = function (object) {
  return !!object && !!(object.jquery || object.dxRenderer);
};
exports.isRenderer = isRenderer;
const isPromise = function (object) {
  return !!object && isFunction(object.then);
};
exports.isPromise = isPromise;
const isDeferred = function (object) {
  return !!object && isFunction(object.done) && isFunction(object.fail);
};
exports.isDeferred = isDeferred;
const isEvent = function (object) {
  return !!(object && object.preventDefault);
};
exports.isEvent = isEvent;

/***/ }),

/***/ 26974:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _console = __webpack_require__(30869);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = (0, _dependency_injector.default)({
  isWrapped: function () {
    return false;
  },
  isWritableWrapped: function () {
    return false;
  },
  wrap: function (value) {
    return value;
  },
  unwrap: function (value) {
    return value;
  },
  assign: function () {
    _console.logger.error('Method \'assign\' should not be used for not wrapped variables. Use \'isWrapped\' method for ensuring.');
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 58020:
/***/ (function(__unused_webpack_module, exports) {



exports.compare = compare;
function compare(x, y, maxLevel) {
  function normalizeArg(value) {
    if (typeof value === 'string') {
      return value.split('.');
    }
    if (typeof value === 'number') {
      return [value];
    }
    return value;
  }
  x = normalizeArg(x);
  y = normalizeArg(y);
  let length = Math.max(x.length, y.length);
  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }
  for (let i = 0; i < length; i++) {
    const xItem = parseInt(x[i] || 0, 10);
    const yItem = parseInt(y[i] || 0, 10);
    if (xItem < yItem) {
      return -1;
    }
    if (xItem > yItem) {
      return 1;
    }
  }
  return 0;
}

/***/ }),

/***/ 77695:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.changeCallback = void 0;
exports.originalViewPort = originalViewPort;
exports.value = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ready = _ready_callbacks.default.add;
const changeCallback = exports.changeCallback = (0, _callbacks.default)();
let $originalViewPort = (0, _renderer.default)();
const value = exports.value = function () {
  let $current;
  return function (element) {
    if (!arguments.length) {
      return $current;
    }
    const $element = (0, _renderer.default)(element);
    $originalViewPort = $element;
    const isNewViewportFound = !!$element.length;
    const prevViewPort = value();
    $current = isNewViewportFound ? $element : (0, _renderer.default)('body');
    changeCallback.fire(isNewViewportFound ? value() : (0, _renderer.default)(), prevViewPort);
  };
}();
ready(function () {
  value('.dx-viewport');
});
function originalViewPort() {
  return $originalViewPort;
}

/***/ }),

/***/ 58201:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.setWindow = exports.hasWindow = exports.hasProperty = exports.getWindow = exports.getNavigator = exports.getCurrentScreenFactor = exports.defaultScreenFactorFunc = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global window */

let hasWindowValue = typeof window !== 'undefined';
const hasWindow = () => hasWindowValue;
exports.hasWindow = hasWindow;
let windowObject = hasWindow() ? window : undefined;
if (!windowObject) {
  windowObject = {};
  windowObject.window = windowObject;
}
const getWindow = () => windowObject;
exports.getWindow = getWindow;
const setWindow = (newWindowObject, hasWindow) => {
  if (hasWindow === undefined) {
    hasWindowValue = typeof window !== 'undefined' && window === newWindowObject;
  } else {
    hasWindowValue = hasWindow;
  }
  windowObject = newWindowObject;
};
exports.setWindow = setWindow;
const hasProperty = prop => hasWindow() && prop in windowObject;
exports.hasProperty = hasProperty;
const defaultScreenFactorFunc = width => {
  if (width < 768) {
    return 'xs';
  } else if (width < 992) {
    return 'sm';
  } else if (width < 1200) {
    return 'md';
  } else {
    return 'lg';
  }
};
exports.defaultScreenFactorFunc = defaultScreenFactorFunc;
const getCurrentScreenFactor = screenFactorCallback => {
  const screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
  const windowWidth = _dom_adapter.default.getDocumentElement()['clientWidth'];
  return screenFactorFunc(windowWidth);
};
exports.getCurrentScreenFactor = getCurrentScreenFactor;
const getNavigator = () => hasWindow() ? windowObject.navigator : {
  userAgent: ''
};
exports.getNavigator = getNavigator;

/***/ }),

/***/ 36739:
/***/ (function(__unused_webpack_module, exports) {



exports.version = exports.fullVersion = void 0;
const version = exports.version = '24.2.0';
const fullVersion = exports.fullVersion = '24.2.0';

/***/ }),

/***/ 66507:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "e", ({
  enumerable: true,
  get: function () {
    return _version.assertDevExtremeVersion;
  }
}));
var _version = __webpack_require__(39550);

/***/ }),

/***/ 67403:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_abstract_store.default;
  }
}));
var _m_abstract_store = _interopRequireDefault(__webpack_require__(2367));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 36893:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _array_utils = __webpack_require__(60637);
var _default = exports["default"] = _array_utils.applyChanges;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 35042:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_array_query.default;
  }
}));
var _m_array_query = _interopRequireDefault(__webpack_require__(35044));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 26562:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_array_store.default;
  }
}));
var _m_array_store = _interopRequireDefault(__webpack_require__(96438));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 60637:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_array_utils = __webpack_require__(23011);
Object.keys(_m_array_utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_array_utils[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_array_utils[key];
    }
  });
});

/***/ }),

/***/ 88036:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_custom_store.default;
  }
}));
var _m_custom_store = _interopRequireDefault(__webpack_require__(65734));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 33546:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _data_source = __webpack_require__(85273);
var _default = exports["default"] = _data_source.DataSource;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 85273:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_data_source = __webpack_require__(77881);
Object.keys(_m_data_source).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_data_source[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_data_source[key];
    }
  });
});

/***/ }),

/***/ 88665:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_operation_manager.default;
  }
}));
var _m_operation_manager = _interopRequireDefault(__webpack_require__(69201));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 9234:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_utils = __webpack_require__(3097);
Object.keys(_m_utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_utils[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_utils[key];
    }
  });
});

/***/ }),

/***/ 8162:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_endpoint_selector.default;
  }
}));
var _m_endpoint_selector = _interopRequireDefault(__webpack_require__(68469));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 18438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_errors = __webpack_require__(56121);
Object.keys(_m_errors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_errors[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_errors[key];
    }
  });
});

/***/ }),

/***/ 82837:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_local_store.default;
  }
}));
var _m_local_store = _interopRequireDefault(__webpack_require__(60305));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 47256:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_context.default;
  }
}));
var _m_context = _interopRequireDefault(__webpack_require__(72006));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 54263:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_query_adapter = __webpack_require__(30953);
Object.keys(_m_query_adapter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_query_adapter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_query_adapter[key];
    }
  });
});

/***/ }),

/***/ 63081:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_request_dispatcher.default;
  }
}));
var _m_request_dispatcher = _interopRequireDefault(__webpack_require__(39755));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 341:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_store.default;
  }
}));
var _m_store = _interopRequireDefault(__webpack_require__(3207));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 77869:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_utils = __webpack_require__(34158);
Object.keys(_m_utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_utils[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_utils[key];
    }
  });
});

/***/ }),

/***/ 96687:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_query.default;
  }
}));
var _m_query = _interopRequireDefault(__webpack_require__(38926));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 16135:
/***/ (function(module, exports) {



exports["default"] = void 0;
var _default = exports["default"] = {};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 77549:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.queryImpl = void 0;
var _array_query = _interopRequireDefault(__webpack_require__(35042));
var _remote_query = _interopRequireDefault(__webpack_require__(41428));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const queryImpl = exports.queryImpl = {
  array: _array_query.default,
  remote: _remote_query.default
};

/***/ }),

/***/ 41428:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_remote_query.default;
  }
}));
var _m_remote_query = _interopRequireDefault(__webpack_require__(59122));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 99236:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_store_helper.default;
  }
}));
var _m_store_helper = _interopRequireDefault(__webpack_require__(18475));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 16454:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_utils = __webpack_require__(27592);
Object.keys(_m_utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_utils[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_utils[key];
    }
  });
});

/***/ }),

/***/ 53305:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _data_source = __webpack_require__(85273);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(9234);
var _m_data_controller = _interopRequireDefault(__webpack_require__(30136));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DATA_SOURCE_OPTIONS_METHOD = '_dataSourceOptions';
const DATA_SOURCE_CHANGED_METHOD = '_dataSourceChangedHandler';
const DATA_SOURCE_LOAD_ERROR_METHOD = '_dataSourceLoadErrorHandler';
const DATA_SOURCE_LOADING_CHANGED_METHOD = '_dataSourceLoadingChangedHandler';
const DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD = '_dataSourceFromUrlLoadMode';
const SPECIFIC_DATA_SOURCE_OPTION = '_getSpecificDataSourceOption';
const NORMALIZE_DATA_SOURCE = '_normalizeDataSource';
const DataHelperMixin = {
  postCtor: function () {
    this.on('disposing', function () {
      this._disposeDataSource();
    }.bind(this));
  },
  _refreshDataSource: function () {
    this._initDataSource();
    this._loadDataSource();
  },
  _initDataSource: function () {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option('dataSource');
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof _data_source.DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : _data_source.DataSource;
        dataSourceOptions = (0, _utils.normalizeDataSourceOptions)(dataSourceOptions, {
          fromUrlLoadMode: DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD in this && this[DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD]()
        });
        this._dataSource = new dataSourceType((0, _extend.extend)(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  },
  _initDataController: function () {
    var _this$option;
    const dataController = (_this$option = this.option) === null || _this$option === void 0 ? void 0 : _this$option.call(this, '_dataController');
    const dataSource = this._dataSource;
    if (dataController) {
      this._dataController = dataController;
    } else {
      this._dataController = new _m_data_controller.default(dataSource);
    }
  },
  _addDataSourceHandlers: function () {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  },
  _addReadyWatcher: function () {
    this.readyWatcher = function (isLoading) {
      this._ready && this._ready(!isLoading);
    }.bind(this);
    this._dataSource.on('loadingChanged', this.readyWatcher);
  },
  _addDataSourceChangeHandler: function () {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = function (e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }.bind(this);
    dataSource.on('changed', this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler: function () {
    this._proxiedDataSourceLoadErrorHandler = this[DATA_SOURCE_LOAD_ERROR_METHOD].bind(this);
    this._dataSource.on('loadError', this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler: function () {
    this._proxiedDataSourceLoadingChangedHandler = this[DATA_SOURCE_LOADING_CHANGED_METHOD].bind(this);
    this._dataSource.on('loadingChanged', this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource: function () {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle: function (key, value) {
    key = key === 'this' ? this._dataSource.key() || 'this' : key;
    return this._dataSource.loadSingle(key, value);
  },
  _isLastPage: function () {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading: function () {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource: function () {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off('changed', this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off('loadError', this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off('loadingChanged', this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off('loadingChanged', this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource: function () {
    return this._dataSource || null;
  }
};
var _default = exports["default"] = DataHelperMixin;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 95429:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_click = __webpack_require__(68344);
Object.keys(_m_click).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_click[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_click[key];
    }
  });
});

/***/ }),

/***/ 49166:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_contextmenu = __webpack_require__(61114);
Object.keys(_m_contextmenu).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_contextmenu[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_contextmenu[key];
    }
  });
});

/***/ }),

/***/ 91633:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_emitter = __webpack_require__(28923);
Object.keys(_m_emitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_emitter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_emitter[key];
    }
  });
});

/***/ }),

/***/ 31391:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_emitter.default;
  }
}));
var _m_emitter = _interopRequireDefault(__webpack_require__(54235));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82495:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_emitter_registrator.default;
  }
}));
var _m_emitter_registrator = _interopRequireDefault(__webpack_require__(59227));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 85788:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_event_registrator.default;
  }
}));
var _m_event_registrator = _interopRequireDefault(__webpack_require__(50202));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 94553:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _memorized_callbacks = _interopRequireDefault(__webpack_require__(83358));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = new _memorized_callbacks.default();
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 55994:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_events_engine.default;
  }
}));
var _m_events_engine = _interopRequireDefault(__webpack_require__(71496));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 2418:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_hook_touch_props.default;
  }
}));
var _m_hook_touch_props = _interopRequireDefault(__webpack_require__(92239));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 51661:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_keyboard_processor.default;
  }
}));
var _m_keyboard_processor = _interopRequireDefault(__webpack_require__(58455));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 765:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_wheel = __webpack_require__(73123);
Object.keys(_m_wheel).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_wheel[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_wheel[key];
    }
  });
});

/***/ }),

/***/ 85272:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "name", ({
  enumerable: true,
  get: function () {
    return _m_dblclick.name;
  }
}));
var _m_dblclick = __webpack_require__(40096);
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
(0, _event_registrator.default)(_m_dblclick.name, _m_dblclick.dblClick);

/***/ }),

/***/ 23174:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_drag = __webpack_require__(6647);
Object.keys(_m_drag).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_drag[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_drag[key];
    }
  });
});

/***/ }),

/***/ 98621:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_emitter.default;
  }
}));
var _m_emitter = _interopRequireDefault(__webpack_require__(86468));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 37334:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_emitterGesture.default;
  }
}));
var _m_emitterGesture = _interopRequireDefault(__webpack_require__(43182));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 11699:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_hold.default;
  }
}));
var _m_hold = _interopRequireDefault(__webpack_require__(43246));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 24028:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_hover = __webpack_require__(84500);
Object.keys(_m_hover).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_hover[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_hover[key];
    }
  });
});

/***/ }),

/***/ 66365:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.triggerHandler = exports.trigger = exports.one = exports.on = exports.off = exports.Event = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
* @name events
*/

const on = exports.on = _events_engine.default.on;
const one = exports.one = _events_engine.default.one;
const off = exports.off = _events_engine.default.off;
const trigger = exports.trigger = _events_engine.default.trigger;
const triggerHandler = exports.triggerHandler = _events_engine.default.triggerHandler;

/**
* @name events.Event
* @type function
* @param1 source:string|event
* @param2 config:object
* @return event
* @module events
* @export Event
* @hidden
*/

const Event = exports.Event = _events_engine.default.Event;

/***/ }),

/***/ 93786:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_pointer.default;
  }
}));
var _m_pointer = _interopRequireDefault(__webpack_require__(90215));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 88136:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_base.default;
  }
}));
var _m_base = _interopRequireDefault(__webpack_require__(54571));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 66509:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_mouse.default;
  }
}));
var _m_mouse = _interopRequireDefault(__webpack_require__(45679));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 87720:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_mouse_and_touch.default;
  }
}));
var _m_mouse_and_touch = _interopRequireDefault(__webpack_require__(62172));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 25544:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_observer.default;
  }
}));
var _m_observer = _interopRequireDefault(__webpack_require__(78199));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 69120:
/***/ (function(module, exports, __webpack_require__) {



Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function () {
    return _m_touch.default;
  }
}));
var _m_touch = _interopRequireDefault(__webpack_require__(31912));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 29007:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_remove = __webpack_require__(88738);
Object.keys(_m_remove).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_remove[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_remove[key];
    }
  });
});

/***/ }),

/***/ 72918:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_short = __webpack_require__(78546);
Object.keys(_m_short).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_short[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_short[key];
    }
  });
});

/***/ }),

/***/ 34309:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_swipe = __webpack_require__(45298);
Object.keys(_m_swipe).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_swipe[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_swipe[key];
    }
  });
});

/***/ }),

/***/ 91093:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.zoomstart = exports.zoomend = exports.zoom = exports.translatestart = exports.translateend = exports.translate = exports.transformstart = exports.transformend = exports.transform = exports.rotatestart = exports.rotateend = exports.rotate = exports.pinchstart = exports.pinchend = exports.pinch = void 0;
var _m_transform = __webpack_require__(83175);
/**
 * @name UI Events.dxtransformstart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/
/**
  * @name UI Events.dxtransform
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 rotation:number
  * @type_function_param1_field4 deltaRotation:number
  * @type_function_param1_field5 translation:object
  * @type_function_param1_field6 deltaTranslation:object
  * @type_function_param1_field7 cancel:boolean
  * @module events/transform
*/
/**
  * @name UI Events.dxtransformend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 rotation:number
  * @type_function_param1_field4 deltaRotation:number
  * @type_function_param1_field5 translation:object
  * @type_function_param1_field6 deltaTranslation:object
  * @type_function_param1_field7 cancel:boolean
  * @module events/transform
*/

/**
 * @name UI Events.dxtranslatestart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/
/**
  * @name UI Events.dxtranslate
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 translation:object
  * @type_function_param1_field2 deltaTranslation:object
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/
/**
  * @name UI Events.dxtranslateend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 translation:object
  * @type_function_param1_field2 deltaTranslation:object
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
* @name UI Events.dxpinchstart
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 cancel:boolean
* @module events/transform
   */
/**
  * @name UI Events.dxpinch
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/
/**
  * @name UI Events.dxpinchend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
 * @name UI Events.dxrotatestart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/
/**
  * @name UI Events.dxrotate
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 rotation:number
  * @type_function_param1_field2 deltaRotation:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/
/**
  * @name UI Events.dxrotateend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 rotation:number
  * @type_function_param1_field2 deltaRotation:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/* eslint-disable spellcheck/spell-checker */
const {
  transformstart,
  transform,
  transformend,
  translatestart,
  translate,
  translateend,
  zoomstart,
  zoom,
  zoomend,
  pinchstart,
  pinch,
  pinchend,
  rotatestart,
  rotate,
  rotateend
} = _m_transform.exportNames;
exports.rotateend = rotateend;
exports.rotate = rotate;
exports.rotatestart = rotatestart;
exports.pinchend = pinchend;
exports.pinch = pinch;
exports.pinchstart = pinchstart;
exports.zoomend = zoomend;
exports.zoom = zoom;
exports.zoomstart = zoomstart;
exports.translateend = translateend;
exports.translate = translate;
exports.translatestart = translatestart;
exports.transformend = transformend;
exports.transform = transform;
exports.transformstart = transformstart;

/***/ }),

/***/ 27575:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_event_nodes_disposing = __webpack_require__(80406);
Object.keys(_m_event_nodes_disposing).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_event_nodes_disposing[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_event_nodes_disposing[key];
    }
  });
});

/***/ }),

/***/ 39644:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _m_event_target = __webpack_require__(8497);
Object.keys(_m_event_target).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _m_event_target[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _m_event_target[key];
    }
  });
});

/***/ }),

/***/ 39611:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _index = __webpack_require__(89488);
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

/***/ }),

/***/ 80506:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.triggerShownEvent = exports.triggerResizeEvent = exports.triggerHidingEvent = exports["default"] = void 0;
var _m_visibility_change = _interopRequireDefault(__webpack_require__(85374));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const triggerShownEvent = exports.triggerShownEvent = _m_visibility_change.default.triggerShownEvent;
const triggerHidingEvent = exports.triggerHidingEvent = _m_visibility_change.default.triggerHidingEvent;
const triggerResizeEvent = exports.triggerResizeEvent = _m_visibility_change.default.triggerResizeEvent;
var _default = exports["default"] = _m_visibility_change.default;

/***/ }),

/***/ 2994:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "exportDataGrid", ({
  enumerable: true,
  get: function () {
    return _export_data_grid.exportDataGrid;
  }
}));
Object.defineProperty(exports, "exportPivotGrid", ({
  enumerable: true,
  get: function () {
    return _export_pivot_grid.exportPivotGrid;
  }
}));
var _export_data_grid = __webpack_require__(8572);
var _export_pivot_grid = __webpack_require__(77328);

/***/ }),

/***/ 78292:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports["export"] = _export;
Object.defineProperty(exports, "fileSaver", ({
  enumerable: true,
  get: function () {
    return _file_saver.fileSaver;
  }
}));
exports.svg = exports.pdf = exports.image = void 0;
var _file_saver = __webpack_require__(48351);
var _image_creator = __webpack_require__(12173);
var _svg_creator = __webpack_require__(37596);
var _type = __webpack_require__(35922);
var _deferred = __webpack_require__(62754);
var _pdf_creator = __webpack_require__(30855);
function _export(data, options, getData) {
  if (!data) {
    return new _deferred.Deferred().resolve();
  }

  // TODO: Can the following actions be not defined? (since they are provided by a widget not by a user)
  const exportingAction = options.exportingAction;
  const exportedAction = options.exportedAction;
  const fileSavingAction = options.fileSavingAction;
  const eventArgs = {
    fileName: options.fileName,
    format: options.format,
    cancel: false
  };
  if ((0, _type.isBoolean)(options.selectedRowsOnly)) {
    eventArgs.selectedRowsOnly = options.selectedRowsOnly;
  }
  (0, _type.isFunction)(exportingAction) && exportingAction(eventArgs);
  if (!eventArgs.cancel) {
    return getData(data, options).then(blob => {
      (0, _type.isFunction)(exportedAction) && exportedAction();
      if ((0, _type.isFunction)(fileSavingAction)) {
        eventArgs.data = blob;
        fileSavingAction(eventArgs);
      }
      if (!eventArgs.cancel) {
        const format = options.format === 'xlsx' ? 'EXCEL' : options.format;
        _file_saver.fileSaver.saveAs(eventArgs.fileName, format, blob);
      }
    });
  }
  return new _deferred.Deferred().resolve();
}
const image = exports.image = {
  creator: _image_creator.imageCreator,
  getData: _image_creator.getData,
  testFormats: _image_creator.testFormats
};
const pdf = exports.pdf = {
  getData: _pdf_creator.getData
};
const svg = exports.svg = {
  creator: _svg_creator.svgCreator,
  getData: _svg_creator.getData
};

/***/ }),

/***/ 5332:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ExportLoadPanel = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _extend = __webpack_require__(13306);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _type = __webpack_require__(35922);
var _load_panel = _interopRequireDefault(__webpack_require__(97218));
var _m_utils = _interopRequireDefault(__webpack_require__(60082));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EXPORT_LOAD_PANEL_CLASS = 'dx-export-loadpanel';
class ExportLoadPanel {
  constructor(component, $targetElement, $container, options) {
    this._$targetElement = $targetElement;
    this._$container = $container;
    this._loadPanel = component._createComponent((0, _renderer.default)('<div>').addClass(EXPORT_LOAD_PANEL_CLASS).appendTo(this._$container), _load_panel.default, this.getOptions(options));
  }
  getDefaultOptions() {
    return {
      animation: null,
      shading: false,
      height: 90,
      width: 200,
      container: this._$container
    };
  }
  getOptions(options) {
    if ((0, _type.isDefined)(options.text)) {
      options.message = options.text;
    } else {
      options.message = _message.default.format('dxDataGrid-exporting');
    }
    return (0, _extend.extend)(this.getDefaultOptions(), options);
  }
  show() {
    this._loadPanel.option('position', _m_utils.default.calculateLoadPanelPosition(this._$targetElement));
    this._loadPanel.show();
  }
  dispose() {
    (0, _renderer.default)(this._loadPanel.element()).remove();
    delete this._loadPanel;
  }
}
exports.ExportLoadPanel = ExportLoadPanel;

/***/ }),

/***/ 11385:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Export = void 0;
var _type = __webpack_require__(35922);
var _export_format = __webpack_require__(38526);
var _extend = __webpack_require__(13306);
var _export_load_panel = __webpack_require__(5332);
var _window = __webpack_require__(58201);
// docs.microsoft.com/en-us/office/troubleshoot/excel/determine-column-widths - "Description of how column widths are determined in Excel"
const MAX_DIGIT_WIDTH_IN_PIXELS = 7; // Calibri font with 11pt size

// support.office.com/en-us/article/change-the-column-width-and-row-height-72f5e3cc-994d-43e8-ae58-9774a0905f46 - "Column.Max - 255"
// support.office.com/en-us/article/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3 - "Column width limit - 255 characters"
const MAX_EXCEL_COLUMN_WIDTH = 255;
const Export = exports.Export = {
  getFullOptions(options) {
    const fullOptions = (0, _extend.extend)({}, options);
    if (!((0, _type.isDefined)(fullOptions.worksheet) && (0, _type.isObject)(fullOptions.worksheet))) {
      throw Error('The "worksheet" field must contain an object.');
    }
    if (!(0, _type.isDefined)(fullOptions.topLeftCell)) {
      fullOptions.topLeftCell = {
        row: 1,
        column: 1
      };
    } else if ((0, _type.isString)(fullOptions.topLeftCell)) {
      const {
        row,
        col
      } = fullOptions.worksheet.getCell(fullOptions.topLeftCell);
      fullOptions.topLeftCell = {
        row,
        column: col
      };
    }
    if (!(0, _type.isDefined)(fullOptions.keepColumnWidths)) {
      fullOptions.keepColumnWidths = true;
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
      fullOptions.loadPanel = {};
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
      fullOptions.loadPanel.enabled = true;
    }
    if (!(0, _type.isDefined)(fullOptions.encodeExecutableContent)) {
      fullOptions.encodeExecutableContent = false;
    }
    return fullOptions;
  },
  convertDateForExcelJS(date) {
    return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  },
  setNumberFormat(excelCell, numberFormat) {
    excelCell.numFmt = numberFormat;
  },
  getCellStyles(dataProvider) {
    const styles = dataProvider.getStyles();
    styles.forEach(style => {
      let numberFormat = this.tryConvertToExcelNumberFormat(style.format, style.dataType);
      if ((0, _type.isDefined)(numberFormat)) {
        numberFormat = numberFormat.replace(/&quot;/g, '"');
      }
      style.numberFormat = numberFormat;
    });
    return styles;
  },
  tryConvertToExcelNumberFormat(format, dataType) {
    const newFormat = _export_format.ExportFormat.formatObjectConverter(format, dataType);
    const currency = newFormat.currency;
    format = newFormat.format;
    dataType = newFormat.dataType;
    return _export_format.ExportFormat.convertFormat(format, newFormat.precision, dataType, currency);
  },
  setAlignment(excelCell, wrapText, horizontalAlignment) {
    excelCell.alignment = excelCell.alignment ?? {};
    if ((0, _type.isDefined)(wrapText)) {
      excelCell.alignment.wrapText = wrapText;
    }
    if ((0, _type.isDefined)(horizontalAlignment)) {
      excelCell.alignment.horizontal = horizontalAlignment;
    }
    excelCell.alignment.vertical = 'top';
  },
  setColumnsWidth(worksheet, widths, startColumnIndex) {
    if (!(0, _type.isDefined)(widths)) {
      return;
    }
    for (let i = 0; i < widths.length; i++) {
      const columnWidth = widths[i];
      if (typeof columnWidth === 'number' && isFinite(columnWidth)) {
        worksheet.getColumn(startColumnIndex + i).width = Math.min(MAX_EXCEL_COLUMN_WIDTH, Math.floor(columnWidth / MAX_DIGIT_WIDTH_IN_PIXELS * 100) / 100);
      }
    }
  },
  export(options, Helpers, getLoadPanelTargetElement, getLoadPanelContainer) {
    var _component$_getIntern;
    const {
      component,
      worksheet,
      topLeftCell,
      keepColumnWidths,
      selectedRowsOnly,
      loadPanel,
      encodeExecutableContent
    } = options;
    const dataProvider = component.getDataProvider(selectedRowsOnly);
    const internalComponent = ((_component$_getIntern = component._getInternalInstance) === null || _component$_getIntern === void 0 ? void 0 : _component$_getIntern.call(component)) || component;
    const initialLoadPanelEnabledOption = internalComponent.option('loadPanel') && internalComponent.option('loadPanel').enabled;
    if (initialLoadPanelEnabledOption) {
      component.option('loadPanel.enabled', false);
    }
    let exportLoadPanel;
    if (loadPanel.enabled && (0, _window.hasWindow)()) {
      const $targetElement = getLoadPanelTargetElement(component);
      const $container = getLoadPanelContainer(component);
      exportLoadPanel = new _export_load_panel.ExportLoadPanel(component, $targetElement, $container, loadPanel);
      exportLoadPanel.show();
    }
    const wrapText = !!component.option('wordWrapEnabled');
    worksheet.properties.outlineProperties = {
      summaryBelow: false,
      summaryRight: false
    };
    const cellRange = {
      from: {
        row: topLeftCell.row,
        column: topLeftCell.column
      },
      to: {
        row: topLeftCell.row,
        column: topLeftCell.column
      }
    };
    return new Promise(resolve => {
      dataProvider.ready().done(() => {
        const columns = dataProvider.getColumns();
        const dataRowsCount = dataProvider.getRowsCount();
        const helpers = new Helpers(component, dataProvider, worksheet, options);
        if (keepColumnWidths) {
          this.setColumnsWidth(worksheet, dataProvider.getColumnsWidths(), cellRange.from.column);
        }
        helpers._exportAllFieldHeaders(columns, this.setAlignment);
        const fieldHeaderRowsCount = helpers._getFieldHeaderRowsCount();
        cellRange.to.row = cellRange.from.row + fieldHeaderRowsCount;
        const styles = this.getCellStyles(dataProvider);
        for (let rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {
          const currentRowIndex = cellRange.from.row + fieldHeaderRowsCount + rowIndex;
          const row = worksheet.getRow(currentRowIndex);
          let startColumnIndex = 0;
          if (helpers._isRowFieldHeadersRow(rowIndex)) {
            startColumnIndex = dataProvider.getRowAreaColCount();
            helpers._exportFieldHeaders('row', currentRowIndex, 0, startColumnIndex, this.setAlignment);
          }
          helpers._trySetOutlineLevel(row, rowIndex);
          this.exportRow(dataProvider, helpers, row, rowIndex, startColumnIndex, columns.length, wrapText, styles, encodeExecutableContent);
          cellRange.to.row = currentRowIndex;
        }
        helpers.mergedRangesManager.applyMergedRages();
        cellRange.to.column += columns.length > 0 ? columns.length - 1 : 0;
        const worksheetViewSettings = worksheet.views[0] || {};
        if (component.option('rtlEnabled')) {
          worksheetViewSettings.rightToLeft = true;
        }
        if (helpers._isFrozenZone(dataProvider)) {
          if (Object.keys(worksheetViewSettings).indexOf('state') === -1) {
            (0, _extend.extend)(worksheetViewSettings, helpers._getWorksheetFrozenState(cellRange));
          }
          helpers._trySetAutoFilter(cellRange);
        }
        if (Object.keys(worksheetViewSettings).length > 0) {
          worksheet.views = [worksheetViewSettings];
        }
        resolve(cellRange);
      }).always(() => {
        if (initialLoadPanelEnabledOption) {
          component.option('loadPanel.enabled', initialLoadPanelEnabledOption);
        }
        if (loadPanel.enabled && (0, _window.hasWindow)()) {
          exportLoadPanel.dispose();
        }
      });
    });
  },
  exportRow(dataProvider, helpers, row, rowIndex, startColumnIndex, columnsCount, wrapText, styles, encodeExecutableContent) {
    for (let cellIndex = startColumnIndex; cellIndex < columnsCount; cellIndex++) {
      const cellData = dataProvider.getCellData(rowIndex, cellIndex, true);
      const excelCell = row.getCell(helpers._getFirstColumnIndex() + cellIndex);
      helpers.mergedRangesManager.updateMergedRanges(excelCell, rowIndex, cellIndex, helpers);
      const cellInfo = helpers.mergedRangesManager.findMergedCellInfo(rowIndex, cellIndex, helpers._isHeaderCell(rowIndex, cellIndex));
      if ((0, _type.isDefined)(cellInfo) && excelCell !== cellInfo.masterCell) {
        excelCell.style = cellInfo.masterCell.style;
        excelCell.value = cellInfo.masterCell.value;
      } else {
        if ((0, _type.isDate)(cellData.value)) {
          excelCell.value = this.convertDateForExcelJS(cellData.value);
        } else {
          excelCell.value = cellData.value;
        }
        if ((0, _type.isDefined)(excelCell.value)) {
          const {
            bold,
            alignment: horizontalAlignment,
            numberFormat
          } = styles[dataProvider.getStyleId(rowIndex, cellIndex)];
          if ((0, _type.isDefined)(numberFormat)) {
            this.setNumberFormat(excelCell, numberFormat);
          } else if ((0, _type.isString)(excelCell.value) && /^[@=+-]/.test(excelCell.value)) {
            this.setNumberFormat(excelCell, '@');
          }
          helpers._trySetFont(excelCell, bold);
          this.setAlignment(excelCell, wrapText, horizontalAlignment);
        }
      }
      helpers._customizeCell(excelCell, cellData.cellSourceData);
      if (encodeExecutableContent) {
        excelCell.value = _export_format.ExportFormat.encode(excelCell.value);
      }
    }
  }
};

/***/ }),

/***/ 8572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.exportDataGrid = exportDataGrid;
var _type = __webpack_require__(35922);
var _export = __webpack_require__(11385);
var _export_merged_ranges_manager = __webpack_require__(31980);
class DataGridHelpers {
  constructor(component, dataProvider, worksheet, options) {
    this.component = component;
    this.dataProvider = dataProvider;
    this.worksheet = worksheet;
    this.mergedRangesManager = new _export_merged_ranges_manager.MergedRangesManager(dataProvider, worksheet);
    this.topLeftCell = options.topLeftCell;
    this.customizeCell = options.customizeCell;
    this.autoFilterEnabled = options.autoFilterEnabled;
  }
  _getFirstColumnIndex() {
    return this.topLeftCell.column;
  }
  _getFieldHeaderRowsCount() {
    return 0;
  }
  _trySetAutoFilter(cellRange) {
    if (this.autoFilterEnabled) {
      if (!(0, _type.isDefined)(this.worksheet.autoFilter) && this.dataProvider.getRowsCount() > 0) {
        const dataRange = {
          from: {
            row: cellRange.from.row + this.dataProvider.getHeaderRowCount() - 1,
            column: cellRange.from.column
          },
          to: cellRange.to
        };
        this.worksheet.autoFilter = dataRange;
      }
    }
  }
  _trySetFont(excelCell, bold) {
    if ((0, _type.isDefined)(bold)) {
      excelCell.font = excelCell.font || {};
      excelCell.font.bold = bold;
    }
  }
  _getWorksheetFrozenState(cellRange) {
    return {
      state: 'frozen',
      ySplit: cellRange.from.row + this.dataProvider.getFrozenArea().y - 1
    };
  }
  _trySetOutlineLevel(row, rowIndex) {
    if (rowIndex >= this.dataProvider.getHeaderRowCount()) {
      row.outlineLevel = this.dataProvider.getGroupLevel(rowIndex);
    }
  }
  _isFrozenZone(dataProvider) {
    return dataProvider.getHeaderRowCount() > 0;
  }
  _isHeaderCell(rowIndex) {
    return rowIndex < this.dataProvider.getHeaderRowCount();
  }
  _isInfoCell() {
    return false;
  }
  _allowToMergeRange() {
    return true;
  }
  _getAllFieldHeaders() {
    return [];
  }
  _customizeCell(excelCell, gridCell) {
    if ((0, _type.isFunction)(this.customizeCell)) {
      this.customizeCell({
        excelCell,
        gridCell
      });
    }
  }
  _exportFieldHeaders() {}
  _exportAllFieldHeaders() {}
  _isRowFieldHeadersRow() {}
}
function exportDataGrid(options) {
  return _export.Export.export(_getFullOptions(options), DataGridHelpers, _getLoadPanelTargetElement, _getLoadPanelContainer);
}
function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportDataGrid" method requires a configuration object.');
  }
  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxDataGrid')) {
    throw Error('The "component" field must contain a DataGrid instance.');
  }
  if (!(0, _type.isDefined)(options.selectedRowsOnly)) {
    options.selectedRowsOnly = false;
  }
  if (!(0, _type.isDefined)(options.autoFilterEnabled)) {
    options.autoFilterEnabled = false;
  }
  return _export.Export.getFullOptions(options);
}
function _getLoadPanelTargetElement(component) {
  return component.getView('rowsView').element();
}
function _getLoadPanelContainer(component) {
  return component.getView('rowsView').element().parent();
}

/***/ }),

/***/ 38526:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ExportFormat = void 0;
var _string = __webpack_require__(68752);
var _number = _interopRequireDefault(__webpack_require__(18016));
var _date = _interopRequireDefault(__webpack_require__(91500));
var _type = __webpack_require__(35922);
var _date2 = __webpack_require__(59937);
var _language_codes = __webpack_require__(9821);
var _extend = __webpack_require__(13306);
__webpack_require__(89740);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ARABIC_ZERO_CODE = 1632;
const DEFINED_NUMBER_FORMTATS = {
  thousands: '#,##0{0},&quot;K&quot;',
  millions: '#,##0{0},,&quot;M&quot;',
  billions: '#,##0{0},,,&quot;B&quot;',
  trillions: '#,##0{0},,,,&quot;T&quot;',
  percent: '0{0}%',
  decimal: '#{0}',
  'fixedpoint': '#,##0{0}',
  exponential: '0{0}E+00',
  currency: ' '
};
const PERIOD_REGEXP = /a+/g;
const DAY_REGEXP = /E/g;
const DO_REGEXP = /dE+/g;
const STANDALONE_MONTH_REGEXP = /L/g;
const HOUR_REGEXP = /h/g;
const ANY_REGEXP = /./g;
function _applyPrecision(format, precision) {
  let result;
  let i;
  if (precision > 0) {
    result = format !== 'decimal' ? '.' : '';
    for (i = 0; i < precision; i++) {
      result = result + '0';
    }
    return result;
  }
  return '';
}
function _hasArabicDigits(text) {
  let code;
  for (let i = 0; i < text.length; i++) {
    code = text.charCodeAt(i);
    if (code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10) {
      return true;
    }
  }
  return false;
}
function _convertDateFormat(format) {
  const formattedValue = (_date.default.format(new Date(2009, 8, 8, 6, 5, 4), format) || '').toString();
  let result = (0, _date2.getFormat)(value => _date.default.format(value, format));
  if (result) {
    result = _convertDateFormatToOpenXml(result);
    result = _getLanguageInfo(formattedValue) + result;
  }
  return result;
}
function _getLanguageInfo(defaultPattern) {
  const languageID = (0, _language_codes.getLanguageId)();
  let languageIDStr = languageID ? languageID.toString(16) : '';
  let languageInfo = '';
  if (_hasArabicDigits(defaultPattern)) {
    while (languageIDStr.length < 3) {
      languageIDStr = '0' + languageIDStr;
    }
    languageInfo = '[$-2010' + languageIDStr + ']';
  } else if (languageIDStr) {
    languageInfo = '[$-' + languageIDStr + ']';
  }
  return languageInfo;
}
function _convertDateFormatToOpenXml(format) {
  return format.split('/').join('\\/').split('\'').map(function (datePart, index) {
    if (index % 2 === 0) {
      return datePart.replace(PERIOD_REGEXP, 'AM/PM').replace(DO_REGEXP, 'd').replace(DAY_REGEXP, 'd').replace(STANDALONE_MONTH_REGEXP, 'M').replace(HOUR_REGEXP, 'H').split('[').join('\\[').split(']').join('\\]');
    }
    if (datePart) {
      return datePart.replace(ANY_REGEXP, '\\$&');
    }
    return '\'';
  }).join('');
}
function _convertNumberFormat(format, precision, currency) {
  let result;
  let excelFormat;
  if (format === 'currency') {
    excelFormat = _number.default.getOpenXmlCurrencyFormat(currency);
  } else {
    excelFormat = DEFINED_NUMBER_FORMTATS[format.toLowerCase()];
  }
  if (excelFormat) {
    result = (0, _string.format)(excelFormat, _applyPrecision(format, precision));
  }
  return result;
}
function _hasCSVInjection(value) {
  if (!value || value.length < 2) {
    return false;
  }
  return _includesCSVExpression(value);
}
function _hasCSVQuotedInjection(value, textQualifier) {
  if (!value || value.length < 4 || value[0] !== textQualifier) {
    return false;
  }
  return _includesCSVExpression(value.substring(1, value.length - 1));
}
function _includesCSVExpression(value) {
  const injectionPrefix = /^[@=\t\r]/;
  const possibleInjectionPrefix = /^[+-]/;
  if (!value) {
    return false;
  }
  if (injectionPrefix.test(value)) {
    return true;
  }
  if (!possibleInjectionPrefix.test(value)) {
    return false;
  }
  return !(0, _type.isNumeric)(value);
}
const ExportFormat = exports.ExportFormat = {
  formatObjectConverter(format, dataType) {
    const result = {
      format: format,
      precision: format && format.precision,
      dataType: dataType
    };
    if ((0, _type.isObject)(format)) {
      return (0, _extend.extend)(result, format, {
        format: format.formatter || format.type,
        currency: format.currency
      });
    }
    return result;
  },
  convertFormat(format, precision, type, currency) {
    if ((0, _type.isDefined)(format)) {
      if (type === 'date') {
        return _convertDateFormat(format);
      } else {
        if ((0, _type.isString)(format) && DEFINED_NUMBER_FORMTATS[format.toLowerCase()]) {
          return _convertNumberFormat(format, precision, currency);
        }
      }
    }
  },
  encode(value) {
    const textQualifier = '"';
    let escaped = false;
    if (_hasCSVInjection(value)) {
      escaped = true;
    } else if (_hasCSVQuotedInjection(value, textQualifier)) {
      value = value.substring(1, value.length - 1);
      escaped = true;
    }
    if (escaped) {
      const singleTextQualifier = textQualifier;
      const escapedTextQualifier = `${textQualifier}${textQualifier}`;
      return textQualifier + '\'' + value.replaceAll(singleTextQualifier, escapedTextQualifier) + textQualifier;
    }
    return value;
  }
};

/***/ }),

/***/ 31980:
/***/ (function(__unused_webpack_module, exports) {



exports.MergedRangesManager = void 0;
class MergedRangesManager {
  constructor(dataProvider, worksheet) {
    this.dataProvider = dataProvider;
    this.worksheet = worksheet;
    this.mergedCells = [];
    this.mergedRanges = [];
  }
  updateMergedRanges(excelCell, rowIndex, cellIndex, helpers) {
    if (helpers._isHeaderCell(rowIndex, cellIndex) && !this.isCellInMergedRanges(rowIndex, cellIndex)) {
      const {
        rowspan,
        colspan
      } = this.dataProvider.getCellMerging(rowIndex, cellIndex);
      const isMasterCellOfMergedRange = colspan || rowspan;
      if (isMasterCellOfMergedRange) {
        const allowToMergeRange = helpers._allowToMergeRange(rowIndex, cellIndex, rowspan, colspan);
        this.updateMergedCells(excelCell, rowIndex, cellIndex, rowspan, colspan);
        if (allowToMergeRange) {
          const shouldReduceInfoRange = helpers._isInfoCell(rowIndex, cellIndex) && helpers._allowExportRowFieldHeaders();
          this.mergedRanges.push({
            masterCell: excelCell,
            rowspan: rowspan - (shouldReduceInfoRange && rowspan > 0),
            colspan
          });
        }
      }
    }
  }
  isCellInMergedRanges(rowIndex, cellIndex) {
    return this.mergedCells[rowIndex] && this.mergedCells[rowIndex][cellIndex];
  }
  findMergedCellInfo(rowIndex, cellIndex, isHeaderCell) {
    if (isHeaderCell && this.isCellInMergedRanges(rowIndex, cellIndex)) {
      return this.mergedCells[rowIndex][cellIndex];
    }
  }
  updateMergedCells(excelCell, rowIndex, cellIndex, rowspan, colspan) {
    for (let i = rowIndex; i <= rowIndex + rowspan; i++) {
      for (let j = cellIndex; j <= cellIndex + colspan; j++) {
        if (!this.mergedCells[i]) {
          this.mergedCells[i] = [];
        }
        this.mergedCells[i][j] = {
          masterCell: excelCell
        };
      }
    }
  }
  addMergedRange(masterCell, rowspan, colspan) {
    this.mergedRanges.push({
      masterCell,
      rowspan,
      colspan
    });
  }
  applyMergedRages() {
    this.mergedRanges.forEach(range => {
      const startRowIndex = range.masterCell.fullAddress.row;
      const startColumnIndex = range.masterCell.fullAddress.col;
      const endRowIndex = startRowIndex + range.rowspan;
      const endColumnIndex = startColumnIndex + range.colspan;
      this.worksheet.mergeCells(startRowIndex, startColumnIndex, endRowIndex, endColumnIndex);
    });
  }
}
exports.MergedRangesManager = MergedRangesManager;

/***/ }),

/***/ 77328:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.exportPivotGrid = exportPivotGrid;
var _type = __webpack_require__(35922);
var _export = __webpack_require__(11385);
var _position = __webpack_require__(37518);
var _inflector = __webpack_require__(78008);
var _export_merged_ranges_manager = __webpack_require__(31980);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const FIELD_HEADERS_SEPARATOR = ', ';
class PivotGridHelpers {
  constructor(component, dataProvider, worksheet, options) {
    this.component = component;
    this.dataProvider = dataProvider;
    this.worksheet = worksheet;
    this.mergedRangesManager = new _export_merged_ranges_manager.MergedRangesManager(dataProvider, worksheet);
    this.topLeftCell = options.topLeftCell;
    this.customizeCell = options.customizeCell;
    this.mergeColumnFieldValues = options.mergeColumnFieldValues;
    this.mergeRowFieldValues = options.mergeRowFieldValues;
    this.exportFilterFieldHeaders = options.exportFilterFieldHeaders;
    this.exportDataFieldHeaders = options.exportDataFieldHeaders;
    this.exportColumnFieldHeaders = options.exportColumnFieldHeaders;
    this.exportRowFieldHeaders = options.exportRowFieldHeaders;
    this.rtlEnabled = component.option('rtlEnabled');
    this.rowHeaderLayout = component.option('rowHeaderLayout');
    this.wrapText = !!component.option('wordWrapEnabled');
    this.filterFieldHeaders = this._tryGetFieldHeaders('filter');
    this.dataFieldHeaders = this._tryGetFieldHeaders('data');
    this.columnFieldHeaders = this._tryGetFieldHeaders('column');
    this.rowFieldHeaders = this._tryGetFieldHeaders('row');
  }
  _getFirstColumnIndex() {
    return this.topLeftCell.column;
  }
  _getWorksheetFrozenState(cellRange) {
    const {
      x,
      y
    } = this.dataProvider.getFrozenArea();
    return {
      state: 'frozen',
      xSplit: cellRange.from.column + x - 1,
      ySplit: cellRange.from.row + y + this._getFieldHeaderRowsCount() - 1
    };
  }
  _getFieldHeaderRowsCount() {
    return 0 + this._allowExportFilterFieldHeaders() + (this._allowExportDataFieldHeaders() || this._allowExportColumnFieldHeaders());
  }
  _isFrozenZone() {
    return true;
  }
  _isHeaderCell(rowIndex, cellIndex) {
    return rowIndex < this.dataProvider.getColumnAreaRowCount() || cellIndex < this.dataProvider.getRowAreaColCount();
  }
  _getDefaultFieldHeaderCellsData(value) {
    return {
      text: value,
      value: value
    };
  }
  _isInfoCell(rowIndex, cellIndex) {
    return rowIndex < this.dataProvider.getColumnAreaRowCount() && cellIndex < this.dataProvider.getRowAreaColCount();
  }
  _allowToMergeRange(rowIndex, cellIndex, rowspan, colspan) {
    return !(this.dataProvider.isColumnAreaCell(rowIndex, cellIndex) && !this.mergeColumnFieldValues && !!colspan || this.dataProvider.isRowAreaCell(rowIndex, cellIndex) && !this.mergeRowFieldValues && !!rowspan);
  }
  _trySetAutoFilter() {}
  _trySetFont(excelCell, bold) {
    if ((0, _type.isDefined)(bold)) {
      excelCell.font = excelCell.font || {};
      excelCell.font.bold = bold;
    }
  }
  _getFieldHeaderStyles() {
    // eslint-disable-next-line spellcheck/spell-checker
    const borderStyle = {
      style: 'thin',
      color: {
        argb: 'FF7E7E7E'
      }
    };
    return {
      alignment: (0, _position.getDefaultAlignment)(this.rtlEnabled),
      bold: true,
      border: {
        bottom: borderStyle,
        left: borderStyle,
        right: borderStyle,
        top: borderStyle
      }
    };
  }
  _trySetOutlineLevel() {}
  _getAllFieldHeaders() {
    return this.dataProvider._exportController.getDataSource()._descriptions;
  }
  _tryGetFieldHeaders(area) {
    if (!this[`export${(0, _inflector.camelize)(area, true)}FieldHeaders`]) {
      return [];
    }
    const fields = this._getAllFieldHeaders()[area === 'data' ? 'values' : `${area}s`].filter(fieldHeader => fieldHeader.area === area);
    if ((0, _position.getDefaultAlignment)(this.rtlEnabled) === 'right') {
      fields.sort((a, b) => b.areaIndex - a.areaIndex);
    }
    return fields.map(field => field.caption);
  }
  _customizeCell(excelCell, pivotCell, shouldPreventCall) {
    if ((0, _type.isFunction)(this.customizeCell) && !shouldPreventCall) {
      this.customizeCell({
        excelCell,
        pivotCell
      });
    }
  }
  _isRowFieldHeadersRow(rowIndex) {
    const isLastInfoRangeCell = this._isInfoCell(rowIndex, 0) && this.dataProvider.getCellData(rowIndex + 1, 0, true).cellSourceData.area === 'row';
    return this._allowExportRowFieldHeaders() && isLastInfoRangeCell;
  }
  _exportAllFieldHeaders(columns, setAlignment) {
    const totalCellsCount = columns.length;
    const rowAreaColCount = this.dataProvider.getRowAreaColCount();
    let rowIndex = this.topLeftCell.row;
    if (this._allowExportFilterFieldHeaders()) {
      this._exportFieldHeaders('filter', rowIndex, 0, totalCellsCount, setAlignment);
      rowIndex++;
    }
    if (this._allowExportDataFieldHeaders()) {
      this._exportFieldHeaders('data', rowIndex, 0, rowAreaColCount, setAlignment);
      if (!this._allowExportColumnFieldHeaders()) {
        this._exportFieldHeaders('column', rowIndex, rowAreaColCount, totalCellsCount - rowAreaColCount, setAlignment);
      }
    }
    if (this._allowExportColumnFieldHeaders()) {
      if (!this._allowExportDataFieldHeaders()) {
        this._exportFieldHeaders('data', rowIndex, 0, rowAreaColCount, setAlignment);
      }
      this._exportFieldHeaders('column', rowIndex, rowAreaColCount, totalCellsCount - rowAreaColCount, setAlignment);
    }
  }
  _exportFieldHeaders(area, rowIndex, startColumnIndex, totalColumnsCount, setAlignment) {
    const fieldHeaders = this[`${area}FieldHeaders`];
    const row = this.worksheet.getRow(rowIndex);
    const shouldMergeHeaderField = area !== 'row' || area === 'row' && this.rowHeaderLayout === 'tree';
    if (shouldMergeHeaderField) {
      this.mergedRangesManager.addMergedRange(row.getCell(this.topLeftCell.column + startColumnIndex), 0, totalColumnsCount - 1);
    }
    for (let cellIndex = 0; cellIndex < totalColumnsCount; cellIndex++) {
      const excelCell = row.getCell(this.topLeftCell.column + startColumnIndex + cellIndex);
      const values = fieldHeaders;
      let cellData = [];
      const value = values.length > totalColumnsCount || shouldMergeHeaderField ? values.join(FIELD_HEADERS_SEPARATOR) : values[cellIndex];
      cellData = _extends({}, this._getDefaultFieldHeaderCellsData(value), {
        headerType: area
      });
      excelCell.value = value;
      this._applyHeaderStyles(excelCell, setAlignment);
      this._customizeCell(excelCell, cellData);
    }
  }
  _applyHeaderStyles(excelCell, setAlignment) {
    const {
      bold,
      alignment,
      border
    } = this._getFieldHeaderStyles();
    this._trySetFont(excelCell, bold);
    setAlignment(excelCell, this.wrapText, alignment);
    excelCell.border = border;
  }
  _allowExportRowFieldHeaders() {
    return this.rowFieldHeaders.length > 0;
  }
  _allowExportFilterFieldHeaders() {
    return this.filterFieldHeaders.length > 0;
  }
  _allowExportDataFieldHeaders() {
    return this.dataFieldHeaders.length > 0;
  }
  _allowExportColumnFieldHeaders() {
    return this.columnFieldHeaders.length > 0;
  }
}
function exportPivotGrid(options) {
  return _export.Export.export(_getFullOptions(options), PivotGridHelpers, _getLoadPanelTargetElement, _getLoadPanelContainer);
}
function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportPivotGrid" method requires a configuration object.');
  }
  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxPivotGrid')) {
    throw Error('The "component" field must contain a PivotGrid instance.');
  }
  if (!(0, _type.isDefined)(options.mergeRowFieldValues)) {
    options.mergeRowFieldValues = true;
  }
  if (!(0, _type.isDefined)(options.mergeColumnFieldValues)) {
    options.mergeColumnFieldValues = true;
  }
  if (!(0, _type.isDefined)(options.exportDataFieldHeaders)) {
    options.exportDataFieldHeaders = false;
  }
  if (!(0, _type.isDefined)(options.exportRowFieldHeaders)) {
    options.exportRowFieldHeaders = false;
  }
  if (!(0, _type.isDefined)(options.exportColumnFieldHeaders)) {
    options.exportColumnFieldHeaders = false;
  }
  if (!(0, _type.isDefined)(options.exportFilterFieldHeaders)) {
    options.exportFilterFieldHeaders = false;
  }
  return _export.Export.getFullOptions(options);
}
function _getLoadPanelTargetElement(component) {
  return component._dataArea.groupElement();
}
function _getLoadPanelContainer(component) {
  return component.$element();
}

/***/ }),

/***/ 48351:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.fileSaver = exports.MIME_TYPES = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _ui = _interopRequireDefault(__webpack_require__(96688));
var _type = __webpack_require__(35922);
var _console = __webpack_require__(30869);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global Windows */

const window = (0, _window.getWindow)();
const navigator = (0, _window.getNavigator)();
const FILE_EXTESIONS = {
  EXCEL: 'xlsx',
  CSS: 'css',
  PNG: 'png',
  JPEG: 'jpeg',
  GIF: 'gif',
  SVG: 'svg',
  PDF: 'pdf'
};
const MIME_TYPES = exports.MIME_TYPES = {
  CSS: 'text/css',
  EXCEL: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  PNG: 'image/png',
  JPEG: 'image/jpeg',
  GIF: 'image/gif',
  SVG: 'image/svg+xml',
  PDF: 'application/pdf'
};

// Use github.com/eligrey/FileSaver.js library instead this method

const fileSaver = exports.fileSaver = {
  _revokeObjectURLTimeout: 30000,
  _getDataUri: function (format, data) {
    const mimeType = this._getMimeType(format);
    return `data:${mimeType};base64,${data}`;
  },
  _getMimeType: function (format) {
    return MIME_TYPES[format] || 'application/octet-stream';
  },
  _linkDownloader: function (fileName, href) {
    const exportLinkElement = _dom_adapter.default.createElement('a');
    exportLinkElement.download = fileName;
    exportLinkElement.href = href;
    exportLinkElement.target = '_blank'; // cors policy

    return exportLinkElement;
  },
  _winJSBlobSave: function (blob, fileName, format) {
    const savePicker = new Windows.Storage.Pickers.FileSavePicker();
    savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
    const fileExtension = FILE_EXTESIONS[format];
    if (fileExtension) {
      const mimeType = this._getMimeType(format);
      savePicker.fileTypeChoices.insert(mimeType, ['.' + fileExtension]);
    }
    savePicker.suggestedFileName = fileName;
    savePicker.pickSaveFileAsync().then(function (file) {
      if (file) {
        file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function (outputStream) {
          const inputStream = blob.msDetachStream();
          Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function () {
            outputStream.flushAsync().done(function () {
              inputStream.close();
              outputStream.close();
            });
          });
        });
      }
    });
  },
  _click: function (link) {
    try {
      // eslint-disable-next-line no-undef
      link.dispatchEvent(new MouseEvent('click', {
        cancelable: true
      }));
    } catch (e) {
      const event = _dom_adapter.default.getDocument().createEvent('MouseEvents');
      event.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      link.dispatchEvent(event);
    }
  },
  _saveBlobAs: function (fileName, format, data) {
    this._blobSaved = false;
    if ((0, _type.isDefined)(navigator.msSaveOrOpenBlob)) {
      navigator.msSaveOrOpenBlob(data, fileName);
      this._blobSaved = true;
    } else if ((0, _type.isDefined)(window.WinJS)) {
      this._winJSBlobSave(data, fileName, format);
      this._blobSaved = true;
    } else {
      const URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
      if ((0, _type.isDefined)(URL)) {
        const objectURL = URL.createObjectURL(data);
        const downloadLink = this._linkDownloader(fileName, objectURL);
        setTimeout(() => {
          URL.revokeObjectURL(objectURL);
          this._objectUrlRevoked = true;
        }, this._revokeObjectURLTimeout);
        this._click(downloadLink);
      } else {
        _console.logger.warn('window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL is not defined');
      }
    }
  },
  saveAs: function (fileName, format, data) {
    const fileExtension = FILE_EXTESIONS[format];
    if (fileExtension) {
      fileName += '.' + fileExtension;
    }
    if ((0, _type.isFunction)(window.Blob)) {
      this._saveBlobAs(fileName, format, data);
    } else {
      if (!(0, _type.isDefined)(navigator.userAgent.match(/iPad/i))) _ui.default.log('E1034');
      const downloadLink = this._linkDownloader(fileName, this._getDataUri(format, data));
      this._click(downloadLink);
    }
  }
};

/***/ }),

/***/ 12173:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.calcScaledInfo = calcScaledInfo;
exports.getData = getData;
exports.imageCreator = void 0;
exports.testFormats = testFormats;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _color = _interopRequireDefault(__webpack_require__(52752));
var _type = __webpack_require__(35922);
var _svg = __webpack_require__(19155);
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom = __webpack_require__(3532);
var _window = __webpack_require__(58201);
var _inflector = __webpack_require__(78008);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const _math = Math;
const PI = _math.PI;
const _min = _math.min;
const _abs = _math.abs;
const _sqrt = _math.sqrt;
const _pow = _math.pow;
const _atan2 = _math.atan2;
const _cos = _math.cos;
const _sin = _math.sin;
const _number = Number;
const IMAGE_QUALITY = 1;
const TEXT_DECORATION_LINE_WIDTH_COEFF = 0.05;
const DEFAULT_FONT_SIZE = '10px';
const DEFAULT_FONT_FAMILY = 'sans-serif';
const DEFAULT_TEXT_COLOR = '#000';
let parseAttributes;
function getStringFromCanvas(canvas, mimeType) {
  const dataURL = canvas.toDataURL(mimeType, IMAGE_QUALITY);
  const imageData = window.atob(dataURL.substring(('data:' + mimeType + ';base64,').length));
  return imageData;
}
function arcTo(x1, y1, x2, y2, radius, largeArcFlag, clockwise, context) {
  const cBx = (x1 + x2) / 2;
  const cBy = (y1 + y2) / 2;
  let aB = _atan2(y1 - y2, x1 - x2);
  const k = largeArcFlag ? 1 : -1;
  aB += 90 * (PI / 180) * (clockwise ? 1 : -1);
  const opSide = _sqrt(_pow(x2 - x1, 2) + _pow(y2 - y1, 2)) / 2;
  const adjSide = _sqrt(_abs(_pow(radius, 2) - _pow(opSide, 2)));
  const centerX = cBx + k * (adjSide * _cos(aB));
  const centerY = cBy + k * (adjSide * _sin(aB));
  const startAngle = _atan2(y1 - centerY, x1 - centerX);
  const endAngle = _atan2(y2 - centerY, x2 - centerX);
  context.arc(centerX, centerY, radius, startAngle, endAngle, !clockwise);
}
function getElementOptions(element, rootAppended) {
  const attr = parseAttributes(element.attributes || {});
  const options = (0, _extend.extend)({}, attr, {
    text: element.textContent.replace(/\s+/g, ' '),
    textAlign: attr['text-anchor'] === 'middle' ? 'center' : attr['text-anchor']
  });
  const transform = attr.transform;
  let coords;
  if (transform) {
    coords = transform.match(/translate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.translateX = _number(coords[0]);
      options.translateY = coords[1] ? _number(coords[1]) : 0;
    }
    coords = transform.match(/rotate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*,*\s*-*\d+([.]\d+)*)*/);
    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.rotationAngle = _number(coords[0]);
      options.rotationX = coords[1] && _number(coords[1]);
      options.rotationY = coords[2] && _number(coords[2]);
    }
    coords = transform.match(/scale\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.scaleX = _number(coords[0]);
      if (coords.length > 1) {
        options.scaleY = _number(coords[1]);
      } else {
        options.scaleY = options.scaleX;
      }
    }
  }
  parseStyles(element, options, rootAppended);
  return options;
}
function drawRect(context, options) {
  const x = options.x;
  const y = options.y;
  const width = options.width;
  const height = options.height;
  let cornerRadius = options.rx;
  if (!cornerRadius) {
    context.rect(x, y, width, height);
  } else {
    cornerRadius = _min(cornerRadius, width / 2, height / 2);
    context.save();
    context.translate(x, y);
    context.moveTo(width / 2, 0);
    context.arcTo(width, 0, width, height, cornerRadius);
    context.arcTo(width, height, 0, height, cornerRadius);
    context.arcTo(0, height, 0, 0, cornerRadius);
    context.arcTo(0, 0, cornerRadius, 0, cornerRadius);
    context.lineTo(width / 2, 0);
    context.restore();
  }
}
function drawImage(context, options, shared) {
  const d = new _deferred.Deferred();
  const image = new window.Image();
  image.onload = function () {
    context.save();
    context.globalAlpha = options.globalAlpha;
    transformElement(context, options);
    clipElement(context, options, shared);
    context.drawImage(image, options.x || 0, options.y || 0, options.width, options.height);
    context.restore();
    d.resolve();
  };
  image.onerror = function () {
    d.resolve();
  };
  image.setAttribute('crossOrigin', 'anonymous');
  image.src = options['href'] || options['xlink:href'];
  return d;
}
function drawPath(context, dAttr) {
  const dArray = dAttr.replace(/,/g, ' ').split(/([A-Z])/i).filter(item => item.trim() !== '');
  let i = 0;
  let params;
  let prevParams;
  let prevParamsLen;
  do {
    params = (dArray[i + 1] || '').trim().split(' ');
    switch (dArray[i]) {
      case 'M':
        context.moveTo(_number(params[0]), _number(params[1]));
        i += 2;
        break;
      case 'L':
        for (let j = 0; j < params.length / 2; j++) {
          context.lineTo(_number(params[j * 2]), _number(params[j * 2 + 1]));
        }
        i += 2;
        break;
      case 'C':
        context.bezierCurveTo(_number(params[0]), _number(params[1]), _number(params[2]), _number(params[3]), _number(params[4]), _number(params[5]));
        i += 2;
        break;
      case 'a':
        prevParams = dArray[i - 1].trim().split(' ');
        prevParamsLen = prevParams.length - 1;
        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(prevParams[prevParamsLen - 1]) + _number(params[5]), _number(prevParams[prevParamsLen]) + _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);
        i += 2;
        break;
      case 'A':
        prevParams = dArray[i - 1].trim().split(' ');
        prevParamsLen = prevParams.length - 1;
        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(params[5]), _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);
        i += 2;
        break;
      case 'Z':
        context.closePath();
        i += 1;
        break;
      default:
        i++;
    }
  } while (i < dArray.length);
}
function parseStyles(element, options, rootAppended) {
  let style = element.style || {};
  let field;
  for (field in style) {
    if (style[field] !== '') {
      options[(0, _inflector.camelize)(field)] = style[field];
    }
  }
  if (rootAppended && _dom_adapter.default.isElementNode(element)) {
    style = window.getComputedStyle(element);
    ['fill', 'stroke', 'stroke-width', 'font-family', 'font-size', 'font-style', 'font-weight'].forEach(function (prop) {
      if (prop in style && style[prop] !== '') {
        options[(0, _inflector.camelize)(prop)] = style[prop];
      }
    });
    ['opacity', 'fill-opacity', 'stroke-opacity'].forEach(function (prop) {
      if (prop in style && style[prop] !== '' && style[prop] !== '1') {
        options[prop] = _number(style[prop]);
      }
    });
  }
  options.textDecoration = options.textDecoration || options.textDecorationLine;
  options.globalAlpha = (0, _type.isDefined)(options.opacity) ? options.opacity : options.globalAlpha;
}
function parseUrl(urlString) {
  const matches = urlString && urlString.match(/url\(.*#(.*?)["']?\)/i);
  return matches && matches[1];
}
function setFontStyle(context, options) {
  const fontParams = [];
  options.fontSize = options.fontSize || DEFAULT_FONT_SIZE;
  options.fontFamily = options.fontFamily || DEFAULT_FONT_FAMILY;
  options.fill = options.fill || DEFAULT_TEXT_COLOR;
  options.fontStyle && fontParams.push(options.fontStyle);
  options.fontWeight && fontParams.push(options.fontWeight);
  fontParams.push(options.fontSize);
  fontParams.push(options.fontFamily);
  context.font = fontParams.join(' ');
  context.textAlign = options.textAlign;
  context.fillStyle = options.fill;
  context.globalAlpha = options.globalAlpha;
}
function drawText(context, options, shared) {
  setFontStyle(context, options);
  applyFilter(context, options, shared);
  options.text && context.fillText(options.text, options.x || 0, options.y || 0);
  strokeElement(context, options, true);
  drawTextDecoration(context, options, shared);
}
function drawTextDecoration(context, options, shared) {
  if (!options.textDecoration || options.textDecoration === 'none') {
    return;
  }
  const x = options.x;
  const textWidth = context.measureText(options.text).width;
  const textHeight = parseInt(options.fontSize, 10);
  const lineHeight = textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF < 1 ? 1 : textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF;
  let y = options.y;
  switch (options.textDecoration) {
    case 'line-through':
      y -= textHeight / 3 + lineHeight / 2;
      break;
    case 'overline':
      y -= textHeight - lineHeight;
      break;
    case 'underline':
      y += lineHeight;
      break;
  }
  context.rect(x, y, textWidth, lineHeight);
  fillElement(context, options, shared);
  strokeElement(context, options);
}
function aggregateOpacity(options) {
  options.strokeOpacity = options['stroke-opacity'] !== undefined ? options['stroke-opacity'] : 1;
  options.fillOpacity = options['fill-opacity'] !== undefined ? options['fill-opacity'] : 1;
  if (options.opacity !== undefined) {
    options.strokeOpacity *= options.opacity;
    options.fillOpacity *= options.opacity;
  }
}
function hasTspan(element) {
  const nodes = element.childNodes;
  for (let i = 0; i < nodes.length; i++) {
    if (nodes[i].tagName === 'tspan') {
      return true;
    }
  }
  return false;
}
function drawTextElement(childNodes, context, options, shared) {
  const lines = [];
  let line;
  let offset = 0;
  for (let i = 0; i < childNodes.length; i++) {
    const element = childNodes[i];
    if (element.tagName === undefined) {
      drawElement(element, context, options, shared);
    } else if (element.tagName === 'tspan' || element.tagName === 'text') {
      const elementOptions = getElementOptions(element, shared.rootAppended);
      const mergedOptions = (0, _extend.extend)({}, options, elementOptions);
      if (element.tagName === 'tspan' && hasTspan(element)) {
        drawTextElement(element.childNodes, context, mergedOptions, shared);
        continue;
      }
      mergedOptions.textAlign = 'start';
      if (!line || elementOptions.x !== undefined) {
        line = {
          elements: [],
          options: [],
          widths: [],
          offsets: []
        };
        lines.push(line);
      }
      if (elementOptions.y !== undefined) {
        offset = 0;
      }
      if (elementOptions.dy !== undefined) {
        offset += parseFloat(elementOptions.dy);
      }
      line.elements.push(element);
      line.options.push(mergedOptions);
      line.offsets.push(offset);
      setFontStyle(context, mergedOptions);
      line.widths.push(context.measureText(mergedOptions.text).width);
    }
  }
  lines.forEach(function (line) {
    const commonWidth = line.widths.reduce(function (commonWidth, width) {
      return commonWidth + width;
    }, 0);
    let xDiff = 0;
    let currentOffset = 0;
    if (options.textAlign === 'center') {
      xDiff = commonWidth / 2;
    }
    if (options.textAlign === 'end') {
      xDiff = commonWidth;
    }
    line.options.forEach(function (o, index) {
      const width = line.widths[index];
      o.x = o.x - xDiff + currentOffset;
      o.y += line.offsets[index];
      currentOffset += width;
    });
    line.elements.forEach(function (element, index) {
      drawTextElement(element.childNodes, context, line.options[index], shared);
    });
  });
}
function drawElement(element, context, parentOptions, shared) {
  const tagName = element.tagName;
  const isText = tagName === 'text' || tagName === 'tspan' || tagName === undefined;
  const isImage = tagName === 'image';
  const isComment = element.nodeType === 8;
  const options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));
  if (options.visibility === 'hidden' || options[_svg.HIDDEN_FOR_EXPORT] || isComment) {
    return;
  }
  context.save();
  !isImage && transformElement(context, options);
  clipElement(context, options, shared);
  aggregateOpacity(options);
  let promise;
  context.beginPath();
  switch (element.tagName) {
    case undefined:
      drawText(context, options, shared);
      break;
    case 'text':
    case 'tspan':
      drawTextElement(element.childNodes, context, options, shared);
      break;
    case 'image':
      promise = drawImage(context, options, shared);
      break;
    case 'path':
      drawPath(context, options.d);
      break;
    case 'rect':
      drawRect(context, options);
      context.closePath(); // for valid clipping
      break;
    case 'circle':
      context.arc(options.cx, options.cy, options.r, 0, 2 * PI, 1);
      break;
  }
  if (!isText) {
    applyFilter(context, options, shared);
    if (!isImage) {
      promise = fillElement(context, options, shared);
    }
    strokeElement(context, options);
  }
  applyGradient(context, options, shared, element, 'linear');
  applyGradient(context, options, shared, element, 'radial');
  context.restore();
  return promise;
}
function applyGradient(context, options, _ref, element, type) {
  let {
    linearGradients,
    radialGradients
  } = _ref;
  const gradients = type === 'linear' ? linearGradients : radialGradients;
  if (Object.keys(gradients).length === 0) {
    return;
  }
  const id = parseUrl(options.fill);
  if (id && gradients[id]) {
    const box = element.getBBox();
    const horizontalCenter = box.x + box.width / 2;
    const verticalCenter = box.y + box.height / 2;
    const maxRadius = Math.max(box.height / 2, box.width / 2);
    const gradient = type === 'linear' ? context.createLinearGradient(box.x, 0, box.x + box.width, 0) : context.createRadialGradient(horizontalCenter, verticalCenter, 0, horizontalCenter, verticalCenter, maxRadius);
    gradients[id].colors.forEach(opt => {
      const offset = parseInt(opt.offset.replace(/%/, ''));
      gradient.addColorStop(offset / 100, opt.stopColor);
    });
    if (type === 'linear') {
      var _gradients$id$transfo;
      const angle = ((_gradients$id$transfo = gradients[id].transform) === null || _gradients$id$transfo === void 0 ? void 0 : _gradients$id$transfo.replace(/\D/g, '')) * Math.PI / 180 ?? 0;
      context.translate(horizontalCenter, verticalCenter);
      context.rotate(angle);
      context.translate(-horizontalCenter, -verticalCenter);
    }
    context.globalAlpha = options.opacity;
    context.fillStyle = gradient;
    context.fill();
  }
}
function applyFilter(context, options, shared) {
  let filterOptions;
  const id = parseUrl(options.filter);
  if (id) {
    filterOptions = shared.filters[id];
    if (!filterOptions) {
      filterOptions = {
        offsetX: 0,
        offsetY: 0,
        blur: 0,
        color: '#000'
      };
    }
    context.shadowOffsetX = filterOptions.offsetX;
    context.shadowOffsetY = filterOptions.offsetY;
    context.shadowColor = filterOptions.color;
    context.shadowBlur = filterOptions.blur;
  }
}

// translate and clip are the special attributtes, they should not be inherited by child nodes
function transformElement(context, options) {
  context.translate(options.translateX || 0, options.translateY || 0);
  options.translateX = undefined;
  options.translateY = undefined;
  if (options.rotationAngle) {
    context.translate(options.rotationX || 0, options.rotationY || 0);
    context.rotate(options.rotationAngle * PI / 180);
    context.translate(-(options.rotationX || 0), -(options.rotationY || 0));
    options.rotationAngle = undefined;
    options.rotationX = undefined;
    options.rotationY = undefined;
  }
  if (isFinite(options.scaleX)) {
    context.scale(options.scaleX, options.scaleY);
    options.scaleX = undefined;
    options.scaleY = undefined;
  }
}
function clipElement(context, options, shared) {
  if (options['clip-path']) {
    drawElement(shared.clipPaths[parseUrl(options['clip-path'])], context, {}, shared);
    context.clip();
    options['clip-path'] = undefined;
  }
}
function hex2rgba(hexColor, alpha) {
  const color = new _color.default(hexColor);
  return 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + alpha + ')';
}
function createGradient(element) {
  var _element$attributes$g;
  const options = {
    colors: [],
    transform: (_element$attributes$g = element.attributes.gradientTransform) === null || _element$attributes$g === void 0 ? void 0 : _element$attributes$g.textContent
  };
  (0, _iterator.each)(element.childNodes, (_, _ref2) => {
    let {
      attributes
    } = _ref2;
    options.colors.push({
      offset: attributes.offset.value,
      stopColor: attributes['stop-color'].value
    });
  });
  return options;
}
function createFilter(element) {
  let color;
  let opacity;
  const filterOptions = {};
  (0, _iterator.each)(element.childNodes, function (_, node) {
    const attr = node.attributes;
    if (!attr.result) {
      return;
    }
    switch (attr.result.value) {
      case 'gaussianBlurResult':
        filterOptions.blur = _number(attr.stdDeviation.value);
        break;
      case 'offsetResult':
        filterOptions.offsetX = _number(attr.dx.value);
        filterOptions.offsetY = _number(attr.dy.value);
        break;
      case 'floodResult':
        color = attr['flood-color'] ? attr['flood-color'].value : '#000';
        opacity = attr['flood-opacity'] ? attr['flood-opacity'].value : 1;
        filterOptions.color = hex2rgba(color, opacity);
        break;
    }
  });
  return filterOptions;
}
function asyncEach(array, callback) {
  let d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _deferred.Deferred();
  let i = 0;
  for (; i < array.length; i++) {
    const result = callback(array[i]);
    if ((0, _type.isPromise)(result)) {
      result.then(() => {
        asyncEach(Array.prototype.slice.call(array, i + 1), callback, d);
      });
      break;
    }
  }
  if (i === array.length) {
    d.resolve();
  }
  return d;
}
function drawCanvasElements(elements, context, parentOptions, shared) {
  return asyncEach(elements, function (element) {
    switch (element.tagName && element.tagName.toLowerCase()) {
      case 'g':
      case 'svg':
        {
          const options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));
          context.save();
          transformElement(context, options);
          clipElement(context, options, shared);
          const onDone = () => {
            context.restore();
          };
          const promise = drawCanvasElements(element.childNodes, context, options, shared);
          if ((0, _type.isPromise)(promise)) {
            promise.then(onDone);
          } else {
            onDone();
          }
          return promise;
        }
      case 'defs':
        return drawCanvasElements(element.childNodes, context, {}, shared);
      case 'clippath':
        shared.clipPaths[element.attributes.id.textContent] = element.childNodes[0];
        break;
      case 'pattern':
        shared.patterns[element.attributes.id.textContent] = element;
        break;
      case 'filter':
        shared.filters[element.id] = createFilter(element);
        break;
      case 'lineargradient':
        shared.linearGradients[element.attributes.id.textContent] = createGradient(element);
        break;
      case 'radialgradient':
        shared.radialGradients[element.attributes.id.textContent] = createGradient(element);
        break;
      default:
        return drawElement(element, context, parentOptions, shared);
    }
  });
}
function setLineDash(context, options) {
  let matches = options['stroke-dasharray'] && options['stroke-dasharray'].match(/(\d+)/g);
  if (matches && matches.length) {
    matches = (0, _iterator.map)(matches, function (item) {
      return _number(item);
    });
    context.setLineDash(matches);
  }
}
function strokeElement(context, options, isText) {
  const stroke = options.stroke;
  if (stroke && stroke !== 'none' && options['stroke-width'] !== 0) {
    setLineDash(context, options);
    context.lineJoin = options['stroke-linejoin'];
    context.lineWidth = options['stroke-width'];
    context.globalAlpha = options.strokeOpacity;
    context.strokeStyle = stroke;
    isText ? context.strokeText(options.text, options.x, options.y) : context.stroke();
    context.globalAlpha = 1;
  }
}
function getPattern(context, pattern, shared, parentOptions) {
  const options = getElementOptions(pattern, shared.rootAppended);
  const patternCanvas = imageCreator._createCanvas(options.width, options.height, 0);
  const patternContext = patternCanvas.getContext('2d');
  const promise = drawCanvasElements(pattern.childNodes, patternContext, options, shared);
  const onDone = () => {
    context.fillStyle = context.createPattern(patternCanvas, 'repeat');
    context.globalAlpha = parentOptions.fillOpacity;
    context.fill();
    context.globalAlpha = 1;
  };
  if ((0, _type.isPromise)(promise)) {
    promise.then(onDone);
  } else {
    onDone();
  }
  return promise;
}
function fillElement(context, options, shared) {
  const fill = options.fill;
  let promise;
  if (fill && fill !== 'none') {
    if (fill.search(/url/) === -1) {
      context.fillStyle = fill;
      context.globalAlpha = options.fillOpacity;
      context.fill();
      context.globalAlpha = 1;
    } else {
      const pattern = shared.patterns[parseUrl(fill)];
      if (!pattern) {
        return;
      }
      promise = getPattern(context, pattern, shared, options);
    }
  }
  return promise;
}
parseAttributes = function (attributes) {
  const newAttributes = {};
  let attr;
  (0, _iterator.each)(attributes, function (index, item) {
    attr = item.textContent;
    if (isFinite(attr)) {
      attr = _number(attr);
    }
    newAttributes[item.name.toLowerCase()] = attr; // lowerCase for Edge
  });
  return newAttributes;
};
function drawBackground(context, width, height, backgroundColor, margin) {
  context.fillStyle = backgroundColor || '#ffffff';
  context.fillRect(-margin, -margin, width + margin * 2, height + margin * 2);
}
function createInvisibleDiv() {
  const invisibleDiv = _dom_adapter.default.createElement('div');
  invisibleDiv.style.left = '-9999px';
  invisibleDiv.style.position = 'absolute';
  return invisibleDiv;
}
function convertSvgToCanvas(svg, canvas, rootAppended) {
  return drawCanvasElements(svg.childNodes, canvas.getContext('2d'), {}, {
    clipPaths: {},
    patterns: {},
    filters: {},
    linearGradients: {},
    radialGradients: {},
    rootAppended
  });
}
function getCanvasFromSvg(markup, _ref3) {
  let {
    width,
    height,
    backgroundColor,
    margin,
    svgToCanvas = convertSvgToCanvas
  } = _ref3;
  const scaledScreenInfo = calcScaledInfo(width, height);
  const canvas = imageCreator._createCanvas(scaledScreenInfo.width, scaledScreenInfo.height, margin);
  const context = canvas.getContext('2d');
  context.setTransform(scaledScreenInfo.pixelRatio, 0, 0, scaledScreenInfo.pixelRatio, 0, 0);
  const svgElem = (0, _svg.getSvgElement)(markup);
  let invisibleDiv;
  const markupIsDomElement = _dom_adapter.default.isElementNode(markup) || (0, _type.isRenderer)(markup);
  context.translate(margin, margin);
  _dom_adapter.default.getBody().appendChild(canvas);
  if (!markupIsDomElement) {
    invisibleDiv = createInvisibleDiv();
    invisibleDiv.appendChild(svgElem);
    _dom_adapter.default.getBody().appendChild(invisibleDiv);
  }
  // for rtl mode
  if (svgElem.attributes.direction) {
    canvas.dir = svgElem.attributes.direction.textContent;
  }
  drawBackground(context, width, height, backgroundColor, margin);
  return (0, _deferred.fromPromise)(svgToCanvas(svgElem, canvas, markupIsDomElement && (0, _dom.contains)(_dom_adapter.default.getBody(), (0, _renderer.default)(markup).get(0)))).then(() => canvas).always(() => {
    invisibleDiv && _dom_adapter.default.getBody().removeChild(invisibleDiv);
    _dom_adapter.default.getBody().removeChild(canvas);
  });
}
const imageCreator = exports.imageCreator = {
  getImageData: function (markup, options) {
    const mimeType = 'image/' + options.format;
    // Injection for testing T403049
    if ((0, _type.isFunction)(options.__parseAttributesFn)) {
      parseAttributes = options.__parseAttributesFn;
    }
    return getCanvasFromSvg(markup, options).then(canvas => getStringFromCanvas(canvas, mimeType));
  },
  getData: function (markup, options) {
    const that = this;
    return imageCreator.getImageData(markup, options).then(binaryData => {
      const mimeType = 'image/' + options.format;
      const data = (0, _type.isFunction)(window.Blob) && !options.useBase64 ? that._getBlob(binaryData, mimeType) : that._getBase64(binaryData);
      return data;
    });
  },
  _getBlob: function (binaryData, mimeType) {
    let i;
    const dataArray = new Uint8Array(binaryData.length);
    for (i = 0; i < binaryData.length; i++) {
      dataArray[i] = binaryData.charCodeAt(i);
    }
    return new window.Blob([dataArray.buffer], {
      type: mimeType
    });
  },
  _getBase64: function (binaryData) {
    return window.btoa(binaryData);
  },
  _createCanvas(width, height, margin) {
    const canvas = (0, _renderer.default)('<canvas>')[0];
    canvas.width = width + margin * 2;
    canvas.height = height + margin * 2;
    canvas.hidden = true;
    return canvas;
  }
};
function getData(data, options) {
  return imageCreator.getData(data, options);
}
function testFormats(formats) {
  const canvas = imageCreator._createCanvas(100, 100, 0);
  return formats.reduce(function (r, f) {
    const mimeType = ('image/' + f).toLowerCase();
    if (canvas.toDataURL(mimeType).indexOf(mimeType) !== -1) {
      r.supported.push(f);
    } else {
      r.unsupported.push(f);
    }
    return r;
  }, {
    supported: [],
    unsupported: []
  });
}
function calcScaledInfo(width, height) {
  const pixelRatio = window.devicePixelRatio || 1;
  return {
    pixelRatio,
    width: width * pixelRatio,
    height: height * pixelRatio
  };
}

/***/ }),

/***/ 18577:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Export = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _date = _interopRequireDefault(__webpack_require__(91500));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _message = _interopRequireDefault(__webpack_require__(28109));
var _export_load_panel = __webpack_require__(5332);
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const Export = exports.Export = {
  getFullOptions: function (options) {
    const fullOptions = (0, _extend.extend)({}, options);
    if (!((0, _type.isDefined)(fullOptions.jsPDFDocument) && (0, _type.isObject)(fullOptions.jsPDFDocument))) {
      throw Error('The "jsPDFDocument" field must contain a jsPDF instance.');
    }
    if (!((0, _type.isDefined)(fullOptions.jsPDFDocument.autoTable) && (0, _type.isFunction)(fullOptions.jsPDFDocument.autoTable))) {
      throw Error('The "exportDataGrid" method requires a autoTable plugin for jsPDF object.');
    }
    if (!(0, _type.isDefined)(fullOptions.keepColumnWidths)) {
      fullOptions.keepColumnWidths = true;
    }
    if (!(0, _type.isDefined)(fullOptions.autoTableOptions)) {
      fullOptions.autoTableOptions = this._getDefaultAutoTableOptions();
    } else {
      if (!(0, _type.isObject)(fullOptions.autoTableOptions)) {
        throw Error('The "autoTableOptions" option must be of object type.');
      }
      fullOptions.autoTableOptions = (0, _extend.extend)(true, {}, this._getDefaultAutoTableOptions(), fullOptions.autoTableOptions);
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
      fullOptions.loadPanel = {};
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
      fullOptions.loadPanel.enabled = true;
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel.text)) {
      fullOptions.loadPanel.text = _message.default.format('dxDataGrid-exporting');
    }
    return fullOptions;
  },
  _getDefaultAutoTableOptions: function () {
    return {
      theme: 'plain',
      tableLineColor: 149,
      tableLineWidth: 0.1,
      styles: {
        textColor: 51,
        lineColor: 149,
        lineWidth: 0
      },
      columnStyles: {},
      headStyles: {
        fontStyle: 'normal',
        textColor: 149,
        lineWidth: 0.1
      },
      bodyStyles: {
        lineWidth: 0.1
      },
      head: [],
      body: []
    };
  },
  export: function (options) {
    var _component$_getIntern;
    const {
      jsPDFDocument,
      autoTableOptions,
      component,
      customizeCell,
      keepColumnWidths,
      selectedRowsOnly,
      loadPanel
    } = options;
    const internalComponent = ((_component$_getIntern = component._getInternalInstance) === null || _component$_getIntern === void 0 ? void 0 : _component$_getIntern.call(component)) || component;
    const initialLoadPanelEnabledOption = internalComponent.option('loadPanel') && internalComponent.option('loadPanel').enabled;
    if (initialLoadPanelEnabledOption) {
      component.option('loadPanel.enabled', false);
    }
    let exportLoadPanel;
    if (loadPanel.enabled && (0, _window.hasWindow)()) {
      const rowsView = component.getView('rowsView');
      exportLoadPanel = new _export_load_panel.ExportLoadPanel(component, rowsView.element(), rowsView.element().parent(), loadPanel);
      exportLoadPanel.show();
    }
    const dataProvider = component.getDataProvider(selectedRowsOnly);
    const wrapText = !!component.option('wordWrapEnabled');
    return new Promise(resolve => {
      dataProvider.ready().done(() => {
        const columns = dataProvider.getColumns();
        const styles = dataProvider.getStyles();
        const dataRowsCount = dataProvider.getRowsCount();
        const headerRowCount = dataProvider.getHeaderRowCount();
        const mergedCells = [];
        if (keepColumnWidths) {
          const pdfColumnWidths = this._tryGetPdfColumnWidths(autoTableOptions.tableWidth, dataProvider.getColumnsWidths());
          if ((0, _type.isDefined)(pdfColumnWidths) && (0, _type.isDefined)(autoTableOptions.columnStyles)) {
            this._setColumnWidths(autoTableOptions.columnStyles, pdfColumnWidths);
          }
        }
        for (let rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {
          const row = [];
          for (let cellIndex = 0; cellIndex < columns.length; cellIndex++) {
            const {
              value,
              cellSourceData: gridCell
            } = dataProvider.getCellData(rowIndex, cellIndex, true);
            const cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];
            const pdfCell = {
              content: this._getFormattedValue(value, cellStyle.format),
              styles: this._getPDFCellStyles(gridCell.rowType, columns[cellIndex].alignment, cellStyle, wrapText)
            };
            if (gridCell.rowType === 'header') {
              const mergedRange = this._tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider);
              if (mergedRange && mergedRange.rowSpan > 0) {
                pdfCell.rowSpan = mergedRange.rowSpan + 1;
              }
              if (mergedRange && mergedRange.colSpan > 0) {
                pdfCell.colSpan = mergedRange.colSpan + 1;
              }
              const isMergedCell = mergedCells[rowIndex] && mergedCells[rowIndex][cellIndex];
              if (!isMergedCell || pdfCell.rowSpan > 1 || pdfCell.colSpan > 1) {
                if ((0, _type.isFunction)(customizeCell)) {
                  customizeCell({
                    gridCell,
                    pdfCell
                  });
                }
                row.push(pdfCell);
              }
            } else if (gridCell.rowType === 'group' && !(0, _type.isDefined)(pdfCell.content) && row.length === 1) {
              row[0].colSpan = row[0].colSpan ?? 1;
              row[0].colSpan++;
            } else {
              pdfCell.content = pdfCell.content ?? '';
              if ((0, _type.isFunction)(customizeCell)) {
                customizeCell({
                  gridCell,
                  pdfCell
                });
              }
              row.push(pdfCell);
            }
          }
          if (rowIndex < headerRowCount) {
            autoTableOptions.head.push(row);
          } else {
            autoTableOptions.body.push(row);
          }
        }
        jsPDFDocument.autoTable(autoTableOptions);
        resolve();
      }).always(() => {
        if (initialLoadPanelEnabledOption) {
          component.option('loadPanel.enabled', initialLoadPanelEnabledOption);
        }
        if (loadPanel.enabled && (0, _window.hasWindow)()) {
          exportLoadPanel.dispose();
        }
      });
    });
  },
  _getFormattedValue: function (value, format) {
    if ((0, _type.isDefined)(format)) {
      if ((0, _type.isDate)(value)) {
        return _date.default.format(value, format);
      }
      if ((0, _type.isNumeric)(value)) {
        return _number.default.format(value, format);
      }
    }
    return value;
  },
  _getPDFCellStyles: function (rowType, columnAlignment, cellStyle, wrapText) {
    const {
      alignment: cellAlignment,
      bold
    } = cellStyle;
    const align = rowType === 'header' ? columnAlignment : cellAlignment;
    const pdfCellStyle = {};
    if (align) {
      pdfCellStyle['halign'] = align;
    }
    if (bold && rowType !== 'header') {
      pdfCellStyle.fontStyle = 'bold';
    }
    if (wrapText) {
      pdfCellStyle.cellWidth = 'wrap';
    }
    return pdfCellStyle;
  },
  _tryGetMergeRange: function (rowIndex, cellIndex, mergedCells, dataProvider) {
    if (!mergedCells[rowIndex] || !mergedCells[rowIndex][cellIndex]) {
      const {
        colspan,
        rowspan
      } = dataProvider.getCellMerging(rowIndex, cellIndex);
      if (colspan || rowspan) {
        for (let i = rowIndex; i <= rowIndex + rowspan || 0; i++) {
          for (let j = cellIndex; j <= cellIndex + colspan || 0; j++) {
            if (!mergedCells[i]) {
              mergedCells[i] = [];
            }
            mergedCells[i][j] = true;
          }
        }
        return {
          rowSpan: rowspan,
          colSpan: colspan
        };
      }
    }
  },
  _tryGetPdfColumnWidths(autoTableWidth, columnWidths) {
    if ((0, _type.isNumeric)(autoTableWidth) && (0, _type.isDefined)(columnWidths)) {
      const tableWidth = columnWidths.reduce((a, b) => a + b, 0);
      return columnWidths.map(columnWidth => autoTableWidth * columnWidth / tableWidth);
    }
  },
  _setColumnWidths: function (autoTableColumnStyles, pdfColumnWidths) {
    pdfColumnWidths.forEach((width, index) => {
      autoTableColumnStyles[index] = autoTableColumnStyles[index] || {};
      autoTableColumnStyles[index].cellWidth = width;
    });
  }
};

/***/ }),

/***/ 83152:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.exportDataGrid = exportDataGrid;
var _type = __webpack_require__(35922);
var _export = __webpack_require__(18577);
function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportDataGrid" method requires a configuration object.');
  }
  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxDataGrid')) {
    throw Error('The "component" field must contain a DataGrid instance.');
  }
  if (!(0, _type.isDefined)(options.selectedRowsOnly)) {
    options.selectedRowsOnly = false;
  }
  return _export.Export.getFullOptions(options);
}
function exportDataGrid(options) {
  return _export.Export.export(_getFullOptions(options));
}

/***/ }),

/***/ 66867:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addNewPage = addNewPage;
exports.drawCellsContent = drawCellsContent;
exports.drawCellsLines = drawCellsLines;
exports.drawGridLines = drawGridLines;
exports.drawLine = drawLine;
exports.drawRect = drawRect;
exports.drawTextInRect = drawTextInRect;
exports.getDocumentStyles = getDocumentStyles;
exports.roundToThreeDecimals = roundToThreeDecimals;
exports.setDocumentStyles = setDocumentStyles;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _pdf_utils = __webpack_require__(79262);
const _excluded = ["_rect", "gridCell"];
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function roundToThreeDecimals(value) {
  return Math.round(value * 1000) / 1000; // checked with browser zoom - 500%
}
function drawCellsContent(doc, customDrawCell, cellsArray, docStyles) {
  cellsArray.forEach(cell => {
    const {
        _rect,
        gridCell
      } = cell,
      pdfCell = _objectWithoutPropertiesLoose(cell, _excluded);
    const {
      x,
      y,
      w,
      h
    } = _rect;
    const rect = {
      x,
      y,
      w,
      h
    };
    const eventArg = {
      doc,
      rect,
      pdfCell,
      gridCell,
      cancel: false
    };
    customDrawCell === null || customDrawCell === void 0 || customDrawCell(eventArg);
    if (!eventArg.cancel) {
      drawCellBackground(doc, cell);
      drawCellText(doc, cell, docStyles);
    }
  });
}
function drawLine(doc, startX, startY, endX, endY) {
  doc.line(roundToThreeDecimals(startX), roundToThreeDecimals(startY), roundToThreeDecimals(endX), roundToThreeDecimals(endY));
}
function drawRect(doc, x, y, width, height, style) {
  if ((0, _type.isDefined)(style)) {
    doc.rect(roundToThreeDecimals(x), roundToThreeDecimals(y), roundToThreeDecimals(width), roundToThreeDecimals(height), style);
  } else {
    doc.rect(roundToThreeDecimals(x), roundToThreeDecimals(y), roundToThreeDecimals(width), roundToThreeDecimals(height));
  }
}
function getLineHeightShift(doc) {
  const DEFAULT_LINE_HEIGHT = 1.15;

  // TODO: check lineHeightFactor from text options. Currently supports only doc options - https://github.com/MrRio/jsPDF/issues/3234
  return (doc.getLineHeightFactor() - DEFAULT_LINE_HEIGHT) * doc.getFontSize();
}
function drawTextInRect(doc, text, rect, verticalAlign, horizontalAlign, jsPDFTextOptions) {
  const textArray = text.split('\n');
  const linesCount = textArray.length;
  const heightOfOneLine = (0, _pdf_utils.calculateTextHeight)(doc, textArray[0], doc.getFont(), {
    wordWrapEnabled: false,
    targetRectWidth: 1000000000
  });
  const vAlign = verticalAlign ?? 'middle';
  const hAlign = horizontalAlign ?? 'left';
  const verticalAlignCoefficientsMap = {
    top: 0,
    middle: 0.5,
    bottom: 1
  };
  const horizontalAlignMap = {
    left: 0,
    center: 0.5,
    right: 1
  };
  const y = rect.y + rect.h * verticalAlignCoefficientsMap[vAlign] - heightOfOneLine * (linesCount - 1) * verticalAlignCoefficientsMap[vAlign] + getLineHeightShift(doc);
  const x = rect.x + rect.w * horizontalAlignMap[hAlign];
  const textOptions = (0, _extend.extend)({
    baseline: vAlign,
    align: hAlign
  }, jsPDFTextOptions);
  doc.text(textArray.join('\n'), roundToThreeDecimals(x), roundToThreeDecimals(y), textOptions);
}
function drawCellBackground(doc, cell) {
  if ((0, _type.isDefined)(cell.backgroundColor)) {
    trySetColor(doc, 'fill', cell.backgroundColor);
    drawRect(doc, cell._rect.x, cell._rect.y, cell._rect.w, cell._rect.h, 'F');
  }
}
function drawCellText(doc, cell, docStyles) {
  if ((0, _type.isDefined)(cell.text) && cell.text !== '') {
    // TODO: use cell.text.trim() ?
    const {
      textColor,
      font,
      _rect,
      padding
    } = cell;
    setTextStyles(doc, {
      textColor,
      font
    }, docStyles);
    const textRect = {
      x: _rect.x + padding.left,
      y: _rect.y + padding.top,
      w: _rect.w - (padding.left + padding.right),
      h: _rect.h - (padding.top + padding.bottom)
    };
    if ((0, _type.isDefined)(cell._textLeftOffset) || (0, _type.isDefined)(cell._textTopOffset)) {
      textRect.x = textRect.x + (cell._textLeftOffset ?? 0);
      textRect.y = textRect.y + (cell._textTopOffset ?? 0);
      doc.saveGraphicsState(); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#saveGraphicsState
      clipOutsideRectContent(doc, cell._rect.x, cell._rect.y, cell._rect.w, cell._rect.h);
    }
    drawTextInRect(doc, cell.text, textRect, cell.verticalAlign, cell.horizontalAlign, cell._internalTextOptions);
    if ((0, _type.isDefined)(cell._textLeftOffset) || (0, _type.isDefined)(cell._textTopOffset)) {
      doc.restoreGraphicsState(); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#restoreGraphicsState
    }
  }
}
function drawCellsLines(doc, cellsArray, docStyles) {
  cellsArray.filter(cell => !(0, _type.isDefined)(cell.borderColor)).forEach(cell => {
    drawBorders(doc, cell._rect, cell, docStyles);
  });
  cellsArray.filter(cell => (0, _type.isDefined)(cell.borderColor)).forEach(cell => {
    drawBorders(doc, cell._rect, cell, docStyles);
  });
}
function drawGridLines(doc, rect, options, docStyles) {
  drawBorders(doc, rect, options, docStyles);
}
function drawBorders(doc, rect, _ref, docStyles) {
  let {
    borderWidth,
    borderColor,
    drawLeftBorder = true,
    drawRightBorder = true,
    drawTopBorder = true,
    drawBottomBorder = true
  } = _ref;
  if (!(0, _type.isDefined)(rect)) {
    throw 'rect is required';
  }
  if (!drawLeftBorder && !drawRightBorder && !drawTopBorder && !drawBottomBorder) {
    return;
  } else if (drawLeftBorder && drawRightBorder && drawTopBorder && drawBottomBorder) {
    setLinesStyles(doc, {
      borderWidth,
      borderColor
    }, docStyles);
    drawRect(doc, rect.x, rect.y, rect.w, rect.h);
  } else {
    setLinesStyles(doc, {
      borderWidth,
      borderColor
    }, docStyles);
    if (drawTopBorder) {
      drawLine(doc, rect.x, rect.y, rect.x + rect.w, rect.y); // top
    }
    if (drawLeftBorder) {
      drawLine(doc, rect.x, rect.y, rect.x, rect.y + rect.h); // left
    }
    if (drawRightBorder) {
      drawLine(doc, rect.x + rect.w, rect.y, rect.x + rect.w, rect.y + rect.h); // right
    }
    if (drawBottomBorder) {
      drawLine(doc, rect.x, rect.y + rect.h, rect.x + rect.w, rect.y + rect.h); // bottom
    }
  }
}
function setTextStyles(doc, _ref2, docStyles) {
  let {
    textColor,
    font
  } = _ref2;
  trySetColor(doc, 'text', (0, _type.isDefined)(textColor) ? textColor : docStyles.textColor);
  const currentFont = (0, _type.isDefined)(font) ? (0, _extend.extend)({}, docStyles.font, font) : docStyles.font;
  const docFont = doc.getFont();
  if (currentFont.name !== docFont.fontName || currentFont.style !== docFont.fontStyle || (0, _type.isDefined)(currentFont.weight) // fontWeight logic, https://raw.githack.com/MrRio/jsPDF/master/docs/jspdf.js.html#line4842
  ) {
    doc.setFont(currentFont.name, currentFont.style, currentFont.weight);
  }
  if (currentFont.size !== doc.getFontSize()) {
    doc.setFontSize(currentFont.size);
  }
}
function setLinesStyles(doc, _ref3, docStyles) {
  let {
    borderWidth,
    borderColor
  } = _ref3;
  const currentBorderWidth = (0, _type.isDefined)(borderWidth) ? borderWidth : docStyles.borderWidth;
  if (currentBorderWidth !== getDocBorderWidth(doc)) {
    setDocBorderWidth(doc, (0, _pdf_utils.toPdfUnit)(doc, currentBorderWidth));
  }
  trySetColor(doc, 'draw', (0, _type.isDefined)(borderColor) ? borderColor : docStyles.borderColor);
}
function trySetColor(doc, target, color) {
  const getterName = `get${capitalizeFirstLetter(target)}Color`;
  const setterName = `set${capitalizeFirstLetter(target)}Color`;
  const {
    ch1 = color,
    ch2,
    ch3,
    ch4
  } = color;
  const normalizedColor = doc.__private__.decodeColorString(doc.__private__.encodeColorString({
    ch1,
    ch2,
    ch3,
    ch4,
    precision: target === 'text' ? 3 : 2
  }));
  if (normalizedColor !== doc[getterName]() || target === 'fill') {
    doc[setterName].apply(doc, [ch1, ch2, ch3, ch4].filter(item => item !== undefined));
  }
}
function getDocumentStyles(doc) {
  const docFont = doc.getFont();
  return {
    borderWidth: getDocBorderWidth(doc),
    borderColor: doc.getDrawColor(),
    font: {
      name: docFont.fontName,
      style: docFont.fontStyle,
      size: doc.getFontSize()
    },
    textColor: doc.getTextColor()
  };
}
function setDocumentStyles(doc, styles) {
  const {
    borderWidth,
    borderColor,
    font,
    textColor
  } = styles;
  const docFont = doc.getFont();
  if (docFont.fontName !== font.name || docFont.fontStyle !== font.style) {
    doc.setFont(font.name, font.style, undefined);
  }
  const docFontSize = doc.getFontSize();
  if (docFontSize !== font.size) {
    doc.setFontSize(font.size);
  }
  if (getDocBorderWidth(doc) !== borderWidth) {
    setDocBorderWidth(doc, borderWidth);
  }
  if (doc.getDrawColor() !== borderColor) {
    doc.setDrawColor(borderColor);
  }
  if (doc.getTextColor() !== textColor) {
    doc.setTextColor(textColor);
  }
}
function addNewPage(doc) {
  doc.addPage();
  resetDocBorderWidth(doc);
}
function getDocBorderWidth(doc) {
  // The 'getLineWidth' method was implemented in 2.5.0 version - https://github.com/parallax/jsPDF/pull/3324
  if ((0, _type.isDefined)(doc.getLineWidth)) {
    return doc.getLineWidth();
  }
  return doc.__borderWidth ?? 0.200025; // // https://github.com/parallax/jsPDF/blob/a56c882e2c139e74a9adaea0baa78fb1386cbf23/src/jspdf.js#L4946
}
function setDocBorderWidth(doc, width) {
  doc.setLineWidth(width);

  // The 'getLineWidth' method was implemented in 2.5.0 version - https://github.com/parallax/jsPDF/pull/3324
  if (!(0, _type.isDefined)(doc.getLineWidth)) {
    doc.__borderWidth = width;
  }
}
function resetDocBorderWidth(doc) {
  if (!(0, _type.isDefined)(doc.getLineWidth)) {
    doc.__borderWidth = null;
  }
}
function clipOutsideRectContent(doc, x, y, w, h) {
  doc.moveTo(roundToThreeDecimals(x), roundToThreeDecimals(y)); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#moveTo - Begin a new subpath by moving the current point to coordinates (x, y)
  doc.lineTo(roundToThreeDecimals(x + w), roundToThreeDecimals(y)); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#lineTo - Append a straight line segment from the current point to the point (x, y)
  doc.lineTo(roundToThreeDecimals(x + w), roundToThreeDecimals(y + h));
  doc.lineTo(roundToThreeDecimals(x), roundToThreeDecimals(y + h));
  doc.clip(); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#clip - Clip all outside path content after calling drawing ops
  doc.discardPath(); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#discardPath - Consumes the current path without any effect. Mainly used in combination with clip or clipEvenOdd.
}

/***/ }),

/***/ 17195:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Export = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _normalizeOptions = __webpack_require__(30646);
var _row_utils = __webpack_require__(65322);
var _height_updater = __webpack_require__(41269);
var _rows_generator = __webpack_require__(27504);
var _rows_splitting = __webpack_require__(22775);
var _draw_utils = __webpack_require__(66867);
var _pdf_utils = __webpack_require__(79262);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _export_load_panel = __webpack_require__(5332);
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getFullOptions(options) {
  const {
    jsPDFDocument
  } = options;
  const fullOptions = (0, _extend.extend)({}, options);
  if (!(0, _type.isDefined)(fullOptions.topLeft)) {
    fullOptions.topLeft = {
      x: 0,
      y: 0
    };
  }
  if (!(0, _type.isDefined)(fullOptions.indent)) {
    fullOptions.indent = 0;
  }
  if (!(0, _type.isDefined)(fullOptions.repeatHeaders)) {
    fullOptions.repeatHeaders = true;
  }
  if (!(0, _type.isDefined)(fullOptions.margin)) {
    fullOptions.margin = (0, _pdf_utils.toPdfUnit)(jsPDFDocument, 40);
  }
  fullOptions.margin = (0, _normalizeOptions.normalizeBoundaryValue)(fullOptions.margin);
  if (!Array.isArray(fullOptions.columnWidths)) {
    fullOptions.columnWidths = [];
  }
  if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
    fullOptions.loadPanel = {};
  }
  if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
    fullOptions.loadPanel.enabled = true;
  }
  if (!(0, _type.isDefined)(fullOptions.loadPanel.text)) {
    fullOptions.loadPanel.text = _message.default.format('dxDataGrid-exporting');
  }
  return fullOptions;
}
function exportDataGrid(options) {
  var _component$_getIntern;
  const {
    jsPDFDocument,
    component,
    selectedRowsOnly,
    loadPanel
  } = options;
  const internalComponent = ((_component$_getIntern = component._getInternalInstance) === null || _component$_getIntern === void 0 ? void 0 : _component$_getIntern.call(component)) || component;
  const initialLoadPanelEnabledOption = internalComponent.option('loadPanel') && internalComponent.option('loadPanel').enabled;
  if (initialLoadPanelEnabledOption) {
    component.option('loadPanel.enabled', false);
  }
  let exportLoadPanel;
  if (loadPanel.enabled && (0, _window.hasWindow)()) {
    const rowsView = component.getView('rowsView');
    exportLoadPanel = new _export_load_panel.ExportLoadPanel(component, rowsView.element(), rowsView.element().parent(), loadPanel);
    exportLoadPanel.show();
  }
  const dataProvider = component.getDataProvider(selectedRowsOnly);
  return new Promise(resolve => {
    dataProvider.ready().done(() => {
      var _options$rowOptions;
      // TODO: pass rowOptions: { headerStyles: { backgroundColor }, groupStyles: {...}, totalStyles: {...} }
      const rowsInfo = (0, _rows_generator.generateRowsInfo)(jsPDFDocument, dataProvider, component, (_options$rowOptions = options.rowOptions) === null || _options$rowOptions === void 0 || (_options$rowOptions = _options$rowOptions.headerStyles) === null || _options$rowOptions === void 0 ? void 0 : _options$rowOptions.backgroundColor);
      if (options.customizeCell) {
        rowsInfo.forEach(rowInfo => rowInfo.cells.forEach(cellInfo => options.customizeCell(cellInfo)));
      }
      (0, _normalizeOptions.normalizeRowsInfo)(rowsInfo);

      // computes withs of the cells depending of the fullOptions
      (0, _row_utils.initializeCellsWidth)(jsPDFDocument, dataProvider, rowsInfo, options);

      // apply intends for correctly set width and colSpan for grouped rows
      (0, _row_utils.resizeFirstColumnByIndentLevel)(rowsInfo, options);

      // apply colSpans + recalculate cellsWidth
      (0, _row_utils.applyColSpans)(rowsInfo);

      // set/update/initCellHeight - autocalculate by text+width+wordWrapEnabled+padding or use value from customizeCell
      (0, _row_utils.calculateHeights)(jsPDFDocument, rowsInfo, options);

      // apply rowSpans + recalculate cells height
      (0, _row_utils.applyRowSpans)(rowsInfo);

      // when we know all rowSpans we can recalculate rowsHeight
      (0, _height_updater.updateRowsAndCellsHeights)(jsPDFDocument, rowsInfo);

      // when we known all sizes we can calculate all coordinates
      (0, _row_utils.calculateCoordinates)(jsPDFDocument, rowsInfo, options); // set/init/update 'pdfCell.top/left'

      // recalculate for grouped rows
      // TODO: applyGroupIndents()

      (0, _row_utils.applyBordersConfig)(rowsInfo);
      (0, _pdf_utils.applyWordWrap)(jsPDFDocument, rowsInfo);

      // splitting to pages
      // ?? TODO: Does split a cell which have an attribute 'colSpan/rowSpan > 0' into two cells and place the first cell on the first page and second cell on the second page. And show initial 'text' in the both new cells ??
      // TODO: applySplitting()

      const docStyles = (0, _draw_utils.getDocumentStyles)(jsPDFDocument);
      const rtlEnabled = !!component.option('rtlEnabled');
      const onSeparateRectHorizontally = _ref => {
        var _sourceRect$sourceCel;
        let {
          sourceRect,
          leftRect,
          rightRect
        } = _ref;
        let leftRectTextOptions = {};
        let rightRectTextOptions = {};
        const isTextNotEmpty = ((_sourceRect$sourceCel = sourceRect.sourceCellInfo.text) === null || _sourceRect$sourceCel === void 0 ? void 0 : _sourceRect$sourceCel.length) > 0;
        if (isTextNotEmpty) {
          if (rtlEnabled) {
            const isTextWidthGreaterThanRect = jsPDFDocument.getTextWidth(sourceRect.sourceCellInfo.text) > leftRect.w;
            const isTextRightAlignment = !(0, _type.isDefined)(sourceRect.sourceCellInfo.horizontalAlign) || sourceRect.sourceCellInfo.horizontalAlign === 'right';
            if (isTextWidthGreaterThanRect || !isTextRightAlignment) {
              var _sourceRect$sourceCel2, _sourceRect$sourceCel3, _sourceRect$sourceCel4;
              let rightRectTextOffset;
              let leftRectTextOffset;
              if (((_sourceRect$sourceCel2 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel2 === void 0 ? void 0 : _sourceRect$sourceCel2.horizontalAlign) === 'right') {
                rightRectTextOffset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;
                leftRectTextOffset = rightRectTextOffset + leftRect.w;
              } else if (((_sourceRect$sourceCel3 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel3 === void 0 ? void 0 : _sourceRect$sourceCel3.horizontalAlign) === 'center') {
                leftRectTextOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w) + sourceRect.sourceCellInfo._rect.w / 2 - leftRect.w / 2;
                rightRectTextOffset = leftRectTextOffset - rightRect.w;
              } else if (((_sourceRect$sourceCel4 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel4 === void 0 ? void 0 : _sourceRect$sourceCel4.horizontalAlign) === 'left') {
                leftRectTextOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w);
                rightRectTextOffset = leftRectTextOffset - rightRect.w;
              }
              leftRectTextOptions = Object.assign({}, {
                _textLeftOffset: rightRectTextOffset
              });
              rightRectTextOptions = Object.assign({}, {
                _textLeftOffset: leftRectTextOffset
              });
            } else {
              rightRectTextOptions = Object.assign({}, {
                text: ''
              });
            }
          } else {
            const isTextWidthGreaterThanRect = jsPDFDocument.getTextWidth(sourceRect.sourceCellInfo.text) > leftRect.w;
            const isTextLeftAlignment = !(0, _type.isDefined)(sourceRect.sourceCellInfo.horizontalAlign) || sourceRect.sourceCellInfo.horizontalAlign === 'left';
            if (isTextWidthGreaterThanRect || !isTextLeftAlignment) {
              var _sourceRect$sourceCel5, _sourceRect$sourceCel6, _sourceRect$sourceCel7;
              let leftTextLeftOffset;
              let rightTextLeftOffset;
              if (((_sourceRect$sourceCel5 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel5 === void 0 ? void 0 : _sourceRect$sourceCel5.horizontalAlign) === 'left') {
                leftTextLeftOffset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;
                rightTextLeftOffset = leftTextLeftOffset - leftRect.w;
              } else if (((_sourceRect$sourceCel6 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel6 === void 0 ? void 0 : _sourceRect$sourceCel6.horizontalAlign) === 'center') {
                const offset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;
                leftTextLeftOffset = offset + (sourceRect.x + sourceRect.w / 2) - (leftRect.x + leftRect.w / 2);
                rightTextLeftOffset = offset + (sourceRect.x + sourceRect.w / 2) - (rightRect.x + rightRect.w / 2);
              } else if (((_sourceRect$sourceCel7 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel7 === void 0 ? void 0 : _sourceRect$sourceCel7.horizontalAlign) === 'right') {
                leftTextLeftOffset = sourceRect.x + sourceRect.w - (leftRect.x + leftRect.w);
                rightTextLeftOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w);
              }
              leftRectTextOptions = Object.assign({}, {
                _textLeftOffset: leftTextLeftOffset
              });
              rightRectTextOptions = Object.assign({}, {
                _textLeftOffset: rightTextLeftOffset
              });
            } else {
              rightRectTextOptions = Object.assign({}, {
                text: ''
              });
            }
          }
        }
        leftRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {
          debugSourceCellInfo: sourceRect.sourceCellInfo
        }, leftRectTextOptions);
        rightRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {
          debugSourceCellInfo: sourceRect.sourceCellInfo
        }, rightRectTextOptions);
      };
      const onSeparateRectVertically = _ref2 => {
        var _sourceRect$sourceCel8;
        let {
          sourceRect,
          topRect,
          bottomRect
        } = _ref2;
        let topRectTextOptions = {};
        let bottomRectTextOptions = {};
        const isTextNotEmpty = ((_sourceRect$sourceCel8 = sourceRect.sourceCellInfo.text) === null || _sourceRect$sourceCel8 === void 0 ? void 0 : _sourceRect$sourceCel8.length) > 0;
        if (isTextNotEmpty) {
          var _sourceRect$sourceCel9;
          const isTextHeightGreaterThanRect = jsPDFDocument.getTextDimensions(sourceRect.sourceCellInfo.text).h > topRect.h;
          const isTextTopAlignment = ((_sourceRect$sourceCel9 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel9 === void 0 ? void 0 : _sourceRect$sourceCel9.verticalAlign) === 'top';
          if (isTextHeightGreaterThanRect || !isTextTopAlignment) {
            var _sourceRect$sourceCel10, _sourceRect$sourceCel11, _sourceRect$sourceCel12;
            let topTextTopOffset;
            let bottomTextTopOffset;
            if (((_sourceRect$sourceCel10 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel10 === void 0 ? void 0 : _sourceRect$sourceCel10.verticalAlign) === 'top') {
              topTextTopOffset = sourceRect.sourceCellInfo._textTopOffset ?? 0;
              bottomTextTopOffset = topTextTopOffset - topRect.h;
            } else if (((_sourceRect$sourceCel11 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel11 === void 0 ? void 0 : _sourceRect$sourceCel11.verticalAlign) === 'middle') {
              const offset = sourceRect.sourceCellInfo._textTopOffset ?? 0;
              topTextTopOffset = offset + (sourceRect.y + sourceRect.h / 2) - (topRect.y + topRect.h / 2);
              bottomTextTopOffset = offset + (sourceRect.y + sourceRect.h / 2) - (bottomRect.y + bottomRect.h / 2);
            } else if (((_sourceRect$sourceCel12 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel12 === void 0 ? void 0 : _sourceRect$sourceCel12.verticalAlign) === 'bottom') {
              topTextTopOffset = sourceRect.y + sourceRect.h - (topRect.y + topRect.h);
              bottomTextTopOffset = sourceRect.y + sourceRect.h - (bottomRect.y + bottomRect.h);
            }
            topRectTextOptions = Object.assign({}, {
              _textTopOffset: topTextTopOffset
            });
            bottomRectTextOptions = Object.assign({}, {
              _textTopOffset: bottomTextTopOffset
            });
          } else {
            bottomRectTextOptions = Object.assign({}, {
              text: ''
            });
          }
        }
        topRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {
          debugSourceCellInfo: sourceRect.sourceCellInfo
        }, topRectTextOptions);
        bottomRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {
          debugSourceCellInfo: sourceRect.sourceCellInfo
        }, bottomRectTextOptions);
      };
      const rectsByPages = (0, _rows_splitting.splitByPages)(jsPDFDocument, rowsInfo, options, onSeparateRectHorizontally, onSeparateRectVertically);
      if (rtlEnabled) {
        (0, _pdf_utils.applyRtl)(jsPDFDocument, rectsByPages, options);
      }
      rectsByPages.forEach((pdfCellsInfo, index) => {
        if (index > 0) {
          (0, _draw_utils.addNewPage)(jsPDFDocument);
        }
        (0, _draw_utils.drawCellsContent)(jsPDFDocument, options.customDrawCell, pdfCellsInfo, docStyles);
        (0, _draw_utils.drawCellsLines)(jsPDFDocument, pdfCellsInfo, docStyles);
        const isEmptyPdfCellsInfoSpecified = (0, _type.isDefined)(pdfCellsInfo) && pdfCellsInfo.length === 0;
        if (isEmptyPdfCellsInfoSpecified) {
          const tableRect = (0, _row_utils.calculateTableSize)(jsPDFDocument, pdfCellsInfo, options); // TODO: after splitting to pages we need get 'rowsInfo' for selected table in the page
          const baseStyle = (0, _rows_generator.getBaseTableStyle)();
          (0, _draw_utils.drawGridLines)(jsPDFDocument, tableRect, baseStyle, docStyles);
        }
      });
      (0, _draw_utils.setDocumentStyles)(jsPDFDocument, docStyles);
      resolve();
    }).always(() => {
      if (initialLoadPanelEnabledOption) {
        component.option('loadPanel.enabled', initialLoadPanelEnabledOption);
      }
      if (loadPanel.enabled && (0, _window.hasWindow)()) {
        exportLoadPanel.dispose();
      }
    });
  });
}
const Export = exports.Export = {
  getFullOptions: _getFullOptions,
  export: exportDataGrid
};

/***/ }),

/***/ 41269:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.updateRowsAndCellsHeights = updateRowsAndCellsHeights;
var _type = __webpack_require__(35922);
var _pdf_utils = __webpack_require__(79262);
function updateRowsAndCellsHeights(doc, rows) {
  const rowsAdditionalHeights = calculateAdditionalRowsHeights(doc, rows);
  rows.forEach(row => {
    row.height += rowsAdditionalHeights[row.rowIndex];
  });
  rows.forEach(row => {
    row.cells.forEach(cell => {
      const rowsCount = (cell.rowSpan ?? 0) + 1;
      cell.pdfCell._rect.h = rows.slice(row.rowIndex, row.rowIndex + rowsCount).reduce((accumulator, rowInfo) => accumulator + rowInfo.height, 0);
    });
  });
}
function calculateAdditionalRowsHeights(doc, rows) {
  const rowsAdditionalHeights = Array.from({
    length: rows.length
  }, () => 0);
  const sortedRows = sortRowsByMaxRowSpanAsc(rows);
  sortedRows.forEach(row => {
    const cellsWithRowSpan = row.cells.filter(cell => (0, _type.isDefined)(cell.rowSpan));
    cellsWithRowSpan.forEach(cell => {
      const targetRectWidth = (0, _pdf_utils.calculateTargetRectWidth)(cell.pdfCell._rect.w, cell.pdfCell.padding);
      const textHeight = (0, _pdf_utils.calculateTextHeight)(doc, cell.pdfCell.text, cell.pdfCell.font, {
        wordWrapEnabled: cell.pdfCell.wordWrapEnabled,
        targetRectWidth
      });
      const cellHeight = textHeight + cell.pdfCell.padding.top + cell.pdfCell.padding.bottom;
      const rowsCount = cell.rowSpan + 1;
      const currentRowSpanRowsHeight = rows.slice(row.rowIndex, row.rowIndex + rowsCount).reduce((accumulator, rowInfo) => accumulator + rowInfo.height + rowsAdditionalHeights[rowInfo.rowIndex], 0);
      if (cellHeight > currentRowSpanRowsHeight) {
        const delta = (cellHeight - currentRowSpanRowsHeight) / rowsCount;
        for (let spanIndex = row.rowIndex; spanIndex < row.rowIndex + rowsCount; spanIndex++) {
          rowsAdditionalHeights[spanIndex] += delta;
        }
      }
    });
  });
  return rowsAdditionalHeights;
}
function sortRowsByMaxRowSpanAsc(rows) {
  const getMaxRowSpan = row => {
    const spansArray = row.cells.map(cell => cell.rowSpan ?? 0);
    return Math.max(...spansArray);
  };
  const sortByMaxRowSpan = (row1, row2) => {
    const row1RowSpan = getMaxRowSpan(row1);
    const row2RowSpan = getMaxRowSpan(row2);
    if (row1RowSpan > row2RowSpan) {
      return 1;
    }
    if (row2RowSpan > row1RowSpan) {
      return -1;
    }
    return 0;
  };
  return [...rows].sort(sortByMaxRowSpan);
}

/***/ }),

/***/ 30646:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.normalizeBoundaryValue = normalizeBoundaryValue;
exports.normalizeRowsInfo = normalizeRowsInfo;
var _type = __webpack_require__(35922);
function normalizeBoundaryValue(value) {
  if ((0, _type.isNumeric)(value)) {
    return {
      top: value,
      right: value,
      bottom: value,
      left: value
    };
  }
  return {
    top: (value === null || value === void 0 ? void 0 : value.top) ?? 0,
    right: (value === null || value === void 0 ? void 0 : value.right) ?? 0,
    bottom: (value === null || value === void 0 ? void 0 : value.bottom) ?? 0,
    left: (value === null || value === void 0 ? void 0 : value.left) ?? 0
  };
}
function normalizeRowsInfo(rowsInfo) {
  rowsInfo.forEach(row => {
    row.cells.forEach(_ref => {
      let {
        pdfCell
      } = _ref;
      pdfCell.padding = normalizeBoundaryValue(pdfCell.padding);
    });
  });
}

/***/ }),

/***/ 79262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.applyRtl = applyRtl;
exports.applyWordWrap = applyWordWrap;
exports.calculateRowHeight = calculateRowHeight;
exports.calculateTargetRectWidth = calculateTargetRectWidth;
exports.calculateTextHeight = calculateTextHeight;
exports.getPageHeight = getPageHeight;
exports.getPageWidth = getPageWidth;
exports.getTextDimensions = getTextDimensions;
exports.getTextLines = getTextLines;
exports.toPdfUnit = toPdfUnit;
var _type = __webpack_require__(35922);
const DOTS_TEXT = '...';
function toPdfUnit(doc, value) {
  const defaultScaleFactor = 1; // https://github.com/parallax/jsPDF/blob/master/src/jspdf.js#L3212
  const coefficient = defaultScaleFactor / doc.internal.scaleFactor;
  return value * coefficient;
}
function getPageWidth(doc) {
  return doc.internal.pageSize.getWidth();
}
function getPageHeight(doc) {
  return doc.internal.pageSize.getHeight();
}
function getTextLines(doc, text, font, _ref) {
  let {
    wordWrapEnabled,
    targetRectWidth
  } = _ref;
  if (wordWrapEnabled) {
    const usedFont = doc.getFont(font === null || font === void 0 ? void 0 : font.name, font === null || font === void 0 ? void 0 : font.style);
    return doc.splitTextToSize(text, targetRectWidth, {
      fontSize: (font === null || font === void 0 ? void 0 : font.size) || doc.getFontSize(),
      fontName: usedFont.fontName,
      fontStyle: usedFont.fontStyle
    });
  }
  let textWithoutLineBreak = text.split('\n').filter(ch => ch !== '').join(' ');
  if (getTextDimensions(doc, textWithoutLineBreak, font).w <= targetRectWidth) {
    return [textWithoutLineBreak];
  }
  let textWidth = getTextDimensions(doc, textWithoutLineBreak + DOTS_TEXT, font).w;
  while (textWithoutLineBreak.length > 0 && textWidth > targetRectWidth) {
    let symbolsCountToRemove = 0;
    if (textWidth >= targetRectWidth * 2) {
      symbolsCountToRemove = textWithoutLineBreak.length / 2;
    }
    if (symbolsCountToRemove < 1) {
      symbolsCountToRemove = 1;
    }
    textWithoutLineBreak = textWithoutLineBreak.substring(0, textWithoutLineBreak.length - symbolsCountToRemove);
    textWidth = getTextDimensions(doc, textWithoutLineBreak + DOTS_TEXT, font).w;
  }
  return [textWithoutLineBreak + DOTS_TEXT];
}
function calculateTargetRectWidth(columnWidth, padding) {
  const width = columnWidth - (padding.left + padding.right);
  return width >= 0 ? width : 0;
}
function getTextDimensions(doc, text, font) {
  return doc.getTextDimensions(text, {
    font: doc.getFont(font === null || font === void 0 ? void 0 : font.name, font === null || font === void 0 ? void 0 : font.style),
    fontSize: (font === null || font === void 0 ? void 0 : font.size) || doc.getFontSize()
  });
}
function calculateTextHeight(doc, text, font, _ref2) {
  let {
    wordWrapEnabled,
    targetRectWidth
  } = _ref2;
  const heightOfOneLine = getTextDimensions(doc, text, font).h;
  const linesCount = getTextLines(doc, text, font, {
    wordWrapEnabled,
    targetRectWidth
  }).length;
  return heightOfOneLine * linesCount * doc.getLineHeightFactor();
}
function calculateRowHeight(doc, cells, columnWidths) {
  if (cells.length !== columnWidths.length) {
    throw 'the cells count must be equal to the count of the columns';
  }
  let rowHeight = 0;
  for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
    if ((0, _type.isDefined)(cells[cellIndex].rowSpan)) {
      // height will be computed at the recalculateHeightForMergedRows step
      continue;
    }
    const cellText = cells[cellIndex].pdfCell.text;
    const cellPadding = cells[cellIndex].pdfCell.padding;
    const font = cells[cellIndex].pdfCell.font;
    const wordWrapEnabled = cells[cellIndex].pdfCell.wordWrapEnabled;
    const columnWidth = columnWidths[cellIndex];
    const targetRectWidth = calculateTargetRectWidth(columnWidth, cellPadding);
    if ((0, _type.isDefined)(cellText)) {
      const textHeight = cellText !== '' ? calculateTextHeight(doc, cellText, font, {
        wordWrapEnabled,
        targetRectWidth
      }) : 0;
      const cellHeight = textHeight + cellPadding.top + cellPadding.bottom;
      if (rowHeight < cellHeight) {
        rowHeight = cellHeight;
      }
    }
  }
  return rowHeight;
}
function applyWordWrap(doc, rowsInfo) {
  rowsInfo.forEach(row => {
    row.cells.forEach(_ref3 => {
      let {
        pdfCell
      } = _ref3;
      if ((0, _type.isDefined)(pdfCell.text)) {
        const lines = getTextLines(doc, pdfCell.text, pdfCell.font, {
          wordWrapEnabled: pdfCell.wordWrapEnabled,
          targetRectWidth: calculateTargetRectWidth(pdfCell._rect.w, pdfCell.padding)
        });
        pdfCell.text = lines.join('\n');
      }
    });
  });
}
function applyRtl(doc, rectsByPages, options) {
  rectsByPages.forEach(pageRects => {
    pageRects.forEach(pdfCell => {
      const mirroredX = getPageWidth(doc) - (pdfCell._rect.x + pdfCell._rect.w);
      const marginDiff = options.margin.left - options.margin.right;
      pdfCell._rect.x = mirroredX + marginDiff;
    });
  });
}

/***/ }),

/***/ 65322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.applyBordersConfig = applyBordersConfig;
exports.applyColSpans = applyColSpans;
exports.applyRowSpans = applyRowSpans;
exports.calculateCoordinates = calculateCoordinates;
exports.calculateHeights = calculateHeights;
exports.calculateTableSize = calculateTableSize;
exports.initializeCellsWidth = initializeCellsWidth;
exports.resizeFirstColumnByIndentLevel = resizeFirstColumnByIndentLevel;
var _type = __webpack_require__(35922);
var _pdf_utils = __webpack_require__(79262);
const getSum = (a, b) => a + b;
function calculateColumnWidths(doc, dataProvider, topLeftX, margin, customerColumnWidths) {
  const DEFAULT_WIDTH = 150;
  const resultWidths = dataProvider.getColumnsWidths().map(width => (0, _pdf_utils.toPdfUnit)(doc, width ?? DEFAULT_WIDTH));
  const totalAutoColumnsWidth = resultWidths.filter((width, index) => !(0, _type.isDefined)(customerColumnWidths[index])).reduce(getSum, 0);
  const totalCustomerColumnsWidth = customerColumnWidths.filter(width => (0, _type.isNumeric)(width)).reduce(getSum, 0);
  const availablePageWidth = getAvailablePageAreaWidth(doc, topLeftX, margin);
  const ratio = totalCustomerColumnsWidth < availablePageWidth ? (availablePageWidth - totalCustomerColumnsWidth) / totalAutoColumnsWidth : 1;
  return resultWidths.map((width, index) => customerColumnWidths[index] ?? width * ratio);
}
function getAvailablePageAreaWidth(doc, topLeftX, margin) {
  return (0, _pdf_utils.getPageWidth)(doc) - topLeftX - margin.left - margin.right;
}
function initializeCellsWidth(doc, dataProvider, rows, options) {
  const columnWidths = calculateColumnWidths(doc, dataProvider, options.topLeft.x, options.margin, options.columnWidths);
  rows.forEach(row => {
    row.cells.forEach((_ref, index) => {
      let {
        gridCell,
        pdfCell
      } = _ref;
      pdfCell._rect.w = columnWidths[index];
    });
  });
}
function calculateHeights(doc, rows, options) {
  rows.forEach(row => {
    const pdfCells = row.cells.map(c => c.pdfCell);
    let customerHeight;
    if (options.onRowExporting) {
      const args = {
        rowCells: pdfCells
      };
      options.onRowExporting(args);
      if ((0, _type.isDefined)(args.rowHeight)) {
        customerHeight = args.rowHeight;
      }
    }
    row.height = (0, _type.isDefined)(customerHeight) ? customerHeight : (0, _pdf_utils.calculateRowHeight)(doc, row.cells, pdfCells.map(c => c._rect.w));
    pdfCells.forEach(cell => {
      cell._rect.h = row.height;
    });
  });
}
function applyColSpans(rows) {
  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    const row = rows[rowIndex];
    for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {
      const cell = row.cells[cellIndex];
      if ((0, _type.isDefined)(cell.colSpan) && !(0, _type.isDefined)(cell.pdfCell.isMerged)) {
        for (let spanIndex = 1; spanIndex <= cell.colSpan; spanIndex++) {
          const mergedCell = rows[rowIndex].cells[cellIndex + spanIndex];
          cell.pdfCell._rect.w += mergedCell.pdfCell._rect.w;
          mergedCell.pdfCell._rect.w = 0;
          mergedCell.pdfCell.isMerged = true;
        }
      }
    }
  }
}
function applyRowSpans(rows) {
  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    const row = rows[rowIndex];
    for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {
      const cell = row.cells[cellIndex];
      if ((0, _type.isDefined)(cell.rowSpan) && !(0, _type.isDefined)(cell.pdfCell.isMerged)) {
        for (let spanIndex = 1; spanIndex <= cell.rowSpan; spanIndex++) {
          const mergedCell = rows[rowIndex + spanIndex].cells[cellIndex];
          cell.pdfCell._rect.h += mergedCell.pdfCell._rect.h;
          mergedCell.pdfCell._rect.h = 0;
          mergedCell.pdfCell.isMerged = true;
        }
      }
    }
  }
}
function resizeFirstColumnByIndentLevel(rows, options) {
  rows.forEach(row => {
    row.cells[0].pdfCell._rect.w -= row.indentLevel * options.indent;
  });
}
function applyBordersConfig(rows) {
  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    const cells = rows[rowIndex].cells;
    for (let columnIndex = 0; columnIndex < cells.length; columnIndex++) {
      const pdfCell = cells[columnIndex].pdfCell;
      const leftPdfCell = columnIndex >= 1 ? cells[columnIndex - 1].pdfCell : null;
      const topPdfCell = rowIndex >= 1 ? rows[rowIndex - 1].cells[columnIndex].pdfCell : null;
      if (pdfCell.drawLeftBorder === false && !(0, _type.isDefined)(cells[columnIndex].colSpan)) {
        // TODO: Check this logic after implementing splitting to pages
        if ((0, _type.isDefined)(leftPdfCell)) {
          leftPdfCell.drawRightBorder = false;
        }
      } else if (!(0, _type.isDefined)(pdfCell.drawLeftBorder)) {
        if ((0, _type.isDefined)(leftPdfCell) && leftPdfCell.drawRightBorder === false) {
          pdfCell.drawLeftBorder = false;
        }
      }
      if (pdfCell.drawTopBorder === false) {
        if ((0, _type.isDefined)(topPdfCell)) {
          topPdfCell.drawBottomBorder = false;
        }
      } else if (!(0, _type.isDefined)(pdfCell.drawTopBorder)) {
        if ((0, _type.isDefined)(topPdfCell) && topPdfCell.drawBottomBorder === false) {
          pdfCell.drawTopBorder = false;
        }
      }
    }
  }
}
function calculateCoordinates(doc, rows, options) {
  const topLeft = options === null || options === void 0 ? void 0 : options.topLeft;
  const margin = options === null || options === void 0 ? void 0 : options.margin;
  let y = ((topLeft === null || topLeft === void 0 ? void 0 : topLeft.y) ?? 0) + margin.top;
  rows.forEach(row => {
    let x = ((topLeft === null || topLeft === void 0 ? void 0 : topLeft.x) ?? 0) + margin.left;
    const intend = row.indentLevel * options.indent;
    row.cells.forEach(cell => {
      cell.pdfCell._rect.x = x + intend;
      cell.pdfCell._rect.y = y;
      x += cell.pdfCell._rect.w;
    });
    y += row.height;
  });
}
function calculateTableSize(doc, cells, options) {
  var _options$topLeft, _options$topLeft2;
  let leftPos;
  let topPos;
  let rightPos;
  let bottomPos;
  cells.forEach(cell => {
    if (!(0, _type.isDefined)(leftPos) || leftPos > cell._rect.x) {
      leftPos = cell._rect.x;
    }
    if (!(0, _type.isDefined)(topPos) || topPos > cell._rect.y) {
      topPos = cell._rect.y;
    }
    if (!(0, _type.isDefined)(rightPos) || rightPos < cell._rect.x + cell._rect.w) {
      rightPos = cell._rect.x + cell._rect.w;
    }
    if (!(0, _type.isDefined)(bottomPos) || bottomPos < cell._rect.y + cell._rect.h) {
      bottomPos = cell._rect.y + cell._rect.h;
    }
  });
  const x = leftPos ?? (options === null || options === void 0 || (_options$topLeft = options.topLeft) === null || _options$topLeft === void 0 ? void 0 : _options$topLeft.x) ?? 0;
  const y = topPos ?? (options === null || options === void 0 || (_options$topLeft2 = options.topLeft) === null || _options$topLeft2 === void 0 ? void 0 : _options$topLeft2.y) ?? 0;
  const w = (0, _type.isDefined)(rightPos) ? rightPos - x : 0;
  const h = (0, _type.isDefined)(bottomPos) ? bottomPos - y : 0;
  return {
    x,
    y,
    w,
    h
  };
}

/***/ }),

/***/ 27504:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.generateRowsInfo = generateRowsInfo;
exports.getBaseTableStyle = getBaseTableStyle;
var _type = __webpack_require__(35922);
var _date = _interopRequireDefault(__webpack_require__(91500));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _pdf_utils = __webpack_require__(79262);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultStyles = {
  base: {
    font: {
      size: 10
    },
    borderWidth: 0.5,
    borderColor: '#979797'
  },
  header: {
    textColor: '#979797'
  },
  group: {},
  data: {},
  groupFooter: {},
  totalFooter: {}
};
function generateRowsInfo(doc, dataProvider, dataGrid, headerBackgroundColor) {
  const result = [];
  const rowsCount = dataProvider.getRowsCount();
  const wordWrapEnabled = !!dataGrid.option('wordWrapEnabled');
  const rtlEnabled = !!dataGrid.option('rtlEnabled');
  const columns = dataProvider.getColumns();
  const styles = dataProvider.getStyles();
  for (let rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
    const rowType = dataProvider.getCellData(rowIndex, 0, true).cellSourceData.rowType;
    let indentLevel = rowType !== 'header' ? dataProvider.getGroupLevel(rowIndex) : 0;
    const previousRow = result[rowIndex - 1];
    if (rowType === 'groupFooter' && (previousRow === null || previousRow === void 0 ? void 0 : previousRow.rowType) === 'groupFooter') {
      indentLevel = previousRow.indentLevel - 1;
    }
    result.push({
      rowType: rowType,
      indentLevel,
      cells: generateRowCells({
        doc,
        dataProvider,
        rowIndex,
        wordWrapEnabled,
        columns,
        styles,
        rowType,
        backgroundColor: rowType === 'header' ? headerBackgroundColor : undefined,
        rtlEnabled
      }),
      rowIndex
    });
  }
  return result;
}
function generateRowCells(_ref) {
  let {
    doc,
    dataProvider,
    rowIndex,
    wordWrapEnabled,
    columns,
    styles,
    rowType,
    backgroundColor,
    rtlEnabled
  } = _ref;
  const result = [];
  for (let cellIndex = 0; cellIndex < columns.length; cellIndex++) {
    const cellData = dataProvider.getCellData(rowIndex, cellIndex, true);
    const cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];
    const style = getPdfCellStyle(columns[cellIndex], rowType, cellStyle);
    const defaultAlignment = rtlEnabled ? 'right' : 'left';
    const paddingValue = (0, _pdf_utils.toPdfUnit)(doc, 5);
    const pdfCell = {
      text: getFormattedValue(cellData.value, cellStyle.format),
      verticalAlign: 'middle',
      horizontalAlign: style.alignment ?? defaultAlignment,
      wordWrapEnabled,
      backgroundColor,
      padding: {
        top: paddingValue,
        right: paddingValue,
        bottom: paddingValue,
        left: paddingValue
      },
      _rect: {},
      _internalTextOptions: {}
    };
    if (rtlEnabled) {
      // https://github.com/parallax/jsPDF/issues/2235
      pdfCell._internalTextOptions.isInputVisual = false;
      pdfCell._internalTextOptions.isOutputVisual = true;
      pdfCell._internalTextOptions.isInputRtl = true;
      pdfCell._internalTextOptions.isOutputRtl = false;
    }
    const cellInfo = {
      gridCell: cellData.cellSourceData,
      pdfCell: Object.assign({}, pdfCell, style)
    };
    if (rowType === 'header') {
      const cellMerging = dataProvider.getCellMerging(rowIndex, cellIndex);
      if (cellMerging && cellMerging.rowspan > 0) {
        cellInfo.rowSpan = cellMerging.rowspan;
      }
      if (cellMerging && cellMerging.colspan > 0) {
        cellInfo.colSpan = cellMerging.colspan;
      }
    } else if (rowType === 'group') {
      const drawLeftBorderField = rtlEnabled ? 'drawRightBorder' : 'drawLeftBorder';
      const drawRightBorderField = rtlEnabled ? 'drawLeftBorder' : 'drawRightBorder';
      cellInfo.pdfCell[drawLeftBorderField] = cellIndex === 0;
      cellInfo.pdfCell[drawRightBorderField] = cellIndex === columns.length - 1;
      if (cellIndex > 0) {
        const isEmptyCellsExceptFirst = result.slice(1).reduce((accumulate, cellInfo) => {
          return accumulate && !(0, _type.isDefined)(cellInfo.pdfCell.text);
        }, true);
        if (!(0, _type.isDefined)(cellInfo.pdfCell.text) && isEmptyCellsExceptFirst) {
          result[0].pdfCell[drawRightBorderField] = true;
          for (let i = 0; i < result.length; i++) {
            result[i].colSpan = result.length;
          }
          cellInfo.colSpan = result.length;
        }
      }
    }
    result.push(cellInfo);
  }
  return result;
}
function getBaseTableStyle() {
  return defaultStyles['base'];
}
function getPdfCellStyle(column, rowType, cellStyle) {
  const styles = Object.assign({}, defaultStyles['base'], defaultStyles[rowType]);
  const alignment = rowType === 'header' ? column.alignment : cellStyle.alignment;
  if (alignment) {
    styles.alignment = alignment;
  }
  if (cellStyle.bold && rowType !== 'header') {
    styles.font = Object.assign({}, styles.font, {
      style: 'bold'
    });
  }
  return styles;
}
function getFormattedValue(value, format) {
  if ((0, _type.isDefined)(format)) {
    if ((0, _type.isDate)(value)) {
      return _date.default.format(value, format);
    }
    if ((0, _type.isNumeric)(value)) {
      return _number.default.format(value, format);
    }
  }
  return value === null || value === void 0 ? void 0 : value.toString();
}

/***/ }),

/***/ 72666:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.createOnSplitMultiPageRow = void 0;
var _pdf_utils = __webpack_require__(79262);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function createMultiCellRect(rect, text, marginTop) {
  return _extends({}, rect, {
    sourceCellInfo: _extends({}, rect.sourceCellInfo, {
      text
    }),
    y: marginTop
  });
}
const createOnSplitMultiPageRow = (doc, options, headerHeight, maxBottomRight) => (isFirstPage, pageRects) => {
  const currentPageRects = [];
  const nextPageRects = [];
  let maxCurrentPageHeight = 0;
  let maxNextPageHeight = 0;
  pageRects.forEach(rect => {
    const {
      w,
      sourceCellInfo
    } = rect;
    const additionalHeight = !isFirstPage && options.repeatHeaders ? headerHeight : headerHeight + options.topLeft.y;
    const heightOfOneLine = (0, _pdf_utils.getTextDimensions)(doc, sourceCellInfo.text, sourceCellInfo.font).h;
    const paddingHeight = sourceCellInfo.padding.top + sourceCellInfo.padding.bottom;
    const fullPageHeight = maxBottomRight.y - additionalHeight - paddingHeight - options.margin.top;
    const possibleLinesCount = Math.floor(fullPageHeight / (heightOfOneLine * doc.getLineHeightFactor()));
    const allLines = (0, _pdf_utils.getTextLines)(doc, sourceCellInfo.text, sourceCellInfo.font, {
      wordWrapEnabled: sourceCellInfo.wordWrapEnabled,
      targetRectWidth: w
    });
    if (possibleLinesCount < allLines.length) {
      const currentPageText = allLines.slice(0, possibleLinesCount).join('\n');
      const currentPageHeight = (0, _pdf_utils.calculateTextHeight)(doc, currentPageText, sourceCellInfo.font, {
        wordWrapEnabled: sourceCellInfo.wordWrapEnabled,
        targetRectWidth: w
      });
      maxCurrentPageHeight = Math.max(maxCurrentPageHeight, currentPageHeight + paddingHeight);
      maxNextPageHeight = rect.h - currentPageHeight;
      currentPageRects.push(createMultiCellRect(rect, currentPageText, options.margin.top));
      nextPageRects.push(createMultiCellRect(rect, allLines.slice(possibleLinesCount).join('\n'), options.margin.top));
    } else {
      const currentPageHeight = (0, _pdf_utils.calculateTextHeight)(doc, sourceCellInfo.text, sourceCellInfo.font, {
        wordWrapEnabled: sourceCellInfo.wordWrapEnabled,
        targetRectWidth: w
      });
      maxCurrentPageHeight = Math.max(maxCurrentPageHeight, currentPageHeight + paddingHeight);
      maxNextPageHeight = Math.max(maxNextPageHeight, currentPageHeight + paddingHeight);
      currentPageRects.push(createMultiCellRect(rect, sourceCellInfo.text, options.margin.top));
      nextPageRects.push(createMultiCellRect(rect, '', options.margin.top));
    }
  });
  currentPageRects.forEach(rect => rect.h = maxCurrentPageHeight);
  nextPageRects.forEach(rect => rect.h = maxNextPageHeight);
  return [currentPageRects, nextPageRects];
};
exports.createOnSplitMultiPageRow = createOnSplitMultiPageRow;

/***/ }),

/***/ 10830:
/***/ (function(__unused_webpack_module, exports) {



exports.getMultiPageRowPages = exports.checkPageContainsOnlyHeader = void 0;
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const isHeader = rect => (rect === null || rect === void 0 ? void 0 : rect.sourceCellInfo.gridCell.rowType) === 'header';
const spitMultiPageRows = (rectsToPatch, isCurrentPageContainsOnlyHeader, firstRectYAdjustment, splitMultiPageRowFunc, checkIsFitToPageFunc) => {
  let [newPageRects, remainPageRects] = splitMultiPageRowFunc(isCurrentPageContainsOnlyHeader, rectsToPatch);
  const newPageRectsArray = [isCurrentPageContainsOnlyHeader ? newPageRects.map(rect => _extends({}, rect, {
    y: firstRectYAdjustment
  })) : newPageRects];
  while (!checkIsFitToPageFunc(false, remainPageRects[0].h)) {
    [newPageRects, remainPageRects] = splitMultiPageRowFunc(false, remainPageRects);
    newPageRectsArray.push(newPageRects);
  }
  return [newPageRectsArray, remainPageRects];
};
const patchRects = (rectsToSplit, rectsToPatch, remainPageRects) => {
  rectsToPatch.forEach((rect, rectIndex) => {
    rect.sourceCellInfo.text = remainPageRects[rectIndex].sourceCellInfo.text;
    rect.h = remainPageRects[rectIndex].h;
  });
  const untouchedRowIdx = rectsToSplit.indexOf(rectsToPatch[rectsToPatch.length - 1]) + 1;
  if (untouchedRowIdx >= rectsToSplit.length) {
    return;
  }
  const delta = rectsToSplit[untouchedRowIdx].y - (rectsToPatch[0].y + remainPageRects[0].h);
  for (let idx = untouchedRowIdx; idx < rectsToSplit.length; idx++) {
    rectsToSplit[idx].y = rectsToSplit[idx].y - delta;
  }
};
const checkPageContainsOnlyHeader = (pageRects, isFirstPage) => isFirstPage && isHeader(pageRects[pageRects.length - 1]);
exports.checkPageContainsOnlyHeader = checkPageContainsOnlyHeader;
const getMultiPageRowPages = (currentPageRects, rectsToSplit, isCurrentPageContainsOnlyHeader, splitMultiPageRowFunc, checkIsFitToPageFunc) => {
  if (!splitMultiPageRowFunc) {
    return [];
  }
  const currentPageLastRect = currentPageRects[currentPageRects.length - 1];
  const nextPageFirstRect = rectsToSplit[currentPageRects.length];
  if (!nextPageFirstRect || isHeader(nextPageFirstRect)) {
    return [];
  }
  const isRectsFitsToPage = checkIsFitToPageFunc(isCurrentPageContainsOnlyHeader, nextPageFirstRect.h);
  if (isRectsFitsToPage && !isCurrentPageContainsOnlyHeader) {
    return [];
  }
  const rectsToPatch = rectsToSplit.filter(_ref => {
    let {
      y
    } = _ref;
    return y === nextPageFirstRect.y;
  });
  const firstRectYAdjustment = currentPageLastRect.y + currentPageLastRect.h;
  const [multiPageRowPages, remainPageRects] = spitMultiPageRows(rectsToPatch, isCurrentPageContainsOnlyHeader, firstRectYAdjustment, splitMultiPageRowFunc, checkIsFitToPageFunc);
  patchRects(rectsToSplit, rectsToPatch, remainPageRects);
  return multiPageRowPages;
};
exports.getMultiPageRowPages = getMultiPageRowPages;

/***/ }),

/***/ 22775:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.splitByPages = splitByPages;
var _type = __webpack_require__(35922);
var _pdf_utils = __webpack_require__(79262);
var _draw_utils = __webpack_require__(66867);
var _get_multipage_row_pages = __webpack_require__(10830);
var _create_on_split_multipage_row = __webpack_require__(72666);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const COORDINATE_EPSILON = 0.001;
function convertToCellsArray(rows) {
  return [].concat.apply([], rows.map(rowInfo => {
    return rowInfo.cells.filter(cell => !(0, _type.isDefined)(cell.pdfCell.isMerged)).map(cellInfo => {
      return Object.assign({}, cellInfo.pdfCell._rect, {
        sourceCellInfo: _extends({}, cellInfo.pdfCell, {
          gridCell: cellInfo.gridCell
        })
      });
    });
  }));
}
function splitByPages(doc, rowsInfo, options, onSeparateRectHorizontally, onSeparateRectVertically) {
  if (rowsInfo.length === 0) {
    // Empty Table
    return [[]];
  }
  const maxBottomRight = {
    x: (0, _pdf_utils.getPageWidth)(doc) - options.margin.right,
    y: (0, _pdf_utils.getPageHeight)(doc) - options.margin.bottom
  };
  const headerRows = rowsInfo.filter(r => r.rowType === 'header');
  const headerHeight = headerRows.reduce((accumulator, row) => {
    return accumulator + row.height;
  }, 0);
  const verticallyPages = splitRectsByPages(convertToCellsArray(rowsInfo), options.margin.top, 'y', 'h', (isFirstPage, currentCoordinate) => {
    const additionalHeight = !isFirstPage && options.repeatHeaders ? headerHeight : 0;
    return (0, _draw_utils.roundToThreeDecimals)(currentCoordinate + additionalHeight) <= (0, _draw_utils.roundToThreeDecimals)(maxBottomRight.y);
  }, (rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit) => {
    const args = {
      sourceRect: rect,
      topRect: {
        x: rect.x,
        y: rect.y,
        w: rect.w,
        h: currentPageMaxRectCoordinate - rect.y
      },
      bottomRect: {
        x: rect.x,
        y: currentPageMaxRectCoordinate,
        w: rect.w,
        h: rect.h - (currentPageMaxRectCoordinate - rect.y)
      }
    };
    onSeparateRectVertically(args);
    currentPageRects.push(args.topRect);
    rectsToSplit.push(args.bottomRect);
  }, (0, _create_on_split_multipage_row.createOnSplitMultiPageRow)(doc, options, headerHeight, maxBottomRight));
  if (options.repeatHeaders) {
    for (let i = 1; i < verticallyPages.length; i++) {
      verticallyPages[i].forEach(rect => rect.y += headerHeight);
      // create deep copy of headers for each page
      const headerCells = convertToCellsArray(headerRows);
      headerCells.forEach(cell => {
        cell.y -= options.topLeft.y;
        // cell.x -= options.topLeft.x; don't forget to uncomment this line after fixing topleft.x issue
      });
      verticallyPages[i] = [...headerCells, ...verticallyPages[i]];
    }
  }
  let pageIndex = 0;
  while (pageIndex < verticallyPages.length) {
    const horizontallyPages = splitRectsByPages(verticallyPages[pageIndex], options.margin.left, 'x', 'w', (pagesLength, currentCoordinate) => (0, _draw_utils.roundToThreeDecimals)(currentCoordinate) <= (0, _draw_utils.roundToThreeDecimals)(maxBottomRight.x), (rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit) => {
      const args = {
        sourceRect: rect,
        leftRect: {
          x: rect.x,
          y: rect.y,
          w: currentPageMaxRectCoordinate - rect.x,
          h: rect.h
        },
        rightRect: {
          x: currentPageMaxRectCoordinate,
          y: rect.y,
          w: rect.w - (currentPageMaxRectCoordinate - rect.x),
          h: rect.h
        }
      };
      onSeparateRectHorizontally(args);
      currentPageRects.push(args.leftRect);
      rectsToSplit.push(args.rightRect);
    });
    if (horizontallyPages.length > 1) {
      verticallyPages.splice(pageIndex, 1, ...horizontallyPages);
      pageIndex += horizontallyPages.length;
    } else {
      pageIndex += 1;
    }
  }
  return verticallyPages.map(rects => {
    return rects.map(rect => Object.assign({}, rect.sourceCellInfo, {
      _rect: rect
    }));
  });
}
function splitRectsByPages(rects, marginValue, coordinate, dimension, isFitToPage, onSeparateCallback, onSplitMultiPageRow) {
  const pages = [];
  const rectsToSplit = [...rects];
  const isFitToPageForMultiPageRow = (isFirstPage, rectHeight) => isFitToPage(isFirstPage, rectHeight + marginValue);
  while (rectsToSplit.length > 0) {
    let currentPageMaxRectCoordinate = 0;
    const currentPageRects = rectsToSplit.filter(rect => {
      const currentRectCoordinate = rect[coordinate] + rect[dimension];
      if (isFitToPage(pages.length === 0, currentRectCoordinate)) {
        if (currentPageMaxRectCoordinate <= currentRectCoordinate) {
          currentPageMaxRectCoordinate = currentRectCoordinate;
        }
        return true;
      } else {
        return false;
      }
    });
    const isCurrentPageContainsOnlyHeader = (0, _get_multipage_row_pages.checkPageContainsOnlyHeader)(currentPageRects, pages.length === 0);
    const multiPageRowPages = (0, _get_multipage_row_pages.getMultiPageRowPages)(currentPageRects, rectsToSplit, isCurrentPageContainsOnlyHeader, onSplitMultiPageRow, isFitToPageForMultiPageRow);
    const rectsToSeparate = rectsToSplit.filter(rect => {
      // Check cells that have 'coordinate' less than 'currentPageMaxRectCoordinate'
      const currentRectLeft = rect[coordinate];
      const currentRectRight = rect[coordinate] + rect[dimension];
      return currentPageMaxRectCoordinate - currentRectLeft > COORDINATE_EPSILON && currentRectRight - currentPageMaxRectCoordinate > COORDINATE_EPSILON;
    });
    rectsToSeparate.forEach(rect => {
      onSeparateCallback(rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit);
      const index = rectsToSplit.indexOf(rect);
      if (index !== -1) {
        rectsToSplit.splice(index, 1);
      }
    });
    currentPageRects.forEach(rect => {
      const index = rectsToSplit.indexOf(rect);
      if (index !== -1) {
        rectsToSplit.splice(index, 1);
      }
    });
    rectsToSplit.forEach(rect => {
      rect[coordinate] = (0, _type.isDefined)(currentPageMaxRectCoordinate) ? rect[coordinate] - currentPageMaxRectCoordinate + marginValue : rect[coordinate];
    });
    const firstPageContainsHeaderAndMultiPageRow = isCurrentPageContainsOnlyHeader && multiPageRowPages.length > 0;
    if (firstPageContainsHeaderAndMultiPageRow) {
      const [firstPage, ...restOfPages] = multiPageRowPages;
      pages.push([...currentPageRects, ...firstPage]);
      pages.push(...restOfPages);
    } else if (currentPageRects.length > 0) {
      pages.push(currentPageRects);
      pages.push(...multiPageRowPages);
    } else if (multiPageRowPages.length > 0) {
      pages.push(...multiPageRowPages);
      pages.push(rectsToSplit);
    } else {
      pages.push(rectsToSplit);
      break;
    }
  }
  return pages;
}

/***/ }),

/***/ 654:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.exportDataGrid = exportDataGrid;
var _type = __webpack_require__(35922);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _export = __webpack_require__(17195);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const HOW_TO_MIGRATE_ARTICLE = 'https://supportcenter.devexpress.com/ticket/details/t1077554';
function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportDataGrid" method requires a configuration object.');
  }
  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxDataGrid')) {
    throw Error('The "component" field must contain a DataGrid instance.');
  }
  if (!((0, _type.isDefined)(options.jsPDFDocument) && (0, _type.isObject)(options.jsPDFDocument))) {
    throw Error('The "jsPDFDocument" field must contain a jsPDF instance.');
  }
  if ((0, _type.isDefined)(options.autoTableOptions)) {
    _errors.default.log('W0001', 'Export', 'autoTableOptions', '22.1', `You can migrate from exporting to PDF with the AutoTable plugin to a new export system. See the following topic for more information: ${HOW_TO_MIGRATE_ARTICLE}`);
  }
  return _export.Export.getFullOptions(options);
}
function exportDataGrid(options) {
  return _export.Export.export(_getFullOptions(options));
}

/***/ }),

/***/ 29982:
/***/ (function(__unused_webpack_module, exports) {



exports.exportGantt = exportGantt;
function exportGantt(options) {
  const component = options.component;
  return component === null || component === void 0 ? void 0 : component.exportToPdf(options);
}

/***/ }),

/***/ 30855:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getData = getData;
var _version = __webpack_require__(36739);
var _window = __webpack_require__(58201);
var _image_creator = __webpack_require__(12173);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
const window = (0, _window.getWindow)();
const mainPageTemplate = '%PDF-1.3\r\n2 0 obj\r\n<</ProcSet[/PDF/ImageB/ImageC/ImageI]/XObject<</I0 5 0 R>>>>\r\nendobj\r\n4 0 obj\r\n<</Type/Pages/Kids[1 0 R]/Count 1>>\r\nendobj\r\n7 0 obj\r\n<</OpenAction[1 0 R /FitH null]/Type/Catalog/Pages 4 0 R/PageLayout/OneColumn>>\r\nendobj\r\n1 0 obj\r\n<</Type/Page/Resources 2 0 R/MediaBox[0 0 _width_ _height_]/Contents 3 0 R/Parent 4 0 R>>\r\nendobj\r\n';
const contentTemplate = '3 0 obj\r\n<</Length 52>>stream\r\n0.20 w\n0 G\nq _width_ 0 0 _height_ 0.00 0.00 cm /I0 Do Q\r\nendstream\r\nendobj\r\n';
const infoTemplate = '6 0 obj\r\n<</CreationDate _date_/Producer(DevExtreme _version_)>>\r\nendobj\r\n';
const imageStartTemplate = '5 0 obj\r\n<</Type/XObject/Subtype/Image/Width _width_/Height _height_/ColorSpace/DeviceRGB/BitsPerComponent 8/Filter/DCTDecode/Length _length_>>stream\r\n';
const imageEndTemplate = '\r\nendstream\r\nendobj\r\n';
const trailerTemplate = 'trailer\r\n<<\r\n/Size 8\r\n/Root 7 0 R\r\n/Info 6 0 R\r\n>>\r\nstartxref\r\n_length_\r\n%%EOF';
const xrefTemplate = 'xref\r\n0 8\r\n0000000000 65535 f\r\n0000000241 00000 n\r\n0000000010 00000 n\r\n_main_ 00000 n\r\n0000000089 00000 n\r\n_image_ 00000 n\r\n_info_ 00000 n\r\n0000000143 00000 n\r\n';
const pad = function (str, len) {
  return str.length < len ? pad('0' + str, len) : str;
};
let composePdfString = function (imageString, options, curDate) {
  const margin = (options.margin || 0) * 2;
  let {
    width,
    height
  } = (0, _image_creator.calcScaledInfo)(options.width, options.height);
  width += margin;
  height += margin;
  const widthPt = (width * 0.75).toFixed(2);
  const heightPt = (height * 0.75).toFixed(2);
  const flooredWidth = Math.floor(width);
  const flooredHeight = Math.floor(height);
  const mainPage = mainPageTemplate.replace('_width_', widthPt).replace('_height_', heightPt);
  const content = contentTemplate.replace('_width_', widthPt).replace('_height_', heightPt);
  const info = infoTemplate.replace('_date_', curDate).replace('_version_', _version.version);
  const image = imageStartTemplate.replace('_width_', flooredWidth).replace('_height_', flooredHeight).replace('_length_', imageString.length) + imageString + imageEndTemplate;
  const xref = getXref(mainPage.length, content.length, info.length);
  const mainContent = mainPage + content + info + image;
  const trailer = trailerTemplate.replace('_length_', mainContent.length);
  return mainContent + xref + trailer;
};
function getXref(mainPageLength, contentLength, infoLength) {
  return xrefTemplate.replace('_main_', pad(mainPageLength + '', 10)).replace('_info_', pad(mainPageLength + contentLength + '', 10)).replace('_image_', pad(mainPageLength + contentLength + infoLength + '', 10));
}
let getCurDate = function () {
  return new Date();
};
let getBlob = function (binaryData) {
  let i = 0;
  const dataArray = new Uint8Array(binaryData.length);
  for (; i < binaryData.length; i++) {
    dataArray[i] = binaryData.charCodeAt(i);
  }
  return new window.Blob([dataArray.buffer], {
    type: 'application/pdf'
  });
};
let getBase64 = function (binaryData) {
  return window.btoa(binaryData);
};
function getTwoDigitValue(value) {
  const stringValue = value.toString();
  if (stringValue.length === 1) {
    return `0${value}`;
  }
  return value;
}
function convertToPdfDateFormat(date) {
  const dateUnits = [date.getUTCFullYear(), getTwoDigitValue(date.getUTCMonth()), getTwoDigitValue(date.getUTCDate()), getTwoDigitValue(date.getUTCHours()), getTwoDigitValue(date.getUTCMinutes()), getTwoDigitValue(date.getUTCSeconds())];
  return `(D:${dateUnits.join('')}Z00'00')`;
}
function getData(data, options) {
  return _image_creator.imageCreator.getImageData(data, (0, _extend.extend)({}, options, {
    format: 'JPEG'
  })).then(imageString => {
    const binaryData = composePdfString(imageString, options, convertToPdfDateFormat(getCurDate()));
    const pdfData = (0, _type.isFunction)(window.Blob) ? getBlob(binaryData) : getBase64(binaryData);
    return pdfData;
  });
}

/***/ }),

/***/ 37596:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getData = getData;
exports.svgCreator = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _ajax = _interopRequireDefault(__webpack_require__(37208));
var _window = __webpack_require__(58201);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _svg = __webpack_require__(19155);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const svgCreator = exports.svgCreator = {
  _markup: '',
  _imageArray: {},
  _imageDeferreds: [],
  _getBinaryFile: function (src, callback) {
    _ajax.default.sendRequest({
      url: src,
      method: 'GET',
      responseType: 'arraybuffer'
    }).done(callback).fail(function () {
      callback(false);
    });
  },
  _loadImages: function () {
    const that = this;
    (0, _iterator.each)(that._imageArray, function (src) {
      const deferred = new _deferred.Deferred();
      that._imageDeferreds.push(deferred);
      that._getBinaryFile(src, function (response) {
        if (!response) {
          delete that._imageArray[src]; // ToDo Warning
          deferred.resolve();
          return;
        }
        let i;
        let binary = '';
        const bytes = new Uint8Array(response);
        const length = bytes.byteLength;
        for (i = 0; i < length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        that._imageArray[src] = 'data:image/png;base64,' + window.btoa(binary);
        deferred.resolve();
      });
    });
  },
  _parseImages: function (element) {
    let href;
    const that = this;
    if (element.tagName === 'image') {
      href = (0, _renderer.default)(element).attr('href') || (0, _renderer.default)(element).attr('xlink:href');
      if (!that._imageArray[href]) {
        that._imageArray[href] = '';
      }
    }
    (0, _iterator.each)(element.childNodes, function (_, element) {
      that._parseImages(element);
    });
  },
  _prepareImages: function (svgElem) {
    this._parseImages(svgElem);
    this._loadImages();
    return _deferred.when.apply(_renderer.default, this._imageDeferreds);
  },
  getData: function (data, options) {
    let markup;
    const that = this;
    const xmlVersion = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>';
    const svgElem = (0, _svg.getSvgElement)(data);
    const $svgObject = (0, _renderer.default)(svgElem);
    $svgObject.find(`[${_svg.HIDDEN_FOR_EXPORT}]`).remove();
    markup = xmlVersion + (0, _svg.getSvgMarkup)($svgObject.get(0), options.backgroundColor);
    return that._prepareImages(svgElem).then(() => {
      (0, _iterator.each)(that._imageArray, function (href, dataURI) {
        const regexpString = `href=['|"]${href}['|"]`;
        markup = markup.replace(new RegExp(regexpString, 'gi'), `href="${dataURI}"`);
      });
      return (0, _type.isFunction)(window.Blob) ? that._getBlob(markup) : that._getBase64(markup);
    });
  },
  _getBlob: function (markup) {
    return new window.Blob([markup], {
      type: 'image/svg+xml'
    });
  },
  _getBase64: function (markup) {
    return window.btoa(markup);
  }
};
function getData(data, options) {
  return svgCreator.getData(data, options);
}

/***/ }),

/***/ 30343:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _date2 = _interopRequireDefault(__webpack_require__(91500));
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
__webpack_require__(89740);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = (0, _dependency_injector.default)({
  format: function (value, format) {
    const formatIsValid = (0, _type.isString)(format) && format !== '' || (0, _type.isPlainObject)(format) || (0, _type.isFunction)(format);
    const valueIsValid = (0, _type.isNumeric)(value) || (0, _type.isDate)(value);
    if (!formatIsValid || !valueIsValid) {
      return (0, _type.isDefined)(value) ? value.toString() : '';
    }
    if ((0, _type.isFunction)(format)) {
      return format(value);
    }
    if ((0, _type.isString)(format)) {
      format = {
        type: format
      };
    }
    if ((0, _type.isNumeric)(value)) {
      return _number.default.format(value, format);
    }
    if ((0, _type.isDate)(value)) {
      return _date2.default.format(value, format);
    }
  },
  getTimeFormat: function (showSecond) {
    return showSecond ? 'longtime' : 'shorttime';
  },
  _normalizeFormat: function (format) {
    if (!Array.isArray(format)) {
      return format;
    }
    if (format.length === 1) {
      return format[0];
    }
    return function (date) {
      return format.map(function (formatPart) {
        return _date2.default.format(date, formatPart);
      }).join(' ');
    };
  },
  getDateFormatByDifferences: function (dateDifferences, intervalFormat) {
    const resultFormat = [];
    const needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);
    if (needSpecialSecondFormatter) {
      const secondFormatter = function (date) {
        return date.getSeconds() + date.getMilliseconds() / 1000 + 's';
      };
      resultFormat.push(secondFormatter);
    } else if (dateDifferences.millisecond) {
      resultFormat.push('millisecond');
    }
    if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
      resultFormat.unshift(this.getTimeFormat(dateDifferences.second));
    }
    if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
      if (intervalFormat && intervalFormat === 'month') {
        return 'monthandyear';
      } else {
        resultFormat.unshift('shortdate');
        return this._normalizeFormat(resultFormat);
      }
    }
    if (dateDifferences.year && dateDifferences.month) {
      return 'monthandyear';
    }
    if (dateDifferences.year && dateDifferences.quarter) {
      return 'quarterandyear';
    }
    if (dateDifferences.year) {
      return 'year';
    }
    if (dateDifferences.quarter) {
      return 'quarter';
    }
    if (dateDifferences.month && dateDifferences.day) {
      if (intervalFormat) {
        const monthDayFormatter = function (date) {
          return _date2.default.getMonthNames('abbreviated')[date.getMonth()] + ' ' + _date2.default.format(date, 'day');
        };
        resultFormat.unshift(monthDayFormatter);
      } else {
        resultFormat.unshift('monthandday');
      }
      return this._normalizeFormat(resultFormat);
    }
    if (dateDifferences.month) {
      return 'month';
    }
    if (dateDifferences.day) {
      if (intervalFormat) {
        resultFormat.unshift('day');
      } else {
        const dayFormatter = function (date) {
          return _date2.default.format(date, 'dayofweek') + ', ' + _date2.default.format(date, 'day');
        };
        resultFormat.unshift(dayFormatter);
      }
      return this._normalizeFormat(resultFormat);
    }
    return this._normalizeFormat(resultFormat);
  },
  getDateFormatByTicks: function (ticks) {
    let maxDiff;
    let currentDiff;
    let i;
    if (ticks.length > 1) {
      maxDiff = _date.default.getDatesDifferences(ticks[0], ticks[1]);
      for (i = 1; i < ticks.length - 1; i++) {
        currentDiff = _date.default.getDatesDifferences(ticks[i], ticks[i + 1]);
        if (maxDiff.count < currentDiff.count) {
          maxDiff = currentDiff;
        }
      }
    } else {
      maxDiff = {
        year: true,
        month: true,
        day: true,
        hour: ticks[0].getHours() > 0,
        minute: ticks[0].getMinutes() > 0,
        second: ticks[0].getSeconds() > 0,
        millisecond: ticks[0].getMilliseconds() > 0
      };
    }
    const resultFormat = this.getDateFormatByDifferences(maxDiff);
    return resultFormat;
  },
  getDateFormatByTickInterval: function (startValue, endValue, tickInterval) {
    let dateUnitInterval;
    const dateDifferencesConverter = {
      week: 'day'
    };
    const correctDateDifferences = function (dateDifferences, tickInterval, value) {
      switch (tickInterval) {
        case 'year':
        case 'quarter':
          dateDifferences.month = value;
        /* falls through */
        case 'month':
          dateDifferences.day = value;
        /* falls through */
        case 'week':
        case 'day':
          dateDifferences.hour = value;
        /* falls through */
        case 'hour':
          dateDifferences.minute = value;
        /* falls through */
        case 'minute':
          dateDifferences.second = value;
        /* falls through */
        case 'second':
          dateDifferences.millisecond = value;
      }
    };
    const correctDifferencesByMaxDate = function (differences, minDate, maxDate) {
      if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
        if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
          differences.millisecond = true;
          differences.second = false;
        }
      } else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
        if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
          differences.second = true;
          differences.minute = false;
        }
      } else if (!maxDate.getMinutes() && maxDate.getHours()) {
        if (maxDate.getHours() - minDate.getHours() === 1) {
          differences.minute = true;
          differences.hour = false;
        }
      } else if (!maxDate.getHours() && maxDate.getDate() > 1) {
        if (maxDate.getDate() - minDate.getDate() === 1) {
          differences.hour = true;
          differences.day = false;
        }
      } else if (maxDate.getDate() === 1 && maxDate.getMonth()) {
        if (maxDate.getMonth() - minDate.getMonth() === 1) {
          differences.day = true;
          differences.month = false;
        }
      } else if (!maxDate.getMonth() && maxDate.getFullYear()) {
        if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
          differences.month = true;
          differences.year = false;
        }
      }
    };
    tickInterval = (0, _type.isString)(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
    const dateDifferences = _date.default.getDatesDifferences(startValue, endValue);
    if (startValue !== endValue) {
      correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
    }
    dateUnitInterval = _date.default.getDateUnitInterval(dateDifferences);
    correctDateDifferences(dateDifferences, dateUnitInterval, true);
    dateUnitInterval = _date.default.getDateUnitInterval(tickInterval || 'second');
    correctDateDifferences(dateDifferences, dateUnitInterval, false);
    dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
    const resultFormat = this.getDateFormatByDifferences(dateDifferences);
    return resultFormat;
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 78475:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _version = __webpack_require__(58020);
var _error = _interopRequireDefault(__webpack_require__(95640));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
__webpack_require__(17394);
__webpack_require__(59228);
__webpack_require__(66809);
__webpack_require__(32185);
__webpack_require__(711);
__webpack_require__(27387);
__webpack_require__(95063);
__webpack_require__(63200);
__webpack_require__(87481);
__webpack_require__(30829);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const useJQuery = (0, _use_jquery.default)();
if (useJQuery && (0, _version.compare)(_jquery.default.fn.jquery, [1, 10]) < 0) {
  throw _error.default.Error('E0012');
}

/***/ }),

/***/ 30829:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _ajax = _interopRequireDefault(__webpack_require__(37208));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  _ajax.default.inject({
    sendRequest: function (options) {
      if (!options.responseType && !options.upload) {
        return _jquery.default.ajax(options);
      }
      return this.callBase.apply(this, [options]);
    }
  });
}

/***/ }),

/***/ 87481:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(5554));
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_jquery.default) {
  const registerJQueryComponent = function (name, componentClass) {
    _jquery.default.fn[name] = function (options) {
      const isMemberInvoke = typeof options === 'string';
      let result;
      if (isMemberInvoke) {
        const memberName = options;
        const memberArgs = [].slice.call(arguments).slice(1);
        this.each(function () {
          const instance = componentClass.getInstance(this);
          if (!instance) {
            throw _errors.default.Error('E0009', name);
          }
          const member = instance[memberName];
          const memberValue = member.apply(instance, memberArgs);
          if (result === undefined) {
            result = memberValue;
          }
        });
      } else {
        this.each(function () {
          const instance = componentClass.getInstance(this);
          if (instance) {
            instance.option(options);
          } else {
            new componentClass(this, options);
          }
        });
        result = this;
      }
      return result;
    };
  };
  _component_registrator_callbacks.default.add(registerJQueryComponent);
}

/***/ }),

/***/ 66809:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _deferred = __webpack_require__(62754);
var _version = __webpack_require__(58020);
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  const Deferred = _jquery.default.Deferred;
  const strategy = {
    Deferred: Deferred
  };
  strategy.when = (0, _version.compare)(_jquery.default.fn.jquery, [3]) < 0 ? _jquery.default.when : function (singleArg) {
    if (arguments.length === 0) {
      return new Deferred().resolve();
    } else if (arguments.length === 1) {
      return singleArg && singleArg.then ? singleArg : new Deferred().resolve(singleArg);
    } else {
      return _jquery.default.when.apply(_jquery.default, arguments);
    }
  };
  (0, _deferred.setStrategy)(strategy);
}

/***/ }),

/***/ 27387:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _easing = __webpack_require__(23908);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_jquery.default) {
  (0, _easing.setEasing)(_jquery.default.easing);
}

/***/ }),

/***/ 63200:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getPublicElementJQuery = getPublicElementJQuery;
var _element = __webpack_require__(6415);
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const useJQuery = (0, _use_jquery.default)();
function getPublicElementJQuery($element) {
  return $element;
}
if (useJQuery) {
  (0, _element.setPublicElementWrapper)(getPublicElementJQuery);
}

/***/ }),

/***/ 95063:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _element_data = __webpack_require__(97906);
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  (0, _element_data.setDataStrategy)(_jquery.default);
}

/***/ }),

/***/ 711:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  _event_registrator_callbacks.default.add(function (name, eventObject) {
    _jquery.default.event.special[name] = eventObject;
  });
  if (_events_engine.default.passiveEventHandlersSupported()) {
    _events_engine.default.forcePassiveFalseEventNames.forEach(function (eventName) {
      _jquery.default.event.special[eventName] = {
        setup: function (data, namespaces, handler) {
          _dom_adapter.default.listen(this, eventName, handler, {
            passive: false
          });
        }
      };
    });
  }
  _events_engine.default.set({
    on: function (element) {
      (0, _jquery.default)(element).on.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    one: function (element) {
      (0, _jquery.default)(element).one.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    off: function (element) {
      (0, _jquery.default)(element).off.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    trigger: function (element) {
      (0, _jquery.default)(element).trigger.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    triggerHandler: function (element) {
      (0, _jquery.default)(element).triggerHandler.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    Event: _jquery.default.Event
  });
}

/***/ }),

/***/ 32185:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _themes_callback = __webpack_require__(89729);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_jquery.default && !_themes_callback.themeReadyCallback.fired()) {
  const holdReady = _jquery.default.holdReady || _jquery.default.fn.holdReady;
  holdReady(true);
  _themes_callback.themeReadyCallback.add(function () {
    _ready_callbacks.default.add(function () {
      holdReady(false);
    });
  });
}

/***/ }),

/***/ 59228:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
var _version = __webpack_require__(58020);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _index = __webpack_require__(39611);
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _hook_touch_props = _interopRequireDefault(__webpack_require__(2418));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  if ((0, _version.compare)(_jquery.default.fn.jquery, [3]) < 0) {
    const POINTER_TYPE_MAP = {
      2: 'touch',
      3: 'pen',
      4: 'mouse'
    };
    (0, _iterator.each)(['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel', 'MSPointerOver', 'MSPointerOut', 'mouseenter', 'mouseleave', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerover', 'pointerout', 'pointerenter', 'pointerleave'], function () {
      _jquery.default.event.fixHooks[this] = {
        filter: function (event, originalEvent) {
          const pointerType = originalEvent.pointerType;
          if ((0, _type.isNumeric)(pointerType)) {
            event.pointerType = POINTER_TYPE_MAP[pointerType];
          }
          return event;
        },
        props: _jquery.default.event.mouseHooks.props.concat(['pointerId', 'pointerType', 'originalTarget', 'width', 'height', 'pressure', 'result', 'tiltX', 'charCode', 'tiltY', 'detail', 'isPrimary', 'prevValue'])
      };
    });
    (0, _iterator.each)(['touchstart', 'touchmove', 'touchend', 'touchcancel'], function () {
      _jquery.default.event.fixHooks[this] = {
        filter: function (event, originalEvent) {
          (0, _hook_touch_props.default)(function (name, hook) {
            event[name] = hook(originalEvent);
          });
          return event;
        },
        props: _jquery.default.event.mouseHooks.props.concat(['touches', 'changedTouches', 'targetTouches', 'detail', 'result', 'originalTarget', 'charCode', 'prevValue'])
      };
    });
    _jquery.default.event.fixHooks['wheel'] = _jquery.default.event.mouseHooks;
    const DX_EVENT_HOOKS = {
      props: _jquery.default.event.mouseHooks.props.concat(['pointerType', 'pointerId', 'pointers'])
    };
    _event_registrator.default.callbacks.add(function (name) {
      _jquery.default.event.fixHooks[name] = DX_EVENT_HOOKS;
    });
    const fix = function (event, originalEvent) {
      const fixHook = _jquery.default.event.fixHooks[originalEvent.type] || _jquery.default.event.mouseHooks;
      const props = fixHook.props ? _jquery.default.event.props.concat(fixHook.props) : _jquery.default.event.props;
      let propIndex = props.length;
      while (propIndex--) {
        const prop = props[propIndex];
        event[prop] = originalEvent[prop];
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    };
    (0, _index.setEventFixMethod)(fix);
  } else {
    (0, _hook_touch_props.default)(function (name, hook) {
      _jquery.default.event.addProp(name, hook);
    });
  }
}

/***/ }),

/***/ 17394:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _renderer_base = _interopRequireDefault(__webpack_require__(82981));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  _renderer_base.default.set(_jquery.default);
}

/***/ }),

/***/ 72722:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _config = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const useJQuery = (0, _config.default)().useJQuery;
if (_jquery.default && useJQuery !== false) {
  (0, _config.default)({
    useJQuery: true
  });
}
function _default() {
  return _jquery.default && (0, _config.default)().useJQuery;
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 49281:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _version = __webpack_require__(58020);
__webpack_require__(89135);
__webpack_require__(70883);
__webpack_require__(89620);
__webpack_require__(24935);
__webpack_require__(74942);
__webpack_require__(27521);
__webpack_require__(61823);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

// Check availability in global environment
if (_knockout.default) {
  if ((0, _version.compare)(_knockout.default.version, [2, 3]) < 0) {
    throw _errors.default.Error('E0013');
  }
}

/***/ }),

/***/ 27521:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _element_data = __webpack_require__(97906);
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _version = __webpack_require__(58020);
var _utils = __webpack_require__(45994);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  const originalKOCleanExternalData = _knockout.default.utils.domNodeDisposal.cleanExternalData;
  const patchCleanData = function () {
    (0, _element_data.afterCleanData)(function (nodes) {
      let i;
      for (i = 0; i < nodes.length; i++) {
        nodes[i].cleanedByJquery = true;
      }
      for (i = 0; i < nodes.length; i++) {
        if (!nodes[i].cleanedByKo) {
          _knockout.default.cleanNode(nodes[i]);
        }
        delete nodes[i].cleanedByKo;
      }
      for (i = 0; i < nodes.length; i++) {
        delete nodes[i].cleanedByJquery;
      }
    });
    _knockout.default.utils.domNodeDisposal.cleanExternalData = function (node) {
      node.cleanedByKo = true;
      if ((0, _utils.getClosestNodeWithKoCreation)(node)) {
        if (!node.cleanedByJquery) {
          (0, _element_data.cleanData)([node]);
        }
      }
    };
  };
  const restoreOriginCleanData = function () {
    (0, _element_data.afterCleanData)(function () {});
    _knockout.default.utils.domNodeDisposal.cleanExternalData = originalKOCleanExternalData;
  };
  patchCleanData();
  _element_data.strategyChanging.add(function (strategy) {
    const isJQuery = !!strategy.fn;
    if (isJQuery && (0, _version.compare)(strategy.fn.jquery, [2, 0]) < 0) {
      restoreOriginCleanData();
    }
  });
}

/***/ }),

/***/ 61823:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _version = __webpack_require__(58020);
var _element_data = __webpack_require__(97906);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  const patchCleanData = function (jQuery) {
    const cleanKoData = function (element, andSelf) {
      const cleanNode = function () {
        _knockout.default.cleanNode(this);
      };
      if (andSelf) {
        element.each(cleanNode);
      } else {
        element.find('*').each(cleanNode);
      }
    };
    const originalEmpty = jQuery.fn.empty;
    jQuery.fn.empty = function () {
      cleanKoData(this, false);
      return originalEmpty.apply(this, arguments);
    };
    const originalRemove = jQuery.fn.remove;
    jQuery.fn.remove = function (selector, keepData) {
      if (!keepData) {
        let subject = this;
        if (selector) {
          subject = subject.filter(selector);
        }
        cleanKoData(subject, true);
      }
      return originalRemove.call(this, selector, keepData);
    };
    const originalHtml = jQuery.fn.html;
    jQuery.fn.html = function (value) {
      if (typeof value === 'string') {
        cleanKoData(this, false);
      }
      return originalHtml.apply(this, arguments);
    };
    const originalReplaceWith = jQuery.fn.replaceWith;
    jQuery.fn.replaceWith = function () {
      const result = originalReplaceWith.apply(this, arguments);
      if (!this.parent().length) {
        cleanKoData(this, true);
      }
      return result;
    };
  };
  _element_data.strategyChanging.add(function (strategy) {
    const isJQuery = !!strategy.fn;
    if (isJQuery && (0, _version.compare)(strategy.fn.jquery, [2, 0]) < 0) {
      patchCleanData(strategy);
    }
  });
}

/***/ }),

/***/ 89135:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _type = __webpack_require__(35922);
var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(5554));
var _ui = _interopRequireDefault(__webpack_require__(14390));
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _component = _interopRequireDefault(__webpack_require__(27135));
var _draggable = _interopRequireDefault(__webpack_require__(42160));
var _scroll_view = _interopRequireDefault(__webpack_require__(4741));
var _template = __webpack_require__(1129);
var _editor = _interopRequireDefault(__webpack_require__(96452));
var _locker = _interopRequireDefault(__webpack_require__(88933));
var _utils = __webpack_require__(45994);
var _config = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  const LOCKS_DATA_KEY = 'dxKoLocks';
  const CREATED_WITH_KO_DATA_KEY = 'dxKoCreation';
  const editorsBindingHandlers = [];
  const registerComponentKoBinding = function (componentName, componentClass) {
    if (_editor.default.isEditor(componentClass.prototype)) {
      editorsBindingHandlers.push(componentName);
    }
    _knockout.default.bindingHandlers[componentName] = {
      init: function (domNode, valueAccessor) {
        const $element = (0, _renderer.default)(domNode);
        const optionChangedCallbacks = (0, _callbacks.default)();
        let optionsByReference = {};
        let component;
        const knockoutConfig = (0, _config.default)().knockout;
        const isBindingPropertyPredicateName = knockoutConfig && knockoutConfig.isBindingPropertyPredicateName;
        let isBindingPropertyPredicate;
        let ctorOptions = {
          onInitializing: function (options) {
            optionsByReference = this._getOptionsByReference();
            _knockout.default.computed(() => {
              const model = _knockout.default.unwrap(valueAccessor());
              if (component) {
                component.beginUpdate();
              }
              isBindingPropertyPredicate = isBindingPropertyPredicateName && model && model[isBindingPropertyPredicateName];
              unwrapModel(model);
              if (component) {
                component.endUpdate();
              } else {
                var _model$onInitializing;
                model === null || model === void 0 || (_model$onInitializing = model.onInitializing) === null || _model$onInitializing === void 0 || _model$onInitializing.call(this, options);
              }
            }, null, {
              disposeWhenNodeIsRemoved: domNode
            });
            component = this;
          },
          modelByElement: function ($element) {
            if ($element.length) {
              const node = (0, _utils.getClosestNodeWithContext)($element.get(0));
              return _knockout.default.dataFor(node);
            }
          },
          nestedComponentOptions: function (component) {
            return {
              modelByElement: component.option('modelByElement'),
              nestedComponentOptions: component.option('nestedComponentOptions')
            };
          },
          _optionChangedCallbacks: optionChangedCallbacks,
          integrationOptions: {
            watchMethod: function (fn, callback, options) {
              options = options || {};
              let skipCallback = options.skipImmediate;
              const watcher = _knockout.default.computed(function () {
                const newValue = _knockout.default.unwrap(fn());
                if (!skipCallback) {
                  callback(newValue);
                }
                skipCallback = false;
              });
              return function () {
                watcher.dispose();
              };
            },
            templates: {
              'dx-polymorph-widget': {
                render: function (options) {
                  const widgetName = _knockout.default.utils.unwrapObservable(options.model.widget);
                  if (!widgetName) {
                    return;
                  }
                  const markup = (0, _renderer.default)('<div>').attr('data-bind', widgetName + ': options').get(0);
                  (0, _renderer.default)(options.container).append(markup);
                  _knockout.default.applyBindings(options.model, markup);
                }
              }
            },
            createTemplate: function (element) {
              return new _template.KoTemplate(element);
            }
          }
        };
        const optionNameToModelMap = {};
        const applyModelValueToOption = function (optionName, modelValue, unwrap) {
          const locks = $element.data(LOCKS_DATA_KEY);
          const optionValue = unwrap ? _knockout.default.unwrap(modelValue) : modelValue;
          if (_knockout.default.isWriteableObservable(modelValue)) {
            optionNameToModelMap[optionName] = modelValue;
          }
          if (component) {
            if (locks.locked(optionName)) {
              return;
            }
            locks.obtain(optionName);
            try {
              if (_knockout.default.ignoreDependencies) {
                _knockout.default.ignoreDependencies(component.option, component, [optionName, optionValue]);
              } else {
                component.option(optionName, optionValue);
              }
            } finally {
              locks.release(optionName);
            }
          } else {
            ctorOptions[optionName] = optionValue;
          }
        };
        const handleOptionChanged = function (args) {
          const optionName = args.fullName;
          const optionValue = args.value;
          if (!(optionName in optionNameToModelMap)) {
            return;
          }
          const $element = this._$element;
          const locks = $element.data(LOCKS_DATA_KEY);
          if (locks.locked(optionName)) {
            return;
          }
          locks.obtain(optionName);
          try {
            optionNameToModelMap[optionName](optionValue);
          } finally {
            locks.release(optionName);
          }
        };
        const createComponent = function () {
          optionChangedCallbacks.add(handleOptionChanged);
          $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new _locker.default());
          new componentClass($element, ctorOptions);
          ctorOptions = null;
        };
        const unwrapModelValue = function (currentModel, propertyName, propertyPath) {
          if (propertyPath === isBindingPropertyPredicateName) {
            return;
          }
          if (!isBindingPropertyPredicate || isBindingPropertyPredicate(propertyPath, propertyName, currentModel)) {
            let unwrappedPropertyValue;
            _knockout.default.computed(function () {
              const propertyValue = currentModel[propertyName];
              applyModelValueToOption(propertyPath, propertyValue, true);
              unwrappedPropertyValue = _knockout.default.unwrap(propertyValue);
            }, null, {
              disposeWhenNodeIsRemoved: domNode
            });
            if ((0, _type.isPlainObject)(unwrappedPropertyValue)) {
              if (!optionsByReference[propertyPath]) {
                unwrapModel(unwrappedPropertyValue, propertyPath);
              }
            }
          } else {
            applyModelValueToOption(propertyPath, currentModel[propertyName], false);
          }
        };
        function unwrapModel(model, propertyPath) {
          for (const propertyName in model) {
            if (Object.prototype.hasOwnProperty.call(model, propertyName)) {
              unwrapModelValue(model, propertyName, propertyPath ? [propertyPath, propertyName].join('.') : propertyName);
            }
          }
        }
        createComponent();
        return {
          controlsDescendantBindings: componentClass.subclassOf(_ui.default) || componentClass.subclassOf(_m_base_widget.default) || componentClass.subclassOf(_component.default) && !(component instanceof _scroll_view.default) || component instanceof _draggable.default
        };
      }
    };
    if (componentName === 'dxValidator') {
      _knockout.default.bindingHandlers['dxValidator'].after = editorsBindingHandlers;
    }
  };
  _component_registrator_callbacks.default.add(function (name, componentClass) {
    registerComponentKoBinding(name, componentClass);
  });
}

/***/ }),

/***/ 89620:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _icon = __webpack_require__(44899);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  _knockout.default.bindingHandlers.dxControlsDescendantBindings = {
    init: function (_, valueAccessor) {
      return {
        controlsDescendantBindings: _knockout.default.unwrap(valueAccessor())
      };
    }
  };
  _knockout.default.bindingHandlers.dxIcon = {
    init: function (element, valueAccessor) {
      const options = _knockout.default.utils.unwrapObservable(valueAccessor()) || {};
      const iconElement = (0, _icon.getImageContainer)(options);
      _knockout.default.virtualElements.emptyNode(element);
      if (iconElement) {
        _knockout.default.virtualElements.prepend(element, iconElement.get(0));
      }
    },
    update: function (element, valueAccessor) {
      const options = _knockout.default.utils.unwrapObservable(valueAccessor()) || {};
      const iconElement = (0, _icon.getImageContainer)(options);
      _knockout.default.virtualElements.emptyNode(element);
      if (iconElement) {
        _knockout.default.virtualElements.prepend(element, iconElement.get(0));
      }
    }
  };
  _knockout.default.virtualElements.allowedBindings.dxIcon = true;
}

/***/ }),

/***/ 70883:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _type = __webpack_require__(35922);
var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  _event_registrator_callbacks.default.add(function (name) {
    const koBindingEventName = (0, _index.addNamespace)(name, name + 'Binding');
    _knockout.default.bindingHandlers[name] = {
      update: function (element, valueAccessor, allBindingsAccessor, viewModel) {
        const $element = (0, _renderer.default)(element);
        const unwrappedValue = _knockout.default.utils.unwrapObservable(valueAccessor());
        const eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;
        _events_engine.default.off($element, koBindingEventName);
        _events_engine.default.on($element, koBindingEventName, (0, _type.isPlainObject)(unwrappedValue) ? unwrappedValue : {}, function (e) {
          eventSource.call(viewModel, viewModel, e);
        });
      }
    };
  });
}

/***/ }),

/***/ 1129:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.KoTemplate = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _type = __webpack_require__(35922);
var _template_base = __webpack_require__(81033);
var _dom = __webpack_require__(3532);
var _utils = __webpack_require__(45994);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const getParentContext = function (data) {
  const parentNode = _dom_adapter.default.createElement('div');
  _knockout.default.applyBindingsToNode(parentNode, null, data);
  const parentContext = _knockout.default.contextFor(parentNode);
  _knockout.default.cleanNode(parentNode);
  return parentContext;
};
const KoTemplate = class extends _template_base.TemplateBase {
  constructor(element) {
    super();
    this._element = element;
    this._template = (0, _renderer.default)('<div>').append((0, _dom.normalizeTemplateElement)(element));
    this._registerKoTemplate();
  }
  _registerKoTemplate() {
    const template = this._template.get(0);
    new _knockout.default.templateSources.anonymousTemplate(template)['nodes'](template);
  }
  _prepareDataForContainer(data, container) {
    if (container && container.length) {
      const node = (0, _utils.getClosestNodeWithContext)(container.get(0));
      const containerContext = _knockout.default.contextFor(node);
      data = data !== undefined ? data : _knockout.default.dataFor(node) || {};
      if (containerContext) {
        return data === containerContext.$data ? containerContext : containerContext.createChildContext(data);
      }
    }

    // workaround for https://github.com/knockout/knockout/pull/651
    return getParentContext(data).createChildContext(data);
  }
  _renderCore(options) {
    const model = this._prepareDataForContainer(options.model, (0, _renderer.default)(options.container));
    if ((0, _type.isDefined)(options.index)) {
      model.$index = options.index;
    }
    const $placeholder = (0, _renderer.default)('<div>').appendTo(options.container);
    let $result;
    _knockout.default.renderTemplate(this._template.get(0), model, {
      afterRender: function (nodes) {
        $result = (0, _renderer.default)(nodes);
      }
    }, $placeholder.get(0), 'replaceNode');
    return $result;
  }
  source() {
    return (0, _renderer.default)(this._element).clone();
  }
  dispose() {
    this._template.remove();
  }
};
exports.KoTemplate = KoTemplate;

/***/ }),

/***/ 45994:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getClosestNodeWithKoCreation = exports.getClosestNodeWithContext = void 0;
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

const getClosestNodeWithContext = node => {
  const context = _knockout.default.contextFor(node);
  if (!context && node.parentNode) {
    return getClosestNodeWithContext(node.parentNode);
  }
  return node;
};
exports.getClosestNodeWithContext = getClosestNodeWithContext;
const getClosestNodeWithKoCreation = node => {
  const $el = (0, _renderer.default)(node);
  const data = $el.data();
  const hasFlag = data && data['dxKoCreation'];
  if (hasFlag) {
    return node;
  }
  if (node.parentNode) {
    return getClosestNodeWithKoCreation(node.parentNode);
  }
  return null;
};
exports.getClosestNodeWithKoCreation = getClosestNodeWithKoCreation;

/***/ }),

/***/ 24935:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _events_strategy = __webpack_require__(80566);
var _validation_engine = _interopRequireDefault(__webpack_require__(90964));
var _deferred = __webpack_require__(62754);
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _knockout = _interopRequireDefault(__webpack_require__(76130));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  const VALIDATION_STATUS_VALID = 'valid';
  const VALIDATION_STATUS_PENDING = 'pending';
  const koDxValidator = _class.default.inherit({
    ctor(target, _ref) {
      let {
        name,
        validationRules
      } = _ref;
      this.target = target;
      this.name = name;
      this.isValid = _knockout.default.observable(true);
      this.validationError = _knockout.default.observable();
      this.validationErrors = _knockout.default.observable();
      this.validationStatus = _knockout.default.observable(VALIDATION_STATUS_VALID);
      this._eventsStrategy = new _events_strategy.EventsStrategy(this);
      this.validationRules = (0, _iterator.map)(validationRules, (rule, index) => {
        return (0, _extend.extend)({}, rule, {
          validator: this,
          index: index
        });
      });
      this._validationInfo = {
        result: null,
        deferred: null
      };
    },
    _updateValidationResult(result) {
      if (!this._validationInfo.result || this._validationInfo.result.id !== result.id) {
        const complete = this._validationInfo.deferred && this._validationInfo.result.complete;
        this._validationInfo.result = (0, _extend.extend)({}, result, {
          complete
        });
      } else {
        for (const prop in result) {
          if (prop !== 'id' && prop !== 'complete') {
            this._validationInfo.result[prop] = result[prop];
          }
        }
      }
    },
    validate() {
      const currentResult = this._validationInfo && this._validationInfo.result;
      const value = this.target();
      if (currentResult && currentResult.status === VALIDATION_STATUS_PENDING && currentResult.value === value) {
        return (0, _extend.extend)({}, currentResult);
      }
      const result = _validation_engine.default.validate(value, this.validationRules, this.name);
      result.id = new _guid.default().toString();
      this._applyValidationResult(result);
      result.complete && result.complete.then(res => {
        if (res.id === this._validationInfo.result.id) {
          this._applyValidationResult(res);
        }
      });
      return (0, _extend.extend)({}, this._validationInfo.result);
    },
    reset() {
      this.target(null);
      const result = {
        id: null,
        isValid: true,
        brokenRule: null,
        pendingRules: null,
        status: VALIDATION_STATUS_VALID,
        complete: null
      };
      this._applyValidationResult(result);
      return result;
    },
    _applyValidationResult(result) {
      result.validator = this;
      this._updateValidationResult(result);
      this.target.dxValidator.isValid(this._validationInfo.result.isValid);
      this.target.dxValidator.validationError(this._validationInfo.result.brokenRule);
      this.target.dxValidator.validationErrors(this._validationInfo.result.brokenRules);
      this.target.dxValidator.validationStatus(this._validationInfo.result.status);
      if (result.status === VALIDATION_STATUS_PENDING) {
        if (!this._validationInfo.deferred) {
          this._validationInfo.deferred = new _deferred.Deferred();
          this._validationInfo.result.complete = this._validationInfo.deferred.promise();
        }
        this._eventsStrategy.fireEvent('validating', [this._validationInfo.result]);
        return;
      }
      if (result.status !== VALIDATION_STATUS_PENDING) {
        this._eventsStrategy.fireEvent('validated', [result]);
        if (this._validationInfo.deferred) {
          this._validationInfo.deferred.resolve(result);
          this._validationInfo.deferred = null;
        }
      }
    },
    on(eventName, eventHandler) {
      this._eventsStrategy.on(eventName, eventHandler);
      return this;
    },
    off(eventName, eventHandler) {
      this._eventsStrategy.off(eventName, eventHandler);
      return this;
    }
  });
  _knockout.default.extenders.dxValidator = function (target, option) {
    target.dxValidator = new koDxValidator(target, option);
    target.subscribe(target.dxValidator.validate.bind(target.dxValidator));
    return target;
  };

  // TODO: MODULARITY: Move this to another place?

  _validation_engine.default.registerModelForValidation = function (model) {
    (0, _iterator.each)(model, function (name, member) {
      if (_knockout.default.isObservable(member) && member.dxValidator) {
        _validation_engine.default.registerValidatorInGroup(model, member.dxValidator);
      }
    });
  };
  _validation_engine.default.unregisterModelForValidation = function (model) {
    (0, _iterator.each)(model, function (name, member) {
      if (_knockout.default.isObservable(member) && member.dxValidator) {
        _validation_engine.default.removeRegisteredValidator(model, member.dxValidator);
      }
    });
  };
  _validation_engine.default.validateModel = _validation_engine.default.validateGroup;
}

/***/ }),

/***/ 74942:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _variable_wrapper = _interopRequireDefault(__webpack_require__(26974));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  _variable_wrapper.default.inject({
    isWrapped: _knockout.default.isObservable,
    isWritableWrapped: _knockout.default.isWritableObservable,
    wrap: _knockout.default.observable,
    unwrap: function (value) {
      if (_knockout.default.isObservable(value)) {
        return _knockout.default.utils.unwrapObservable(value);
      }
      return this.callBase(value);
    },
    assign: function (variable, value) {
      if (_knockout.default.isObservable(variable)) {
        variable(value);
      } else {
        this.callBase(variable, value);
      }
    }
  });
}

/***/ }),

/***/ 94484:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "date", ({
  enumerable: true,
  get: function () {
    return _date.default;
  }
}));
exports.disableIntl = disableIntl;
exports.locale = exports.loadMessages = exports.formatNumber = exports.formatMessage = exports.formatDate = void 0;
Object.defineProperty(exports, "message", ({
  enumerable: true,
  get: function () {
    return _message.default;
  }
}));
Object.defineProperty(exports, "number", ({
  enumerable: true,
  get: function () {
    return _number.default;
  }
}));
exports.parseNumber = exports.parseDate = void 0;
var _core = _interopRequireDefault(__webpack_require__(91331));
var _message = _interopRequireDefault(__webpack_require__(28109));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _date = _interopRequireDefault(__webpack_require__(91500));
__webpack_require__(89740);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @name localization
 */

const locale = exports.locale = _core.default.locale.bind(_core.default);
const loadMessages = exports.loadMessages = _message.default.load.bind(_message.default);
const formatMessage = exports.formatMessage = _message.default.format.bind(_message.default);
const formatNumber = exports.formatNumber = _number.default.format.bind(_number.default);
const parseNumber = exports.parseNumber = _number.default.parse.bind(_number.default);
const formatDate = exports.formatDate = _date.default.format.bind(_date.default);
const parseDate = exports.parseDate = _date.default.parse.bind(_date.default);
function disableIntl() {
  if (_number.default.engine() === 'intl') {
    _number.default.resetInjection();
  }
  if (_date.default.engine() === 'intl') {
    _date.default.resetInjection();
  }
}

/***/ }),

/***/ 71868:
/***/ (function(module, exports) {



exports["default"] = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = exports["default"] = {
  "af": "#,##0.00;(#,##0.00)",
  "af-NA": "#,##0.00;(#,##0.00)",
  "agq": "#,##0.00",
  "ak": "#,##0.00",
  "am": "#,##0.00;(#,##0.00)",
  "ar": "#,##0.00;(#,##0.00)",
  "ar-AE": "#,##0.00;(#,##0.00)",
  "ar-BH": "#,##0.00;(#,##0.00)",
  "ar-DJ": "#,##0.00;(#,##0.00)",
  "ar-DZ": "#,##0.00;(#,##0.00)",
  "ar-EG": "#,##0.00;(#,##0.00)",
  "ar-EH": "#,##0.00;(#,##0.00)",
  "ar-ER": "#,##0.00;(#,##0.00)",
  "ar-IL": "#,##0.00;(#,##0.00)",
  "ar-IQ": "#,##0.00;(#,##0.00)",
  "ar-JO": "#,##0.00;(#,##0.00)",
  "ar-KM": "#,##0.00;(#,##0.00)",
  "ar-KW": "#,##0.00;(#,##0.00)",
  "ar-LB": "#,##0.00;(#,##0.00)",
  "ar-LY": "#,##0.00;(#,##0.00)",
  "ar-MA": "#,##0.00;(#,##0.00)",
  "ar-MR": "#,##0.00;(#,##0.00)",
  "ar-OM": "#,##0.00;(#,##0.00)",
  "ar-PS": "#,##0.00;(#,##0.00)",
  "ar-QA": "#,##0.00;(#,##0.00)",
  "ar-SA": "#,##0.00;(#,##0.00)",
  "ar-SD": "#,##0.00;(#,##0.00)",
  "ar-SO": "#,##0.00;(#,##0.00)",
  "ar-SS": "#,##0.00;(#,##0.00)",
  "ar-SY": "#,##0.00;(#,##0.00)",
  "ar-TD": "#,##0.00;(#,##0.00)",
  "ar-TN": "#,##0.00;(#,##0.00)",
  "ar-YE": "#,##0.00;(#,##0.00)",
  "as": "#,##,##0.00",
  "asa": "#,##0.00",
  "ast": "#,##0.00",
  "az": "#,##0.00",
  "az-Cyrl": "#,##0.00",
  "az-Latn": "#,##0.00",
  "bas": "#,##0.00",
  "be": "#,##0.00",
  "be-tarask": "#,##0.00",
  "bem": "#,##0.00;(#,##0.00)",
  "bez": "#,##0.00",
  "bg": "0.00;(0.00)",
  "bm": "#,##0.00;(#,##0.00)",
  "bn": "#,##,##0.00;(#,##,##0.00)",
  "bn-IN": "#,##,##0.00;(#,##,##0.00)",
  "bo": "#,##0.00",
  "bo-IN": "#,##0.00",
  "br": "#,##0.00",
  "brx": "#,##,##0.00",
  "bs": "#,##0.00",
  "bs-Cyrl": "#,##0.00",
  "bs-Latn": "#,##0.00",
  "ca": "#,##0.00;(#,##0.00)",
  "ca-AD": "#,##0.00;(#,##0.00)",
  "ca-ES-valencia": "#,##0.00;(#,##0.00)",
  "ca-FR": "#,##0.00;(#,##0.00)",
  "ca-IT": "#,##0.00;(#,##0.00)",
  "ccp": "#,##,##0.00;(#,##,##0.00)",
  "ccp-IN": "#,##,##0.00;(#,##,##0.00)",
  "ce": "#,##0.00",
  "ceb": "#,##0.00;(#,##0.00)",
  "cgg": "#,##0.00",
  "chr": "#,##0.00;(#,##0.00)",
  "ckb": "#,##0.00",
  "ckb-IR": "#,##0.00",
  "cs": "#,##0.00",
  "cy": "#,##0.00;(#,##0.00)",
  "da": "#,##0.00",
  "da-GL": "#,##0.00",
  "dav": "#,##0.00;(#,##0.00)",
  "de": "#,##0.00",
  "de-AT": "#,##0.00",
  "de-BE": "#,##0.00",
  "de-CH": "#,##0.00",
  "de-IT": "#,##0.00",
  "de-LI": "#,##0.00",
  "de-LU": "#,##0.00",
  "dje": "#,##0.00",
  "doi": "#,##0.00",
  "dsb": "#,##0.00",
  "dua": "#,##0.00",
  "dyo": "#,##0.00",
  "dz": "#,##,##0.00",
  "ebu": "#,##0.00;(#,##0.00)",
  "ee": "#,##0.00;(#,##0.00)",
  "ee-TG": "#,##0.00;(#,##0.00)",
  "el": "#,##0.00",
  "el-CY": "#,##0.00",
  "en": "#,##0.00;(#,##0.00)",
  "en-001": "#,##0.00;(#,##0.00)",
  "en-150": "#,##0.00",
  "en-AE": "#,##0.00;(#,##0.00)",
  "en-AG": "#,##0.00;(#,##0.00)",
  "en-AI": "#,##0.00;(#,##0.00)",
  "en-AS": "#,##0.00;(#,##0.00)",
  "en-AT": "#,##0.00",
  "en-AU": "#,##0.00;(#,##0.00)",
  "en-BB": "#,##0.00;(#,##0.00)",
  "en-BE": "#,##0.00",
  "en-BI": "#,##0.00;(#,##0.00)",
  "en-BM": "#,##0.00;(#,##0.00)",
  "en-BS": "#,##0.00;(#,##0.00)",
  "en-BW": "#,##0.00;(#,##0.00)",
  "en-BZ": "#,##0.00;(#,##0.00)",
  "en-CA": "#,##0.00;(#,##0.00)",
  "en-CC": "#,##0.00;(#,##0.00)",
  "en-CH": "#,##0.00;-#,##0.00",
  "en-CK": "#,##0.00;(#,##0.00)",
  "en-CM": "#,##0.00;(#,##0.00)",
  "en-CX": "#,##0.00;(#,##0.00)",
  "en-CY": "#,##0.00;(#,##0.00)",
  "en-DE": "#,##0.00",
  "en-DG": "#,##0.00;(#,##0.00)",
  "en-DK": "#,##0.00",
  "en-DM": "#,##0.00;(#,##0.00)",
  "en-ER": "#,##0.00;(#,##0.00)",
  "en-FI": "#,##0.00",
  "en-FJ": "#,##0.00;(#,##0.00)",
  "en-FK": "#,##0.00;(#,##0.00)",
  "en-FM": "#,##0.00;(#,##0.00)",
  "en-GB": "#,##0.00;(#,##0.00)",
  "en-GD": "#,##0.00;(#,##0.00)",
  "en-GG": "#,##0.00;(#,##0.00)",
  "en-GH": "#,##0.00;(#,##0.00)",
  "en-GI": "#,##0.00;(#,##0.00)",
  "en-GM": "#,##0.00;(#,##0.00)",
  "en-GU": "#,##0.00;(#,##0.00)",
  "en-GY": "#,##0.00;(#,##0.00)",
  "en-HK": "#,##0.00;(#,##0.00)",
  "en-IE": "#,##0.00;(#,##0.00)",
  "en-IL": "#,##0.00;(#,##0.00)",
  "en-IM": "#,##0.00;(#,##0.00)",
  "en-IN": "#,##0.00;(#,##0.00)",
  "en-IO": "#,##0.00;(#,##0.00)",
  "en-JE": "#,##0.00;(#,##0.00)",
  "en-JM": "#,##0.00;(#,##0.00)",
  "en-KE": "#,##0.00;(#,##0.00)",
  "en-KI": "#,##0.00;(#,##0.00)",
  "en-KN": "#,##0.00;(#,##0.00)",
  "en-KY": "#,##0.00;(#,##0.00)",
  "en-LC": "#,##0.00;(#,##0.00)",
  "en-LR": "#,##0.00;(#,##0.00)",
  "en-LS": "#,##0.00;(#,##0.00)",
  "en-MG": "#,##0.00;(#,##0.00)",
  "en-MH": "#,##0.00;(#,##0.00)",
  "en-MO": "#,##0.00;(#,##0.00)",
  "en-MP": "#,##0.00;(#,##0.00)",
  "en-MS": "#,##0.00;(#,##0.00)",
  "en-MT": "#,##0.00;(#,##0.00)",
  "en-MU": "#,##0.00;(#,##0.00)",
  "en-MV": "#,##0.00",
  "en-MW": "#,##0.00;(#,##0.00)",
  "en-MY": "#,##0.00;(#,##0.00)",
  "en-NA": "#,##0.00;(#,##0.00)",
  "en-NF": "#,##0.00;(#,##0.00)",
  "en-NG": "#,##0.00;(#,##0.00)",
  "en-NL": "#,##0.00;(#,##0.00)",
  "en-NR": "#,##0.00;(#,##0.00)",
  "en-NU": "#,##0.00;(#,##0.00)",
  "en-NZ": "#,##0.00;(#,##0.00)",
  "en-PG": "#,##0.00;(#,##0.00)",
  "en-PH": "#,##0.00;(#,##0.00)",
  "en-PK": "#,##0.00;(#,##0.00)",
  "en-PN": "#,##0.00;(#,##0.00)",
  "en-PR": "#,##0.00;(#,##0.00)",
  "en-PW": "#,##0.00;(#,##0.00)",
  "en-RW": "#,##0.00;(#,##0.00)",
  "en-SB": "#,##0.00;(#,##0.00)",
  "en-SC": "#,##0.00;(#,##0.00)",
  "en-SD": "#,##0.00;(#,##0.00)",
  "en-SE": "#,##0.00",
  "en-SG": "#,##0.00;(#,##0.00)",
  "en-SH": "#,##0.00;(#,##0.00)",
  "en-SI": "#,##0.00;(#,##0.00)",
  "en-SL": "#,##0.00;(#,##0.00)",
  "en-SS": "#,##0.00;(#,##0.00)",
  "en-SX": "#,##0.00;(#,##0.00)",
  "en-SZ": "#,##0.00;(#,##0.00)",
  "en-TC": "#,##0.00;(#,##0.00)",
  "en-TK": "#,##0.00;(#,##0.00)",
  "en-TO": "#,##0.00;(#,##0.00)",
  "en-TT": "#,##0.00;(#,##0.00)",
  "en-TV": "#,##0.00;(#,##0.00)",
  "en-TZ": "#,##0.00;(#,##0.00)",
  "en-UG": "#,##0.00;(#,##0.00)",
  "en-UM": "#,##0.00;(#,##0.00)",
  "en-VC": "#,##0.00;(#,##0.00)",
  "en-VG": "#,##0.00;(#,##0.00)",
  "en-VI": "#,##0.00;(#,##0.00)",
  "en-VU": "#,##0.00;(#,##0.00)",
  "en-WS": "#,##0.00;(#,##0.00)",
  "en-ZA": "#,##0.00;(#,##0.00)",
  "en-ZM": "#,##0.00;(#,##0.00)",
  "en-ZW": "#,##0.00;(#,##0.00)",
  "eo": "#,##0.00",
  "es": "#,##0.00",
  "es-419": "#,##0.00",
  "es-AR": "#,##0.00;(#,##0.00)",
  "es-BO": "#,##0.00",
  "es-BR": "#,##0.00",
  "es-BZ": "#,##0.00",
  "es-CL": "#,##0.00",
  "es-CO": "#,##0.00",
  "es-CR": "#,##0.00",
  "es-CU": "#,##0.00",
  "es-DO": "#,##0.00;(#,##0.00)",
  "es-EA": "#,##0.00",
  "es-EC": "#,##0.00",
  "es-GQ": "#,##0.00",
  "es-GT": "#,##0.00",
  "es-HN": "#,##0.00",
  "es-IC": "#,##0.00",
  "es-MX": "#,##0.00",
  "es-NI": "#,##0.00",
  "es-PA": "#,##0.00",
  "es-PE": "#,##0.00",
  "es-PH": "#,##0.00",
  "es-PR": "#,##0.00",
  "es-PY": "#,##0.00",
  "es-SV": "#,##0.00",
  "es-US": "#,##0.00",
  "es-UY": "#,##0.00;(#,##0.00)",
  "es-VE": "#,##0.00",
  "et": "#,##0.00;(#,##0.00)",
  "eu": "#,##0.00;(#,##0.00)",
  "ewo": "#,##0.00",
  "fa": "#,##0.00;(#,##0.00)",
  "fa-AF": "#,##0.00;(#,##0.00)",
  "ff": "#,##0.00",
  "ff-Adlm": "#,##0.00",
  "ff-Adlm-BF": "#,##0.00",
  "ff-Adlm-CM": "#,##0.00",
  "ff-Adlm-GH": "#,##0.00",
  "ff-Adlm-GM": "#,##0.00",
  "ff-Adlm-GW": "#,##0.00",
  "ff-Adlm-LR": "#,##0.00",
  "ff-Adlm-MR": "#,##0.00",
  "ff-Adlm-NE": "#,##0.00",
  "ff-Adlm-NG": "#,##0.00",
  "ff-Adlm-SL": "#,##0.00",
  "ff-Adlm-SN": "#,##0.00",
  "ff-Latn": "#,##0.00",
  "ff-Latn-BF": "#,##0.00",
  "ff-Latn-CM": "#,##0.00",
  "ff-Latn-GH": "#,##0.00",
  "ff-Latn-GM": "#,##0.00",
  "ff-Latn-GN": "#,##0.00",
  "ff-Latn-GW": "#,##0.00",
  "ff-Latn-LR": "#,##0.00",
  "ff-Latn-MR": "#,##0.00",
  "ff-Latn-NE": "#,##0.00",
  "ff-Latn-NG": "#,##0.00",
  "ff-Latn-SL": "#,##0.00",
  "fi": "#,##0.00",
  "fil": "#,##0.00;(#,##0.00)",
  "fo": "#,##0.00;(#,##0.00)",
  "fo-DK": "#,##0.00;(#,##0.00)",
  "fr": "#,##0.00;(#,##0.00)",
  "fr-BE": "#,##0.00;(#,##0.00)",
  "fr-BF": "#,##0.00;(#,##0.00)",
  "fr-BI": "#,##0.00;(#,##0.00)",
  "fr-BJ": "#,##0.00;(#,##0.00)",
  "fr-BL": "#,##0.00;(#,##0.00)",
  "fr-CA": "#,##0.00;(#,##0.00)",
  "fr-CD": "#,##0.00;(#,##0.00)",
  "fr-CF": "#,##0.00;(#,##0.00)",
  "fr-CG": "#,##0.00;(#,##0.00)",
  "fr-CH": "#,##0.00;(#,##0.00)",
  "fr-CI": "#,##0.00;(#,##0.00)",
  "fr-CM": "#,##0.00;(#,##0.00)",
  "fr-DJ": "#,##0.00;(#,##0.00)",
  "fr-DZ": "#,##0.00;(#,##0.00)",
  "fr-GA": "#,##0.00;(#,##0.00)",
  "fr-GF": "#,##0.00;(#,##0.00)",
  "fr-GN": "#,##0.00;(#,##0.00)",
  "fr-GP": "#,##0.00;(#,##0.00)",
  "fr-GQ": "#,##0.00;(#,##0.00)",
  "fr-HT": "#,##0.00;(#,##0.00)",
  "fr-KM": "#,##0.00;(#,##0.00)",
  "fr-LU": "#,##0.00;(#,##0.00)",
  "fr-MA": "#,##0.00;(#,##0.00)",
  "fr-MC": "#,##0.00;(#,##0.00)",
  "fr-MF": "#,##0.00;(#,##0.00)",
  "fr-MG": "#,##0.00;(#,##0.00)",
  "fr-ML": "#,##0.00;(#,##0.00)",
  "fr-MQ": "#,##0.00;(#,##0.00)",
  "fr-MR": "#,##0.00;(#,##0.00)",
  "fr-MU": "#,##0.00;(#,##0.00)",
  "fr-NC": "#,##0.00;(#,##0.00)",
  "fr-NE": "#,##0.00;(#,##0.00)",
  "fr-PF": "#,##0.00;(#,##0.00)",
  "fr-PM": "#,##0.00;(#,##0.00)",
  "fr-RE": "#,##0.00;(#,##0.00)",
  "fr-RW": "#,##0.00;(#,##0.00)",
  "fr-SC": "#,##0.00;(#,##0.00)",
  "fr-SN": "#,##0.00;(#,##0.00)",
  "fr-SY": "#,##0.00;(#,##0.00)",
  "fr-TD": "#,##0.00;(#,##0.00)",
  "fr-TG": "#,##0.00;(#,##0.00)",
  "fr-TN": "#,##0.00;(#,##0.00)",
  "fr-VU": "#,##0.00;(#,##0.00)",
  "fr-WF": "#,##0.00;(#,##0.00)",
  "fr-YT": "#,##0.00;(#,##0.00)",
  "fur": "#,##0.00",
  "fy": "#,##0.00;(#,##0.00)",
  "ga": "#,##0.00;(#,##0.00)",
  "ga-GB": "#,##0.00;(#,##0.00)",
  "gd": "#,##0.00;(#,##0.00)",
  "gl": "#,##0.00",
  "gsw": "#,##0.00",
  "gsw-FR": "#,##0.00",
  "gsw-LI": "#,##0.00",
  "gu": "#,##,##0.00;(#,##,##0.00)",
  "guz": "#,##0.00;(#,##0.00)",
  "gv": "#,##0.00",
  "ha": "#,##0.00",
  "ha-GH": "#,##0.00",
  "ha-NE": "#,##0.00",
  "haw": "#,##0.00;(#,##0.00)",
  "he": "#,##0.00",
  "hi": "#,##,##0.00",
  "hi-Latn": "#,##,##0.00",
  "hr": "#,##0.00",
  "hr-BA": "#,##0.00",
  "hsb": "#,##0.00",
  "hu": "#,##0.00",
  "hy": "#,##0.00",
  "ia": "#,##0.00;(#,##0.00)",
  "id": "#,##0.00",
  "ig": "#,##0.00;(#,##0.00)",
  "ii": "#,##0.00",
  "is": "#,##0.00",
  "it": "#,##0.00",
  "it-CH": "#,##0.00",
  "it-SM": "#,##0.00",
  "it-VA": "#,##0.00",
  "ja": "#,##0.00;(#,##0.00)",
  "jgo": "#,##0.00",
  "jmc": "#,##0.00",
  "jv": "#,##0.00",
  "ka": "#,##0.00",
  "kab": "#,##0.00",
  "kam": "#,##0.00;(#,##0.00)",
  "kde": "#,##0.00;(#,##0.00)",
  "kea": "#,##0.00;(#,##0.00)",
  "kgp": "#,##0.00",
  "khq": "#,##0.00",
  "ki": "#,##0.00;(#,##0.00)",
  "kk": "#,##0.00",
  "kkj": "#,##0.00",
  "kl": "#,##0.00;-#,##0.00",
  "kln": "#,##0.00;(#,##0.00)",
  "km": "#,##0.00;(#,##0.00)",
  "kn": "#,##0.00;(#,##0.00)",
  "ko": "#,##0.00;(#,##0.00)",
  "ko-KP": "#,##0.00;(#,##0.00)",
  "kok": "#,##0.00;(#,##0.00)",
  "ks": "#,##0.00",
  "ks-Arab": "#,##0.00",
  "ks-Deva": "#,##0.00",
  "ksb": "#,##0.00",
  "ksf": "#,##0.00",
  "ksh": "#,##0.00",
  "ku": "#,##0.00;(#,##0.00)",
  "kw": "#,##0.00",
  "ky": "#,##0.00",
  "lag": "#,##0.00",
  "lb": "#,##0.00",
  "lg": "#,##0.00",
  "lkt": "#,##0.00",
  "ln": "#,##0.00",
  "ln-AO": "#,##0.00",
  "ln-CF": "#,##0.00",
  "ln-CG": "#,##0.00",
  "lo": "#,##0.00;-#,##0.00",
  "lrc": "#,##0.00",
  "lrc-IQ": "#,##0.00",
  "lt": "#,##0.00",
  "lu": "#,##0.00",
  "luo": "#,##0.00",
  "luy": "#,##0.00;-#,##0.00",
  "lv": "#,##0.00",
  "mai": "#,##0.00",
  "mas": "#,##0.00;(#,##0.00)",
  "mas-TZ": "#,##0.00;(#,##0.00)",
  "mer": "#,##0.00;(#,##0.00)",
  "mfe": "#,##0.00",
  "mg": "#,##0.00",
  "mgh": "#,##0.00",
  "mgo": "#,##0.00",
  "mi": "#,##0.00",
  "mk": "#,##0.00",
  "ml": "#,##0.00;(#,##0.00)",
  "mn": "#,##0.00",
  "mni": "#,##0.00",
  "mni-Beng": "#,##0.00",
  "mr": "#,##0.00;(#,##0.00)",
  "ms": "#,##0.00;(#,##0.00)",
  "ms-BN": "#,##0.00;(#,##0.00)",
  "ms-ID": "#,##0.00",
  "ms-SG": "#,##0.00;(#,##0.00)",
  "mt": "#,##0.00",
  "mua": "#,##0.00;(#,##0.00)",
  "my": "#,##0.00",
  "mzn": "#,##0.00",
  "naq": "#,##0.00",
  "nb": "#,##0.00;(#,##0.00)",
  "nb-SJ": "#,##0.00;(#,##0.00)",
  "nd": "#,##0.00;(#,##0.00)",
  "nds": "#,##0.00",
  "nds-NL": "#,##0.00",
  "ne": "#,##,##0.00",
  "ne-IN": "#,##,##0.00",
  "nl": "#,##0.00;(#,##0.00)",
  "nl-AW": "#,##0.00;(#,##0.00)",
  "nl-BE": "#,##0.00;(#,##0.00)",
  "nl-BQ": "#,##0.00;(#,##0.00)",
  "nl-CW": "#,##0.00;(#,##0.00)",
  "nl-SR": "#,##0.00;(#,##0.00)",
  "nl-SX": "#,##0.00;(#,##0.00)",
  "nmg": "#,##0.00",
  "nn": "#,##0.00",
  "nnh": "#,##0.00",
  "no": "#,##0.00;(#,##0.00)",
  "nus": "#,##0.00;(#,##0.00)",
  "nyn": "#,##0.00",
  "om": "#,##0.00",
  "om-KE": "#,##0.00",
  "or": "#,##0.00;(#,##0.00)",
  "os": "#,##0.00",
  "os-RU": "#,##0.00",
  "pa": "#,##0.00",
  "pa-Arab": "#,##0.00",
  "pa-Guru": "#,##0.00",
  "pcm": "#,##0.00",
  "pl": "#,##0.00;(#,##0.00)",
  "ps": "#,##0.00;(#,##0.00)",
  "ps-PK": "#,##0.00;(#,##0.00)",
  "pt": "#,##0.00",
  "pt-AO": "#,##0.00;(#,##0.00)",
  "pt-CH": "#,##0.00;(#,##0.00)",
  "pt-CV": "#,##0.00;(#,##0.00)",
  "pt-GQ": "#,##0.00;(#,##0.00)",
  "pt-GW": "#,##0.00;(#,##0.00)",
  "pt-LU": "#,##0.00;(#,##0.00)",
  "pt-MO": "#,##0.00;(#,##0.00)",
  "pt-MZ": "#,##0.00;(#,##0.00)",
  "pt-PT": "#,##0.00;(#,##0.00)",
  "pt-ST": "#,##0.00;(#,##0.00)",
  "pt-TL": "#,##0.00;(#,##0.00)",
  "qu": "#,##0.00",
  "qu-BO": "#,##0.00",
  "qu-EC": "#,##0.00",
  "rm": "#,##0.00",
  "rn": "#,##0.00",
  "ro": "#,##0.00;(#,##0.00)",
  "ro-MD": "#,##0.00;(#,##0.00)",
  "rof": "#,##0.00",
  "ru": "#,##0.00",
  "ru-BY": "#,##0.00",
  "ru-KG": "#,##0.00",
  "ru-KZ": "#,##0.00",
  "ru-MD": "#,##0.00",
  "ru-UA": "#,##0.00",
  "rw": "#,##0.00",
  "rwk": "#,##0.00",
  "sa": "#,##0.00",
  "sah": "#,##0.00",
  "saq": "#,##0.00;(#,##0.00)",
  "sat": "#,##0.00",
  "sat-Olck": "#,##0.00",
  "sbp": "#,##0.00",
  "sc": "#,##0.00",
  "sd": "#,##0.00",
  "sd-Arab": "#,##0.00",
  "sd-Deva": "#,##0.00",
  "se": "#,##0.00",
  "se-FI": "#,##0.00",
  "se-SE": "#,##0.00",
  "seh": "#,##0.00",
  "ses": "#,##0.00",
  "sg": "#,##0.00;-#,##0.00",
  "shi": "#,##0.00",
  "shi-Latn": "#,##0.00",
  "shi-Tfng": "#,##0.00",
  "si": "#,##0.00;(#,##0.00)",
  "sk": "#,##0.00;(#,##0.00)",
  "sl": "#,##0.00;(#,##0.00)",
  "smn": "#,##0.00",
  "sn": "#,##0.00;(#,##0.00)",
  "so": "#,##0.00;(#,##0.00)",
  "so-DJ": "#,##0.00;(#,##0.00)",
  "so-ET": "#,##0.00;(#,##0.00)",
  "so-KE": "#,##0.00;(#,##0.00)",
  "sq": "#,##0.00;(#,##0.00)",
  "sq-MK": "#,##0.00;(#,##0.00)",
  "sq-XK": "#,##0.00;(#,##0.00)",
  "sr": "#,##0.00;(#,##0.00)",
  "sr-Cyrl": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-BA": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-ME": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-XK": "#,##0.00;(#,##0.00)",
  "sr-Latn": "#,##0.00;(#,##0.00)",
  "sr-Latn-BA": "#,##0.00;(#,##0.00)",
  "sr-Latn-ME": "#,##0.00;(#,##0.00)",
  "sr-Latn-XK": "#,##0.00;(#,##0.00)",
  "su": "#,##0.00",
  "su-Latn": "#,##0.00",
  "sv": "#,##0.00",
  "sv-AX": "#,##0.00",
  "sv-FI": "#,##0.00",
  "sw": "#,##0.00",
  "sw-CD": "#,##0.00",
  "sw-KE": "#,##0.00",
  "sw-UG": "#,##0.00",
  "ta": "#,##0.00;(#,##0.00)",
  "ta-LK": "#,##0.00;(#,##0.00)",
  "ta-MY": "#,##0.00;(#,##0.00)",
  "ta-SG": "#,##0.00;(#,##0.00)",
  "te": "#,##0.00;(#,##0.00)",
  "teo": "#,##0.00;(#,##0.00)",
  "teo-KE": "#,##0.00;(#,##0.00)",
  "tg": "#,##0.00",
  "th": "#,##0.00;(#,##0.00)",
  "ti": "#,##0.00",
  "ti-ER": "#,##0.00",
  "tk": "#,##0.00",
  "to": "#,##0.00",
  "tr": "#,##0.00;(#,##0.00)",
  "tr-CY": "#,##0.00;(#,##0.00)",
  "tt": "#,##0.00",
  "twq": "#,##0.00",
  "tzm": "#,##0.00",
  "ug": "#,##0.00;(#,##0.00)",
  "uk": "#,##0.00",
  "und": "#,##0.00",
  "ur": "#,##0.00;(#,##0.00)",
  "ur-IN": "#,##0.00;(#,##0.00)",
  "uz": "#,##0.00",
  "uz-Arab": "#,##0.00",
  "uz-Cyrl": "#,##0.00",
  "uz-Latn": "#,##0.00",
  "vai": "#,##0.00;(#,##0.00)",
  "vai-Latn": "#,##0.00;(#,##0.00)",
  "vai-Vaii": "#,##0.00;(#,##0.00)",
  "vi": "#,##0.00",
  "vun": "#,##0.00",
  "wae": "#,##0.00",
  "wo": "#,##0.00",
  "xh": "#,##0.00",
  "xog": "#,##0.00",
  "yav": "#,##0.00;(#,##0.00)",
  "yi": "#,##0.00",
  "yo": "#,##0.00;(#,##0.00)",
  "yo-BJ": "#,##0.00;(#,##0.00)",
  "yrl": "#,##0.00",
  "yrl-CO": "#,##0.00",
  "yrl-VE": "#,##0.00",
  "yue": "#,##0.00;(#,##0.00)",
  "yue-Hans": "#,##0.00;(#,##0.00)",
  "yue-Hant": "#,##0.00;(#,##0.00)",
  "zgh": "#,##0.00",
  "zh": "#,##0.00;(#,##0.00)",
  "zh-Hans": "#,##0.00;(#,##0.00)",
  "zh-Hans-HK": "#,##0.00;(#,##0.00)",
  "zh-Hans-MO": "#,##0.00;(#,##0.00)",
  "zh-Hans-SG": "#,##0.00;(#,##0.00)",
  "zh-Hant": "#,##0.00;(#,##0.00)",
  "zh-Hant-HK": "#,##0.00;(#,##0.00)",
  "zh-Hant-MO": "#,##0.00;(#,##0.00)",
  "zu": "#,##0.00;(#,##0.00)"
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 35608:
/***/ (function(__unused_webpack_module, exports) {



exports.enCldr = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
const enCldr = exports.enCldr = {
  "main": {
    "en": {
      "identity": {
        "version": {
          "_cldrVersion": "36"
        }
      },
      "dates": {
        "calendars": {
          "gregorian": {
            "months": {
              "format": {
                "abbreviated": {
                  "1": "Jan",
                  "2": "Feb",
                  "3": "Mar",
                  "4": "Apr",
                  "5": "May",
                  "6": "Jun",
                  "7": "Jul",
                  "8": "Aug",
                  "9": "Sep",
                  "10": "Oct",
                  "11": "Nov",
                  "12": "Dec"
                },
                "narrow": {
                  "1": "J",
                  "2": "F",
                  "3": "M",
                  "4": "A",
                  "5": "M",
                  "6": "J",
                  "7": "J",
                  "8": "A",
                  "9": "S",
                  "10": "O",
                  "11": "N",
                  "12": "D"
                },
                "wide": {
                  "1": "January",
                  "2": "February",
                  "3": "March",
                  "4": "April",
                  "5": "May",
                  "6": "June",
                  "7": "July",
                  "8": "August",
                  "9": "September",
                  "10": "October",
                  "11": "November",
                  "12": "December"
                }
              },
              "stand-alone": {
                "abbreviated": {
                  "1": "Jan",
                  "2": "Feb",
                  "3": "Mar",
                  "4": "Apr",
                  "5": "May",
                  "6": "Jun",
                  "7": "Jul",
                  "8": "Aug",
                  "9": "Sep",
                  "10": "Oct",
                  "11": "Nov",
                  "12": "Dec"
                },
                "narrow": {
                  "1": "J",
                  "2": "F",
                  "3": "M",
                  "4": "A",
                  "5": "M",
                  "6": "J",
                  "7": "J",
                  "8": "A",
                  "9": "S",
                  "10": "O",
                  "11": "N",
                  "12": "D"
                },
                "wide": {
                  "1": "January",
                  "2": "February",
                  "3": "March",
                  "4": "April",
                  "5": "May",
                  "6": "June",
                  "7": "July",
                  "8": "August",
                  "9": "September",
                  "10": "October",
                  "11": "November",
                  "12": "December"
                }
              }
            },
            "days": {
              "format": {
                "abbreviated": {
                  "sun": "Sun",
                  "mon": "Mon",
                  "tue": "Tue",
                  "wed": "Wed",
                  "thu": "Thu",
                  "fri": "Fri",
                  "sat": "Sat"
                },
                "narrow": {
                  "sun": "S",
                  "mon": "M",
                  "tue": "T",
                  "wed": "W",
                  "thu": "T",
                  "fri": "F",
                  "sat": "S"
                },
                "short": {
                  "sun": "Su",
                  "mon": "Mo",
                  "tue": "Tu",
                  "wed": "We",
                  "thu": "Th",
                  "fri": "Fr",
                  "sat": "Sa"
                },
                "wide": {
                  "sun": "Sunday",
                  "mon": "Monday",
                  "tue": "Tuesday",
                  "wed": "Wednesday",
                  "thu": "Thursday",
                  "fri": "Friday",
                  "sat": "Saturday"
                }
              },
              "stand-alone": {
                "abbreviated": {
                  "sun": "Sun",
                  "mon": "Mon",
                  "tue": "Tue",
                  "wed": "Wed",
                  "thu": "Thu",
                  "fri": "Fri",
                  "sat": "Sat"
                },
                "narrow": {
                  "sun": "S",
                  "mon": "M",
                  "tue": "T",
                  "wed": "W",
                  "thu": "T",
                  "fri": "F",
                  "sat": "S"
                },
                "short": {
                  "sun": "Su",
                  "mon": "Mo",
                  "tue": "Tu",
                  "wed": "We",
                  "thu": "Th",
                  "fri": "Fr",
                  "sat": "Sa"
                },
                "wide": {
                  "sun": "Sunday",
                  "mon": "Monday",
                  "tue": "Tuesday",
                  "wed": "Wednesday",
                  "thu": "Thursday",
                  "fri": "Friday",
                  "sat": "Saturday"
                }
              }
            },
            "quarters": {
              "format": {
                "abbreviated": {
                  "1": "Q1",
                  "2": "Q2",
                  "3": "Q3",
                  "4": "Q4"
                },
                "narrow": {
                  "1": "1",
                  "2": "2",
                  "3": "3",
                  "4": "4"
                },
                "wide": {
                  "1": "1st quarter",
                  "2": "2nd quarter",
                  "3": "3rd quarter",
                  "4": "4th quarter"
                }
              },
              "stand-alone": {
                "abbreviated": {
                  "1": "Q1",
                  "2": "Q2",
                  "3": "Q3",
                  "4": "Q4"
                },
                "narrow": {
                  "1": "1",
                  "2": "2",
                  "3": "3",
                  "4": "4"
                },
                "wide": {
                  "1": "1st quarter",
                  "2": "2nd quarter",
                  "3": "3rd quarter",
                  "4": "4th quarter"
                }
              }
            },
            "dayPeriods": {
              "format": {
                "abbreviated": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "in the morning",
                  "afternoon1": "in the afternoon",
                  "evening1": "in the evening",
                  "night1": "at night"
                },
                "narrow": {
                  "midnight": "mi",
                  "am": "a",
                  "am-alt-variant": "am",
                  "noon": "n",
                  "pm": "p",
                  "pm-alt-variant": "pm",
                  "morning1": "in the morning",
                  "afternoon1": "in the afternoon",
                  "evening1": "in the evening",
                  "night1": "at night"
                },
                "wide": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "in the morning",
                  "afternoon1": "in the afternoon",
                  "evening1": "in the evening",
                  "night1": "at night"
                }
              },
              "stand-alone": {
                "abbreviated": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "morning",
                  "afternoon1": "afternoon",
                  "evening1": "evening",
                  "night1": "night"
                },
                "narrow": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "morning",
                  "afternoon1": "afternoon",
                  "evening1": "evening",
                  "night1": "night"
                },
                "wide": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "morning",
                  "afternoon1": "afternoon",
                  "evening1": "evening",
                  "night1": "night"
                }
              }
            },
            "eras": {
              "eraNames": {
                "0": "Before Christ",
                "1": "Anno Domini",
                "0-alt-variant": "Before Common Era",
                "1-alt-variant": "Common Era"
              },
              "eraAbbr": {
                "0": "BC",
                "1": "AD",
                "0-alt-variant": "BCE",
                "1-alt-variant": "CE"
              },
              "eraNarrow": {
                "0": "B",
                "1": "A",
                "0-alt-variant": "BCE",
                "1-alt-variant": "CE"
              }
            },
            "dateFormats": {
              "full": "EEEE, MMMM d, y",
              "long": "MMMM d, y",
              "medium": "MMM d, y",
              "short": "M/d/yy"
            },
            "timeFormats": {
              "full": "h:mm:ss a zzzz",
              "long": "h:mm:ss a z",
              "medium": "h:mm:ss a",
              "short": "h:mm a"
            },
            "dateTimeFormats": {
              "full": "{1} 'at' {0}",
              "long": "{1} 'at' {0}",
              "medium": "{1}, {0}",
              "short": "{1}, {0}",
              "availableFormats": {
                "Bh": "h B",
                "Bhm": "h:mm B",
                "Bhms": "h:mm:ss B",
                "d": "d",
                "E": "ccc",
                "EBhm": "E h:mm B",
                "EBhms": "E h:mm:ss B",
                "Ed": "d E",
                "Ehm": "E h:mm a",
                "EHm": "E HH:mm",
                "Ehms": "E h:mm:ss a",
                "EHms": "E HH:mm:ss",
                "Gy": "y G",
                "GyMMM": "MMM y G",
                "GyMMMd": "MMM d, y G",
                "GyMMMEd": "E, MMM d, y G",
                "h": "h a",
                "H": "HH",
                "hm": "h:mm a",
                "Hm": "HH:mm",
                "hms": "h:mm:ss a",
                "Hms": "HH:mm:ss",
                "hmsv": "h:mm:ss a v",
                "Hmsv": "HH:mm:ss v",
                "hmv": "h:mm a v",
                "Hmv": "HH:mm v",
                "M": "L",
                "Md": "M/d",
                "MEd": "E, M/d",
                "MMM": "LLL",
                "MMMd": "MMM d",
                "MMMEd": "E, MMM d",
                "MMMMd": "MMMM d",
                "MMMMW-count-one": "'week' W 'of' MMMM",
                "MMMMW-count-other": "'week' W 'of' MMMM",
                "ms": "mm:ss",
                "y": "y",
                "yM": "M/y",
                "yMd": "M/d/y",
                "yMEd": "E, M/d/y",
                "yMMM": "MMM y",
                "yMMMd": "MMM d, y",
                "yMMMEd": "E, MMM d, y",
                "yMMMM": "MMMM y",
                "yQQQ": "QQQ y",
                "yQQQQ": "QQQQ y",
                "yw-count-one": "'week' w 'of' Y",
                "yw-count-other": "'week' w 'of' Y"
              }
            }
          }
        }
      },
      "numbers": {
        "defaultNumberingSystem": "latn",
        "otherNumberingSystems": {
          "native": "latn"
        },
        "minimumGroupingDigits": "1",
        "symbols-numberSystem-latn": {
          "decimal": ".",
          "group": ",",
          "list": ";",
          "percentSign": "%",
          "plusSign": "+",
          "minusSign": "-",
          "exponential": "E",
          "superscriptingExponent": "",
          "perMille": "",
          "infinity": "",
          "nan": "NaN",
          "timeSeparator": ":"
        },
        "decimalFormats-numberSystem-latn": {
          "standard": "#,##0.###"
        },
        "scientificFormats-numberSystem-latn": {
          "standard": "#E0"
        },
        "percentFormats-numberSystem-latn": {
          "standard": "#,##0%"
        },
        "currencyFormats-numberSystem-latn": {
          "currencySpacing": {
            "beforeCurrency": {
              "currencyMatch": "[:^S:]",
              "surroundingMatch": "[:digit:]",
              "insertBetween": ""
            },
            "afterCurrency": {
              "currencyMatch": "[:^S:]",
              "surroundingMatch": "[:digit:]",
              "insertBetween": ""
            }
          },
          "standard": "#,##0.00",
          "accounting": "#,##0.00;(#,##0.00)"
        },
        "currencies": {
          "ADP": {
            "symbol": "ADP"
          },
          "AED": {
            "symbol": "AED"
          },
          "AFA": {
            "symbol": "AFA"
          },
          "AFN": {
            "symbol": "AFN"
          },
          "ALK": {
            "symbol": "ALK"
          },
          "ALL": {
            "symbol": "ALL"
          },
          "AMD": {
            "symbol": "AMD"
          },
          "ANG": {
            "symbol": "ANG"
          },
          "AOA": {
            "symbol": "AOA",
            "symbol-alt-narrow": "Kz"
          },
          "AOK": {
            "symbol": "AOK"
          },
          "AON": {
            "symbol": "AON"
          },
          "AOR": {
            "symbol": "AOR"
          },
          "ARA": {
            "symbol": "ARA"
          },
          "ARL": {
            "symbol": "ARL"
          },
          "ARM": {
            "symbol": "ARM"
          },
          "ARP": {
            "symbol": "ARP"
          },
          "ARS": {
            "symbol": "ARS",
            "symbol-alt-narrow": "$"
          },
          "ATS": {
            "symbol": "ATS"
          },
          "AUD": {
            "symbol": "A$",
            "symbol-alt-narrow": "$"
          },
          "AWG": {
            "symbol": "AWG"
          },
          "AZM": {
            "symbol": "AZM"
          },
          "AZN": {
            "symbol": "AZN"
          },
          "BAD": {
            "symbol": "BAD"
          },
          "BAM": {
            "symbol": "BAM",
            "symbol-alt-narrow": "KM"
          },
          "BAN": {
            "symbol": "BAN"
          },
          "BBD": {
            "symbol": "BBD",
            "symbol-alt-narrow": "$"
          },
          "BDT": {
            "symbol": "BDT",
            "symbol-alt-narrow": ""
          },
          "BEC": {
            "symbol": "BEC"
          },
          "BEF": {
            "symbol": "BEF"
          },
          "BEL": {
            "symbol": "BEL"
          },
          "BGL": {
            "symbol": "BGL"
          },
          "BGM": {
            "symbol": "BGM"
          },
          "BGN": {
            "symbol": "BGN"
          },
          "BGO": {
            "symbol": "BGO"
          },
          "BHD": {
            "symbol": "BHD"
          },
          "BIF": {
            "symbol": "BIF"
          },
          "BMD": {
            "symbol": "BMD",
            "symbol-alt-narrow": "$"
          },
          "BND": {
            "symbol": "BND",
            "symbol-alt-narrow": "$"
          },
          "BOB": {
            "symbol": "BOB",
            "symbol-alt-narrow": "Bs"
          },
          "BOL": {
            "symbol": "BOL"
          },
          "BOP": {
            "symbol": "BOP"
          },
          "BOV": {
            "symbol": "BOV"
          },
          "BRB": {
            "symbol": "BRB"
          },
          "BRC": {
            "symbol": "BRC"
          },
          "BRE": {
            "symbol": "BRE"
          },
          "BRL": {
            "symbol": "R$",
            "symbol-alt-narrow": "R$"
          },
          "BRN": {
            "symbol": "BRN"
          },
          "BRR": {
            "symbol": "BRR"
          },
          "BRZ": {
            "symbol": "BRZ"
          },
          "BSD": {
            "symbol": "BSD",
            "symbol-alt-narrow": "$"
          },
          "BTN": {
            "symbol": "BTN"
          },
          "BUK": {
            "symbol": "BUK"
          },
          "BWP": {
            "symbol": "BWP",
            "symbol-alt-narrow": "P"
          },
          "BYB": {
            "symbol": "BYB"
          },
          "BYN": {
            "symbol": "BYN",
            "symbol-alt-narrow": "."
          },
          "BYR": {
            "symbol": "BYR"
          },
          "BZD": {
            "symbol": "BZD",
            "symbol-alt-narrow": "$"
          },
          "CAD": {
            "symbol": "CA$",
            "symbol-alt-narrow": "$"
          },
          "CDF": {
            "symbol": "CDF"
          },
          "CHE": {
            "symbol": "CHE"
          },
          "CHF": {
            "symbol": "CHF"
          },
          "CHW": {
            "symbol": "CHW"
          },
          "CLE": {
            "symbol": "CLE"
          },
          "CLF": {
            "symbol": "CLF"
          },
          "CLP": {
            "symbol": "CLP",
            "symbol-alt-narrow": "$"
          },
          "CNH": {
            "symbol": "CNH"
          },
          "CNX": {
            "symbol": "CNX"
          },
          "CNY": {
            "symbol": "CN",
            "symbol-alt-narrow": ""
          },
          "COP": {
            "symbol": "COP",
            "symbol-alt-narrow": "$"
          },
          "COU": {
            "symbol": "COU"
          },
          "CRC": {
            "symbol": "CRC",
            "symbol-alt-narrow": ""
          },
          "CSD": {
            "symbol": "CSD"
          },
          "CSK": {
            "symbol": "CSK"
          },
          "CUC": {
            "symbol": "CUC",
            "symbol-alt-narrow": "$"
          },
          "CUP": {
            "symbol": "CUP",
            "symbol-alt-narrow": "$"
          },
          "CVE": {
            "symbol": "CVE"
          },
          "CYP": {
            "symbol": "CYP"
          },
          "CZK": {
            "symbol": "CZK",
            "symbol-alt-narrow": "K"
          },
          "DDM": {
            "symbol": "DDM"
          },
          "DEM": {
            "symbol": "DEM"
          },
          "DJF": {
            "symbol": "DJF"
          },
          "DKK": {
            "symbol": "DKK",
            "symbol-alt-narrow": "kr"
          },
          "DOP": {
            "symbol": "DOP",
            "symbol-alt-narrow": "$"
          },
          "DZD": {
            "symbol": "DZD"
          },
          "ECS": {
            "symbol": "ECS"
          },
          "ECV": {
            "symbol": "ECV"
          },
          "EEK": {
            "symbol": "EEK"
          },
          "EGP": {
            "symbol": "EGP",
            "symbol-alt-narrow": "E"
          },
          "ERN": {
            "symbol": "ERN"
          },
          "ESA": {
            "symbol": "ESA"
          },
          "ESB": {
            "symbol": "ESB"
          },
          "ESP": {
            "symbol": "ESP",
            "symbol-alt-narrow": ""
          },
          "ETB": {
            "symbol": "ETB"
          },
          "EUR": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "FIM": {
            "symbol": "FIM"
          },
          "FJD": {
            "symbol": "FJD",
            "symbol-alt-narrow": "$"
          },
          "FKP": {
            "symbol": "FKP",
            "symbol-alt-narrow": ""
          },
          "FRF": {
            "symbol": "FRF"
          },
          "GBP": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "GEK": {
            "symbol": "GEK"
          },
          "GEL": {
            "symbol": "GEL",
            "symbol-alt-narrow": ""
          },
          "GHC": {
            "symbol": "GHC"
          },
          "GHS": {
            "symbol": "GHS"
          },
          "GIP": {
            "symbol": "GIP",
            "symbol-alt-narrow": ""
          },
          "GMD": {
            "symbol": "GMD"
          },
          "GNF": {
            "symbol": "GNF",
            "symbol-alt-narrow": "FG"
          },
          "GNS": {
            "symbol": "GNS"
          },
          "GQE": {
            "symbol": "GQE"
          },
          "GRD": {
            "symbol": "GRD"
          },
          "GTQ": {
            "symbol": "GTQ",
            "symbol-alt-narrow": "Q"
          },
          "GWE": {
            "symbol": "GWE"
          },
          "GWP": {
            "symbol": "GWP"
          },
          "GYD": {
            "symbol": "GYD",
            "symbol-alt-narrow": "$"
          },
          "HKD": {
            "symbol": "HK$",
            "symbol-alt-narrow": "$"
          },
          "HNL": {
            "symbol": "HNL",
            "symbol-alt-narrow": "L"
          },
          "HRD": {
            "symbol": "HRD"
          },
          "HRK": {
            "symbol": "HRK",
            "symbol-alt-narrow": "kn"
          },
          "HTG": {
            "symbol": "HTG"
          },
          "HUF": {
            "symbol": "HUF",
            "symbol-alt-narrow": "Ft"
          },
          "IDR": {
            "symbol": "IDR",
            "symbol-alt-narrow": "Rp"
          },
          "IEP": {
            "symbol": "IEP"
          },
          "ILP": {
            "symbol": "ILP"
          },
          "ILR": {
            "symbol": "ILR"
          },
          "ILS": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "INR": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "IQD": {
            "symbol": "IQD"
          },
          "IRR": {
            "symbol": "IRR"
          },
          "ISJ": {
            "symbol": "ISJ"
          },
          "ISK": {
            "symbol": "ISK",
            "symbol-alt-narrow": "kr"
          },
          "ITL": {
            "symbol": "ITL"
          },
          "JMD": {
            "symbol": "JMD",
            "symbol-alt-narrow": "$"
          },
          "JOD": {
            "symbol": "JOD"
          },
          "JPY": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "KES": {
            "symbol": "KES"
          },
          "KGS": {
            "symbol": "KGS"
          },
          "KHR": {
            "symbol": "KHR",
            "symbol-alt-narrow": ""
          },
          "KMF": {
            "symbol": "KMF",
            "symbol-alt-narrow": "CF"
          },
          "KPW": {
            "symbol": "KPW",
            "symbol-alt-narrow": ""
          },
          "KRH": {
            "symbol": "KRH"
          },
          "KRO": {
            "symbol": "KRO"
          },
          "KRW": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "KWD": {
            "symbol": "KWD"
          },
          "KYD": {
            "symbol": "KYD",
            "symbol-alt-narrow": "$"
          },
          "KZT": {
            "symbol": "KZT",
            "symbol-alt-narrow": ""
          },
          "LAK": {
            "symbol": "LAK",
            "symbol-alt-narrow": ""
          },
          "LBP": {
            "symbol": "LBP",
            "symbol-alt-narrow": "L"
          },
          "LKR": {
            "symbol": "LKR",
            "symbol-alt-narrow": "Rs"
          },
          "LRD": {
            "symbol": "LRD",
            "symbol-alt-narrow": "$"
          },
          "LSL": {
            "symbol": "LSL"
          },
          "LTL": {
            "symbol": "LTL",
            "symbol-alt-narrow": "Lt"
          },
          "LTT": {
            "symbol": "LTT"
          },
          "LUC": {
            "symbol": "LUC"
          },
          "LUF": {
            "symbol": "LUF"
          },
          "LUL": {
            "symbol": "LUL"
          },
          "LVL": {
            "symbol": "LVL",
            "symbol-alt-narrow": "Ls"
          },
          "LVR": {
            "symbol": "LVR"
          },
          "LYD": {
            "symbol": "LYD"
          },
          "MAD": {
            "symbol": "MAD"
          },
          "MAF": {
            "symbol": "MAF"
          },
          "MCF": {
            "symbol": "MCF"
          },
          "MDC": {
            "symbol": "MDC"
          },
          "MDL": {
            "symbol": "MDL"
          },
          "MGA": {
            "symbol": "MGA",
            "symbol-alt-narrow": "Ar"
          },
          "MGF": {
            "symbol": "MGF"
          },
          "MKD": {
            "symbol": "MKD"
          },
          "MKN": {
            "symbol": "MKN"
          },
          "MLF": {
            "symbol": "MLF"
          },
          "MMK": {
            "symbol": "MMK",
            "symbol-alt-narrow": "K"
          },
          "MNT": {
            "symbol": "MNT",
            "symbol-alt-narrow": ""
          },
          "MOP": {
            "symbol": "MOP"
          },
          "MRO": {
            "symbol": "MRO"
          },
          "MRU": {
            "symbol": "MRU"
          },
          "MTL": {
            "symbol": "MTL"
          },
          "MTP": {
            "symbol": "MTP"
          },
          "MUR": {
            "symbol": "MUR",
            "symbol-alt-narrow": "Rs"
          },
          "MVP": {
            "symbol": "MVP"
          },
          "MVR": {
            "symbol": "MVR"
          },
          "MWK": {
            "symbol": "MWK"
          },
          "MXN": {
            "symbol": "MX$",
            "symbol-alt-narrow": "$"
          },
          "MXP": {
            "symbol": "MXP"
          },
          "MXV": {
            "symbol": "MXV"
          },
          "MYR": {
            "symbol": "MYR",
            "symbol-alt-narrow": "RM"
          },
          "MZE": {
            "symbol": "MZE"
          },
          "MZM": {
            "symbol": "MZM"
          },
          "MZN": {
            "symbol": "MZN"
          },
          "NAD": {
            "symbol": "NAD",
            "symbol-alt-narrow": "$"
          },
          "NGN": {
            "symbol": "NGN",
            "symbol-alt-narrow": ""
          },
          "NIC": {
            "symbol": "NIC"
          },
          "NIO": {
            "symbol": "NIO",
            "symbol-alt-narrow": "C$"
          },
          "NLG": {
            "symbol": "NLG"
          },
          "NOK": {
            "symbol": "NOK",
            "symbol-alt-narrow": "kr"
          },
          "NPR": {
            "symbol": "NPR",
            "symbol-alt-narrow": "Rs"
          },
          "NZD": {
            "symbol": "NZ$",
            "symbol-alt-narrow": "$"
          },
          "OMR": {
            "symbol": "OMR"
          },
          "PAB": {
            "symbol": "PAB"
          },
          "PEI": {
            "symbol": "PEI"
          },
          "PEN": {
            "symbol": "PEN"
          },
          "PES": {
            "symbol": "PES"
          },
          "PGK": {
            "symbol": "PGK"
          },
          "PHP": {
            "symbol": "PHP",
            "symbol-alt-narrow": ""
          },
          "PKR": {
            "symbol": "PKR",
            "symbol-alt-narrow": "Rs"
          },
          "PLN": {
            "symbol": "PLN",
            "symbol-alt-narrow": "z"
          },
          "PLZ": {
            "symbol": "PLZ"
          },
          "PTE": {
            "symbol": "PTE"
          },
          "PYG": {
            "symbol": "PYG",
            "symbol-alt-narrow": ""
          },
          "QAR": {
            "symbol": "QAR"
          },
          "RHD": {
            "symbol": "RHD"
          },
          "ROL": {
            "symbol": "ROL"
          },
          "RON": {
            "symbol": "RON",
            "symbol-alt-narrow": "lei"
          },
          "RSD": {
            "symbol": "RSD"
          },
          "RUB": {
            "symbol": "RUB",
            "symbol-alt-narrow": ""
          },
          "RUR": {
            "symbol": "RUR",
            "symbol-alt-narrow": "."
          },
          "RWF": {
            "symbol": "RWF",
            "symbol-alt-narrow": "RF"
          },
          "SAR": {
            "symbol": "SAR"
          },
          "SBD": {
            "symbol": "SBD",
            "symbol-alt-narrow": "$"
          },
          "SCR": {
            "symbol": "SCR"
          },
          "SDD": {
            "symbol": "SDD"
          },
          "SDG": {
            "symbol": "SDG"
          },
          "SDP": {
            "symbol": "SDP"
          },
          "SEK": {
            "symbol": "SEK",
            "symbol-alt-narrow": "kr"
          },
          "SGD": {
            "symbol": "SGD",
            "symbol-alt-narrow": "$"
          },
          "SHP": {
            "symbol": "SHP",
            "symbol-alt-narrow": ""
          },
          "SIT": {
            "symbol": "SIT"
          },
          "SKK": {
            "symbol": "SKK"
          },
          "SLL": {
            "symbol": "SLL"
          },
          "SOS": {
            "symbol": "SOS"
          },
          "SRD": {
            "symbol": "SRD",
            "symbol-alt-narrow": "$"
          },
          "SRG": {
            "symbol": "SRG"
          },
          "SSP": {
            "symbol": "SSP",
            "symbol-alt-narrow": ""
          },
          "STD": {
            "symbol": "STD"
          },
          "STN": {
            "symbol": "STN",
            "symbol-alt-narrow": "Db"
          },
          "SUR": {
            "symbol": "SUR"
          },
          "SVC": {
            "symbol": "SVC"
          },
          "SYP": {
            "symbol": "SYP",
            "symbol-alt-narrow": ""
          },
          "SZL": {
            "symbol": "SZL"
          },
          "THB": {
            "symbol": "THB",
            "symbol-alt-narrow": ""
          },
          "TJR": {
            "symbol": "TJR"
          },
          "TJS": {
            "symbol": "TJS"
          },
          "TMM": {
            "symbol": "TMM"
          },
          "TMT": {
            "symbol": "TMT"
          },
          "TND": {
            "symbol": "TND"
          },
          "TOP": {
            "symbol": "TOP",
            "symbol-alt-narrow": "T$"
          },
          "TPE": {
            "symbol": "TPE"
          },
          "TRL": {
            "symbol": "TRL"
          },
          "TRY": {
            "symbol": "TRY",
            "symbol-alt-narrow": ""
          },
          "TTD": {
            "symbol": "TTD",
            "symbol-alt-narrow": "$"
          },
          "TWD": {
            "symbol": "NT$",
            "symbol-alt-narrow": "$"
          },
          "TZS": {
            "symbol": "TZS"
          },
          "UAH": {
            "symbol": "UAH",
            "symbol-alt-narrow": ""
          },
          "UAK": {
            "symbol": "UAK"
          },
          "UGS": {
            "symbol": "UGS"
          },
          "UGX": {
            "symbol": "UGX"
          },
          "USD": {
            "symbol": "$",
            "symbol-alt-narrow": "$"
          },
          "USN": {
            "symbol": "USN"
          },
          "USS": {
            "symbol": "USS"
          },
          "UYI": {
            "symbol": "UYI"
          },
          "UYP": {
            "symbol": "UYP"
          },
          "UYU": {
            "symbol": "UYU",
            "symbol-alt-narrow": "$"
          },
          "UYW": {
            "symbol": "UYW"
          },
          "UZS": {
            "symbol": "UZS"
          },
          "VEB": {
            "symbol": "VEB"
          },
          "VEF": {
            "symbol": "VEF",
            "symbol-alt-narrow": "Bs"
          },
          "VES": {
            "symbol": "VES"
          },
          "VND": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "VNN": {
            "symbol": "VNN"
          },
          "VUV": {
            "symbol": "VUV"
          },
          "WST": {
            "symbol": "WST"
          },
          "XAF": {
            "symbol": "FCFA"
          },
          "XAG": {
            "symbol": "XAG"
          },
          "XAU": {
            "symbol": "XAU"
          },
          "XBA": {
            "symbol": "XBA"
          },
          "XBB": {
            "symbol": "XBB"
          },
          "XBC": {
            "symbol": "XBC"
          },
          "XBD": {
            "symbol": "XBD"
          },
          "XCD": {
            "symbol": "EC$",
            "symbol-alt-narrow": "$"
          },
          "XDR": {
            "symbol": "XDR"
          },
          "XEU": {
            "symbol": "XEU"
          },
          "XFO": {
            "symbol": "XFO"
          },
          "XFU": {
            "symbol": "XFU"
          },
          "XOF": {
            "symbol": "CFA"
          },
          "XPD": {
            "symbol": "XPD"
          },
          "XPF": {
            "symbol": "CFPF"
          },
          "XPT": {
            "symbol": "XPT"
          },
          "XRE": {
            "symbol": "XRE"
          },
          "XSU": {
            "symbol": "XSU"
          },
          "XTS": {
            "symbol": "XTS"
          },
          "XUA": {
            "symbol": "XUA"
          },
          "XXX": {
            "symbol": ""
          },
          "YDD": {
            "symbol": "YDD"
          },
          "YER": {
            "symbol": "YER"
          },
          "YUD": {
            "symbol": "YUD"
          },
          "YUM": {
            "symbol": "YUM"
          },
          "YUN": {
            "symbol": "YUN"
          },
          "YUR": {
            "symbol": "YUR"
          },
          "ZAL": {
            "symbol": "ZAL"
          },
          "ZAR": {
            "symbol": "ZAR",
            "symbol-alt-narrow": "R"
          },
          "ZMK": {
            "symbol": "ZMK"
          },
          "ZMW": {
            "symbol": "ZMW",
            "symbol-alt-narrow": "ZK"
          },
          "ZRN": {
            "symbol": "ZRN"
          },
          "ZRZ": {
            "symbol": "ZRZ"
          },
          "ZWD": {
            "symbol": "ZWD"
          },
          "ZWL": {
            "symbol": "ZWL"
          },
          "ZWR": {
            "symbol": "ZWR"
          }
        }
      }
    }
  }
};

/***/ }),

/***/ 92286:
/***/ (function(module, exports) {



exports["default"] = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = exports["default"] = {
  "af-NA": 1,
  "agq": 1,
  "ak": 1,
  "ar": 6,
  "ar-EH": 1,
  "ar-ER": 1,
  "ar-KM": 1,
  "ar-LB": 1,
  "ar-MA": 1,
  "ar-MR": 1,
  "ar-PS": 1,
  "ar-SO": 1,
  "ar-SS": 1,
  "ar-TD": 1,
  "ar-TN": 1,
  "asa": 1,
  "ast": 1,
  "az": 1,
  "az-Cyrl": 1,
  "bas": 1,
  "be": 1,
  "bem": 1,
  "bez": 1,
  "bg": 1,
  "bm": 1,
  "br": 1,
  "bs": 1,
  "bs-Cyrl": 1,
  "ca": 1,
  "ce": 1,
  "cgg": 1,
  "ckb": 6,
  "cs": 1,
  "cy": 1,
  "da": 1,
  "de": 1,
  "dje": 1,
  "dsb": 1,
  "dua": 1,
  "dyo": 1,
  "ee": 1,
  "el": 1,
  "en-001": 1,
  "en-AE": 6,
  "en-BI": 1,
  "en-MP": 1,
  "en-MV": 5,
  "en-SD": 6,
  "eo": 1,
  "es": 1,
  "et": 1,
  "eu": 1,
  "ewo": 1,
  "fa": 6,
  "ff": 1,
  "ff-Adlm": 1,
  "fi": 1,
  "fo": 1,
  "fr": 1,
  "fr-DJ": 6,
  "fr-DZ": 6,
  "fr-SY": 6,
  "fur": 1,
  "fy": 1,
  "ga": 1,
  "gd": 1,
  "gl": 1,
  "gsw": 1,
  "gv": 1,
  "ha": 1,
  "hr": 1,
  "hsb": 1,
  "hu": 1,
  "hy": 1,
  "ia": 1,
  "ig": 1,
  "is": 1,
  "it": 1,
  "jgo": 1,
  "jmc": 1,
  "ka": 1,
  "kab": 6,
  "kde": 1,
  "kea": 1,
  "khq": 1,
  "kk": 1,
  "kkj": 1,
  "kl": 1,
  "ko-KP": 1,
  "ksb": 1,
  "ksf": 1,
  "ksh": 1,
  "ku": 1,
  "kw": 1,
  "ky": 1,
  "lag": 1,
  "lb": 1,
  "lg": 1,
  "ln": 1,
  "lrc": 6,
  "lt": 1,
  "lu": 1,
  "lv": 1,
  "mas-TZ": 1,
  "mfe": 1,
  "mg": 1,
  "mgo": 1,
  "mi": 1,
  "mk": 1,
  "mn": 1,
  "ms": 1,
  "mua": 1,
  "mzn": 6,
  "naq": 1,
  "nds": 1,
  "nl": 1,
  "nmg": 1,
  "nnh": 1,
  "no": 1,
  "nus": 1,
  "nyn": 1,
  "os": 1,
  "pcm": 1,
  "pl": 1,
  "ps": 6,
  "pt-AO": 1,
  "pt-CH": 1,
  "pt-CV": 1,
  "pt-GQ": 1,
  "pt-GW": 1,
  "pt-LU": 1,
  "pt-ST": 1,
  "pt-TL": 1,
  "qu-BO": 1,
  "qu-EC": 1,
  "rm": 1,
  "rn": 1,
  "ro": 1,
  "rof": 1,
  "ru": 1,
  "rw": 1,
  "rwk": 1,
  "sah": 1,
  "sbp": 1,
  "sc": 1,
  "se": 1,
  "ses": 1,
  "sg": 1,
  "shi": 1,
  "shi-Latn": 1,
  "si": 1,
  "sk": 1,
  "sl": 1,
  "smn": 1,
  "so": 1,
  "so-DJ": 6,
  "sq": 1,
  "sr": 1,
  "sr-Latn": 1,
  "sv": 1,
  "sw": 1,
  "ta-LK": 1,
  "ta-MY": 1,
  "teo": 1,
  "tg": 1,
  "ti-ER": 1,
  "tk": 1,
  "to": 1,
  "tr": 1,
  "tt": 1,
  "twq": 1,
  "tzm": 1,
  "uk": 1,
  "uz": 1,
  "uz-Arab": 6,
  "uz-Cyrl": 1,
  "vai": 1,
  "vai-Latn": 1,
  "vi": 1,
  "vun": 1,
  "wae": 1,
  "wo": 1,
  "xog": 1,
  "yav": 1,
  "yi": 1,
  "yo": 1,
  "zgh": 1
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 73806:
/***/ (function(module, exports) {



exports["default"] = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = exports["default"] = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MV": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "hi-Latn": "en-IN",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  "nb": "no",
  "nn": "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "und",
  "az-Cyrl": "und",
  "bal-Latn": "und",
  "blt-Latn": "und",
  "bm-Nkoo": "und",
  "bs-Cyrl": "und",
  "byn-Latn": "und",
  "cu-Glag": "und",
  "dje-Arab": "und",
  "dyo-Arab": "und",
  "en-Dsrt": "und",
  "en-Shaw": "und",
  "ff-Adlm": "und",
  "ff-Arab": "und",
  "ha-Arab": "und",
  "iu-Latn": "und",
  "kk-Arab": "und",
  "ks-Deva": "und",
  "ku-Arab": "und",
  "ky-Arab": "und",
  "ky-Latn": "und",
  "ml-Arab": "und",
  "mn-Mong": "und",
  "mni-Mtei": "und",
  "ms-Arab": "und",
  "pa-Arab": "und",
  "sat-Deva": "und",
  "sd-Deva": "und",
  "sd-Khoj": "und",
  "sd-Sind": "und",
  "shi-Latn": "und",
  "so-Arab": "und",
  "sr-Latn": "und",
  "sw-Arab": "und",
  "tg-Arab": "und",
  "ug-Cyrl": "und",
  "uz-Arab": "und",
  "uz-Cyrl": "und",
  "vai-Latn": "und",
  "wo-Arab": "und",
  "yo-Arab": "und",
  "yue-Hans": "und",
  "zh-Hant": "und",
  "zh-Hant-MO": "zh-Hant-HK"
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 57421:
/***/ (function(__unused_webpack_module, exports) {



exports.supplementalCldr = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
const supplementalCldr = exports.supplementalCldr = {
  "supplemental": {
    "version": {
      "_unicodeVersion": "12.1.0",
      "_cldrVersion": "36"
    },
    "likelySubtags": {
      "aa": "aa-Latn-ET",
      "aai": "aai-Latn-ZZ",
      "aak": "aak-Latn-ZZ",
      "aau": "aau-Latn-ZZ",
      "ab": "ab-Cyrl-GE",
      "abi": "abi-Latn-ZZ",
      "abq": "abq-Cyrl-ZZ",
      "abr": "abr-Latn-GH",
      "abt": "abt-Latn-ZZ",
      "aby": "aby-Latn-ZZ",
      "acd": "acd-Latn-ZZ",
      "ace": "ace-Latn-ID",
      "ach": "ach-Latn-UG",
      "ada": "ada-Latn-GH",
      "ade": "ade-Latn-ZZ",
      "adj": "adj-Latn-ZZ",
      "adp": "adp-Tibt-BT",
      "ady": "ady-Cyrl-RU",
      "adz": "adz-Latn-ZZ",
      "ae": "ae-Avst-IR",
      "aeb": "aeb-Arab-TN",
      "aey": "aey-Latn-ZZ",
      "af": "af-Latn-ZA",
      "agc": "agc-Latn-ZZ",
      "agd": "agd-Latn-ZZ",
      "agg": "agg-Latn-ZZ",
      "agm": "agm-Latn-ZZ",
      "ago": "ago-Latn-ZZ",
      "agq": "agq-Latn-CM",
      "aha": "aha-Latn-ZZ",
      "ahl": "ahl-Latn-ZZ",
      "aho": "aho-Ahom-IN",
      "ajg": "ajg-Latn-ZZ",
      "ak": "ak-Latn-GH",
      "akk": "akk-Xsux-IQ",
      "ala": "ala-Latn-ZZ",
      "ali": "ali-Latn-ZZ",
      "aln": "aln-Latn-XK",
      "alt": "alt-Cyrl-RU",
      "am": "am-Ethi-ET",
      "amm": "amm-Latn-ZZ",
      "amn": "amn-Latn-ZZ",
      "amo": "amo-Latn-NG",
      "amp": "amp-Latn-ZZ",
      "an": "an-Latn-ES",
      "anc": "anc-Latn-ZZ",
      "ank": "ank-Latn-ZZ",
      "ann": "ann-Latn-ZZ",
      "any": "any-Latn-ZZ",
      "aoj": "aoj-Latn-ZZ",
      "aom": "aom-Latn-ZZ",
      "aoz": "aoz-Latn-ID",
      "apc": "apc-Arab-ZZ",
      "apd": "apd-Arab-TG",
      "ape": "ape-Latn-ZZ",
      "apr": "apr-Latn-ZZ",
      "aps": "aps-Latn-ZZ",
      "apz": "apz-Latn-ZZ",
      "ar": "ar-Arab-EG",
      "arc": "arc-Armi-IR",
      "arc-Nbat": "arc-Nbat-JO",
      "arc-Palm": "arc-Palm-SY",
      "arh": "arh-Latn-ZZ",
      "arn": "arn-Latn-CL",
      "aro": "aro-Latn-BO",
      "arq": "arq-Arab-DZ",
      "ars": "ars-Arab-SA",
      "ary": "ary-Arab-MA",
      "arz": "arz-Arab-EG",
      "as": "as-Beng-IN",
      "asa": "asa-Latn-TZ",
      "ase": "ase-Sgnw-US",
      "asg": "asg-Latn-ZZ",
      "aso": "aso-Latn-ZZ",
      "ast": "ast-Latn-ES",
      "ata": "ata-Latn-ZZ",
      "atg": "atg-Latn-ZZ",
      "atj": "atj-Latn-CA",
      "auy": "auy-Latn-ZZ",
      "av": "av-Cyrl-RU",
      "avl": "avl-Arab-ZZ",
      "avn": "avn-Latn-ZZ",
      "avt": "avt-Latn-ZZ",
      "avu": "avu-Latn-ZZ",
      "awa": "awa-Deva-IN",
      "awb": "awb-Latn-ZZ",
      "awo": "awo-Latn-ZZ",
      "awx": "awx-Latn-ZZ",
      "ay": "ay-Latn-BO",
      "ayb": "ayb-Latn-ZZ",
      "az": "az-Latn-AZ",
      "az-Arab": "az-Arab-IR",
      "az-IQ": "az-Arab-IQ",
      "az-IR": "az-Arab-IR",
      "az-RU": "az-Cyrl-RU",
      "ba": "ba-Cyrl-RU",
      "bal": "bal-Arab-PK",
      "ban": "ban-Latn-ID",
      "bap": "bap-Deva-NP",
      "bar": "bar-Latn-AT",
      "bas": "bas-Latn-CM",
      "bav": "bav-Latn-ZZ",
      "bax": "bax-Bamu-CM",
      "bba": "bba-Latn-ZZ",
      "bbb": "bbb-Latn-ZZ",
      "bbc": "bbc-Latn-ID",
      "bbd": "bbd-Latn-ZZ",
      "bbj": "bbj-Latn-CM",
      "bbp": "bbp-Latn-ZZ",
      "bbr": "bbr-Latn-ZZ",
      "bcf": "bcf-Latn-ZZ",
      "bch": "bch-Latn-ZZ",
      "bci": "bci-Latn-CI",
      "bcm": "bcm-Latn-ZZ",
      "bcn": "bcn-Latn-ZZ",
      "bco": "bco-Latn-ZZ",
      "bcq": "bcq-Ethi-ZZ",
      "bcu": "bcu-Latn-ZZ",
      "bdd": "bdd-Latn-ZZ",
      "be": "be-Cyrl-BY",
      "bef": "bef-Latn-ZZ",
      "beh": "beh-Latn-ZZ",
      "bej": "bej-Arab-SD",
      "bem": "bem-Latn-ZM",
      "bet": "bet-Latn-ZZ",
      "bew": "bew-Latn-ID",
      "bex": "bex-Latn-ZZ",
      "bez": "bez-Latn-TZ",
      "bfd": "bfd-Latn-CM",
      "bfq": "bfq-Taml-IN",
      "bft": "bft-Arab-PK",
      "bfy": "bfy-Deva-IN",
      "bg": "bg-Cyrl-BG",
      "bgc": "bgc-Deva-IN",
      "bgn": "bgn-Arab-PK",
      "bgx": "bgx-Grek-TR",
      "bhb": "bhb-Deva-IN",
      "bhg": "bhg-Latn-ZZ",
      "bhi": "bhi-Deva-IN",
      "bhl": "bhl-Latn-ZZ",
      "bho": "bho-Deva-IN",
      "bhy": "bhy-Latn-ZZ",
      "bi": "bi-Latn-VU",
      "bib": "bib-Latn-ZZ",
      "big": "big-Latn-ZZ",
      "bik": "bik-Latn-PH",
      "bim": "bim-Latn-ZZ",
      "bin": "bin-Latn-NG",
      "bio": "bio-Latn-ZZ",
      "biq": "biq-Latn-ZZ",
      "bjh": "bjh-Latn-ZZ",
      "bji": "bji-Ethi-ZZ",
      "bjj": "bjj-Deva-IN",
      "bjn": "bjn-Latn-ID",
      "bjo": "bjo-Latn-ZZ",
      "bjr": "bjr-Latn-ZZ",
      "bjt": "bjt-Latn-SN",
      "bjz": "bjz-Latn-ZZ",
      "bkc": "bkc-Latn-ZZ",
      "bkm": "bkm-Latn-CM",
      "bkq": "bkq-Latn-ZZ",
      "bku": "bku-Latn-PH",
      "bkv": "bkv-Latn-ZZ",
      "blt": "blt-Tavt-VN",
      "bm": "bm-Latn-ML",
      "bmh": "bmh-Latn-ZZ",
      "bmk": "bmk-Latn-ZZ",
      "bmq": "bmq-Latn-ML",
      "bmu": "bmu-Latn-ZZ",
      "bn": "bn-Beng-BD",
      "bng": "bng-Latn-ZZ",
      "bnm": "bnm-Latn-ZZ",
      "bnp": "bnp-Latn-ZZ",
      "bo": "bo-Tibt-CN",
      "boj": "boj-Latn-ZZ",
      "bom": "bom-Latn-ZZ",
      "bon": "bon-Latn-ZZ",
      "bpy": "bpy-Beng-IN",
      "bqc": "bqc-Latn-ZZ",
      "bqi": "bqi-Arab-IR",
      "bqp": "bqp-Latn-ZZ",
      "bqv": "bqv-Latn-CI",
      "br": "br-Latn-FR",
      "bra": "bra-Deva-IN",
      "brh": "brh-Arab-PK",
      "brx": "brx-Deva-IN",
      "brz": "brz-Latn-ZZ",
      "bs": "bs-Latn-BA",
      "bsj": "bsj-Latn-ZZ",
      "bsq": "bsq-Bass-LR",
      "bss": "bss-Latn-CM",
      "bst": "bst-Ethi-ZZ",
      "bto": "bto-Latn-PH",
      "btt": "btt-Latn-ZZ",
      "btv": "btv-Deva-PK",
      "bua": "bua-Cyrl-RU",
      "buc": "buc-Latn-YT",
      "bud": "bud-Latn-ZZ",
      "bug": "bug-Latn-ID",
      "buk": "buk-Latn-ZZ",
      "bum": "bum-Latn-CM",
      "buo": "buo-Latn-ZZ",
      "bus": "bus-Latn-ZZ",
      "buu": "buu-Latn-ZZ",
      "bvb": "bvb-Latn-GQ",
      "bwd": "bwd-Latn-ZZ",
      "bwr": "bwr-Latn-ZZ",
      "bxh": "bxh-Latn-ZZ",
      "bye": "bye-Latn-ZZ",
      "byn": "byn-Ethi-ER",
      "byr": "byr-Latn-ZZ",
      "bys": "bys-Latn-ZZ",
      "byv": "byv-Latn-CM",
      "byx": "byx-Latn-ZZ",
      "bza": "bza-Latn-ZZ",
      "bze": "bze-Latn-ML",
      "bzf": "bzf-Latn-ZZ",
      "bzh": "bzh-Latn-ZZ",
      "bzw": "bzw-Latn-ZZ",
      "ca": "ca-Latn-ES",
      "can": "can-Latn-ZZ",
      "cbj": "cbj-Latn-ZZ",
      "cch": "cch-Latn-NG",
      "ccp": "ccp-Cakm-BD",
      "ce": "ce-Cyrl-RU",
      "ceb": "ceb-Latn-PH",
      "cfa": "cfa-Latn-ZZ",
      "cgg": "cgg-Latn-UG",
      "ch": "ch-Latn-GU",
      "chk": "chk-Latn-FM",
      "chm": "chm-Cyrl-RU",
      "cho": "cho-Latn-US",
      "chp": "chp-Latn-CA",
      "chr": "chr-Cher-US",
      "cic": "cic-Latn-US",
      "cja": "cja-Arab-KH",
      "cjm": "cjm-Cham-VN",
      "cjv": "cjv-Latn-ZZ",
      "ckb": "ckb-Arab-IQ",
      "ckl": "ckl-Latn-ZZ",
      "cko": "cko-Latn-ZZ",
      "cky": "cky-Latn-ZZ",
      "cla": "cla-Latn-ZZ",
      "cme": "cme-Latn-ZZ",
      "cmg": "cmg-Soyo-MN",
      "co": "co-Latn-FR",
      "cop": "cop-Copt-EG",
      "cps": "cps-Latn-PH",
      "cr": "cr-Cans-CA",
      "crh": "crh-Cyrl-UA",
      "crj": "crj-Cans-CA",
      "crk": "crk-Cans-CA",
      "crl": "crl-Cans-CA",
      "crm": "crm-Cans-CA",
      "crs": "crs-Latn-SC",
      "cs": "cs-Latn-CZ",
      "csb": "csb-Latn-PL",
      "csw": "csw-Cans-CA",
      "ctd": "ctd-Pauc-MM",
      "cu": "cu-Cyrl-RU",
      "cu-Glag": "cu-Glag-BG",
      "cv": "cv-Cyrl-RU",
      "cy": "cy-Latn-GB",
      "da": "da-Latn-DK",
      "dad": "dad-Latn-ZZ",
      "daf": "daf-Latn-ZZ",
      "dag": "dag-Latn-ZZ",
      "dah": "dah-Latn-ZZ",
      "dak": "dak-Latn-US",
      "dar": "dar-Cyrl-RU",
      "dav": "dav-Latn-KE",
      "dbd": "dbd-Latn-ZZ",
      "dbq": "dbq-Latn-ZZ",
      "dcc": "dcc-Arab-IN",
      "ddn": "ddn-Latn-ZZ",
      "de": "de-Latn-DE",
      "ded": "ded-Latn-ZZ",
      "den": "den-Latn-CA",
      "dga": "dga-Latn-ZZ",
      "dgh": "dgh-Latn-ZZ",
      "dgi": "dgi-Latn-ZZ",
      "dgl": "dgl-Arab-ZZ",
      "dgr": "dgr-Latn-CA",
      "dgz": "dgz-Latn-ZZ",
      "dia": "dia-Latn-ZZ",
      "dje": "dje-Latn-NE",
      "dnj": "dnj-Latn-CI",
      "dob": "dob-Latn-ZZ",
      "doi": "doi-Arab-IN",
      "dop": "dop-Latn-ZZ",
      "dow": "dow-Latn-ZZ",
      "drh": "drh-Mong-CN",
      "dri": "dri-Latn-ZZ",
      "drs": "drs-Ethi-ZZ",
      "dsb": "dsb-Latn-DE",
      "dtm": "dtm-Latn-ML",
      "dtp": "dtp-Latn-MY",
      "dts": "dts-Latn-ZZ",
      "dty": "dty-Deva-NP",
      "dua": "dua-Latn-CM",
      "duc": "duc-Latn-ZZ",
      "dud": "dud-Latn-ZZ",
      "dug": "dug-Latn-ZZ",
      "dv": "dv-Thaa-MV",
      "dva": "dva-Latn-ZZ",
      "dww": "dww-Latn-ZZ",
      "dyo": "dyo-Latn-SN",
      "dyu": "dyu-Latn-BF",
      "dz": "dz-Tibt-BT",
      "dzg": "dzg-Latn-ZZ",
      "ebu": "ebu-Latn-KE",
      "ee": "ee-Latn-GH",
      "efi": "efi-Latn-NG",
      "egl": "egl-Latn-IT",
      "egy": "egy-Egyp-EG",
      "eka": "eka-Latn-ZZ",
      "eky": "eky-Kali-MM",
      "el": "el-Grek-GR",
      "ema": "ema-Latn-ZZ",
      "emi": "emi-Latn-ZZ",
      "en": "en-Latn-US",
      "en-Shaw": "en-Shaw-GB",
      "enn": "enn-Latn-ZZ",
      "enq": "enq-Latn-ZZ",
      "eo": "eo-Latn-001",
      "eri": "eri-Latn-ZZ",
      "es": "es-Latn-ES",
      "esg": "esg-Gonm-IN",
      "esu": "esu-Latn-US",
      "et": "et-Latn-EE",
      "etr": "etr-Latn-ZZ",
      "ett": "ett-Ital-IT",
      "etu": "etu-Latn-ZZ",
      "etx": "etx-Latn-ZZ",
      "eu": "eu-Latn-ES",
      "ewo": "ewo-Latn-CM",
      "ext": "ext-Latn-ES",
      "fa": "fa-Arab-IR",
      "faa": "faa-Latn-ZZ",
      "fab": "fab-Latn-ZZ",
      "fag": "fag-Latn-ZZ",
      "fai": "fai-Latn-ZZ",
      "fan": "fan-Latn-GQ",
      "ff": "ff-Latn-SN",
      "ff-Adlm": "ff-Adlm-GN",
      "ffi": "ffi-Latn-ZZ",
      "ffm": "ffm-Latn-ML",
      "fi": "fi-Latn-FI",
      "fia": "fia-Arab-SD",
      "fil": "fil-Latn-PH",
      "fit": "fit-Latn-SE",
      "fj": "fj-Latn-FJ",
      "flr": "flr-Latn-ZZ",
      "fmp": "fmp-Latn-ZZ",
      "fo": "fo-Latn-FO",
      "fod": "fod-Latn-ZZ",
      "fon": "fon-Latn-BJ",
      "for": "for-Latn-ZZ",
      "fpe": "fpe-Latn-ZZ",
      "fqs": "fqs-Latn-ZZ",
      "fr": "fr-Latn-FR",
      "frc": "frc-Latn-US",
      "frp": "frp-Latn-FR",
      "frr": "frr-Latn-DE",
      "frs": "frs-Latn-DE",
      "fub": "fub-Arab-CM",
      "fud": "fud-Latn-WF",
      "fue": "fue-Latn-ZZ",
      "fuf": "fuf-Latn-GN",
      "fuh": "fuh-Latn-ZZ",
      "fuq": "fuq-Latn-NE",
      "fur": "fur-Latn-IT",
      "fuv": "fuv-Latn-NG",
      "fuy": "fuy-Latn-ZZ",
      "fvr": "fvr-Latn-SD",
      "fy": "fy-Latn-NL",
      "ga": "ga-Latn-IE",
      "gaa": "gaa-Latn-GH",
      "gaf": "gaf-Latn-ZZ",
      "gag": "gag-Latn-MD",
      "gah": "gah-Latn-ZZ",
      "gaj": "gaj-Latn-ZZ",
      "gam": "gam-Latn-ZZ",
      "gan": "gan-Hans-CN",
      "gaw": "gaw-Latn-ZZ",
      "gay": "gay-Latn-ID",
      "gba": "gba-Latn-ZZ",
      "gbf": "gbf-Latn-ZZ",
      "gbm": "gbm-Deva-IN",
      "gby": "gby-Latn-ZZ",
      "gbz": "gbz-Arab-IR",
      "gcr": "gcr-Latn-GF",
      "gd": "gd-Latn-GB",
      "gde": "gde-Latn-ZZ",
      "gdn": "gdn-Latn-ZZ",
      "gdr": "gdr-Latn-ZZ",
      "geb": "geb-Latn-ZZ",
      "gej": "gej-Latn-ZZ",
      "gel": "gel-Latn-ZZ",
      "gez": "gez-Ethi-ET",
      "gfk": "gfk-Latn-ZZ",
      "ggn": "ggn-Deva-NP",
      "ghs": "ghs-Latn-ZZ",
      "gil": "gil-Latn-KI",
      "gim": "gim-Latn-ZZ",
      "gjk": "gjk-Arab-PK",
      "gjn": "gjn-Latn-ZZ",
      "gju": "gju-Arab-PK",
      "gkn": "gkn-Latn-ZZ",
      "gkp": "gkp-Latn-ZZ",
      "gl": "gl-Latn-ES",
      "glk": "glk-Arab-IR",
      "gmm": "gmm-Latn-ZZ",
      "gmv": "gmv-Ethi-ZZ",
      "gn": "gn-Latn-PY",
      "gnd": "gnd-Latn-ZZ",
      "gng": "gng-Latn-ZZ",
      "god": "god-Latn-ZZ",
      "gof": "gof-Ethi-ZZ",
      "goi": "goi-Latn-ZZ",
      "gom": "gom-Deva-IN",
      "gon": "gon-Telu-IN",
      "gor": "gor-Latn-ID",
      "gos": "gos-Latn-NL",
      "got": "got-Goth-UA",
      "grb": "grb-Latn-ZZ",
      "grc": "grc-Cprt-CY",
      "grc-Linb": "grc-Linb-GR",
      "grt": "grt-Beng-IN",
      "grw": "grw-Latn-ZZ",
      "gsw": "gsw-Latn-CH",
      "gu": "gu-Gujr-IN",
      "gub": "gub-Latn-BR",
      "guc": "guc-Latn-CO",
      "gud": "gud-Latn-ZZ",
      "gur": "gur-Latn-GH",
      "guw": "guw-Latn-ZZ",
      "gux": "gux-Latn-ZZ",
      "guz": "guz-Latn-KE",
      "gv": "gv-Latn-IM",
      "gvf": "gvf-Latn-ZZ",
      "gvr": "gvr-Deva-NP",
      "gvs": "gvs-Latn-ZZ",
      "gwc": "gwc-Arab-ZZ",
      "gwi": "gwi-Latn-CA",
      "gwt": "gwt-Arab-ZZ",
      "gyi": "gyi-Latn-ZZ",
      "ha": "ha-Latn-NG",
      "ha-CM": "ha-Arab-CM",
      "ha-SD": "ha-Arab-SD",
      "hag": "hag-Latn-ZZ",
      "hak": "hak-Hans-CN",
      "ham": "ham-Latn-ZZ",
      "haw": "haw-Latn-US",
      "haz": "haz-Arab-AF",
      "hbb": "hbb-Latn-ZZ",
      "hdy": "hdy-Ethi-ZZ",
      "he": "he-Hebr-IL",
      "hhy": "hhy-Latn-ZZ",
      "hi": "hi-Deva-IN",
      "hia": "hia-Latn-ZZ",
      "hif": "hif-Latn-FJ",
      "hig": "hig-Latn-ZZ",
      "hih": "hih-Latn-ZZ",
      "hil": "hil-Latn-PH",
      "hla": "hla-Latn-ZZ",
      "hlu": "hlu-Hluw-TR",
      "hmd": "hmd-Plrd-CN",
      "hmt": "hmt-Latn-ZZ",
      "hnd": "hnd-Arab-PK",
      "hne": "hne-Deva-IN",
      "hnj": "hnj-Hmng-LA",
      "hnn": "hnn-Latn-PH",
      "hno": "hno-Arab-PK",
      "ho": "ho-Latn-PG",
      "hoc": "hoc-Deva-IN",
      "hoj": "hoj-Deva-IN",
      "hot": "hot-Latn-ZZ",
      "hr": "hr-Latn-HR",
      "hsb": "hsb-Latn-DE",
      "hsn": "hsn-Hans-CN",
      "ht": "ht-Latn-HT",
      "hu": "hu-Latn-HU",
      "hui": "hui-Latn-ZZ",
      "hy": "hy-Armn-AM",
      "hz": "hz-Latn-NA",
      "ia": "ia-Latn-001",
      "ian": "ian-Latn-ZZ",
      "iar": "iar-Latn-ZZ",
      "iba": "iba-Latn-MY",
      "ibb": "ibb-Latn-NG",
      "iby": "iby-Latn-ZZ",
      "ica": "ica-Latn-ZZ",
      "ich": "ich-Latn-ZZ",
      "id": "id-Latn-ID",
      "idd": "idd-Latn-ZZ",
      "idi": "idi-Latn-ZZ",
      "idu": "idu-Latn-ZZ",
      "ife": "ife-Latn-TG",
      "ig": "ig-Latn-NG",
      "igb": "igb-Latn-ZZ",
      "ige": "ige-Latn-ZZ",
      "ii": "ii-Yiii-CN",
      "ijj": "ijj-Latn-ZZ",
      "ik": "ik-Latn-US",
      "ikk": "ikk-Latn-ZZ",
      "ikt": "ikt-Latn-CA",
      "ikw": "ikw-Latn-ZZ",
      "ikx": "ikx-Latn-ZZ",
      "ilo": "ilo-Latn-PH",
      "imo": "imo-Latn-ZZ",
      "in": "in-Latn-ID",
      "inh": "inh-Cyrl-RU",
      "io": "io-Latn-001",
      "iou": "iou-Latn-ZZ",
      "iri": "iri-Latn-ZZ",
      "is": "is-Latn-IS",
      "it": "it-Latn-IT",
      "iu": "iu-Cans-CA",
      "iw": "iw-Hebr-IL",
      "iwm": "iwm-Latn-ZZ",
      "iws": "iws-Latn-ZZ",
      "izh": "izh-Latn-RU",
      "izi": "izi-Latn-ZZ",
      "ja": "ja-Jpan-JP",
      "jab": "jab-Latn-ZZ",
      "jam": "jam-Latn-JM",
      "jbo": "jbo-Latn-001",
      "jbu": "jbu-Latn-ZZ",
      "jen": "jen-Latn-ZZ",
      "jgk": "jgk-Latn-ZZ",
      "jgo": "jgo-Latn-CM",
      "ji": "ji-Hebr-UA",
      "jib": "jib-Latn-ZZ",
      "jmc": "jmc-Latn-TZ",
      "jml": "jml-Deva-NP",
      "jra": "jra-Latn-ZZ",
      "jut": "jut-Latn-DK",
      "jv": "jv-Latn-ID",
      "jw": "jw-Latn-ID",
      "ka": "ka-Geor-GE",
      "kaa": "kaa-Cyrl-UZ",
      "kab": "kab-Latn-DZ",
      "kac": "kac-Latn-MM",
      "kad": "kad-Latn-ZZ",
      "kai": "kai-Latn-ZZ",
      "kaj": "kaj-Latn-NG",
      "kam": "kam-Latn-KE",
      "kao": "kao-Latn-ML",
      "kbd": "kbd-Cyrl-RU",
      "kbm": "kbm-Latn-ZZ",
      "kbp": "kbp-Latn-ZZ",
      "kbq": "kbq-Latn-ZZ",
      "kbx": "kbx-Latn-ZZ",
      "kby": "kby-Arab-NE",
      "kcg": "kcg-Latn-NG",
      "kck": "kck-Latn-ZW",
      "kcl": "kcl-Latn-ZZ",
      "kct": "kct-Latn-ZZ",
      "kde": "kde-Latn-TZ",
      "kdh": "kdh-Arab-TG",
      "kdl": "kdl-Latn-ZZ",
      "kdt": "kdt-Thai-TH",
      "kea": "kea-Latn-CV",
      "ken": "ken-Latn-CM",
      "kez": "kez-Latn-ZZ",
      "kfo": "kfo-Latn-CI",
      "kfr": "kfr-Deva-IN",
      "kfy": "kfy-Deva-IN",
      "kg": "kg-Latn-CD",
      "kge": "kge-Latn-ID",
      "kgf": "kgf-Latn-ZZ",
      "kgp": "kgp-Latn-BR",
      "kha": "kha-Latn-IN",
      "khb": "khb-Talu-CN",
      "khn": "khn-Deva-IN",
      "khq": "khq-Latn-ML",
      "khs": "khs-Latn-ZZ",
      "kht": "kht-Mymr-IN",
      "khw": "khw-Arab-PK",
      "khz": "khz-Latn-ZZ",
      "ki": "ki-Latn-KE",
      "kij": "kij-Latn-ZZ",
      "kiu": "kiu-Latn-TR",
      "kiw": "kiw-Latn-ZZ",
      "kj": "kj-Latn-NA",
      "kjd": "kjd-Latn-ZZ",
      "kjg": "kjg-Laoo-LA",
      "kjs": "kjs-Latn-ZZ",
      "kjy": "kjy-Latn-ZZ",
      "kk": "kk-Cyrl-KZ",
      "kk-AF": "kk-Arab-AF",
      "kk-Arab": "kk-Arab-CN",
      "kk-CN": "kk-Arab-CN",
      "kk-IR": "kk-Arab-IR",
      "kk-MN": "kk-Arab-MN",
      "kkc": "kkc-Latn-ZZ",
      "kkj": "kkj-Latn-CM",
      "kl": "kl-Latn-GL",
      "kln": "kln-Latn-KE",
      "klq": "klq-Latn-ZZ",
      "klt": "klt-Latn-ZZ",
      "klx": "klx-Latn-ZZ",
      "km": "km-Khmr-KH",
      "kmb": "kmb-Latn-AO",
      "kmh": "kmh-Latn-ZZ",
      "kmo": "kmo-Latn-ZZ",
      "kms": "kms-Latn-ZZ",
      "kmu": "kmu-Latn-ZZ",
      "kmw": "kmw-Latn-ZZ",
      "kn": "kn-Knda-IN",
      "knf": "knf-Latn-GW",
      "knp": "knp-Latn-ZZ",
      "ko": "ko-Kore-KR",
      "koi": "koi-Cyrl-RU",
      "kok": "kok-Deva-IN",
      "kol": "kol-Latn-ZZ",
      "kos": "kos-Latn-FM",
      "koz": "koz-Latn-ZZ",
      "kpe": "kpe-Latn-LR",
      "kpf": "kpf-Latn-ZZ",
      "kpo": "kpo-Latn-ZZ",
      "kpr": "kpr-Latn-ZZ",
      "kpx": "kpx-Latn-ZZ",
      "kqb": "kqb-Latn-ZZ",
      "kqf": "kqf-Latn-ZZ",
      "kqs": "kqs-Latn-ZZ",
      "kqy": "kqy-Ethi-ZZ",
      "kr": "kr-Latn-ZZ",
      "krc": "krc-Cyrl-RU",
      "kri": "kri-Latn-SL",
      "krj": "krj-Latn-PH",
      "krl": "krl-Latn-RU",
      "krs": "krs-Latn-ZZ",
      "kru": "kru-Deva-IN",
      "ks": "ks-Arab-IN",
      "ksb": "ksb-Latn-TZ",
      "ksd": "ksd-Latn-ZZ",
      "ksf": "ksf-Latn-CM",
      "ksh": "ksh-Latn-DE",
      "ksj": "ksj-Latn-ZZ",
      "ksr": "ksr-Latn-ZZ",
      "ktb": "ktb-Ethi-ZZ",
      "ktm": "ktm-Latn-ZZ",
      "kto": "kto-Latn-ZZ",
      "ktr": "ktr-Latn-MY",
      "ku": "ku-Latn-TR",
      "ku-Arab": "ku-Arab-IQ",
      "ku-LB": "ku-Arab-LB",
      "kub": "kub-Latn-ZZ",
      "kud": "kud-Latn-ZZ",
      "kue": "kue-Latn-ZZ",
      "kuj": "kuj-Latn-ZZ",
      "kum": "kum-Cyrl-RU",
      "kun": "kun-Latn-ZZ",
      "kup": "kup-Latn-ZZ",
      "kus": "kus-Latn-ZZ",
      "kv": "kv-Cyrl-RU",
      "kvg": "kvg-Latn-ZZ",
      "kvr": "kvr-Latn-ID",
      "kvx": "kvx-Arab-PK",
      "kw": "kw-Latn-GB",
      "kwj": "kwj-Latn-ZZ",
      "kwo": "kwo-Latn-ZZ",
      "kwq": "kwq-Latn-ZZ",
      "kxa": "kxa-Latn-ZZ",
      "kxc": "kxc-Ethi-ZZ",
      "kxe": "kxe-Latn-ZZ",
      "kxm": "kxm-Thai-TH",
      "kxp": "kxp-Arab-PK",
      "kxw": "kxw-Latn-ZZ",
      "kxz": "kxz-Latn-ZZ",
      "ky": "ky-Cyrl-KG",
      "ky-Arab": "ky-Arab-CN",
      "ky-CN": "ky-Arab-CN",
      "ky-Latn": "ky-Latn-TR",
      "ky-TR": "ky-Latn-TR",
      "kye": "kye-Latn-ZZ",
      "kyx": "kyx-Latn-ZZ",
      "kzj": "kzj-Latn-MY",
      "kzr": "kzr-Latn-ZZ",
      "kzt": "kzt-Latn-MY",
      "la": "la-Latn-VA",
      "lab": "lab-Lina-GR",
      "lad": "lad-Hebr-IL",
      "lag": "lag-Latn-TZ",
      "lah": "lah-Arab-PK",
      "laj": "laj-Latn-UG",
      "las": "las-Latn-ZZ",
      "lb": "lb-Latn-LU",
      "lbe": "lbe-Cyrl-RU",
      "lbu": "lbu-Latn-ZZ",
      "lbw": "lbw-Latn-ID",
      "lcm": "lcm-Latn-ZZ",
      "lcp": "lcp-Thai-CN",
      "ldb": "ldb-Latn-ZZ",
      "led": "led-Latn-ZZ",
      "lee": "lee-Latn-ZZ",
      "lem": "lem-Latn-ZZ",
      "lep": "lep-Lepc-IN",
      "leq": "leq-Latn-ZZ",
      "leu": "leu-Latn-ZZ",
      "lez": "lez-Cyrl-RU",
      "lg": "lg-Latn-UG",
      "lgg": "lgg-Latn-ZZ",
      "li": "li-Latn-NL",
      "lia": "lia-Latn-ZZ",
      "lid": "lid-Latn-ZZ",
      "lif": "lif-Deva-NP",
      "lif-Limb": "lif-Limb-IN",
      "lig": "lig-Latn-ZZ",
      "lih": "lih-Latn-ZZ",
      "lij": "lij-Latn-IT",
      "lis": "lis-Lisu-CN",
      "ljp": "ljp-Latn-ID",
      "lki": "lki-Arab-IR",
      "lkt": "lkt-Latn-US",
      "lle": "lle-Latn-ZZ",
      "lln": "lln-Latn-ZZ",
      "lmn": "lmn-Telu-IN",
      "lmo": "lmo-Latn-IT",
      "lmp": "lmp-Latn-ZZ",
      "ln": "ln-Latn-CD",
      "lns": "lns-Latn-ZZ",
      "lnu": "lnu-Latn-ZZ",
      "lo": "lo-Laoo-LA",
      "loj": "loj-Latn-ZZ",
      "lok": "lok-Latn-ZZ",
      "lol": "lol-Latn-CD",
      "lor": "lor-Latn-ZZ",
      "los": "los-Latn-ZZ",
      "loz": "loz-Latn-ZM",
      "lrc": "lrc-Arab-IR",
      "lt": "lt-Latn-LT",
      "ltg": "ltg-Latn-LV",
      "lu": "lu-Latn-CD",
      "lua": "lua-Latn-CD",
      "luo": "luo-Latn-KE",
      "luy": "luy-Latn-KE",
      "luz": "luz-Arab-IR",
      "lv": "lv-Latn-LV",
      "lwl": "lwl-Thai-TH",
      "lzh": "lzh-Hans-CN",
      "lzz": "lzz-Latn-TR",
      "mad": "mad-Latn-ID",
      "maf": "maf-Latn-CM",
      "mag": "mag-Deva-IN",
      "mai": "mai-Deva-IN",
      "mak": "mak-Latn-ID",
      "man": "man-Latn-GM",
      "man-GN": "man-Nkoo-GN",
      "man-Nkoo": "man-Nkoo-GN",
      "mas": "mas-Latn-KE",
      "maw": "maw-Latn-ZZ",
      "maz": "maz-Latn-MX",
      "mbh": "mbh-Latn-ZZ",
      "mbo": "mbo-Latn-ZZ",
      "mbq": "mbq-Latn-ZZ",
      "mbu": "mbu-Latn-ZZ",
      "mbw": "mbw-Latn-ZZ",
      "mci": "mci-Latn-ZZ",
      "mcp": "mcp-Latn-ZZ",
      "mcq": "mcq-Latn-ZZ",
      "mcr": "mcr-Latn-ZZ",
      "mcu": "mcu-Latn-ZZ",
      "mda": "mda-Latn-ZZ",
      "mde": "mde-Arab-ZZ",
      "mdf": "mdf-Cyrl-RU",
      "mdh": "mdh-Latn-PH",
      "mdj": "mdj-Latn-ZZ",
      "mdr": "mdr-Latn-ID",
      "mdx": "mdx-Ethi-ZZ",
      "med": "med-Latn-ZZ",
      "mee": "mee-Latn-ZZ",
      "mek": "mek-Latn-ZZ",
      "men": "men-Latn-SL",
      "mer": "mer-Latn-KE",
      "met": "met-Latn-ZZ",
      "meu": "meu-Latn-ZZ",
      "mfa": "mfa-Arab-TH",
      "mfe": "mfe-Latn-MU",
      "mfn": "mfn-Latn-ZZ",
      "mfo": "mfo-Latn-ZZ",
      "mfq": "mfq-Latn-ZZ",
      "mg": "mg-Latn-MG",
      "mgh": "mgh-Latn-MZ",
      "mgl": "mgl-Latn-ZZ",
      "mgo": "mgo-Latn-CM",
      "mgp": "mgp-Deva-NP",
      "mgy": "mgy-Latn-TZ",
      "mh": "mh-Latn-MH",
      "mhi": "mhi-Latn-ZZ",
      "mhl": "mhl-Latn-ZZ",
      "mi": "mi-Latn-NZ",
      "mif": "mif-Latn-ZZ",
      "min": "min-Latn-ID",
      "mis": "mis-Hatr-IQ",
      "mis-Medf": "mis-Medf-NG",
      "miw": "miw-Latn-ZZ",
      "mk": "mk-Cyrl-MK",
      "mki": "mki-Arab-ZZ",
      "mkl": "mkl-Latn-ZZ",
      "mkp": "mkp-Latn-ZZ",
      "mkw": "mkw-Latn-ZZ",
      "ml": "ml-Mlym-IN",
      "mle": "mle-Latn-ZZ",
      "mlp": "mlp-Latn-ZZ",
      "mls": "mls-Latn-SD",
      "mmo": "mmo-Latn-ZZ",
      "mmu": "mmu-Latn-ZZ",
      "mmx": "mmx-Latn-ZZ",
      "mn": "mn-Cyrl-MN",
      "mn-CN": "mn-Mong-CN",
      "mn-Mong": "mn-Mong-CN",
      "mna": "mna-Latn-ZZ",
      "mnf": "mnf-Latn-ZZ",
      "mni": "mni-Beng-IN",
      "mnw": "mnw-Mymr-MM",
      "mo": "mo-Latn-RO",
      "moa": "moa-Latn-ZZ",
      "moe": "moe-Latn-CA",
      "moh": "moh-Latn-CA",
      "mos": "mos-Latn-BF",
      "mox": "mox-Latn-ZZ",
      "mpp": "mpp-Latn-ZZ",
      "mps": "mps-Latn-ZZ",
      "mpt": "mpt-Latn-ZZ",
      "mpx": "mpx-Latn-ZZ",
      "mql": "mql-Latn-ZZ",
      "mr": "mr-Deva-IN",
      "mrd": "mrd-Deva-NP",
      "mrj": "mrj-Cyrl-RU",
      "mro": "mro-Mroo-BD",
      "ms": "ms-Latn-MY",
      "ms-CC": "ms-Arab-CC",
      "ms-ID": "ms-Arab-ID",
      "mt": "mt-Latn-MT",
      "mtc": "mtc-Latn-ZZ",
      "mtf": "mtf-Latn-ZZ",
      "mti": "mti-Latn-ZZ",
      "mtr": "mtr-Deva-IN",
      "mua": "mua-Latn-CM",
      "mur": "mur-Latn-ZZ",
      "mus": "mus-Latn-US",
      "mva": "mva-Latn-ZZ",
      "mvn": "mvn-Latn-ZZ",
      "mvy": "mvy-Arab-PK",
      "mwk": "mwk-Latn-ML",
      "mwr": "mwr-Deva-IN",
      "mwv": "mwv-Latn-ID",
      "mww": "mww-Hmnp-US",
      "mxc": "mxc-Latn-ZW",
      "mxm": "mxm-Latn-ZZ",
      "my": "my-Mymr-MM",
      "myk": "myk-Latn-ZZ",
      "mym": "mym-Ethi-ZZ",
      "myv": "myv-Cyrl-RU",
      "myw": "myw-Latn-ZZ",
      "myx": "myx-Latn-UG",
      "myz": "myz-Mand-IR",
      "mzk": "mzk-Latn-ZZ",
      "mzm": "mzm-Latn-ZZ",
      "mzn": "mzn-Arab-IR",
      "mzp": "mzp-Latn-ZZ",
      "mzw": "mzw-Latn-ZZ",
      "mzz": "mzz-Latn-ZZ",
      "na": "na-Latn-NR",
      "nac": "nac-Latn-ZZ",
      "naf": "naf-Latn-ZZ",
      "nak": "nak-Latn-ZZ",
      "nan": "nan-Hans-CN",
      "nap": "nap-Latn-IT",
      "naq": "naq-Latn-NA",
      "nas": "nas-Latn-ZZ",
      "nb": "nb-Latn-NO",
      "nca": "nca-Latn-ZZ",
      "nce": "nce-Latn-ZZ",
      "ncf": "ncf-Latn-ZZ",
      "nch": "nch-Latn-MX",
      "nco": "nco-Latn-ZZ",
      "ncu": "ncu-Latn-ZZ",
      "nd": "nd-Latn-ZW",
      "ndc": "ndc-Latn-MZ",
      "nds": "nds-Latn-DE",
      "ne": "ne-Deva-NP",
      "neb": "neb-Latn-ZZ",
      "new": "new-Deva-NP",
      "nex": "nex-Latn-ZZ",
      "nfr": "nfr-Latn-ZZ",
      "ng": "ng-Latn-NA",
      "nga": "nga-Latn-ZZ",
      "ngb": "ngb-Latn-ZZ",
      "ngl": "ngl-Latn-MZ",
      "nhb": "nhb-Latn-ZZ",
      "nhe": "nhe-Latn-MX",
      "nhw": "nhw-Latn-MX",
      "nif": "nif-Latn-ZZ",
      "nii": "nii-Latn-ZZ",
      "nij": "nij-Latn-ID",
      "nin": "nin-Latn-ZZ",
      "niu": "niu-Latn-NU",
      "niy": "niy-Latn-ZZ",
      "niz": "niz-Latn-ZZ",
      "njo": "njo-Latn-IN",
      "nkg": "nkg-Latn-ZZ",
      "nko": "nko-Latn-ZZ",
      "nl": "nl-Latn-NL",
      "nmg": "nmg-Latn-CM",
      "nmz": "nmz-Latn-ZZ",
      "nn": "nn-Latn-NO",
      "nnf": "nnf-Latn-ZZ",
      "nnh": "nnh-Latn-CM",
      "nnk": "nnk-Latn-ZZ",
      "nnm": "nnm-Latn-ZZ",
      "nnp": "nnp-Wcho-IN",
      "no": "no-Latn-NO",
      "nod": "nod-Lana-TH",
      "noe": "noe-Deva-IN",
      "non": "non-Runr-SE",
      "nop": "nop-Latn-ZZ",
      "nou": "nou-Latn-ZZ",
      "nqo": "nqo-Nkoo-GN",
      "nr": "nr-Latn-ZA",
      "nrb": "nrb-Latn-ZZ",
      "nsk": "nsk-Cans-CA",
      "nsn": "nsn-Latn-ZZ",
      "nso": "nso-Latn-ZA",
      "nss": "nss-Latn-ZZ",
      "ntm": "ntm-Latn-ZZ",
      "ntr": "ntr-Latn-ZZ",
      "nui": "nui-Latn-ZZ",
      "nup": "nup-Latn-ZZ",
      "nus": "nus-Latn-SS",
      "nuv": "nuv-Latn-ZZ",
      "nux": "nux-Latn-ZZ",
      "nv": "nv-Latn-US",
      "nwb": "nwb-Latn-ZZ",
      "nxq": "nxq-Latn-CN",
      "nxr": "nxr-Latn-ZZ",
      "ny": "ny-Latn-MW",
      "nym": "nym-Latn-TZ",
      "nyn": "nyn-Latn-UG",
      "nzi": "nzi-Latn-GH",
      "oc": "oc-Latn-FR",
      "ogc": "ogc-Latn-ZZ",
      "okr": "okr-Latn-ZZ",
      "okv": "okv-Latn-ZZ",
      "om": "om-Latn-ET",
      "ong": "ong-Latn-ZZ",
      "onn": "onn-Latn-ZZ",
      "ons": "ons-Latn-ZZ",
      "opm": "opm-Latn-ZZ",
      "or": "or-Orya-IN",
      "oro": "oro-Latn-ZZ",
      "oru": "oru-Arab-ZZ",
      "os": "os-Cyrl-GE",
      "osa": "osa-Osge-US",
      "ota": "ota-Arab-ZZ",
      "otk": "otk-Orkh-MN",
      "ozm": "ozm-Latn-ZZ",
      "pa": "pa-Guru-IN",
      "pa-Arab": "pa-Arab-PK",
      "pa-PK": "pa-Arab-PK",
      "pag": "pag-Latn-PH",
      "pal": "pal-Phli-IR",
      "pal-Phlp": "pal-Phlp-CN",
      "pam": "pam-Latn-PH",
      "pap": "pap-Latn-AW",
      "pau": "pau-Latn-PW",
      "pbi": "pbi-Latn-ZZ",
      "pcd": "pcd-Latn-FR",
      "pcm": "pcm-Latn-NG",
      "pdc": "pdc-Latn-US",
      "pdt": "pdt-Latn-CA",
      "ped": "ped-Latn-ZZ",
      "peo": "peo-Xpeo-IR",
      "pex": "pex-Latn-ZZ",
      "pfl": "pfl-Latn-DE",
      "phl": "phl-Arab-ZZ",
      "phn": "phn-Phnx-LB",
      "pil": "pil-Latn-ZZ",
      "pip": "pip-Latn-ZZ",
      "pka": "pka-Brah-IN",
      "pko": "pko-Latn-KE",
      "pl": "pl-Latn-PL",
      "pla": "pla-Latn-ZZ",
      "pms": "pms-Latn-IT",
      "png": "png-Latn-ZZ",
      "pnn": "pnn-Latn-ZZ",
      "pnt": "pnt-Grek-GR",
      "pon": "pon-Latn-FM",
      "ppa": "ppa-Deva-IN",
      "ppo": "ppo-Latn-ZZ",
      "pra": "pra-Khar-PK",
      "prd": "prd-Arab-IR",
      "prg": "prg-Latn-001",
      "ps": "ps-Arab-AF",
      "pss": "pss-Latn-ZZ",
      "pt": "pt-Latn-BR",
      "ptp": "ptp-Latn-ZZ",
      "puu": "puu-Latn-GA",
      "pwa": "pwa-Latn-ZZ",
      "qu": "qu-Latn-PE",
      "quc": "quc-Latn-GT",
      "qug": "qug-Latn-EC",
      "rai": "rai-Latn-ZZ",
      "raj": "raj-Deva-IN",
      "rao": "rao-Latn-ZZ",
      "rcf": "rcf-Latn-RE",
      "rej": "rej-Latn-ID",
      "rel": "rel-Latn-ZZ",
      "res": "res-Latn-ZZ",
      "rgn": "rgn-Latn-IT",
      "rhg": "rhg-Arab-MM",
      "ria": "ria-Latn-IN",
      "rif": "rif-Tfng-MA",
      "rif-NL": "rif-Latn-NL",
      "rjs": "rjs-Deva-NP",
      "rkt": "rkt-Beng-BD",
      "rm": "rm-Latn-CH",
      "rmf": "rmf-Latn-FI",
      "rmo": "rmo-Latn-CH",
      "rmt": "rmt-Arab-IR",
      "rmu": "rmu-Latn-SE",
      "rn": "rn-Latn-BI",
      "rna": "rna-Latn-ZZ",
      "rng": "rng-Latn-MZ",
      "ro": "ro-Latn-RO",
      "rob": "rob-Latn-ID",
      "rof": "rof-Latn-TZ",
      "roo": "roo-Latn-ZZ",
      "rro": "rro-Latn-ZZ",
      "rtm": "rtm-Latn-FJ",
      "ru": "ru-Cyrl-RU",
      "rue": "rue-Cyrl-UA",
      "rug": "rug-Latn-SB",
      "rw": "rw-Latn-RW",
      "rwk": "rwk-Latn-TZ",
      "rwo": "rwo-Latn-ZZ",
      "ryu": "ryu-Kana-JP",
      "sa": "sa-Deva-IN",
      "saf": "saf-Latn-GH",
      "sah": "sah-Cyrl-RU",
      "saq": "saq-Latn-KE",
      "sas": "sas-Latn-ID",
      "sat": "sat-Latn-IN",
      "sav": "sav-Latn-SN",
      "saz": "saz-Saur-IN",
      "sba": "sba-Latn-ZZ",
      "sbe": "sbe-Latn-ZZ",
      "sbp": "sbp-Latn-TZ",
      "sc": "sc-Latn-IT",
      "sck": "sck-Deva-IN",
      "scl": "scl-Arab-ZZ",
      "scn": "scn-Latn-IT",
      "sco": "sco-Latn-GB",
      "scs": "scs-Latn-CA",
      "sd": "sd-Arab-PK",
      "sd-Deva": "sd-Deva-IN",
      "sd-Khoj": "sd-Khoj-IN",
      "sd-Sind": "sd-Sind-IN",
      "sdc": "sdc-Latn-IT",
      "sdh": "sdh-Arab-IR",
      "se": "se-Latn-NO",
      "sef": "sef-Latn-CI",
      "seh": "seh-Latn-MZ",
      "sei": "sei-Latn-MX",
      "ses": "ses-Latn-ML",
      "sg": "sg-Latn-CF",
      "sga": "sga-Ogam-IE",
      "sgs": "sgs-Latn-LT",
      "sgw": "sgw-Ethi-ZZ",
      "sgz": "sgz-Latn-ZZ",
      "shi": "shi-Tfng-MA",
      "shk": "shk-Latn-ZZ",
      "shn": "shn-Mymr-MM",
      "shu": "shu-Arab-ZZ",
      "si": "si-Sinh-LK",
      "sid": "sid-Latn-ET",
      "sig": "sig-Latn-ZZ",
      "sil": "sil-Latn-ZZ",
      "sim": "sim-Latn-ZZ",
      "sjr": "sjr-Latn-ZZ",
      "sk": "sk-Latn-SK",
      "skc": "skc-Latn-ZZ",
      "skr": "skr-Arab-PK",
      "sks": "sks-Latn-ZZ",
      "sl": "sl-Latn-SI",
      "sld": "sld-Latn-ZZ",
      "sli": "sli-Latn-PL",
      "sll": "sll-Latn-ZZ",
      "sly": "sly-Latn-ID",
      "sm": "sm-Latn-WS",
      "sma": "sma-Latn-SE",
      "smj": "smj-Latn-SE",
      "smn": "smn-Latn-FI",
      "smp": "smp-Samr-IL",
      "smq": "smq-Latn-ZZ",
      "sms": "sms-Latn-FI",
      "sn": "sn-Latn-ZW",
      "snc": "snc-Latn-ZZ",
      "snk": "snk-Latn-ML",
      "snp": "snp-Latn-ZZ",
      "snx": "snx-Latn-ZZ",
      "sny": "sny-Latn-ZZ",
      "so": "so-Latn-SO",
      "sog": "sog-Sogd-UZ",
      "sok": "sok-Latn-ZZ",
      "soq": "soq-Latn-ZZ",
      "sou": "sou-Thai-TH",
      "soy": "soy-Latn-ZZ",
      "spd": "spd-Latn-ZZ",
      "spl": "spl-Latn-ZZ",
      "sps": "sps-Latn-ZZ",
      "sq": "sq-Latn-AL",
      "sr": "sr-Cyrl-RS",
      "sr-ME": "sr-Latn-ME",
      "sr-RO": "sr-Latn-RO",
      "sr-RU": "sr-Latn-RU",
      "sr-TR": "sr-Latn-TR",
      "srb": "srb-Sora-IN",
      "srn": "srn-Latn-SR",
      "srr": "srr-Latn-SN",
      "srx": "srx-Deva-IN",
      "ss": "ss-Latn-ZA",
      "ssd": "ssd-Latn-ZZ",
      "ssg": "ssg-Latn-ZZ",
      "ssy": "ssy-Latn-ER",
      "st": "st-Latn-ZA",
      "stk": "stk-Latn-ZZ",
      "stq": "stq-Latn-DE",
      "su": "su-Latn-ID",
      "sua": "sua-Latn-ZZ",
      "sue": "sue-Latn-ZZ",
      "suk": "suk-Latn-TZ",
      "sur": "sur-Latn-ZZ",
      "sus": "sus-Latn-GN",
      "sv": "sv-Latn-SE",
      "sw": "sw-Latn-TZ",
      "swb": "swb-Arab-YT",
      "swc": "swc-Latn-CD",
      "swg": "swg-Latn-DE",
      "swp": "swp-Latn-ZZ",
      "swv": "swv-Deva-IN",
      "sxn": "sxn-Latn-ID",
      "sxw": "sxw-Latn-ZZ",
      "syl": "syl-Beng-BD",
      "syr": "syr-Syrc-IQ",
      "szl": "szl-Latn-PL",
      "ta": "ta-Taml-IN",
      "taj": "taj-Deva-NP",
      "tal": "tal-Latn-ZZ",
      "tan": "tan-Latn-ZZ",
      "taq": "taq-Latn-ZZ",
      "tbc": "tbc-Latn-ZZ",
      "tbd": "tbd-Latn-ZZ",
      "tbf": "tbf-Latn-ZZ",
      "tbg": "tbg-Latn-ZZ",
      "tbo": "tbo-Latn-ZZ",
      "tbw": "tbw-Latn-PH",
      "tbz": "tbz-Latn-ZZ",
      "tci": "tci-Latn-ZZ",
      "tcy": "tcy-Knda-IN",
      "tdd": "tdd-Tale-CN",
      "tdg": "tdg-Deva-NP",
      "tdh": "tdh-Deva-NP",
      "tdu": "tdu-Latn-MY",
      "te": "te-Telu-IN",
      "ted": "ted-Latn-ZZ",
      "tem": "tem-Latn-SL",
      "teo": "teo-Latn-UG",
      "tet": "tet-Latn-TL",
      "tfi": "tfi-Latn-ZZ",
      "tg": "tg-Cyrl-TJ",
      "tg-Arab": "tg-Arab-PK",
      "tg-PK": "tg-Arab-PK",
      "tgc": "tgc-Latn-ZZ",
      "tgo": "tgo-Latn-ZZ",
      "tgu": "tgu-Latn-ZZ",
      "th": "th-Thai-TH",
      "thl": "thl-Deva-NP",
      "thq": "thq-Deva-NP",
      "thr": "thr-Deva-NP",
      "ti": "ti-Ethi-ET",
      "tif": "tif-Latn-ZZ",
      "tig": "tig-Ethi-ER",
      "tik": "tik-Latn-ZZ",
      "tim": "tim-Latn-ZZ",
      "tio": "tio-Latn-ZZ",
      "tiv": "tiv-Latn-NG",
      "tk": "tk-Latn-TM",
      "tkl": "tkl-Latn-TK",
      "tkr": "tkr-Latn-AZ",
      "tkt": "tkt-Deva-NP",
      "tl": "tl-Latn-PH",
      "tlf": "tlf-Latn-ZZ",
      "tlx": "tlx-Latn-ZZ",
      "tly": "tly-Latn-AZ",
      "tmh": "tmh-Latn-NE",
      "tmy": "tmy-Latn-ZZ",
      "tn": "tn-Latn-ZA",
      "tnh": "tnh-Latn-ZZ",
      "to": "to-Latn-TO",
      "tof": "tof-Latn-ZZ",
      "tog": "tog-Latn-MW",
      "toq": "toq-Latn-ZZ",
      "tpi": "tpi-Latn-PG",
      "tpm": "tpm-Latn-ZZ",
      "tpz": "tpz-Latn-ZZ",
      "tqo": "tqo-Latn-ZZ",
      "tr": "tr-Latn-TR",
      "tru": "tru-Latn-TR",
      "trv": "trv-Latn-TW",
      "trw": "trw-Arab-ZZ",
      "ts": "ts-Latn-ZA",
      "tsd": "tsd-Grek-GR",
      "tsf": "tsf-Deva-NP",
      "tsg": "tsg-Latn-PH",
      "tsj": "tsj-Tibt-BT",
      "tsw": "tsw-Latn-ZZ",
      "tt": "tt-Cyrl-RU",
      "ttd": "ttd-Latn-ZZ",
      "tte": "tte-Latn-ZZ",
      "ttj": "ttj-Latn-UG",
      "ttr": "ttr-Latn-ZZ",
      "tts": "tts-Thai-TH",
      "ttt": "ttt-Latn-AZ",
      "tuh": "tuh-Latn-ZZ",
      "tul": "tul-Latn-ZZ",
      "tum": "tum-Latn-MW",
      "tuq": "tuq-Latn-ZZ",
      "tvd": "tvd-Latn-ZZ",
      "tvl": "tvl-Latn-TV",
      "tvu": "tvu-Latn-ZZ",
      "twh": "twh-Latn-ZZ",
      "twq": "twq-Latn-NE",
      "txg": "txg-Tang-CN",
      "ty": "ty-Latn-PF",
      "tya": "tya-Latn-ZZ",
      "tyv": "tyv-Cyrl-RU",
      "tzm": "tzm-Latn-MA",
      "ubu": "ubu-Latn-ZZ",
      "udm": "udm-Cyrl-RU",
      "ug": "ug-Arab-CN",
      "ug-Cyrl": "ug-Cyrl-KZ",
      "ug-KZ": "ug-Cyrl-KZ",
      "ug-MN": "ug-Cyrl-MN",
      "uga": "uga-Ugar-SY",
      "uk": "uk-Cyrl-UA",
      "uli": "uli-Latn-FM",
      "umb": "umb-Latn-AO",
      "und": "en-Latn-US",
      "und-002": "en-Latn-NG",
      "und-003": "en-Latn-US",
      "und-005": "pt-Latn-BR",
      "und-009": "en-Latn-AU",
      "und-011": "en-Latn-NG",
      "und-013": "es-Latn-MX",
      "und-014": "sw-Latn-TZ",
      "und-015": "ar-Arab-EG",
      "und-017": "sw-Latn-CD",
      "und-018": "en-Latn-ZA",
      "und-019": "en-Latn-US",
      "und-021": "en-Latn-US",
      "und-029": "es-Latn-CU",
      "und-030": "zh-Hans-CN",
      "und-034": "hi-Deva-IN",
      "und-035": "id-Latn-ID",
      "und-039": "it-Latn-IT",
      "und-053": "en-Latn-AU",
      "und-054": "en-Latn-PG",
      "und-057": "en-Latn-GU",
      "und-061": "sm-Latn-WS",
      "und-142": "zh-Hans-CN",
      "und-143": "uz-Latn-UZ",
      "und-145": "ar-Arab-SA",
      "und-150": "ru-Cyrl-RU",
      "und-151": "ru-Cyrl-RU",
      "und-154": "en-Latn-GB",
      "und-155": "de-Latn-DE",
      "und-202": "en-Latn-NG",
      "und-419": "es-Latn-419",
      "und-AD": "ca-Latn-AD",
      "und-Adlm": "ff-Adlm-GN",
      "und-AE": "ar-Arab-AE",
      "und-AF": "fa-Arab-AF",
      "und-Aghb": "lez-Aghb-RU",
      "und-Ahom": "aho-Ahom-IN",
      "und-AL": "sq-Latn-AL",
      "und-AM": "hy-Armn-AM",
      "und-AO": "pt-Latn-AO",
      "und-AQ": "und-Latn-AQ",
      "und-AR": "es-Latn-AR",
      "und-Arab": "ar-Arab-EG",
      "und-Arab-CC": "ms-Arab-CC",
      "und-Arab-CN": "ug-Arab-CN",
      "und-Arab-GB": "ks-Arab-GB",
      "und-Arab-ID": "ms-Arab-ID",
      "und-Arab-IN": "ur-Arab-IN",
      "und-Arab-KH": "cja-Arab-KH",
      "und-Arab-MM": "rhg-Arab-MM",
      "und-Arab-MN": "kk-Arab-MN",
      "und-Arab-MU": "ur-Arab-MU",
      "und-Arab-NG": "ha-Arab-NG",
      "und-Arab-PK": "ur-Arab-PK",
      "und-Arab-TG": "apd-Arab-TG",
      "und-Arab-TH": "mfa-Arab-TH",
      "und-Arab-TJ": "fa-Arab-TJ",
      "und-Arab-TR": "az-Arab-TR",
      "und-Arab-YT": "swb-Arab-YT",
      "und-Armi": "arc-Armi-IR",
      "und-Armn": "hy-Armn-AM",
      "und-AS": "sm-Latn-AS",
      "und-AT": "de-Latn-AT",
      "und-Avst": "ae-Avst-IR",
      "und-AW": "nl-Latn-AW",
      "und-AX": "sv-Latn-AX",
      "und-AZ": "az-Latn-AZ",
      "und-BA": "bs-Latn-BA",
      "und-Bali": "ban-Bali-ID",
      "und-Bamu": "bax-Bamu-CM",
      "und-Bass": "bsq-Bass-LR",
      "und-Batk": "bbc-Batk-ID",
      "und-BD": "bn-Beng-BD",
      "und-BE": "nl-Latn-BE",
      "und-Beng": "bn-Beng-BD",
      "und-BF": "fr-Latn-BF",
      "und-BG": "bg-Cyrl-BG",
      "und-BH": "ar-Arab-BH",
      "und-Bhks": "sa-Bhks-IN",
      "und-BI": "rn-Latn-BI",
      "und-BJ": "fr-Latn-BJ",
      "und-BL": "fr-Latn-BL",
      "und-BN": "ms-Latn-BN",
      "und-BO": "es-Latn-BO",
      "und-Bopo": "zh-Bopo-TW",
      "und-BQ": "pap-Latn-BQ",
      "und-BR": "pt-Latn-BR",
      "und-Brah": "pka-Brah-IN",
      "und-Brai": "fr-Brai-FR",
      "und-BT": "dz-Tibt-BT",
      "und-Bugi": "bug-Bugi-ID",
      "und-Buhd": "bku-Buhd-PH",
      "und-BV": "und-Latn-BV",
      "und-BY": "be-Cyrl-BY",
      "und-Cakm": "ccp-Cakm-BD",
      "und-Cans": "cr-Cans-CA",
      "und-Cari": "xcr-Cari-TR",
      "und-CD": "sw-Latn-CD",
      "und-CF": "fr-Latn-CF",
      "und-CG": "fr-Latn-CG",
      "und-CH": "de-Latn-CH",
      "und-Cham": "cjm-Cham-VN",
      "und-Cher": "chr-Cher-US",
      "und-CI": "fr-Latn-CI",
      "und-CL": "es-Latn-CL",
      "und-CM": "fr-Latn-CM",
      "und-CN": "zh-Hans-CN",
      "und-CO": "es-Latn-CO",
      "und-Copt": "cop-Copt-EG",
      "und-CP": "und-Latn-CP",
      "und-Cprt": "grc-Cprt-CY",
      "und-CR": "es-Latn-CR",
      "und-CU": "es-Latn-CU",
      "und-CV": "pt-Latn-CV",
      "und-CW": "pap-Latn-CW",
      "und-CY": "el-Grek-CY",
      "und-Cyrl": "ru-Cyrl-RU",
      "und-Cyrl-AL": "mk-Cyrl-AL",
      "und-Cyrl-BA": "sr-Cyrl-BA",
      "und-Cyrl-GE": "ab-Cyrl-GE",
      "und-Cyrl-GR": "mk-Cyrl-GR",
      "und-Cyrl-MD": "uk-Cyrl-MD",
      "und-Cyrl-RO": "bg-Cyrl-RO",
      "und-Cyrl-SK": "uk-Cyrl-SK",
      "und-Cyrl-TR": "kbd-Cyrl-TR",
      "und-Cyrl-XK": "sr-Cyrl-XK",
      "und-CZ": "cs-Latn-CZ",
      "und-DE": "de-Latn-DE",
      "und-Deva": "hi-Deva-IN",
      "und-Deva-BT": "ne-Deva-BT",
      "und-Deva-FJ": "hif-Deva-FJ",
      "und-Deva-MU": "bho-Deva-MU",
      "und-Deva-PK": "btv-Deva-PK",
      "und-DJ": "aa-Latn-DJ",
      "und-DK": "da-Latn-DK",
      "und-DO": "es-Latn-DO",
      "und-Dogr": "doi-Dogr-IN",
      "und-Dupl": "fr-Dupl-FR",
      "und-DZ": "ar-Arab-DZ",
      "und-EA": "es-Latn-EA",
      "und-EC": "es-Latn-EC",
      "und-EE": "et-Latn-EE",
      "und-EG": "ar-Arab-EG",
      "und-Egyp": "egy-Egyp-EG",
      "und-EH": "ar-Arab-EH",
      "und-Elba": "sq-Elba-AL",
      "und-Elym": "arc-Elym-IR",
      "und-ER": "ti-Ethi-ER",
      "und-ES": "es-Latn-ES",
      "und-ET": "am-Ethi-ET",
      "und-Ethi": "am-Ethi-ET",
      "und-EU": "en-Latn-GB",
      "und-EZ": "de-Latn-EZ",
      "und-FI": "fi-Latn-FI",
      "und-FO": "fo-Latn-FO",
      "und-FR": "fr-Latn-FR",
      "und-GA": "fr-Latn-GA",
      "und-GE": "ka-Geor-GE",
      "und-Geor": "ka-Geor-GE",
      "und-GF": "fr-Latn-GF",
      "und-GH": "ak-Latn-GH",
      "und-GL": "kl-Latn-GL",
      "und-Glag": "cu-Glag-BG",
      "und-GN": "fr-Latn-GN",
      "und-Gong": "wsg-Gong-IN",
      "und-Gonm": "esg-Gonm-IN",
      "und-Goth": "got-Goth-UA",
      "und-GP": "fr-Latn-GP",
      "und-GQ": "es-Latn-GQ",
      "und-GR": "el-Grek-GR",
      "und-Gran": "sa-Gran-IN",
      "und-Grek": "el-Grek-GR",
      "und-Grek-TR": "bgx-Grek-TR",
      "und-GS": "und-Latn-GS",
      "und-GT": "es-Latn-GT",
      "und-Gujr": "gu-Gujr-IN",
      "und-Guru": "pa-Guru-IN",
      "und-GW": "pt-Latn-GW",
      "und-Hanb": "zh-Hanb-TW",
      "und-Hang": "ko-Hang-KR",
      "und-Hani": "zh-Hani-CN",
      "und-Hano": "hnn-Hano-PH",
      "und-Hans": "zh-Hans-CN",
      "und-Hant": "zh-Hant-TW",
      "und-Hatr": "mis-Hatr-IQ",
      "und-Hebr": "he-Hebr-IL",
      "und-Hebr-CA": "yi-Hebr-CA",
      "und-Hebr-GB": "yi-Hebr-GB",
      "und-Hebr-SE": "yi-Hebr-SE",
      "und-Hebr-UA": "yi-Hebr-UA",
      "und-Hebr-US": "yi-Hebr-US",
      "und-Hira": "ja-Hira-JP",
      "und-HK": "zh-Hant-HK",
      "und-Hluw": "hlu-Hluw-TR",
      "und-HM": "und-Latn-HM",
      "und-Hmng": "hnj-Hmng-LA",
      "und-Hmnp": "mww-Hmnp-US",
      "und-HN": "es-Latn-HN",
      "und-HR": "hr-Latn-HR",
      "und-HT": "ht-Latn-HT",
      "und-HU": "hu-Latn-HU",
      "und-Hung": "hu-Hung-HU",
      "und-IC": "es-Latn-IC",
      "und-ID": "id-Latn-ID",
      "und-IL": "he-Hebr-IL",
      "und-IN": "hi-Deva-IN",
      "und-IQ": "ar-Arab-IQ",
      "und-IR": "fa-Arab-IR",
      "und-IS": "is-Latn-IS",
      "und-IT": "it-Latn-IT",
      "und-Ital": "ett-Ital-IT",
      "und-Jamo": "ko-Jamo-KR",
      "und-Java": "jv-Java-ID",
      "und-JO": "ar-Arab-JO",
      "und-JP": "ja-Jpan-JP",
      "und-Jpan": "ja-Jpan-JP",
      "und-Kali": "eky-Kali-MM",
      "und-Kana": "ja-Kana-JP",
      "und-KE": "sw-Latn-KE",
      "und-KG": "ky-Cyrl-KG",
      "und-KH": "km-Khmr-KH",
      "und-Khar": "pra-Khar-PK",
      "und-Khmr": "km-Khmr-KH",
      "und-Khoj": "sd-Khoj-IN",
      "und-KM": "ar-Arab-KM",
      "und-Knda": "kn-Knda-IN",
      "und-Kore": "ko-Kore-KR",
      "und-KP": "ko-Kore-KP",
      "und-KR": "ko-Kore-KR",
      "und-Kthi": "bho-Kthi-IN",
      "und-KW": "ar-Arab-KW",
      "und-KZ": "ru-Cyrl-KZ",
      "und-LA": "lo-Laoo-LA",
      "und-Lana": "nod-Lana-TH",
      "und-Laoo": "lo-Laoo-LA",
      "und-Latn-AF": "tk-Latn-AF",
      "und-Latn-AM": "ku-Latn-AM",
      "und-Latn-CN": "za-Latn-CN",
      "und-Latn-CY": "tr-Latn-CY",
      "und-Latn-DZ": "fr-Latn-DZ",
      "und-Latn-ET": "en-Latn-ET",
      "und-Latn-GE": "ku-Latn-GE",
      "und-Latn-IR": "tk-Latn-IR",
      "und-Latn-KM": "fr-Latn-KM",
      "und-Latn-MA": "fr-Latn-MA",
      "und-Latn-MK": "sq-Latn-MK",
      "und-Latn-MM": "kac-Latn-MM",
      "und-Latn-MO": "pt-Latn-MO",
      "und-Latn-MR": "fr-Latn-MR",
      "und-Latn-RU": "krl-Latn-RU",
      "und-Latn-SY": "fr-Latn-SY",
      "und-Latn-TN": "fr-Latn-TN",
      "und-Latn-TW": "trv-Latn-TW",
      "und-Latn-UA": "pl-Latn-UA",
      "und-LB": "ar-Arab-LB",
      "und-Lepc": "lep-Lepc-IN",
      "und-LI": "de-Latn-LI",
      "und-Limb": "lif-Limb-IN",
      "und-Lina": "lab-Lina-GR",
      "und-Linb": "grc-Linb-GR",
      "und-Lisu": "lis-Lisu-CN",
      "und-LK": "si-Sinh-LK",
      "und-LS": "st-Latn-LS",
      "und-LT": "lt-Latn-LT",
      "und-LU": "fr-Latn-LU",
      "und-LV": "lv-Latn-LV",
      "und-LY": "ar-Arab-LY",
      "und-Lyci": "xlc-Lyci-TR",
      "und-Lydi": "xld-Lydi-TR",
      "und-MA": "ar-Arab-MA",
      "und-Mahj": "hi-Mahj-IN",
      "und-Maka": "mak-Maka-ID",
      "und-Mand": "myz-Mand-IR",
      "und-Mani": "xmn-Mani-CN",
      "und-Marc": "bo-Marc-CN",
      "und-MC": "fr-Latn-MC",
      "und-MD": "ro-Latn-MD",
      "und-ME": "sr-Latn-ME",
      "und-Medf": "mis-Medf-NG",
      "und-Mend": "men-Mend-SL",
      "und-Merc": "xmr-Merc-SD",
      "und-Mero": "xmr-Mero-SD",
      "und-MF": "fr-Latn-MF",
      "und-MG": "mg-Latn-MG",
      "und-MK": "mk-Cyrl-MK",
      "und-ML": "bm-Latn-ML",
      "und-Mlym": "ml-Mlym-IN",
      "und-MM": "my-Mymr-MM",
      "und-MN": "mn-Cyrl-MN",
      "und-MO": "zh-Hant-MO",
      "und-Modi": "mr-Modi-IN",
      "und-Mong": "mn-Mong-CN",
      "und-MQ": "fr-Latn-MQ",
      "und-MR": "ar-Arab-MR",
      "und-Mroo": "mro-Mroo-BD",
      "und-MT": "mt-Latn-MT",
      "und-Mtei": "mni-Mtei-IN",
      "und-MU": "mfe-Latn-MU",
      "und-Mult": "skr-Mult-PK",
      "und-MV": "dv-Thaa-MV",
      "und-MX": "es-Latn-MX",
      "und-MY": "ms-Latn-MY",
      "und-Mymr": "my-Mymr-MM",
      "und-Mymr-IN": "kht-Mymr-IN",
      "und-Mymr-TH": "mnw-Mymr-TH",
      "und-MZ": "pt-Latn-MZ",
      "und-NA": "af-Latn-NA",
      "und-Nand": "sa-Nand-IN",
      "und-Narb": "xna-Narb-SA",
      "und-Nbat": "arc-Nbat-JO",
      "und-NC": "fr-Latn-NC",
      "und-NE": "ha-Latn-NE",
      "und-Newa": "new-Newa-NP",
      "und-NI": "es-Latn-NI",
      "und-Nkoo": "man-Nkoo-GN",
      "und-NL": "nl-Latn-NL",
      "und-NO": "nb-Latn-NO",
      "und-NP": "ne-Deva-NP",
      "und-Nshu": "zhx-Nshu-CN",
      "und-Ogam": "sga-Ogam-IE",
      "und-Olck": "sat-Olck-IN",
      "und-OM": "ar-Arab-OM",
      "und-Orkh": "otk-Orkh-MN",
      "und-Orya": "or-Orya-IN",
      "und-Osge": "osa-Osge-US",
      "und-Osma": "so-Osma-SO",
      "und-PA": "es-Latn-PA",
      "und-Palm": "arc-Palm-SY",
      "und-Pauc": "ctd-Pauc-MM",
      "und-PE": "es-Latn-PE",
      "und-Perm": "kv-Perm-RU",
      "und-PF": "fr-Latn-PF",
      "und-PG": "tpi-Latn-PG",
      "und-PH": "fil-Latn-PH",
      "und-Phag": "lzh-Phag-CN",
      "und-Phli": "pal-Phli-IR",
      "und-Phlp": "pal-Phlp-CN",
      "und-Phnx": "phn-Phnx-LB",
      "und-PK": "ur-Arab-PK",
      "und-PL": "pl-Latn-PL",
      "und-Plrd": "hmd-Plrd-CN",
      "und-PM": "fr-Latn-PM",
      "und-PR": "es-Latn-PR",
      "und-Prti": "xpr-Prti-IR",
      "und-PS": "ar-Arab-PS",
      "und-PT": "pt-Latn-PT",
      "und-PW": "pau-Latn-PW",
      "und-PY": "gn-Latn-PY",
      "und-QA": "ar-Arab-QA",
      "und-QO": "en-Latn-DG",
      "und-RE": "fr-Latn-RE",
      "und-Rjng": "rej-Rjng-ID",
      "und-RO": "ro-Latn-RO",
      "und-Rohg": "rhg-Rohg-MM",
      "und-RS": "sr-Cyrl-RS",
      "und-RU": "ru-Cyrl-RU",
      "und-Runr": "non-Runr-SE",
      "und-RW": "rw-Latn-RW",
      "und-SA": "ar-Arab-SA",
      "und-Samr": "smp-Samr-IL",
      "und-Sarb": "xsa-Sarb-YE",
      "und-Saur": "saz-Saur-IN",
      "und-SC": "fr-Latn-SC",
      "und-SD": "ar-Arab-SD",
      "und-SE": "sv-Latn-SE",
      "und-Sgnw": "ase-Sgnw-US",
      "und-Shaw": "en-Shaw-GB",
      "und-Shrd": "sa-Shrd-IN",
      "und-SI": "sl-Latn-SI",
      "und-Sidd": "sa-Sidd-IN",
      "und-Sind": "sd-Sind-IN",
      "und-Sinh": "si-Sinh-LK",
      "und-SJ": "nb-Latn-SJ",
      "und-SK": "sk-Latn-SK",
      "und-SM": "it-Latn-SM",
      "und-SN": "fr-Latn-SN",
      "und-SO": "so-Latn-SO",
      "und-Sogd": "sog-Sogd-UZ",
      "und-Sogo": "sog-Sogo-UZ",
      "und-Sora": "srb-Sora-IN",
      "und-Soyo": "cmg-Soyo-MN",
      "und-SR": "nl-Latn-SR",
      "und-ST": "pt-Latn-ST",
      "und-Sund": "su-Sund-ID",
      "und-SV": "es-Latn-SV",
      "und-SY": "ar-Arab-SY",
      "und-Sylo": "syl-Sylo-BD",
      "und-Syrc": "syr-Syrc-IQ",
      "und-Tagb": "tbw-Tagb-PH",
      "und-Takr": "doi-Takr-IN",
      "und-Tale": "tdd-Tale-CN",
      "und-Talu": "khb-Talu-CN",
      "und-Taml": "ta-Taml-IN",
      "und-Tang": "txg-Tang-CN",
      "und-Tavt": "blt-Tavt-VN",
      "und-TD": "fr-Latn-TD",
      "und-Telu": "te-Telu-IN",
      "und-TF": "fr-Latn-TF",
      "und-Tfng": "zgh-Tfng-MA",
      "und-TG": "fr-Latn-TG",
      "und-Tglg": "fil-Tglg-PH",
      "und-TH": "th-Thai-TH",
      "und-Thaa": "dv-Thaa-MV",
      "und-Thai": "th-Thai-TH",
      "und-Thai-CN": "lcp-Thai-CN",
      "und-Thai-KH": "kdt-Thai-KH",
      "und-Thai-LA": "kdt-Thai-LA",
      "und-Tibt": "bo-Tibt-CN",
      "und-Tirh": "mai-Tirh-IN",
      "und-TJ": "tg-Cyrl-TJ",
      "und-TK": "tkl-Latn-TK",
      "und-TL": "pt-Latn-TL",
      "und-TM": "tk-Latn-TM",
      "und-TN": "ar-Arab-TN",
      "und-TO": "to-Latn-TO",
      "und-TR": "tr-Latn-TR",
      "und-TV": "tvl-Latn-TV",
      "und-TW": "zh-Hant-TW",
      "und-TZ": "sw-Latn-TZ",
      "und-UA": "uk-Cyrl-UA",
      "und-UG": "sw-Latn-UG",
      "und-Ugar": "uga-Ugar-SY",
      "und-UY": "es-Latn-UY",
      "und-UZ": "uz-Latn-UZ",
      "und-VA": "it-Latn-VA",
      "und-Vaii": "vai-Vaii-LR",
      "und-VE": "es-Latn-VE",
      "und-VN": "vi-Latn-VN",
      "und-VU": "bi-Latn-VU",
      "und-Wara": "hoc-Wara-IN",
      "und-Wcho": "nnp-Wcho-IN",
      "und-WF": "fr-Latn-WF",
      "und-WS": "sm-Latn-WS",
      "und-XK": "sq-Latn-XK",
      "und-Xpeo": "peo-Xpeo-IR",
      "und-Xsux": "akk-Xsux-IQ",
      "und-YE": "ar-Arab-YE",
      "und-Yiii": "ii-Yiii-CN",
      "und-YT": "fr-Latn-YT",
      "und-Zanb": "cmg-Zanb-MN",
      "und-ZW": "sn-Latn-ZW",
      "unr": "unr-Beng-IN",
      "unr-Deva": "unr-Deva-NP",
      "unr-NP": "unr-Deva-NP",
      "unx": "unx-Beng-IN",
      "uok": "uok-Latn-ZZ",
      "ur": "ur-Arab-PK",
      "uri": "uri-Latn-ZZ",
      "urt": "urt-Latn-ZZ",
      "urw": "urw-Latn-ZZ",
      "usa": "usa-Latn-ZZ",
      "utr": "utr-Latn-ZZ",
      "uvh": "uvh-Latn-ZZ",
      "uvl": "uvl-Latn-ZZ",
      "uz": "uz-Latn-UZ",
      "uz-AF": "uz-Arab-AF",
      "uz-Arab": "uz-Arab-AF",
      "uz-CN": "uz-Cyrl-CN",
      "vag": "vag-Latn-ZZ",
      "vai": "vai-Vaii-LR",
      "van": "van-Latn-ZZ",
      "ve": "ve-Latn-ZA",
      "vec": "vec-Latn-IT",
      "vep": "vep-Latn-RU",
      "vi": "vi-Latn-VN",
      "vic": "vic-Latn-SX",
      "viv": "viv-Latn-ZZ",
      "vls": "vls-Latn-BE",
      "vmf": "vmf-Latn-DE",
      "vmw": "vmw-Latn-MZ",
      "vo": "vo-Latn-001",
      "vot": "vot-Latn-RU",
      "vro": "vro-Latn-EE",
      "vun": "vun-Latn-TZ",
      "vut": "vut-Latn-ZZ",
      "wa": "wa-Latn-BE",
      "wae": "wae-Latn-CH",
      "waj": "waj-Latn-ZZ",
      "wal": "wal-Ethi-ET",
      "wan": "wan-Latn-ZZ",
      "war": "war-Latn-PH",
      "wbp": "wbp-Latn-AU",
      "wbq": "wbq-Telu-IN",
      "wbr": "wbr-Deva-IN",
      "wci": "wci-Latn-ZZ",
      "wer": "wer-Latn-ZZ",
      "wgi": "wgi-Latn-ZZ",
      "whg": "whg-Latn-ZZ",
      "wib": "wib-Latn-ZZ",
      "wiu": "wiu-Latn-ZZ",
      "wiv": "wiv-Latn-ZZ",
      "wja": "wja-Latn-ZZ",
      "wji": "wji-Latn-ZZ",
      "wls": "wls-Latn-WF",
      "wmo": "wmo-Latn-ZZ",
      "wnc": "wnc-Latn-ZZ",
      "wni": "wni-Arab-KM",
      "wnu": "wnu-Latn-ZZ",
      "wo": "wo-Latn-SN",
      "wob": "wob-Latn-ZZ",
      "wos": "wos-Latn-ZZ",
      "wrs": "wrs-Latn-ZZ",
      "wsg": "wsg-Gong-IN",
      "wsk": "wsk-Latn-ZZ",
      "wtm": "wtm-Deva-IN",
      "wuu": "wuu-Hans-CN",
      "wuv": "wuv-Latn-ZZ",
      "wwa": "wwa-Latn-ZZ",
      "xav": "xav-Latn-BR",
      "xbi": "xbi-Latn-ZZ",
      "xcr": "xcr-Cari-TR",
      "xes": "xes-Latn-ZZ",
      "xh": "xh-Latn-ZA",
      "xla": "xla-Latn-ZZ",
      "xlc": "xlc-Lyci-TR",
      "xld": "xld-Lydi-TR",
      "xmf": "xmf-Geor-GE",
      "xmn": "xmn-Mani-CN",
      "xmr": "xmr-Merc-SD",
      "xna": "xna-Narb-SA",
      "xnr": "xnr-Deva-IN",
      "xog": "xog-Latn-UG",
      "xon": "xon-Latn-ZZ",
      "xpr": "xpr-Prti-IR",
      "xrb": "xrb-Latn-ZZ",
      "xsa": "xsa-Sarb-YE",
      "xsi": "xsi-Latn-ZZ",
      "xsm": "xsm-Latn-ZZ",
      "xsr": "xsr-Deva-NP",
      "xwe": "xwe-Latn-ZZ",
      "yam": "yam-Latn-ZZ",
      "yao": "yao-Latn-MZ",
      "yap": "yap-Latn-FM",
      "yas": "yas-Latn-ZZ",
      "yat": "yat-Latn-ZZ",
      "yav": "yav-Latn-CM",
      "yay": "yay-Latn-ZZ",
      "yaz": "yaz-Latn-ZZ",
      "yba": "yba-Latn-ZZ",
      "ybb": "ybb-Latn-CM",
      "yby": "yby-Latn-ZZ",
      "yer": "yer-Latn-ZZ",
      "ygr": "ygr-Latn-ZZ",
      "ygw": "ygw-Latn-ZZ",
      "yi": "yi-Hebr-001",
      "yko": "yko-Latn-ZZ",
      "yle": "yle-Latn-ZZ",
      "ylg": "ylg-Latn-ZZ",
      "yll": "yll-Latn-ZZ",
      "yml": "yml-Latn-ZZ",
      "yo": "yo-Latn-NG",
      "yon": "yon-Latn-ZZ",
      "yrb": "yrb-Latn-ZZ",
      "yre": "yre-Latn-ZZ",
      "yrl": "yrl-Latn-BR",
      "yss": "yss-Latn-ZZ",
      "yua": "yua-Latn-MX",
      "yue": "yue-Hant-HK",
      "yue-CN": "yue-Hans-CN",
      "yue-Hans": "yue-Hans-CN",
      "yuj": "yuj-Latn-ZZ",
      "yut": "yut-Latn-ZZ",
      "yuw": "yuw-Latn-ZZ",
      "za": "za-Latn-CN",
      "zag": "zag-Latn-SD",
      "zdj": "zdj-Arab-KM",
      "zea": "zea-Latn-NL",
      "zgh": "zgh-Tfng-MA",
      "zh": "zh-Hans-CN",
      "zh-AU": "zh-Hant-AU",
      "zh-BN": "zh-Hant-BN",
      "zh-Bopo": "zh-Bopo-TW",
      "zh-GB": "zh-Hant-GB",
      "zh-GF": "zh-Hant-GF",
      "zh-Hanb": "zh-Hanb-TW",
      "zh-Hant": "zh-Hant-TW",
      "zh-HK": "zh-Hant-HK",
      "zh-ID": "zh-Hant-ID",
      "zh-MO": "zh-Hant-MO",
      "zh-MY": "zh-Hant-MY",
      "zh-PA": "zh-Hant-PA",
      "zh-PF": "zh-Hant-PF",
      "zh-PH": "zh-Hant-PH",
      "zh-SR": "zh-Hant-SR",
      "zh-TH": "zh-Hant-TH",
      "zh-TW": "zh-Hant-TW",
      "zh-US": "zh-Hant-US",
      "zh-VN": "zh-Hant-VN",
      "zhx": "zhx-Nshu-CN",
      "zia": "zia-Latn-ZZ",
      "zlm": "zlm-Latn-TG",
      "zmi": "zmi-Latn-MY",
      "zne": "zne-Latn-ZZ",
      "zu": "zu-Latn-ZA",
      "zza": "zza-Latn-TR"
    },
    "timeData": {
      "AX": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "BQ": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "CP": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "CZ": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "DK": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "FI": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "ID": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "IS": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "ML": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "NE": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "RU": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "SE": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "SJ": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "SK": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "AS": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "BT": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "DJ": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "ER": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "GH": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "IN": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "LS": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "PG": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "PW": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "SO": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "TO": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "VU": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "WS": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "001": {
        "_allowed": "H h",
        "_preferred": "H"
      },
      "AL": {
        "_allowed": "h H hB",
        "_preferred": "h"
      },
      "TD": {
        "_allowed": "h H hB",
        "_preferred": "h"
      },
      "ca_ES": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "CF": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "CM": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "fr_CA": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "gl_ES": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "it_CH": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "it_IT": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "LU": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "NP": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "PF": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "SC": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "SM": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "SN": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "TF": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "VA": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "CY": {
        "_allowed": "h H hb hB",
        "_preferred": "h"
      },
      "GR": {
        "_allowed": "h H hb hB",
        "_preferred": "h"
      },
      "CO": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "DO": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "KP": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "KR": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "NA": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "PA": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "PR": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "VE": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "AC": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "AI": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "BW": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "BZ": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "CC": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "CK": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "CX": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "DG": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "FK": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "GB": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "GG": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "GI": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "IE": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "IM": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "IO": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "JE": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "LT": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "MK": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "MN": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "MS": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "NF": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "NG": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "NR": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "NU": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "PN": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "SH": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "SX": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "TA": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "ZA": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "af_ZA": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "AR": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "CL": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "CR": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "CU": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "EA": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_BO": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_BR": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_EC": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_ES": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_GQ": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_PE": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "GT": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "HN": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "IC": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "KG": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "KM": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "LK": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "MA": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "MX": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "NI": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "PY": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "SV": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "UY": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "JP": {
        "_allowed": "H h K",
        "_preferred": "H"
      },
      "AD": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "AM": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "AO": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "AT": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "AW": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BE": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BF": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BJ": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BL": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "CG": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "CI": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "CV": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "DE": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "EE": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "FR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GA": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GF": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GN": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GP": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GW": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "HR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "IL": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "IT": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "KZ": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MC": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MD": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MF": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MQ": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MZ": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "NC": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "NL": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "PM": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "PT": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "RE": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "RO": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "SI": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "SR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "ST": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "TG": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "TR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "WF": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "YT": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BD": {
        "_allowed": "h hB H",
        "_preferred": "h"
      },
      "PK": {
        "_allowed": "h hB H",
        "_preferred": "h"
      },
      "AZ": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "BA": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "BG": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "CH": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "GE": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "LI": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "ME": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "RS": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "UA": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "UZ": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "XK": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "AG": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "AU": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "BB": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "BM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "BS": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "CA": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "DM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "en_001": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "FJ": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "FM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "GD": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "GM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "GU": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "GY": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "JM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "KI": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "KN": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "KY": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "LC": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "LR": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "MH": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "MP": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "MW": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "NZ": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SB": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SG": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SL": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SS": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SZ": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "TC": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "TT": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "UM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "US": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "VC": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "VG": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "VI": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "ZM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "BO": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "EC": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "ES": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "GQ": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "PE": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "AE": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "ar_001": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "BH": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "DZ": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "EG": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "EH": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "IQ": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "JO": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "KW": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "LB": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "LY": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "MR": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "OM": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "PH": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "PS": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "QA": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "SA": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "SD": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "SY": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "TN": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "YE": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "AF": {
        "_allowed": "H hb hB h",
        "_preferred": "H"
      },
      "LA": {
        "_allowed": "H hb hB h",
        "_preferred": "H"
      },
      "LV": {
        "_allowed": "H hB hb h",
        "_preferred": "H"
      },
      "TL": {
        "_allowed": "H hB hb h",
        "_preferred": "H"
      },
      "zu_ZA": {
        "_allowed": "H hB hb h",
        "_preferred": "H"
      },
      "CD": {
        "_allowed": "hB H",
        "_preferred": "H"
      },
      "IR": {
        "_allowed": "hB H",
        "_preferred": "H"
      },
      "hi_IN": {
        "_allowed": "hB h H",
        "_preferred": "h"
      },
      "kn_IN": {
        "_allowed": "hB h H",
        "_preferred": "h"
      },
      "ml_IN": {
        "_allowed": "hB h H",
        "_preferred": "h"
      },
      "te_IN": {
        "_allowed": "hB h H",
        "_preferred": "h"
      },
      "KH": {
        "_allowed": "hB h H hb",
        "_preferred": "h"
      },
      "ta_IN": {
        "_allowed": "hB h hb H",
        "_preferred": "h"
      },
      "BN": {
        "_allowed": "hb hB h H",
        "_preferred": "h"
      },
      "MY": {
        "_allowed": "hb hB h H",
        "_preferred": "h"
      },
      "CN": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "ET": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "gu_IN": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "HK": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "MO": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "mr_IN": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "pa_IN": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "TW": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "KE": {
        "_allowed": "hB hb H h",
        "_preferred": "H"
      },
      "MM": {
        "_allowed": "hB hb H h",
        "_preferred": "H"
      },
      "TZ": {
        "_allowed": "hB hb H h",
        "_preferred": "H"
      },
      "UG": {
        "_allowed": "hB hb H h",
        "_preferred": "H"
      }
    },
    "weekData": {
      "minDays": {
        "001": "1",
        "AD": "4",
        "AN": "4",
        "AT": "4",
        "AX": "4",
        "BE": "4",
        "BG": "4",
        "CH": "4",
        "CZ": "4",
        "DE": "4",
        "DK": "4",
        "EE": "4",
        "ES": "4",
        "FI": "4",
        "FJ": "4",
        "FO": "4",
        "FR": "4",
        "GB": "4",
        "GF": "4",
        "GG": "4",
        "GI": "4",
        "GP": "4",
        "GR": "4",
        "GU": "1",
        "HU": "4",
        "IE": "4",
        "IM": "4",
        "IS": "4",
        "IT": "4",
        "JE": "4",
        "LI": "4",
        "LT": "4",
        "LU": "4",
        "MC": "4",
        "MQ": "4",
        "NL": "4",
        "NO": "4",
        "PL": "4",
        "PT": "4",
        "RE": "4",
        "RU": "4",
        "SE": "4",
        "SJ": "4",
        "SK": "4",
        "SM": "4",
        "UM": "1",
        "US": "1",
        "VA": "4",
        "VI": "1"
      },
      "firstDay": {
        "001": "mon",
        "AD": "mon",
        "AE": "sat",
        "AF": "sat",
        "AG": "sun",
        "AI": "mon",
        "AL": "mon",
        "AM": "mon",
        "AN": "mon",
        "AR": "mon",
        "AS": "sun",
        "AT": "mon",
        "AU": "sun",
        "AX": "mon",
        "AZ": "mon",
        "BA": "mon",
        "BD": "sun",
        "BE": "mon",
        "BG": "mon",
        "BH": "sat",
        "BM": "mon",
        "BN": "mon",
        "BR": "sun",
        "BS": "sun",
        "BT": "sun",
        "BW": "sun",
        "BY": "mon",
        "BZ": "sun",
        "CA": "sun",
        "CH": "mon",
        "CL": "mon",
        "CM": "mon",
        "CN": "sun",
        "CO": "sun",
        "CR": "mon",
        "CY": "mon",
        "CZ": "mon",
        "DE": "mon",
        "DJ": "sat",
        "DK": "mon",
        "DM": "sun",
        "DO": "sun",
        "DZ": "sat",
        "EC": "mon",
        "EE": "mon",
        "EG": "sat",
        "ES": "mon",
        "ET": "sun",
        "FI": "mon",
        "FJ": "mon",
        "FO": "mon",
        "FR": "mon",
        "GB": "mon",
        "GB-alt-variant": "sun",
        "GE": "mon",
        "GF": "mon",
        "GP": "mon",
        "GR": "mon",
        "GT": "sun",
        "GU": "sun",
        "HK": "sun",
        "HN": "sun",
        "HR": "mon",
        "HU": "mon",
        "ID": "sun",
        "IE": "mon",
        "IL": "sun",
        "IN": "sun",
        "IQ": "sat",
        "IR": "sat",
        "IS": "mon",
        "IT": "mon",
        "JM": "sun",
        "JO": "sat",
        "JP": "sun",
        "KE": "sun",
        "KG": "mon",
        "KH": "sun",
        "KR": "sun",
        "KW": "sat",
        "KZ": "mon",
        "LA": "sun",
        "LB": "mon",
        "LI": "mon",
        "LK": "mon",
        "LT": "mon",
        "LU": "mon",
        "LV": "mon",
        "LY": "sat",
        "MC": "mon",
        "MD": "mon",
        "ME": "mon",
        "MH": "sun",
        "MK": "mon",
        "MM": "sun",
        "MN": "mon",
        "MO": "sun",
        "MQ": "mon",
        "MT": "sun",
        "MV": "fri",
        "MX": "sun",
        "MY": "mon",
        "MZ": "sun",
        "NI": "sun",
        "NL": "mon",
        "NO": "mon",
        "NP": "sun",
        "NZ": "mon",
        "OM": "sat",
        "PA": "sun",
        "PE": "sun",
        "PH": "sun",
        "PK": "sun",
        "PL": "mon",
        "PR": "sun",
        "PT": "sun",
        "PY": "sun",
        "QA": "sat",
        "RE": "mon",
        "RO": "mon",
        "RS": "mon",
        "RU": "mon",
        "SA": "sun",
        "SD": "sat",
        "SE": "mon",
        "SG": "sun",
        "SI": "mon",
        "SK": "mon",
        "SM": "mon",
        "SV": "sun",
        "SY": "sat",
        "TH": "sun",
        "TJ": "mon",
        "TM": "mon",
        "TR": "mon",
        "TT": "sun",
        "TW": "sun",
        "UA": "mon",
        "UM": "sun",
        "US": "sun",
        "UY": "mon",
        "UZ": "mon",
        "VA": "mon",
        "VE": "sun",
        "VI": "sun",
        "VN": "mon",
        "WS": "sun",
        "XK": "mon",
        "YE": "sun",
        "ZA": "sun",
        "ZW": "sun"
      },
      "weekendStart": {
        "001": "sat",
        "AE": "fri",
        "AF": "thu",
        "BH": "fri",
        "DZ": "fri",
        "EG": "fri",
        "IL": "fri",
        "IN": "sun",
        "IQ": "fri",
        "IR": "fri",
        "JO": "fri",
        "KW": "fri",
        "LY": "fri",
        "OM": "fri",
        "QA": "fri",
        "SA": "fri",
        "SD": "fri",
        "SY": "fri",
        "UG": "sun",
        "YE": "fri"
      },
      "weekendEnd": {
        "001": "sun",
        "AE": "sat",
        "AF": "fri",
        "BH": "sat",
        "DZ": "sat",
        "EG": "sat",
        "IL": "sat",
        "IQ": "sat",
        "IR": "fri",
        "JO": "sat",
        "KW": "sat",
        "LY": "sat",
        "OM": "sat",
        "QA": "sat",
        "SA": "sat",
        "SD": "sat",
        "SY": "sat",
        "YE": "sat"
      },
      "af": {
        "_ordering": "weekOfDate weekOfInterval weekOfMonth"
      },
      "am az bs cs cy da el et hi ky lt mk sk ta th": {
        "_ordering": "weekOfYear weekOfMonth"
      },
      "ar fil gu hu hy id kk ko": {
        "_ordering": "weekOfMonth"
      },
      "be ro ru": {
        "_ordering": "weekOfInterval weekOfMonth"
      },
      "bg de iw pt ur zh": {
        "_ordering": "weekOfDate weekOfMonth weekOfInterval"
      },
      "ca es fr gl": {
        "_ordering": "weekOfDate"
      },
      "en bn ja ka": {
        "_ordering": "weekOfDate weekOfMonth"
      },
      "eu": {
        "_ordering": "weekOfMonth weekOfDate"
      },
      "fa hr it lv pl si sr uk uz": {
        "_ordering": "weekOfMonth weekOfInterval"
      },
      "fi zh-TW": {
        "_ordering": "weekOfYear weekOfDate weekOfMonth"
      },
      "is mn no sv vi": {
        "_ordering": "weekOfYear weekOfMonth weekOfInterval"
      },
      "km mr": {
        "_ordering": "weekOfMonth weekOfYear"
      },
      "kn ml pa": {
        "_ordering": "weekOfMonth weekOfDate weekOfYear"
      },
      "lo sq": {
        "_ordering": "weekOfMonth weekOfInterval weekOfDate weekOfYear"
      },
      "ms tr": {
        "_ordering": "weekOfMonth weekOfYear weekOfInterval weekOfDate"
      },
      "nl": {
        "_ordering": "weekOfDate weekOfYear weekOfMonth"
      },
      "sl": {
        "_ordering": "weekOfInterval"
      },
      "sw te": {
        "_ordering": "weekOfMonth weekOfInterval weekOfYear"
      },
      "und": {
        "_ordering": "weekOfYear"
      },
      "zu": {
        "_ordering": "weekOfYear weekOfInterval"
      }
    },
    "currencyData": {
      "fractions": {
        "ADP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "AFN": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ALL": {
          "_rounding": "0",
          "_digits": "0"
        },
        "AMD": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "BHD": {
          "_rounding": "0",
          "_digits": "3"
        },
        "BIF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "BYN": {
          "_rounding": "0",
          "_digits": "2"
        },
        "BYR": {
          "_rounding": "0",
          "_digits": "0"
        },
        "CAD": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "5"
        },
        "CHF": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "5"
        },
        "CLF": {
          "_rounding": "0",
          "_digits": "4"
        },
        "CLP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "COP": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "CRC": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "CZK": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "DEFAULT": {
          "_rounding": "0",
          "_digits": "2"
        },
        "DJF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "DKK": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "50"
        },
        "ESP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "GNF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "GYD": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "HUF": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "IDR": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "IQD": {
          "_rounding": "0",
          "_digits": "0"
        },
        "IRR": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ISK": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ITL": {
          "_rounding": "0",
          "_digits": "0"
        },
        "JOD": {
          "_rounding": "0",
          "_digits": "3"
        },
        "JPY": {
          "_rounding": "0",
          "_digits": "0"
        },
        "KMF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "KPW": {
          "_rounding": "0",
          "_digits": "0"
        },
        "KRW": {
          "_rounding": "0",
          "_digits": "0"
        },
        "KWD": {
          "_rounding": "0",
          "_digits": "3"
        },
        "LAK": {
          "_rounding": "0",
          "_digits": "0"
        },
        "LBP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "LUF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "LYD": {
          "_rounding": "0",
          "_digits": "3"
        },
        "MGA": {
          "_rounding": "0",
          "_digits": "0"
        },
        "MGF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "MMK": {
          "_rounding": "0",
          "_digits": "0"
        },
        "MNT": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "MRO": {
          "_rounding": "0",
          "_digits": "0"
        },
        "MUR": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "NOK": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "OMR": {
          "_rounding": "0",
          "_digits": "3"
        },
        "PKR": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "PYG": {
          "_rounding": "0",
          "_digits": "0"
        },
        "RSD": {
          "_rounding": "0",
          "_digits": "0"
        },
        "RWF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "SEK": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "SLL": {
          "_rounding": "0",
          "_digits": "0"
        },
        "SOS": {
          "_rounding": "0",
          "_digits": "0"
        },
        "STD": {
          "_rounding": "0",
          "_digits": "0"
        },
        "SYP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "TMM": {
          "_rounding": "0",
          "_digits": "0"
        },
        "TND": {
          "_rounding": "0",
          "_digits": "3"
        },
        "TRL": {
          "_rounding": "0",
          "_digits": "0"
        },
        "TWD": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "TZS": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "UGX": {
          "_rounding": "0",
          "_digits": "0"
        },
        "UYI": {
          "_rounding": "0",
          "_digits": "0"
        },
        "UYW": {
          "_rounding": "0",
          "_digits": "4"
        },
        "UZS": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "VEF": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "VND": {
          "_rounding": "0",
          "_digits": "0"
        },
        "VUV": {
          "_rounding": "0",
          "_digits": "0"
        },
        "XAF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "XOF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "XPF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "YER": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ZMK": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ZWD": {
          "_rounding": "0",
          "_digits": "0"
        }
      },
      "region": {
        "AC": [{
          "SHP": {
            "_from": "1976-01-01"
          }
        }],
        "AD": [{
          "ESP": {
            "_from": "1873-01-01",
            "_to": "2002-02-28"
          }
        }, {
          "ADP": {
            "_from": "1936-01-01",
            "_to": "2001-12-31"
          }
        }, {
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "AE": [{
          "AED": {
            "_from": "1973-05-19"
          }
        }],
        "AF": [{
          "AFA": {
            "_from": "1927-03-14",
            "_to": "2002-12-31"
          }
        }, {
          "AFN": {
            "_from": "2002-10-07"
          }
        }],
        "AG": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "AI": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "AL": [{
          "ALK": {
            "_from": "1946-11-01",
            "_to": "1965-08-16"
          }
        }, {
          "ALL": {
            "_from": "1965-08-16"
          }
        }],
        "AM": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1993-11-22"
          }
        }, {
          "AMD": {
            "_from": "1993-11-22"
          }
        }],
        "AO": [{
          "AOK": {
            "_from": "1977-01-08",
            "_to": "1991-03-01"
          }
        }, {
          "AON": {
            "_from": "1990-09-25",
            "_to": "2000-02-01"
          }
        }, {
          "AOR": {
            "_from": "1995-07-01",
            "_to": "2000-02-01"
          }
        }, {
          "AOA": {
            "_from": "1999-12-13"
          }
        }],
        "AQ": [{
          "XXX": {
            "_tender": "false"
          }
        }],
        "AR": [{
          "ARM": {
            "_from": "1881-11-05",
            "_to": "1970-01-01"
          }
        }, {
          "ARL": {
            "_from": "1970-01-01",
            "_to": "1983-06-01"
          }
        }, {
          "ARP": {
            "_from": "1983-06-01",
            "_to": "1985-06-14"
          }
        }, {
          "ARA": {
            "_from": "1985-06-14",
            "_to": "1992-01-01"
          }
        }, {
          "ARS": {
            "_from": "1992-01-01"
          }
        }],
        "AS": [{
          "USD": {
            "_from": "1904-07-16"
          }
        }],
        "AT": [{
          "ATS": {
            "_from": "1947-12-04",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "AU": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "AW": [{
          "ANG": {
            "_from": "1940-05-10",
            "_to": "1986-01-01"
          }
        }, {
          "AWG": {
            "_from": "1986-01-01"
          }
        }],
        "AX": [{
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "AZ": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1994-01-01"
          }
        }, {
          "AZM": {
            "_from": "1993-11-22",
            "_to": "2006-12-31"
          }
        }, {
          "AZN": {
            "_from": "2006-01-01"
          }
        }],
        "BA": [{
          "YUD": {
            "_from": "1966-01-01",
            "_to": "1990-01-01"
          }
        }, {
          "YUN": {
            "_from": "1990-01-01",
            "_to": "1992-07-01"
          }
        }, {
          "YUR": {
            "_from": "1992-07-01",
            "_to": "1993-10-01"
          }
        }, {
          "BAD": {
            "_from": "1992-07-01",
            "_to": "1994-08-15"
          }
        }, {
          "BAN": {
            "_from": "1994-08-15",
            "_to": "1997-07-01"
          }
        }, {
          "BAM": {
            "_from": "1995-01-01"
          }
        }],
        "BB": [{
          "XCD": {
            "_from": "1965-10-06",
            "_to": "1973-12-03"
          }
        }, {
          "BBD": {
            "_from": "1973-12-03"
          }
        }],
        "BD": [{
          "INR": {
            "_from": "1835-08-17",
            "_to": "1948-04-01"
          }
        }, {
          "PKR": {
            "_from": "1948-04-01",
            "_to": "1972-01-01"
          }
        }, {
          "BDT": {
            "_from": "1972-01-01"
          }
        }],
        "BE": [{
          "NLG": {
            "_from": "1816-12-15",
            "_to": "1831-02-07"
          }
        }, {
          "BEF": {
            "_from": "1831-02-07",
            "_to": "2002-02-28"
          }
        }, {
          "BEC": {
            "_tender": "false",
            "_from": "1970-01-01",
            "_to": "1990-03-05"
          }
        }, {
          "BEL": {
            "_tender": "false",
            "_from": "1970-01-01",
            "_to": "1990-03-05"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "BF": [{
          "XOF": {
            "_from": "1984-08-04"
          }
        }],
        "BG": [{
          "BGO": {
            "_from": "1879-07-08",
            "_to": "1952-05-12"
          }
        }, {
          "BGM": {
            "_from": "1952-05-12",
            "_to": "1962-01-01"
          }
        }, {
          "BGL": {
            "_from": "1962-01-01",
            "_to": "1999-07-05"
          }
        }, {
          "BGN": {
            "_from": "1999-07-05"
          }
        }],
        "BH": [{
          "BHD": {
            "_from": "1965-10-16"
          }
        }],
        "BI": [{
          "BIF": {
            "_from": "1964-05-19"
          }
        }],
        "BJ": [{
          "XOF": {
            "_from": "1975-11-30"
          }
        }],
        "BL": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "BM": [{
          "BMD": {
            "_from": "1970-02-06"
          }
        }],
        "BN": [{
          "MYR": {
            "_from": "1963-09-16",
            "_to": "1967-06-12"
          }
        }, {
          "BND": {
            "_from": "1967-06-12"
          }
        }],
        "BO": [{
          "BOV": {
            "_tender": "false"
          }
        }, {
          "BOL": {
            "_from": "1863-06-23",
            "_to": "1963-01-01"
          }
        }, {
          "BOP": {
            "_from": "1963-01-01",
            "_to": "1986-12-31"
          }
        }, {
          "BOB": {
            "_from": "1987-01-01"
          }
        }],
        "BQ": [{
          "ANG": {
            "_from": "2010-10-10",
            "_to": "2011-01-01"
          }
        }, {
          "USD": {
            "_from": "2011-01-01"
          }
        }],
        "BR": [{
          "BRZ": {
            "_from": "1942-11-01",
            "_to": "1967-02-13"
          }
        }, {
          "BRB": {
            "_from": "1967-02-13",
            "_to": "1986-02-28"
          }
        }, {
          "BRC": {
            "_from": "1986-02-28",
            "_to": "1989-01-15"
          }
        }, {
          "BRN": {
            "_from": "1989-01-15",
            "_to": "1990-03-16"
          }
        }, {
          "BRE": {
            "_from": "1990-03-16",
            "_to": "1993-08-01"
          }
        }, {
          "BRR": {
            "_from": "1993-08-01",
            "_to": "1994-07-01"
          }
        }, {
          "BRL": {
            "_from": "1994-07-01"
          }
        }],
        "BS": [{
          "BSD": {
            "_from": "1966-05-25"
          }
        }],
        "BT": [{
          "INR": {
            "_from": "1907-01-01"
          }
        }, {
          "BTN": {
            "_from": "1974-04-16"
          }
        }],
        "BU": [{
          "BUK": {
            "_from": "1952-07-01",
            "_to": "1989-06-18"
          }
        }],
        "BV": [{
          "NOK": {
            "_from": "1905-06-07"
          }
        }],
        "BW": [{
          "ZAR": {
            "_from": "1961-02-14",
            "_to": "1976-08-23"
          }
        }, {
          "BWP": {
            "_from": "1976-08-23"
          }
        }],
        "BY": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1994-11-08"
          }
        }, {
          "BYB": {
            "_from": "1994-08-01",
            "_to": "2000-12-31"
          }
        }, {
          "BYR": {
            "_from": "2000-01-01",
            "_to": "2017-01-01"
          }
        }, {
          "BYN": {
            "_from": "2016-07-01"
          }
        }],
        "BZ": [{
          "BZD": {
            "_from": "1974-01-01"
          }
        }],
        "CA": [{
          "CAD": {
            "_from": "1858-01-01"
          }
        }],
        "CC": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "CD": [{
          "ZRZ": {
            "_from": "1971-10-27",
            "_to": "1993-11-01"
          }
        }, {
          "ZRN": {
            "_from": "1993-11-01",
            "_to": "1998-07-01"
          }
        }, {
          "CDF": {
            "_from": "1998-07-01"
          }
        }],
        "CF": [{
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "CG": [{
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "CH": [{
          "CHE": {
            "_tender": "false"
          }
        }, {
          "CHW": {
            "_tender": "false"
          }
        }, {
          "CHF": {
            "_from": "1799-03-17"
          }
        }],
        "CI": [{
          "XOF": {
            "_from": "1958-12-04"
          }
        }],
        "CK": [{
          "NZD": {
            "_from": "1967-07-10"
          }
        }],
        "CL": [{
          "CLF": {
            "_tender": "false"
          }
        }, {
          "CLE": {
            "_from": "1960-01-01",
            "_to": "1975-09-29"
          }
        }, {
          "CLP": {
            "_from": "1975-09-29"
          }
        }],
        "CM": [{
          "XAF": {
            "_from": "1973-04-01"
          }
        }],
        "CN": [{
          "CNY": {
            "_from": "1953-03-01"
          }
        }, {
          "CNX": {
            "_tender": "false",
            "_from": "1979-01-01",
            "_to": "1998-12-31"
          }
        }, {
          "CNH": {
            "_tender": "false",
            "_from": "2010-07-19"
          }
        }],
        "CO": [{
          "COU": {
            "_tender": "false"
          }
        }, {
          "COP": {
            "_from": "1905-01-01"
          }
        }],
        "CP": [{
          "XXX": {
            "_tender": "false"
          }
        }],
        "CR": [{
          "CRC": {
            "_from": "1896-10-26"
          }
        }],
        "CS": [{
          "YUM": {
            "_from": "1994-01-24",
            "_to": "2002-05-15"
          }
        }, {
          "CSD": {
            "_from": "2002-05-15",
            "_to": "2006-06-03"
          }
        }, {
          "EUR": {
            "_from": "2003-02-04",
            "_to": "2006-06-03"
          }
        }],
        "CU": [{
          "CUP": {
            "_from": "1859-01-01"
          }
        }, {
          "USD": {
            "_from": "1899-01-01",
            "_to": "1959-01-01"
          }
        }, {
          "CUC": {
            "_from": "1994-01-01"
          }
        }],
        "CV": [{
          "PTE": {
            "_from": "1911-05-22",
            "_to": "1975-07-05"
          }
        }, {
          "CVE": {
            "_from": "1914-01-01"
          }
        }],
        "CW": [{
          "ANG": {
            "_from": "2010-10-10"
          }
        }],
        "CX": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "CY": [{
          "CYP": {
            "_from": "1914-09-10",
            "_to": "2008-01-31"
          }
        }, {
          "EUR": {
            "_from": "2008-01-01"
          }
        }],
        "CZ": [{
          "CSK": {
            "_from": "1953-06-01",
            "_to": "1993-03-01"
          }
        }, {
          "CZK": {
            "_from": "1993-01-01"
          }
        }],
        "DD": [{
          "DDM": {
            "_from": "1948-07-20",
            "_to": "1990-10-02"
          }
        }],
        "DE": [{
          "DEM": {
            "_from": "1948-06-20",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "DG": [{
          "USD": {
            "_from": "1965-11-08"
          }
        }],
        "DJ": [{
          "DJF": {
            "_from": "1977-06-27"
          }
        }],
        "DK": [{
          "DKK": {
            "_from": "1873-05-27"
          }
        }],
        "DM": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "DO": [{
          "USD": {
            "_from": "1905-06-21",
            "_to": "1947-10-01"
          }
        }, {
          "DOP": {
            "_from": "1947-10-01"
          }
        }],
        "DZ": [{
          "DZD": {
            "_from": "1964-04-01"
          }
        }],
        "EA": [{
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "EC": [{
          "ECS": {
            "_from": "1884-04-01",
            "_to": "2000-10-02"
          }
        }, {
          "ECV": {
            "_tender": "false",
            "_from": "1993-05-23",
            "_to": "2000-01-09"
          }
        }, {
          "USD": {
            "_from": "2000-10-02"
          }
        }],
        "EE": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1992-06-20"
          }
        }, {
          "EEK": {
            "_from": "1992-06-21",
            "_to": "2010-12-31"
          }
        }, {
          "EUR": {
            "_from": "2011-01-01"
          }
        }],
        "EG": [{
          "EGP": {
            "_from": "1885-11-14"
          }
        }],
        "EH": [{
          "MAD": {
            "_from": "1976-02-26"
          }
        }],
        "ER": [{
          "ETB": {
            "_from": "1993-05-24",
            "_to": "1997-11-08"
          }
        }, {
          "ERN": {
            "_from": "1997-11-08"
          }
        }],
        "ES": [{
          "ESP": {
            "_from": "1868-10-19",
            "_to": "2002-02-28"
          }
        }, {
          "ESB": {
            "_tender": "false",
            "_from": "1975-01-01",
            "_to": "1994-12-31"
          }
        }, {
          "ESA": {
            "_tender": "false",
            "_from": "1978-01-01",
            "_to": "1981-12-31"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "ET": [{
          "ETB": {
            "_from": "1976-09-15"
          }
        }],
        "EU": [{
          "XEU": {
            "_tender": "false",
            "_from": "1979-01-01",
            "_to": "1998-12-31"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "FI": [{
          "FIM": {
            "_from": "1963-01-01",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "FJ": [{
          "FJD": {
            "_from": "1969-01-13"
          }
        }],
        "FK": [{
          "FKP": {
            "_from": "1901-01-01"
          }
        }],
        "FM": [{
          "JPY": {
            "_from": "1914-10-03",
            "_to": "1944-01-01"
          }
        }, {
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "FO": [{
          "DKK": {
            "_from": "1948-01-01"
          }
        }],
        "FR": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "GA": [{
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "GB": [{
          "GBP": {
            "_from": "1694-07-27"
          }
        }],
        "GD": [{
          "XCD": {
            "_from": "1967-02-27"
          }
        }],
        "GE": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1993-06-11"
          }
        }, {
          "GEK": {
            "_from": "1993-04-05",
            "_to": "1995-09-25"
          }
        }, {
          "GEL": {
            "_from": "1995-09-23"
          }
        }],
        "GF": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "GG": [{
          "GBP": {
            "_from": "1830-01-01"
          }
        }],
        "GH": [{
          "GHC": {
            "_from": "1979-03-09",
            "_to": "2007-12-31"
          }
        }, {
          "GHS": {
            "_from": "2007-07-03"
          }
        }],
        "GI": [{
          "GIP": {
            "_from": "1713-01-01"
          }
        }],
        "GL": [{
          "DKK": {
            "_from": "1873-05-27"
          }
        }],
        "GM": [{
          "GMD": {
            "_from": "1971-07-01"
          }
        }],
        "GN": [{
          "GNS": {
            "_from": "1972-10-02",
            "_to": "1986-01-06"
          }
        }, {
          "GNF": {
            "_from": "1986-01-06"
          }
        }],
        "GP": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "GQ": [{
          "GQE": {
            "_from": "1975-07-07",
            "_to": "1986-06-01"
          }
        }, {
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "GR": [{
          "GRD": {
            "_from": "1954-05-01",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "2001-01-01"
          }
        }],
        "GS": [{
          "GBP": {
            "_from": "1908-01-01"
          }
        }],
        "GT": [{
          "GTQ": {
            "_from": "1925-05-27"
          }
        }],
        "GU": [{
          "USD": {
            "_from": "1944-08-21"
          }
        }],
        "GW": [{
          "GWE": {
            "_from": "1914-01-01",
            "_to": "1976-02-28"
          }
        }, {
          "GWP": {
            "_from": "1976-02-28",
            "_to": "1997-03-31"
          }
        }, {
          "XOF": {
            "_from": "1997-03-31"
          }
        }],
        "GY": [{
          "GYD": {
            "_from": "1966-05-26"
          }
        }],
        "HK": [{
          "HKD": {
            "_from": "1895-02-02"
          }
        }],
        "HM": [{
          "AUD": {
            "_from": "1967-02-16"
          }
        }],
        "HN": [{
          "HNL": {
            "_from": "1926-04-03"
          }
        }],
        "HR": [{
          "YUD": {
            "_from": "1966-01-01",
            "_to": "1990-01-01"
          }
        }, {
          "YUN": {
            "_from": "1990-01-01",
            "_to": "1991-12-23"
          }
        }, {
          "HRD": {
            "_from": "1991-12-23",
            "_to": "1995-01-01"
          }
        }, {
          "HRK": {
            "_from": "1994-05-30"
          }
        }],
        "HT": [{
          "HTG": {
            "_from": "1872-08-26"
          }
        }, {
          "USD": {
            "_from": "1915-01-01"
          }
        }],
        "HU": [{
          "HUF": {
            "_from": "1946-07-23"
          }
        }],
        "IC": [{
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "ID": [{
          "IDR": {
            "_from": "1965-12-13"
          }
        }],
        "IE": [{
          "GBP": {
            "_from": "1800-01-01",
            "_to": "1922-01-01"
          }
        }, {
          "IEP": {
            "_from": "1922-01-01",
            "_to": "2002-02-09"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "IL": [{
          "ILP": {
            "_from": "1948-08-16",
            "_to": "1980-02-22"
          }
        }, {
          "ILR": {
            "_from": "1980-02-22",
            "_to": "1985-09-04"
          }
        }, {
          "ILS": {
            "_from": "1985-09-04"
          }
        }],
        "IM": [{
          "GBP": {
            "_from": "1840-01-03"
          }
        }],
        "IN": [{
          "INR": {
            "_from": "1835-08-17"
          }
        }],
        "IO": [{
          "USD": {
            "_from": "1965-11-08"
          }
        }],
        "IQ": [{
          "EGP": {
            "_from": "1920-11-11",
            "_to": "1931-04-19"
          }
        }, {
          "INR": {
            "_from": "1920-11-11",
            "_to": "1931-04-19"
          }
        }, {
          "IQD": {
            "_from": "1931-04-19"
          }
        }],
        "IR": [{
          "IRR": {
            "_from": "1932-05-13"
          }
        }],
        "IS": [{
          "DKK": {
            "_from": "1873-05-27",
            "_to": "1918-12-01"
          }
        }, {
          "ISJ": {
            "_from": "1918-12-01",
            "_to": "1981-01-01"
          }
        }, {
          "ISK": {
            "_from": "1981-01-01"
          }
        }],
        "IT": [{
          "ITL": {
            "_from": "1862-08-24",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "JE": [{
          "GBP": {
            "_from": "1837-01-01"
          }
        }],
        "JM": [{
          "JMD": {
            "_from": "1969-09-08"
          }
        }],
        "JO": [{
          "JOD": {
            "_from": "1950-07-01"
          }
        }],
        "JP": [{
          "JPY": {
            "_from": "1871-06-01"
          }
        }],
        "KE": [{
          "KES": {
            "_from": "1966-09-14"
          }
        }],
        "KG": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1993-05-10"
          }
        }, {
          "KGS": {
            "_from": "1993-05-10"
          }
        }],
        "KH": [{
          "KHR": {
            "_from": "1980-03-20"
          }
        }],
        "KI": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "KM": [{
          "KMF": {
            "_from": "1975-07-06"
          }
        }],
        "KN": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "KP": [{
          "KPW": {
            "_from": "1959-04-17"
          }
        }],
        "KR": [{
          "KRO": {
            "_from": "1945-08-15",
            "_to": "1953-02-15"
          }
        }, {
          "KRH": {
            "_from": "1953-02-15",
            "_to": "1962-06-10"
          }
        }, {
          "KRW": {
            "_from": "1962-06-10"
          }
        }],
        "KW": [{
          "KWD": {
            "_from": "1961-04-01"
          }
        }],
        "KY": [{
          "JMD": {
            "_from": "1969-09-08",
            "_to": "1971-01-01"
          }
        }, {
          "KYD": {
            "_from": "1971-01-01"
          }
        }],
        "KZ": [{
          "KZT": {
            "_from": "1993-11-05"
          }
        }],
        "LA": [{
          "LAK": {
            "_from": "1979-12-10"
          }
        }],
        "LB": [{
          "LBP": {
            "_from": "1948-02-02"
          }
        }],
        "LC": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "LI": [{
          "CHF": {
            "_from": "1921-02-01"
          }
        }],
        "LK": [{
          "LKR": {
            "_from": "1978-05-22"
          }
        }],
        "LR": [{
          "LRD": {
            "_from": "1944-01-01"
          }
        }],
        "LS": [{
          "ZAR": {
            "_from": "1961-02-14"
          }
        }, {
          "LSL": {
            "_from": "1980-01-22"
          }
        }],
        "LT": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1992-10-01"
          }
        }, {
          "LTT": {
            "_from": "1992-10-01",
            "_to": "1993-06-25"
          }
        }, {
          "LTL": {
            "_from": "1993-06-25",
            "_to": "2014-12-31"
          }
        }, {
          "EUR": {
            "_from": "2015-01-01"
          }
        }],
        "LU": [{
          "LUF": {
            "_from": "1944-09-04",
            "_to": "2002-02-28"
          }
        }, {
          "LUC": {
            "_tender": "false",
            "_from": "1970-01-01",
            "_to": "1990-03-05"
          }
        }, {
          "LUL": {
            "_tender": "false",
            "_from": "1970-01-01",
            "_to": "1990-03-05"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "LV": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1992-07-20"
          }
        }, {
          "LVR": {
            "_from": "1992-05-07",
            "_to": "1993-10-17"
          }
        }, {
          "LVL": {
            "_from": "1993-06-28",
            "_to": "2013-12-31"
          }
        }, {
          "EUR": {
            "_from": "2014-01-01"
          }
        }],
        "LY": [{
          "LYD": {
            "_from": "1971-09-01"
          }
        }],
        "MA": [{
          "MAF": {
            "_from": "1881-01-01",
            "_to": "1959-10-17"
          }
        }, {
          "MAD": {
            "_from": "1959-10-17"
          }
        }],
        "MC": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "MCF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "MD": [{
          "MDC": {
            "_from": "1992-06-01",
            "_to": "1993-11-29"
          }
        }, {
          "MDL": {
            "_from": "1993-11-29"
          }
        }],
        "ME": [{
          "YUM": {
            "_from": "1994-01-24",
            "_to": "2002-05-15"
          }
        }, {
          "DEM": {
            "_from": "1999-10-02",
            "_to": "2002-05-15"
          }
        }, {
          "EUR": {
            "_from": "2002-01-01"
          }
        }],
        "MF": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "MG": [{
          "MGF": {
            "_from": "1963-07-01",
            "_to": "2004-12-31"
          }
        }, {
          "MGA": {
            "_from": "1983-11-01"
          }
        }],
        "MH": [{
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "MK": [{
          "MKN": {
            "_from": "1992-04-26",
            "_to": "1993-05-20"
          }
        }, {
          "MKD": {
            "_from": "1993-05-20"
          }
        }],
        "ML": [{
          "XOF": {
            "_from": "1958-11-24",
            "_to": "1962-07-02"
          }
        }, {
          "MLF": {
            "_from": "1962-07-02",
            "_to": "1984-08-31"
          }
        }, {
          "XOF": {
            "_from": "1984-06-01"
          }
        }],
        "MM": [{
          "BUK": {
            "_from": "1952-07-01",
            "_to": "1989-06-18"
          }
        }, {
          "MMK": {
            "_from": "1989-06-18"
          }
        }],
        "MN": [{
          "MNT": {
            "_from": "1915-03-01"
          }
        }],
        "MO": [{
          "MOP": {
            "_from": "1901-01-01"
          }
        }],
        "MP": [{
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "MQ": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "MR": [{
          "XOF": {
            "_from": "1958-11-28",
            "_to": "1973-06-29"
          }
        }, {
          "MRO": {
            "_from": "1973-06-29",
            "_to": "2018-06-30"
          }
        }, {
          "MRU": {
            "_from": "2018-01-01"
          }
        }],
        "MS": [{
          "XCD": {
            "_from": "1967-02-27"
          }
        }],
        "MT": [{
          "MTP": {
            "_from": "1914-08-13",
            "_to": "1968-06-07"
          }
        }, {
          "MTL": {
            "_from": "1968-06-07",
            "_to": "2008-01-31"
          }
        }, {
          "EUR": {
            "_from": "2008-01-01"
          }
        }],
        "MU": [{
          "MUR": {
            "_from": "1934-04-01"
          }
        }],
        "MV": [{
          "MVP": {
            "_from": "1947-01-01",
            "_to": "1981-07-01"
          }
        }, {
          "MVR": {
            "_from": "1981-07-01"
          }
        }],
        "MW": [{
          "MWK": {
            "_from": "1971-02-15"
          }
        }],
        "MX": [{
          "MXV": {
            "_tender": "false"
          }
        }, {
          "MXP": {
            "_from": "1822-01-01",
            "_to": "1992-12-31"
          }
        }, {
          "MXN": {
            "_from": "1993-01-01"
          }
        }],
        "MY": [{
          "MYR": {
            "_from": "1963-09-16"
          }
        }],
        "MZ": [{
          "MZE": {
            "_from": "1975-06-25",
            "_to": "1980-06-16"
          }
        }, {
          "MZM": {
            "_from": "1980-06-16",
            "_to": "2006-12-31"
          }
        }, {
          "MZN": {
            "_from": "2006-07-01"
          }
        }],
        "NA": [{
          "ZAR": {
            "_from": "1961-02-14"
          }
        }, {
          "NAD": {
            "_from": "1993-01-01"
          }
        }],
        "NC": [{
          "XPF": {
            "_from": "1985-01-01"
          }
        }],
        "NE": [{
          "XOF": {
            "_from": "1958-12-19"
          }
        }],
        "NF": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "NG": [{
          "NGN": {
            "_from": "1973-01-01"
          }
        }],
        "NI": [{
          "NIC": {
            "_from": "1988-02-15",
            "_to": "1991-04-30"
          }
        }, {
          "NIO": {
            "_from": "1991-04-30"
          }
        }],
        "NL": [{
          "NLG": {
            "_from": "1813-01-01",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "NO": [{
          "SEK": {
            "_from": "1873-05-27",
            "_to": "1905-06-07"
          }
        }, {
          "NOK": {
            "_from": "1905-06-07"
          }
        }],
        "NP": [{
          "INR": {
            "_from": "1870-01-01",
            "_to": "1966-10-17"
          }
        }, {
          "NPR": {
            "_from": "1933-01-01"
          }
        }],
        "NR": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "NU": [{
          "NZD": {
            "_from": "1967-07-10"
          }
        }],
        "NZ": [{
          "NZD": {
            "_from": "1967-07-10"
          }
        }],
        "OM": [{
          "OMR": {
            "_from": "1972-11-11"
          }
        }],
        "PA": [{
          "PAB": {
            "_from": "1903-11-04"
          }
        }, {
          "USD": {
            "_from": "1903-11-18"
          }
        }],
        "PE": [{
          "PES": {
            "_from": "1863-02-14",
            "_to": "1985-02-01"
          }
        }, {
          "PEI": {
            "_from": "1985-02-01",
            "_to": "1991-07-01"
          }
        }, {
          "PEN": {
            "_from": "1991-07-01"
          }
        }],
        "PF": [{
          "XPF": {
            "_from": "1945-12-26"
          }
        }],
        "PG": [{
          "AUD": {
            "_from": "1966-02-14",
            "_to": "1975-09-16"
          }
        }, {
          "PGK": {
            "_from": "1975-09-16"
          }
        }],
        "PH": [{
          "PHP": {
            "_from": "1946-07-04"
          }
        }],
        "PK": [{
          "INR": {
            "_from": "1835-08-17",
            "_to": "1947-08-15"
          }
        }, {
          "PKR": {
            "_from": "1948-04-01"
          }
        }],
        "PL": [{
          "PLZ": {
            "_from": "1950-10-28",
            "_to": "1994-12-31"
          }
        }, {
          "PLN": {
            "_from": "1995-01-01"
          }
        }],
        "PM": [{
          "FRF": {
            "_from": "1972-12-21",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "PN": [{
          "NZD": {
            "_from": "1969-01-13"
          }
        }],
        "PR": [{
          "ESP": {
            "_from": "1800-01-01",
            "_to": "1898-12-10"
          }
        }, {
          "USD": {
            "_from": "1898-12-10"
          }
        }],
        "PS": [{
          "JOD": {
            "_from": "1950-07-01",
            "_to": "1967-06-01"
          }
        }, {
          "ILP": {
            "_from": "1967-06-01",
            "_to": "1980-02-22"
          }
        }, {
          "ILS": {
            "_from": "1985-09-04"
          }
        }, {
          "JOD": {
            "_from": "1996-02-12"
          }
        }],
        "PT": [{
          "PTE": {
            "_from": "1911-05-22",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "PW": [{
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "PY": [{
          "PYG": {
            "_from": "1943-11-01"
          }
        }],
        "QA": [{
          "QAR": {
            "_from": "1973-05-19"
          }
        }],
        "RE": [{
          "FRF": {
            "_from": "1975-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "RO": [{
          "ROL": {
            "_from": "1952-01-28",
            "_to": "2006-12-31"
          }
        }, {
          "RON": {
            "_from": "2005-07-01"
          }
        }],
        "RS": [{
          "YUM": {
            "_from": "1994-01-24",
            "_to": "2002-05-15"
          }
        }, {
          "CSD": {
            "_from": "2002-05-15",
            "_to": "2006-10-25"
          }
        }, {
          "RSD": {
            "_from": "2006-10-25"
          }
        }],
        "RU": [{
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1998-12-31"
          }
        }, {
          "RUB": {
            "_from": "1999-01-01"
          }
        }],
        "RW": [{
          "RWF": {
            "_from": "1964-05-19"
          }
        }],
        "SA": [{
          "SAR": {
            "_from": "1952-10-22"
          }
        }],
        "SB": [{
          "AUD": {
            "_from": "1966-02-14",
            "_to": "1978-06-30"
          }
        }, {
          "SBD": {
            "_from": "1977-10-24"
          }
        }],
        "SC": [{
          "SCR": {
            "_from": "1903-11-01"
          }
        }],
        "SD": [{
          "EGP": {
            "_from": "1889-01-19",
            "_to": "1958-01-01"
          }
        }, {
          "GBP": {
            "_from": "1889-01-19",
            "_to": "1958-01-01"
          }
        }, {
          "SDP": {
            "_from": "1957-04-08",
            "_to": "1998-06-01"
          }
        }, {
          "SDD": {
            "_from": "1992-06-08",
            "_to": "2007-06-30"
          }
        }, {
          "SDG": {
            "_from": "2007-01-10"
          }
        }],
        "SE": [{
          "SEK": {
            "_from": "1873-05-27"
          }
        }],
        "SG": [{
          "MYR": {
            "_from": "1963-09-16",
            "_to": "1967-06-12"
          }
        }, {
          "SGD": {
            "_from": "1967-06-12"
          }
        }],
        "SH": [{
          "SHP": {
            "_from": "1917-02-15"
          }
        }],
        "SI": [{
          "SIT": {
            "_from": "1992-10-07",
            "_to": "2007-01-14"
          }
        }, {
          "EUR": {
            "_from": "2007-01-01"
          }
        }],
        "SJ": [{
          "NOK": {
            "_from": "1905-06-07"
          }
        }],
        "SK": [{
          "CSK": {
            "_from": "1953-06-01",
            "_to": "1992-12-31"
          }
        }, {
          "SKK": {
            "_from": "1992-12-31",
            "_to": "2009-01-01"
          }
        }, {
          "EUR": {
            "_from": "2009-01-01"
          }
        }],
        "SL": [{
          "GBP": {
            "_from": "1808-11-30",
            "_to": "1966-02-04"
          }
        }, {
          "SLL": {
            "_from": "1964-08-04"
          }
        }],
        "SM": [{
          "ITL": {
            "_from": "1865-12-23",
            "_to": "2001-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "SN": [{
          "XOF": {
            "_from": "1959-04-04"
          }
        }],
        "SO": [{
          "SOS": {
            "_from": "1960-07-01"
          }
        }],
        "SR": [{
          "NLG": {
            "_from": "1815-11-20",
            "_to": "1940-05-10"
          }
        }, {
          "SRG": {
            "_from": "1940-05-10",
            "_to": "2003-12-31"
          }
        }, {
          "SRD": {
            "_from": "2004-01-01"
          }
        }],
        "SS": [{
          "SDG": {
            "_from": "2007-01-10",
            "_to": "2011-09-01"
          }
        }, {
          "SSP": {
            "_from": "2011-07-18"
          }
        }],
        "ST": [{
          "STD": {
            "_from": "1977-09-08",
            "_to": "2017-12-31"
          }
        }, {
          "STN": {
            "_from": "2018-01-01"
          }
        }],
        "SU": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }],
        "SV": [{
          "SVC": {
            "_from": "1919-11-11",
            "_to": "2001-01-01"
          }
        }, {
          "USD": {
            "_from": "2001-01-01"
          }
        }],
        "SX": [{
          "ANG": {
            "_from": "2010-10-10"
          }
        }],
        "SY": [{
          "SYP": {
            "_from": "1948-01-01"
          }
        }],
        "SZ": [{
          "SZL": {
            "_from": "1974-09-06"
          }
        }],
        "TA": [{
          "GBP": {
            "_from": "1938-01-12"
          }
        }],
        "TC": [{
          "USD": {
            "_from": "1969-09-08"
          }
        }],
        "TD": [{
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "TF": [{
          "FRF": {
            "_from": "1959-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "TG": [{
          "XOF": {
            "_from": "1958-11-28"
          }
        }],
        "TH": [{
          "THB": {
            "_from": "1928-04-15"
          }
        }],
        "TJ": [{
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1995-05-10"
          }
        }, {
          "TJR": {
            "_from": "1995-05-10",
            "_to": "2000-10-25"
          }
        }, {
          "TJS": {
            "_from": "2000-10-26"
          }
        }],
        "TK": [{
          "NZD": {
            "_from": "1967-07-10"
          }
        }],
        "TL": [{
          "TPE": {
            "_from": "1959-01-02",
            "_to": "2002-05-20"
          }
        }, {
          "IDR": {
            "_from": "1975-12-07",
            "_to": "2002-05-20"
          }
        }, {
          "USD": {
            "_from": "1999-10-20"
          }
        }],
        "TM": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1993-11-01"
          }
        }, {
          "TMM": {
            "_from": "1993-11-01",
            "_to": "2009-01-01"
          }
        }, {
          "TMT": {
            "_from": "2009-01-01"
          }
        }],
        "TN": [{
          "TND": {
            "_from": "1958-11-01"
          }
        }],
        "TO": [{
          "TOP": {
            "_from": "1966-02-14"
          }
        }],
        "TP": [{
          "TPE": {
            "_from": "1959-01-02",
            "_to": "2002-05-20"
          }
        }, {
          "IDR": {
            "_from": "1975-12-07",
            "_to": "2002-05-20"
          }
        }],
        "TR": [{
          "TRL": {
            "_from": "1922-11-01",
            "_to": "2005-12-31"
          }
        }, {
          "TRY": {
            "_from": "2005-01-01"
          }
        }],
        "TT": [{
          "TTD": {
            "_from": "1964-01-01"
          }
        }],
        "TV": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "TW": [{
          "TWD": {
            "_from": "1949-06-15"
          }
        }],
        "TZ": [{
          "TZS": {
            "_from": "1966-06-14"
          }
        }],
        "UA": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1992-11-13"
          }
        }, {
          "UAK": {
            "_from": "1992-11-13",
            "_to": "1993-10-17"
          }
        }, {
          "UAH": {
            "_from": "1996-09-02"
          }
        }],
        "UG": [{
          "UGS": {
            "_from": "1966-08-15",
            "_to": "1987-05-15"
          }
        }, {
          "UGX": {
            "_from": "1987-05-15"
          }
        }],
        "UM": [{
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "US": [{
          "USN": {
            "_tender": "false"
          }
        }, {
          "USS": {
            "_tender": "false",
            "_to": "2014-03-01"
          }
        }, {
          "USD": {
            "_from": "1792-01-01"
          }
        }],
        "UY": [{
          "UYI": {
            "_tender": "false"
          }
        }, {
          "UYW": {
            "_tender": "false"
          }
        }, {
          "UYP": {
            "_from": "1975-07-01",
            "_to": "1993-03-01"
          }
        }, {
          "UYU": {
            "_from": "1993-03-01"
          }
        }],
        "UZ": [{
          "UZS": {
            "_from": "1994-07-01"
          }
        }],
        "VA": [{
          "ITL": {
            "_from": "1870-10-19",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "VC": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "VE": [{
          "VEB": {
            "_from": "1871-05-11",
            "_to": "2008-06-30"
          }
        }, {
          "VEF": {
            "_from": "2008-01-01",
            "_to": "2018-08-20"
          }
        }, {
          "VES": {
            "_from": "2018-08-20"
          }
        }],
        "VG": [{
          "USD": {
            "_from": "1833-01-01"
          }
        }, {
          "GBP": {
            "_from": "1833-01-01",
            "_to": "1959-01-01"
          }
        }],
        "VI": [{
          "USD": {
            "_from": "1837-01-01"
          }
        }],
        "VN": [{
          "VNN": {
            "_from": "1978-05-03",
            "_to": "1985-09-14"
          }
        }, {
          "VND": {
            "_from": "1985-09-14"
          }
        }],
        "VU": [{
          "VUV": {
            "_from": "1981-01-01"
          }
        }],
        "WF": [{
          "XPF": {
            "_from": "1961-07-30"
          }
        }],
        "WS": [{
          "WST": {
            "_from": "1967-07-10"
          }
        }],
        "XK": [{
          "YUM": {
            "_from": "1994-01-24",
            "_to": "1999-09-30"
          }
        }, {
          "DEM": {
            "_from": "1999-09-01",
            "_to": "2002-03-09"
          }
        }, {
          "EUR": {
            "_from": "2002-01-01"
          }
        }],
        "YD": [{
          "YDD": {
            "_from": "1965-04-01",
            "_to": "1996-01-01"
          }
        }],
        "YE": [{
          "YER": {
            "_from": "1990-05-22"
          }
        }],
        "YT": [{
          "KMF": {
            "_from": "1975-01-01",
            "_to": "1976-02-23"
          }
        }, {
          "FRF": {
            "_from": "1976-02-23",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "YU": [{
          "YUD": {
            "_from": "1966-01-01",
            "_to": "1990-01-01"
          }
        }, {
          "YUN": {
            "_from": "1990-01-01",
            "_to": "1992-07-24"
          }
        }, {
          "YUM": {
            "_from": "1994-01-24",
            "_to": "2002-05-15"
          }
        }],
        "ZA": [{
          "ZAR": {
            "_from": "1961-02-14"
          }
        }, {
          "ZAL": {
            "_tender": "false",
            "_from": "1985-09-01",
            "_to": "1995-03-13"
          }
        }],
        "ZM": [{
          "ZMK": {
            "_from": "1968-01-16",
            "_to": "2013-01-01"
          }
        }, {
          "ZMW": {
            "_from": "2013-01-01"
          }
        }],
        "ZR": [{
          "ZRZ": {
            "_from": "1971-10-27",
            "_to": "1993-11-01"
          }
        }, {
          "ZRN": {
            "_from": "1993-11-01",
            "_to": "1998-07-31"
          }
        }],
        "ZW": [{
          "RHD": {
            "_from": "1970-02-17",
            "_to": "1980-04-18"
          }
        }, {
          "ZWD": {
            "_from": "1980-04-18",
            "_to": "2008-08-01"
          }
        }, {
          "ZWR": {
            "_from": "2008-08-01",
            "_to": "2009-02-02"
          }
        }, {
          "ZWL": {
            "_from": "2009-02-02",
            "_to": "2009-04-12"
          }
        }, {
          "USD": {
            "_from": "2009-04-12"
          }
        }],
        "ZZ": [{
          "XAG": {
            "_tender": "false"
          }
        }, {
          "XAU": {
            "_tender": "false"
          }
        }, {
          "XBA": {
            "_tender": "false"
          }
        }, {
          "XBB": {
            "_tender": "false"
          }
        }, {
          "XBC": {
            "_tender": "false"
          }
        }, {
          "XBD": {
            "_tender": "false"
          }
        }, {
          "XDR": {
            "_tender": "false"
          }
        }, {
          "XPD": {
            "_tender": "false"
          }
        }, {
          "XPT": {
            "_tender": "false"
          }
        }, {
          "XSU": {
            "_tender": "false"
          }
        }, {
          "XTS": {
            "_tender": "false"
          }
        }, {
          "XUA": {
            "_tender": "false"
          }
        }, {
          "XXX": {
            "_tender": "false"
          }
        }, {
          "XRE": {
            "_tender": "false",
            "_to": "1999-11-30"
          }
        }, {
          "XFU": {
            "_tender": "false",
            "_to": "2013-11-30"
          }
        }, {
          "XFO": {
            "_tender": "false",
            "_from": "1930-01-01",
            "_to": "2003-04-01"
          }
        }]
      }
    },
    "numberingSystems": {
      "adlm": {
        "_digits": "",
        "_type": "numeric"
      },
      "ahom": {
        "_digits": "",
        "_type": "numeric"
      },
      "arab": {
        "_digits": "",
        "_type": "numeric"
      },
      "arabext": {
        "_digits": "",
        "_type": "numeric"
      },
      "armn": {
        "_rules": "armenian-upper",
        "_type": "algorithmic"
      },
      "armnlow": {
        "_rules": "armenian-lower",
        "_type": "algorithmic"
      },
      "bali": {
        "_digits": "",
        "_type": "numeric"
      },
      "beng": {
        "_digits": "",
        "_type": "numeric"
      },
      "bhks": {
        "_digits": "",
        "_type": "numeric"
      },
      "brah": {
        "_digits": "",
        "_type": "numeric"
      },
      "cakm": {
        "_digits": "",
        "_type": "numeric"
      },
      "cham": {
        "_digits": "",
        "_type": "numeric"
      },
      "cyrl": {
        "_rules": "cyrillic-lower",
        "_type": "algorithmic"
      },
      "deva": {
        "_digits": "",
        "_type": "numeric"
      },
      "ethi": {
        "_rules": "ethiopic",
        "_type": "algorithmic"
      },
      "fullwide": {
        "_digits": "",
        "_type": "numeric"
      },
      "geor": {
        "_rules": "georgian",
        "_type": "algorithmic"
      },
      "gong": {
        "_digits": "",
        "_type": "numeric"
      },
      "gonm": {
        "_digits": "",
        "_type": "numeric"
      },
      "grek": {
        "_rules": "greek-upper",
        "_type": "algorithmic"
      },
      "greklow": {
        "_rules": "greek-lower",
        "_type": "algorithmic"
      },
      "gujr": {
        "_digits": "",
        "_type": "numeric"
      },
      "guru": {
        "_digits": "",
        "_type": "numeric"
      },
      "hanidays": {
        "_rules": "zh/SpelloutRules/spellout-numbering-days",
        "_type": "algorithmic"
      },
      "hanidec": {
        "_digits": "",
        "_type": "numeric"
      },
      "hans": {
        "_rules": "zh/SpelloutRules/spellout-cardinal",
        "_type": "algorithmic"
      },
      "hansfin": {
        "_rules": "zh/SpelloutRules/spellout-cardinal-financial",
        "_type": "algorithmic"
      },
      "hant": {
        "_rules": "zh_Hant/SpelloutRules/spellout-cardinal",
        "_type": "algorithmic"
      },
      "hantfin": {
        "_rules": "zh_Hant/SpelloutRules/spellout-cardinal-financial",
        "_type": "algorithmic"
      },
      "hebr": {
        "_rules": "hebrew",
        "_type": "algorithmic"
      },
      "hmng": {
        "_digits": "",
        "_type": "numeric"
      },
      "hmnp": {
        "_digits": "",
        "_type": "numeric"
      },
      "java": {
        "_digits": "",
        "_type": "numeric"
      },
      "jpan": {
        "_rules": "ja/SpelloutRules/spellout-cardinal",
        "_type": "algorithmic"
      },
      "jpanfin": {
        "_rules": "ja/SpelloutRules/spellout-cardinal-financial",
        "_type": "algorithmic"
      },
      "jpanyear": {
        "_rules": "ja/SpelloutRules/spellout-numbering-year-latn",
        "_type": "algorithmic"
      },
      "kali": {
        "_digits": "",
        "_type": "numeric"
      },
      "khmr": {
        "_digits": "",
        "_type": "numeric"
      },
      "knda": {
        "_digits": "",
        "_type": "numeric"
      },
      "lana": {
        "_digits": "",
        "_type": "numeric"
      },
      "lanatham": {
        "_digits": "",
        "_type": "numeric"
      },
      "laoo": {
        "_digits": "",
        "_type": "numeric"
      },
      "latn": {
        "_digits": "0123456789",
        "_type": "numeric"
      },
      "lepc": {
        "_digits": "",
        "_type": "numeric"
      },
      "limb": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathbold": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathdbl": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathmono": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathsanb": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathsans": {
        "_digits": "",
        "_type": "numeric"
      },
      "mlym": {
        "_digits": "",
        "_type": "numeric"
      },
      "modi": {
        "_digits": "",
        "_type": "numeric"
      },
      "mong": {
        "_digits": "",
        "_type": "numeric"
      },
      "mroo": {
        "_digits": "",
        "_type": "numeric"
      },
      "mtei": {
        "_digits": "",
        "_type": "numeric"
      },
      "mymr": {
        "_digits": "",
        "_type": "numeric"
      },
      "mymrshan": {
        "_digits": "",
        "_type": "numeric"
      },
      "mymrtlng": {
        "_digits": "",
        "_type": "numeric"
      },
      "newa": {
        "_digits": "",
        "_type": "numeric"
      },
      "nkoo": {
        "_digits": "",
        "_type": "numeric"
      },
      "olck": {
        "_digits": "",
        "_type": "numeric"
      },
      "orya": {
        "_digits": "",
        "_type": "numeric"
      },
      "osma": {
        "_digits": "",
        "_type": "numeric"
      },
      "rohg": {
        "_digits": "",
        "_type": "numeric"
      },
      "roman": {
        "_rules": "roman-upper",
        "_type": "algorithmic"
      },
      "romanlow": {
        "_rules": "roman-lower",
        "_type": "algorithmic"
      },
      "saur": {
        "_digits": "",
        "_type": "numeric"
      },
      "shrd": {
        "_digits": "",
        "_type": "numeric"
      },
      "sind": {
        "_digits": "",
        "_type": "numeric"
      },
      "sinh": {
        "_digits": "",
        "_type": "numeric"
      },
      "sora": {
        "_digits": "",
        "_type": "numeric"
      },
      "sund": {
        "_digits": "",
        "_type": "numeric"
      },
      "takr": {
        "_digits": "",
        "_type": "numeric"
      },
      "talu": {
        "_digits": "",
        "_type": "numeric"
      },
      "taml": {
        "_rules": "tamil",
        "_type": "algorithmic"
      },
      "tamldec": {
        "_digits": "",
        "_type": "numeric"
      },
      "telu": {
        "_digits": "",
        "_type": "numeric"
      },
      "thai": {
        "_digits": "",
        "_type": "numeric"
      },
      "tibt": {
        "_digits": "",
        "_type": "numeric"
      },
      "tirh": {
        "_digits": "",
        "_type": "numeric"
      },
      "vaii": {
        "_digits": "",
        "_type": "numeric"
      },
      "wara": {
        "_digits": "",
        "_type": "numeric"
      },
      "wcho": {
        "_digits": "",
        "_type": "numeric"
      }
    }
  }
};

/***/ }),

/***/ 91331:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _parent_locales = _interopRequireDefault(__webpack_require__(73806));
var _parentLocale = _interopRequireDefault(__webpack_require__(49198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LOCALE = 'en';
var _default = exports["default"] = (0, _dependency_injector.default)({
  locale: (() => {
    let currentLocale = DEFAULT_LOCALE;
    return locale => {
      if (!locale) {
        return currentLocale;
      }
      currentLocale = locale;
    };
  })(),
  getValueByClosestLocale: function (getter) {
    let locale = this.locale();
    let value = getter(locale);
    let isRootLocale;
    while (!value && !isRootLocale) {
      locale = (0, _parentLocale.default)(_parent_locales.default, locale);
      if (locale) {
        value = getter(locale);
      } else {
        isRootLocale = true;
      }
    }
    if (value === undefined && locale !== DEFAULT_LOCALE) {
      return getter(DEFAULT_LOCALE);
    }
    return value;
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 89740:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _default = exports["default"] = {
  _formatNumberCore: function (value, format, formatConfig) {
    if (format === 'currency') {
      formatConfig.precision = formatConfig.precision || 0;
      let result = this.format(value, (0, _extend.extend)({}, formatConfig, {
        type: 'fixedpoint'
      }));
      const currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, '$$$$');
      result = result.replace(/^(\D*)(\d.*)/, '$1' + currencyPart + '$2');
      return result;
    }
    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function () {
    return {
      symbol: '$'
    };
  },
  getOpenXmlCurrencyFormat: function () {
    return '$#,##0{0}_);\\($#,##0{0}\\)';
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 91500:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _date = __webpack_require__(40594);
var _date2 = __webpack_require__(59937);
var _date3 = __webpack_require__(2892);
var _default_date_names = _interopRequireDefault(__webpack_require__(15564));
var _first_day_of_week_data = _interopRequireDefault(__webpack_require__(92286));
var _core = _interopRequireDefault(__webpack_require__(91331));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _date4 = _interopRequireDefault(__webpack_require__(13024));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_DAY_OF_WEEK_INDEX = 0;
const hasIntl = typeof Intl !== 'undefined';
const FORMATS_TO_PATTERN_MAP = {
  'shortdate': 'M/d/y',
  'shorttime': 'h:mm a',
  'longdate': 'EEEE, MMMM d, y',
  'longtime': 'h:mm:ss a',
  'monthandday': 'MMMM d',
  'monthandyear': 'MMMM y',
  'quarterandyear': 'QQQ y',
  'day': 'd',
  'year': 'y',
  'shortdateshorttime': 'M/d/y, h:mm a',
  'longdatelongtime': 'EEEE, MMMM d, y, h:mm:ss a',
  'month': 'LLLL',
  'shortyear': 'yy',
  'dayofweek': 'EEEE',
  'quarter': 'QQQ',
  'hour': 'HH',
  'minute': 'mm',
  'second': 'ss',
  'millisecond': 'SSS',
  'datetime-local': 'yyyy-MM-ddTHH\':\'mm\':\'ss'
};
const possiblePartPatterns = {
  year: ['y', 'yy', 'yyyy'],
  day: ['d', 'dd'],
  month: ['M', 'MM', 'MMM', 'MMMM'],
  hours: ['H', 'HH', 'h', 'hh', 'ah'],
  minutes: ['m', 'mm'],
  seconds: ['s', 'ss'],
  milliseconds: ['S', 'SS', 'SSS']
};
const dateLocalization = (0, _dependency_injector.default)({
  engine: function () {
    return 'base';
  },
  _getPatternByFormat: function (format) {
    return FORMATS_TO_PATTERN_MAP[format.toLowerCase()];
  },
  _expandPattern: function (pattern) {
    return this._getPatternByFormat(pattern) || pattern;
  },
  formatUsesMonthName: function (format) {
    return this._expandPattern(format).indexOf('MMMM') !== -1;
  },
  formatUsesDayName: function (format) {
    return this._expandPattern(format).indexOf('EEEE') !== -1;
  },
  getFormatParts: function (format) {
    const pattern = this._getPatternByFormat(format) || format;
    const result = [];
    (0, _iterator.each)(pattern.split(/\W+/), (_, formatPart) => {
      (0, _iterator.each)(possiblePartPatterns, (partName, possiblePatterns) => {
        if (possiblePatterns.includes(formatPart)) {
          result.push(partName);
        }
      });
    });
    return result;
  },
  getMonthNames: function (format) {
    return _default_date_names.default.getMonthNames(format);
  },
  getDayNames: function (format) {
    return _default_date_names.default.getDayNames(format);
  },
  getQuarterNames: function (format) {
    return _default_date_names.default.getQuarterNames(format);
  },
  getPeriodNames: function (format) {
    return _default_date_names.default.getPeriodNames(format);
  },
  getTimeSeparator: function () {
    return ':';
  },
  is24HourFormat: function (format) {
    const amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
    const pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
    const amTimeFormatted = this.format(amTime, format);
    const pmTimeFormatted = this.format(pmTime, format);
    for (let i = 0; i < amTimeFormatted.length; i++) {
      if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
        return !isNaN(parseInt(amTimeFormatted[i]));
      }
    }
  },
  format: function (date, format) {
    if (!date) {
      return;
    }
    if (!format) {
      return date;
    }
    let formatter;
    if (typeof format === 'function') {
      formatter = format;
    } else if (format.formatter) {
      formatter = format.formatter;
    } else {
      format = format.type || format;
      if ((0, _type.isString)(format)) {
        format = FORMATS_TO_PATTERN_MAP[format.toLowerCase()] || format;
        return _number.default.convertDigits((0, _date.getFormatter)(format, this)(date));
      }
    }
    if (!formatter) {
      // TODO: log warning or error
      return;
    }
    return formatter(date);
  },
  parse: function (text, format) {
    const that = this;
    let ldmlFormat;
    let formatter;
    if (!text) {
      return;
    }
    if (!format) {
      return this.parse(text, 'shortdate');
    }
    if (format.parser) {
      return format.parser(text);
    }
    if (typeof format === 'string' && !FORMATS_TO_PATTERN_MAP[format.toLowerCase()]) {
      ldmlFormat = format;
    } else {
      formatter = value => {
        const text = that.format(value, format);
        return _number.default.convertDigits(text, true);
      };
      try {
        ldmlFormat = (0, _date2.getFormat)(formatter);
      } catch (e) {}
    }
    if (ldmlFormat) {
      text = _number.default.convertDigits(text, true);
      return (0, _date3.getParser)(ldmlFormat, this)(text);
    }
    _errors.default.log('W0012');
    const result = new Date(text);
    if (!result || isNaN(result.getTime())) {
      return;
    }
    return result;
  },
  firstDayOfWeekIndex: function () {
    const index = _core.default.getValueByClosestLocale(locale => _first_day_of_week_data.default[locale]);
    return index === undefined ? DEFAULT_DAY_OF_WEEK_INDEX : index;
  }
});
if (hasIntl) {
  dateLocalization.inject(_date4.default);
}
var _default = exports["default"] = dateLocalization;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 15564:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
const MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
const DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
const PERIODS = ['AM', 'PM'];
const QUARTERS = ['Q1', 'Q2', 'Q3', 'Q4'];

// TODO: optimize
const cutCaptions = (captions, format) => {
  const lengthByFormat = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return (0, _iterator.map)(captions, caption => {
    return caption.substr(0, lengthByFormat[format]);
  });
};
var _default = exports["default"] = {
  getMonthNames: function (format) {
    return cutCaptions(MONTHS, format);
  },
  getDayNames: function (format) {
    return cutCaptions(DAYS, format);
  },
  getQuarterNames: function (format) {
    return QUARTERS;
  },
  getPeriodNames: function (format) {
    return PERIODS;
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 18121:
/***/ (function(__unused_webpack_module, exports) {



exports.defaultMessages = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
const defaultMessages = exports.defaultMessages = {
  "en": {
    "Yes": "Yes",
    "No": "No",
    "Cancel": "Cancel",
    "Close": "Close",
    "Clear": "Clear",
    "Done": "Done",
    "Loading": "Loading...",
    "Select": "Select...",
    "Search": "Search",
    "Back": "Back",
    "OK": "OK",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxList-listAriaLabel": "Items",
    "dxList-listAriaLabel-deletable": "Deletable items",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxDateRangeBox-invalidStartDateMessage": "Start value must be a date",
    "dxDateRangeBox-invalidEndDateMessage": "End value must be a date",
    "dxDateRangeBox-startDateOutOfRangeMessage": "Start date is out of range",
    "dxDateRangeBox-endDateOutOfRangeMessage": "End date is out of range",
    "dxDateRangeBox-startDateLabel": "Start Date",
    "dxDateRangeBox-endDateLabel": "End Date",
    "dxFileUploader-selectFile": "Select a file",
    "dxFileUploader-dropFile": "or Drop a file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "KB",
    "dxFileUploader-Mb": "MB",
    "dxFileUploader-Gb": "GB",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-emptyHeaderWithColumnChooserText": "Use {0} to display columns",
    "dxDataGrid-emptyHeaderWithGroupPanelText": "Drag a column from the group panel here",
    "dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText": "Use {0} or drag a column from the group panel",
    "dxDataGrid-emptyHeaderColumnChooserText": "column chooser",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-ariaSearchBox": "Search box",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-ariaNotSortedColumn": "Not sorted column",
    "dxDataGrid-ariaSortedAscendingColumn": "Column sorted in ascending order",
    "dxDataGrid-ariaSortedDescendingColumn": "Column sorted in descending order",
    "dxDataGrid-ariaSortIndex": "Sort index {0}",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Fix",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "To the left",
    "dxDataGrid-columnFixingRightPosition": "To the right",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows to {0}",
    "dxDataGrid-exportAll": "Export all data to {0}",
    "dxDataGrid-headerFilterLabel": "Filter options",
    "dxDataGrid-headerFilterIndicatorLabel": "Show filter options for column '{0}'",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaColumnHeader": "Column header",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaError": "Error",
    "dxDataGrid-ariaRevertButton": "Press Escape to discard the changes",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaModifiedCell": "Modified",
    "dxDataGrid-ariaDeletedCell": "Deleted",
    "dxDataGrid-ariaEditableCell": "Editable",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaCollapsedRow": "Collapsed row",
    "dxDataGrid-ariaExpandedRow": "Expanded row",
    "dxDataGrid-ariaDataGrid": "Data grid with {0} rows and {1} columns",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-ariaEditForm": "Edit form",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxDataGrid-masterDetail": "Cell with details",
    "dxTreeList-ariaTreeList": "Tree list with {0} rows and {1} columns",
    "dxTreeList-ariaExpandableInstruction": "Press Ctrl + right arrow to expand the focused node and Ctrl + left arrow to collapse it",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSize": "Items per page: {0}",
    "dxPager-pageSizesAllText": "All",
    "dxPager-page": "Page {0}",
    "dxPager-prevPage": "Previous Page",
    "dxPager-nextPage": "Next Page",
    "dxPager-ariaLabel": "Page Navigation",
    "dxPager-ariaPageSize": "Page size",
    "dxPager-ariaPageNumber": "Page number",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": "Sort \"{0}\" by This Column",
    "dxPivotGrid-sortRowBySummary": "Sort \"{0}\" by This Row",
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-appointmentAriaLabel-group": "Group: {0}",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-confirmRecurrenceEditTitle": "Edit Recurring Appointment",
    "dxScheduler-confirmRecurrenceDeleteTitle": "Delete Recurring Appointment",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-currentDay": "Today",
    "dxCalendar-currentMonth": "Current month",
    "dxCalendar-currentYear": "Current year",
    "dxCalendar-currentYearRange": "Current year range",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxCalendar-previousMonthButtonLabel": "Previous month",
    "dxCalendar-previousYearButtonLabel": "Previous year",
    "dxCalendar-previousDecadeButtonLabel": "Previous decade",
    "dxCalendar-previousCenturyButtonLabel": "Previous century",
    "dxCalendar-nextMonthButtonLabel": "Next month",
    "dxCalendar-nextYearButtonLabel": "Next year",
    "dxCalendar-nextDecadeButtonLabel": "Next decade",
    "dxCalendar-nextCenturyButtonLabel": "Next century",
    "dxCalendar-captionMonthLabel": "Month selection",
    "dxCalendar-captionYearLabel": "Year selection",
    "dxCalendar-captionDecadeLabel": "Decade selection",
    "dxCalendar-captionCenturyLabel": "Century selection",
    "dxCalendar-selectedDate": "The selected date is {0}",
    "dxCalendar-selectedDateRange": "The selected date range is from {0} to {1}",
    "dxCalendar-readOnlyLabel": "Read-only calendar",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "dxTagBox-tagRoleDescription": "Tag. Press the delete button to remove this tag",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-dialogUpdateImageCaption": "Update Image",
    "dxHtmlEditor-dialogImageUpdateButton": "Update",
    "dxHtmlEditor-dialogImageAddButton": "Add",
    "dxHtmlEditor-dialogImageSpecifyUrl": "From the Web",
    "dxHtmlEditor-dialogImageSelectFile": "From This Device",
    "dxHtmlEditor-dialogImageKeepAspectRatio": "Keep Aspect Ratio",
    "dxHtmlEditor-dialogImageEncodeToBase64": "Encode to Base64",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertHeaderRow": "Insert Header Row",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-cellProperties": "Cell Properties",
    "dxHtmlEditor-tableProperties": "Table Properties",
    "dxHtmlEditor-insert": "Insert",
    "dxHtmlEditor-delete": "Delete",
    "dxHtmlEditor-border": "Border",
    "dxHtmlEditor-style": "Style",
    "dxHtmlEditor-width": "Width",
    "dxHtmlEditor-height": "Height",
    "dxHtmlEditor-borderColor": "Color",
    "dxHtmlEditor-tableBackground": "Background",
    "dxHtmlEditor-dimensions": "Dimensions",
    "dxHtmlEditor-alignment": "Alignment",
    "dxHtmlEditor-horizontal": "Horizontal",
    "dxHtmlEditor-vertical": "Vertical",
    "dxHtmlEditor-paddingVertical": "Vertical Padding",
    "dxHtmlEditor-paddingHorizontal": "Horizontal Padding",
    "dxHtmlEditor-pixels": "Pixels",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxHtmlEditor-borderStyleNone": "none",
    "dxHtmlEditor-borderStyleHidden": "hidden",
    "dxHtmlEditor-borderStyleDotted": "dotted",
    "dxHtmlEditor-borderStyleDashed": "dashed",
    "dxHtmlEditor-borderStyleSolid": "solid",
    "dxHtmlEditor-borderStyleDouble": "double",
    "dxHtmlEditor-borderStyleGroove": "groove",
    "dxHtmlEditor-borderStyleRidge": "ridge",
    "dxHtmlEditor-borderStyleInset": "inset",
    "dxHtmlEditor-borderStyleOutset": "outset",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-editingDownloadSingleItemErrorMessage": "Item was not downloaded",
    "dxFileManager-editingDownloadMultipleItemsErrorMessage": "{0} items were not downloaded",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop a file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-dialogConstraintCriticalViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. How would you like to proceed?",
    "dxGantt-dialogDeleteDependenciesMessage": "Delete the dependency relations",
    "dxGantt-dialogMoveTaskAndKeepDependenciesMessage": "Move the task and keep the dependencies",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}",
    "dxGantt-sortingAscendingText": "Sort Ascending",
    "dxGantt-sortingDescendingText": "Sort Descending",
    "dxGantt-sortingClearText": "Clear Sorting",
    "dxGantt-showResources": "Show Resources",
    "dxGantt-showDependencies": "Show Dependencies",
    "dxGantt-dialogStartDateValidation": "Start date must be after {0}",
    "dxGantt-dialogEndDateValidation": "End date must be after {0}",
    "dxGallery-itemName": "Gallery item",
    "dxMultiView-elementAriaRoleDescription": "MultiView",
    "dxMultiView-elementAriaLabel": "Use the arrow keys or swipe to navigate between views",
    "dxMultiView-itemAriaRoleDescription": "View",
    "dxMultiView-itemAriaLabel": "{0} of {1}",
    "dxSplitter-resizeHandleAriaLabel": "Split bar"
  }
};

/***/ }),

/***/ 74872:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _core = _interopRequireDefault(__webpack_require__(91331));
var _en = __webpack_require__(35608);
var _supplemental = __webpack_require__(57421);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_globalize.default && _globalize.default.load) {
  if (!_globalize.default.locale()) {
    _globalize.default.load(_en.enCldr, _supplemental.supplementalCldr);
    _globalize.default.locale('en');
  }
  _core.default.inject({
    locale: function (locale) {
      if (!locale) {
        return _globalize.default.locale().locale;
      }
      _globalize.default.locale(locale);
    }
  });
}

/***/ }),

/***/ 7239:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _open_xml_currency_format = _interopRequireDefault(__webpack_require__(44592));
__webpack_require__(74872);
__webpack_require__(908);
__webpack_require__(89740);
__webpack_require__(71272);
var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _config = _interopRequireDefault(__webpack_require__(80209));
var _number2 = _interopRequireDefault(__webpack_require__(18016));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports, import/no-unresolved

// eslint-disable-next-line no-restricted-imports

const CURRENCY_STYLES = ['symbol', 'accounting'];
if (_globalize.default && _globalize.default.formatCurrency) {
  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.locale('en');
  }
  const formattersCache = {};
  const getFormatter = (currency, format) => {
    let formatter;
    let formatCacheKey;
    if (typeof format === 'object') {
      formatCacheKey = _globalize.default.locale().locale + ':' + currency + ':' + JSON.stringify(format);
    } else {
      formatCacheKey = _globalize.default.locale().locale + ':' + currency + ':' + format;
    }
    formatter = formattersCache[formatCacheKey];
    if (!formatter) {
      formatter = formattersCache[formatCacheKey] = _globalize.default.currencyFormatter(currency, format);
    }
    return formatter;
  };
  const globalizeCurrencyLocalization = {
    _formatNumberCore: function (value, format, formatConfig) {
      if (format === 'currency') {
        const currency = formatConfig && formatConfig.currency || (0, _config.default)().defaultCurrency;
        return getFormatter(currency, this._normalizeFormatConfig(format, formatConfig, value))(value);
      }
      return this.callBase.apply(this, arguments);
    },
    _normalizeFormatConfig: function (format, formatConfig, value) {
      const normalizedConfig = this.callBase(format, formatConfig, value);
      if (format === 'currency') {
        const useAccountingStyle = formatConfig.useCurrencyAccountingStyle ?? (0, _config.default)().defaultUseCurrencyAccountingStyle;
        normalizedConfig.style = CURRENCY_STYLES[+useAccountingStyle];
      }
      return normalizedConfig;
    },
    format: function (value, format) {
      if (typeof value !== 'number') {
        return value;
      }
      format = this._normalizeFormat(format);
      if (format) {
        if (format.currency === 'default') {
          format.currency = (0, _config.default)().defaultCurrency;
        }
        if (format.type === 'currency') {
          return this._formatNumber(value, this._parseNumberFormatString('currency'), format);
        } else if (!format.type && format.currency) {
          return getFormatter(format.currency, format)(value);
        }
      }
      return this.callBase.apply(this, arguments);
    },
    getCurrencySymbol: function (currency) {
      if (!currency) {
        currency = (0, _config.default)().defaultCurrency;
      }
      return _globalize.default.cldr.main('numbers/currencies/' + currency);
    },
    getOpenXmlCurrencyFormat: function (currency) {
      const currencySymbol = this.getCurrencySymbol(currency).symbol;
      const accountingFormat = _globalize.default.cldr.main('numbers/currencyFormats-numberSystem-latn').accounting;
      return (0, _open_xml_currency_format.default)(currencySymbol, accountingFormat);
    }
  };
  _number2.default.inject(globalizeCurrencyLocalization);
}

/***/ }),

/***/ 60316:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(74872);
__webpack_require__(908);
__webpack_require__(71272);
var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _date2 = _interopRequireDefault(__webpack_require__(91500));
var _type = __webpack_require__(35922);
var iteratorUtils = _interopRequireWildcard(__webpack_require__(95479));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports, import/no-unresolved

const ACCEPTABLE_JSON_FORMAT_PROPERTIES = ['skeleton', 'date', 'time', 'datetime', 'raw'];
const RTL_MARKS_REGEX = /[\u200E\u200F]/g;

// eslint-disable-next-line no-restricted-imports

if (_globalize.default && _globalize.default.formatDate) {
  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.locale('en');
  }
  const formattersCache = {};
  const FORMATS_TO_GLOBALIZE_MAP = {
    'shortdate': {
      path: 'dateTimeFormats/availableFormats/yMd'
    },
    'shorttime': {
      path: 'timeFormats/short'
    },
    'longdate': {
      path: 'dateFormats/full'
    },
    'longtime': {
      path: 'timeFormats/medium'
    },
    'monthandday': {
      path: 'dateTimeFormats/availableFormats/MMMMd'
    },
    'monthandyear': {
      path: 'dateTimeFormats/availableFormats/yMMMM'
    },
    'quarterandyear': {
      path: 'dateTimeFormats/availableFormats/yQQQ'
    },
    'day': {
      path: 'dateTimeFormats/availableFormats/d'
    },
    'year': {
      path: 'dateTimeFormats/availableFormats/y'
    },
    'shortdateshorttime': {
      path: 'dateTimeFormats/short',
      parts: ['shorttime', 'shortdate']
    },
    'longdatelongtime': {
      path: 'dateTimeFormats/medium',
      parts: ['longtime', 'longdate']
    },
    'month': {
      pattern: 'LLLL'
    },
    'shortyear': {
      pattern: 'yy'
    },
    'dayofweek': {
      pattern: 'EEEE'
    },
    'quarter': {
      pattern: 'QQQ'
    },
    'millisecond': {
      pattern: 'SSS'
    },
    'hour': {
      pattern: 'HH'
    },
    'minute': {
      pattern: 'mm'
    },
    'second': {
      pattern: 'ss'
    }
  };
  const globalizeDateLocalization = {
    engine: function () {
      return 'globalize';
    },
    _getPatternByFormat: function (format) {
      const that = this;
      const lowerFormat = format.toLowerCase();
      const globalizeFormat = FORMATS_TO_GLOBALIZE_MAP[lowerFormat];
      if (lowerFormat === 'datetime-local') {
        return 'yyyy-MM-ddTHH\':\'mm\':\'ss';
      }
      if (!globalizeFormat) {
        return;
      }
      let result = globalizeFormat.path && that._getFormatStringByPath(globalizeFormat.path) || globalizeFormat.pattern;
      if (globalizeFormat.parts) {
        iteratorUtils.each(globalizeFormat.parts, (index, part) => {
          result = result.replace('{' + index + '}', that._getPatternByFormat(part));
        });
      }
      return result;
    },
    _getFormatStringByPath: function (path) {
      return _globalize.default.locale().main('dates/calendars/gregorian/' + path);
    },
    getPeriodNames: function (format, type) {
      format = format || 'wide';
      type = type === 'format' ? type : 'stand-alone';
      const json = _globalize.default.locale().main(`dates/calendars/gregorian/dayPeriods/${type}/${format}`);
      return [json['am'], json['pm']];
    },
    getMonthNames: function (format, type) {
      const months = _globalize.default.locale().main('dates/calendars/gregorian/months/' + (type === 'format' ? type : 'stand-alone') + '/' + (format || 'wide'));
      return iteratorUtils.map(months, month => {
        return month;
      });
    },
    getDayNames: function (format) {
      const days = _globalize.default.locale().main('dates/calendars/gregorian/days/stand-alone/' + (format || 'wide'));
      return iteratorUtils.map(days, day => {
        return day;
      });
    },
    getTimeSeparator: function () {
      return _globalize.default.locale().main('numbers/symbols-numberSystem-latn/timeSeparator');
    },
    removeRtlMarks(text) {
      return text.replace(RTL_MARKS_REGEX, '');
    },
    format: function (date, format) {
      if (!date) {
        return;
      }
      if (!format) {
        return date;
      }
      let formatter;
      let formatCacheKey;
      if (typeof format === 'function') {
        return format(date);
      }
      if (format.formatter) {
        return format.formatter(date);
      }
      format = format.type || format;
      if (typeof format === 'string') {
        formatCacheKey = _globalize.default.locale().locale + ':' + format;
        formatter = formattersCache[formatCacheKey];
        if (!formatter) {
          format = {
            raw: this._getPatternByFormat(format) || format
          };
          formatter = formattersCache[formatCacheKey] = _globalize.default.dateFormatter(format);
        }
      } else {
        if (!this._isAcceptableFormat(format)) {
          return;
        }
        formatter = _globalize.default.dateFormatter(format);
      }
      return this.removeRtlMarks(formatter(date));
    },
    parse: function (text, format) {
      if (!text) {
        return;
      }
      if (!format || typeof format === 'function' || (0, _type.isObject)(format) && !this._isAcceptableFormat(format)) {
        if (format) {
          const parsedValue = this.callBase(text, format);
          if (parsedValue) {
            return parsedValue;
          }
        }
        return _globalize.default.parseDate(text);
      }
      if (format.parser) {
        return format.parser(text);
      }
      if (typeof format === 'string') {
        format = {
          raw: this._getPatternByFormat(format) || format
        };
      }
      const parsedDate = _globalize.default.parseDate(text, format);
      return parsedDate ? parsedDate : this.callBase(text, format);
    },
    _isAcceptableFormat: function (format) {
      if (format.parser) {
        return true;
      }
      for (let i = 0; i < ACCEPTABLE_JSON_FORMAT_PROPERTIES.length; i++) {
        if (Object.prototype.hasOwnProperty.call(format, ACCEPTABLE_JSON_FORMAT_PROPERTIES[i])) {
          return true;
        }
      }
    },
    firstDayOfWeekIndex: function () {
      const firstDay = _globalize.default.locale().supplemental.weekData.firstDay();
      return this._getDayKeys().indexOf(firstDay);
    },
    _getDayKeys: function () {
      const days = _globalize.default.locale().main('dates/calendars/gregorian/days/format/short');
      return iteratorUtils.map(days, (day, key) => {
        return key;
      });
    }
  };
  _date2.default.resetInjection();
  _date2.default.inject(globalizeDateLocalization);
}

/***/ }),

/***/ 46949:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(74872);
var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _message = _interopRequireDefault(__webpack_require__(28109));
var _core2 = _interopRequireDefault(__webpack_require__(91331));
__webpack_require__(71272);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

// eslint-disable-next-line no-restricted-imports, import/no-unresolved

if (_globalize.default && _globalize.default.formatMessage) {
  const DEFAULT_LOCALE = 'en';
  const originalLoadMessages = _globalize.default.loadMessages;
  _globalize.default.loadMessages = messages => {
    _message.default.load(messages);
  };
  const globalizeMessageLocalization = {
    engine: function () {
      return 'globalize';
    },
    ctor: function () {
      this.load(this._dictionary);
    },
    load: function (messages) {
      this.callBase(messages);
      originalLoadMessages(messages);
    },
    getMessagesByLocales: function () {
      return _globalize.default.cldr.get('globalize-messages');
    },
    getFormatter: function (key, locale) {
      const currentLocale = locale || _core2.default.locale();
      let formatter = this._getFormatterBase(key, locale);
      if (!formatter) {
        formatter = this._formatterByGlobalize(key, locale);
      }
      if (!formatter && currentLocale !== DEFAULT_LOCALE) {
        formatter = this.getFormatter(key, DEFAULT_LOCALE);
      }
      return formatter;
    },
    _formatterByGlobalize: function (key, locale) {
      const currentGlobalize = !locale || locale === _core2.default.locale() ? _globalize.default : new _globalize.default(locale);
      let result;
      if (this._messageLoaded(key, locale)) {
        result = currentGlobalize.messageFormatter(key);
      }
      return result;
    },
    _messageLoaded: function (key, locale) {
      const currentCldr = locale ? new _globalize.default(locale).cldr : _globalize.default.locale();
      const value = currentCldr.get(['globalize-messages/{bundle}', key]);
      return !!value;
    },
    _loadSingle: function (key, value, locale) {
      const data = {};
      data[locale] = {};
      data[locale][key] = value;
      this.load(data);
    }
  };
  _message.default.inject(globalizeMessageLocalization);
}

/***/ }),

/***/ 908:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(74872);
var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _errors = _interopRequireDefault(__webpack_require__(17381));
__webpack_require__(71272);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

// eslint-disable-next-line no-restricted-imports, import/no-unresolved

const MAX_FRACTION_DIGITS = 20;
if (_globalize.default && _globalize.default.formatNumber) {
  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.locale('en');
  }
  const formattersCache = {};
  const getFormatter = format => {
    let formatter;
    let formatCacheKey;
    if (typeof format === 'object') {
      formatCacheKey = _globalize.default.locale().locale + ':' + JSON.stringify(format);
    } else {
      formatCacheKey = _globalize.default.locale().locale + ':' + format;
    }
    formatter = formattersCache[formatCacheKey];
    if (!formatter) {
      formatter = formattersCache[formatCacheKey] = _globalize.default.numberFormatter(format);
    }
    return formatter;
  };
  const globalizeNumberLocalization = {
    engine: function () {
      return 'globalize';
    },
    _formatNumberCore: function (value, format, formatConfig) {
      if (format === 'exponential') {
        return this.callBase.apply(this, arguments);
      }
      return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value);
    },
    _normalizeFormatConfig: function (format, formatConfig, value) {
      let config;
      if (format === 'decimal') {
        config = {
          minimumIntegerDigits: formatConfig.precision || 1,
          useGrouping: false,
          minimumFractionDigits: 0,
          maximumFractionDigits: MAX_FRACTION_DIGITS,
          round: value < 0 ? 'ceil' : 'floor'
        };
      } else {
        config = this._getPrecisionConfig(formatConfig.precision);
      }
      if (format === 'percent') {
        config.style = 'percent';
      }
      return config;
    },
    _getPrecisionConfig: function (precision) {
      let config;
      if (precision === null) {
        config = {
          minimumFractionDigits: 0,
          maximumFractionDigits: MAX_FRACTION_DIGITS
        };
      } else {
        config = {
          minimumFractionDigits: precision || 0,
          maximumFractionDigits: precision || 0
        };
      }
      return config;
    },
    format: function (value, format) {
      if (typeof value !== 'number') {
        return value;
      }
      format = this._normalizeFormat(format);
      if (!format || typeof format !== 'function' && !format.type && !format.formatter) {
        return getFormatter(format)(value);
      }
      return this.callBase.apply(this, arguments);
    },
    parse: function (text, format) {
      if (!text) {
        return;
      }
      if (format && (format.parser || typeof format === 'string')) {
        return this.callBase.apply(this, arguments);
      }
      if (format) {
        // Current parser functionality provided as-is and is independent of the most of capabilities of formatter.
        _errors.default.log('W0011');
      }
      let result = _globalize.default.parseNumber(text);
      if (isNaN(result)) {
        result = this.callBase.apply(this, arguments);
      }
      return result;
    }
  };
  _number.default.resetInjection();
  _number.default.inject(globalizeNumberLocalization);
}

/***/ }),

/***/ 13024:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _core = _interopRequireDefault(__webpack_require__(91331));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* globals Intl */

const SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;
const NARROW_NO_BREAK_SPACE_REGEX = /[\u202F]/g;
const getIntlFormatter = format => {
  return date => {
    // NOTE: Intl in some browsers formates dates with timezone offset which was at the moment for this date.
    // But the method "new Date" creates date using current offset. So, we decided to format dates in the UTC timezone.
    if (!format.timeZoneName) {
      const year = date.getFullYear();
      // NOTE: new Date(99,0,1) will return 1999 year, but 99 expected
      const recognizableAsTwentyCentury = String(year).length < 3;
      const safeYearShift = 400;
      const temporaryYearValue = recognizableAsTwentyCentury ? year + safeYearShift : year;
      const utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      if (recognizableAsTwentyCentury) {
        utcDate.setFullYear(year);
      }
      const utcFormat = (0, _extend.extend)({
        timeZone: 'UTC'
      }, format);
      return formatDateTime(utcDate, utcFormat);
    }
    return formatDateTime(date, format);
  };
};
const formattersCache = {};
const getFormatter = format => {
  const key = _core.default.locale() + '/' + JSON.stringify(format);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.DateTimeFormat(_core.default.locale(), format).format;
  }
  return formattersCache[key];
};
function formatDateTime(date, format) {
  return getFormatter(format)(date).replace(SYMBOLS_TO_REMOVE_REGEX, '').replace(NARROW_NO_BREAK_SPACE_REGEX, ' ');
}
const formatNumber = number => {
  return new Intl.NumberFormat(_core.default.locale()).format(number);
};
const getAlternativeNumeralsMap = (() => {
  const numeralsMapCache = {};
  return locale => {
    if (!(locale in numeralsMapCache)) {
      if (formatNumber(0) === '0') {
        numeralsMapCache[locale] = false;
        return false;
      }
      numeralsMapCache[locale] = {};
      for (let i = 0; i < 10; ++i) {
        numeralsMapCache[locale][formatNumber(i)] = i;
      }
    }
    return numeralsMapCache[locale];
  };
})();
const normalizeNumerals = dateString => {
  const alternativeNumeralsMap = getAlternativeNumeralsMap(_core.default.locale());
  if (!alternativeNumeralsMap) {
    return dateString;
  }
  return dateString.split('').map(sign => {
    return sign in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign]) : sign;
  }).join('');
};
const removeLeadingZeroes = str => {
  return str.replace(/(\D)0+(\d)/g, '$1$2');
};
const dateStringEquals = (actual, expected) => {
  return removeLeadingZeroes(actual) === removeLeadingZeroes(expected);
};
const normalizeMonth = text => {
  return text.replace('d\u2019', 'de '); // NOTE: For "ca" locale
};
const intlFormats = {
  'day': {
    day: 'numeric'
  },
  'date': {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  'dayofweek': {
    weekday: 'long'
  },
  'longdate': {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  'longdatelongtime': {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric'
  },
  'longtime': {
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric'
  },
  'month': {
    month: 'long'
  },
  'monthandday': {
    month: 'long',
    day: 'numeric'
  },
  'monthandyear': {
    year: 'numeric',
    month: 'long'
  },
  'shortdate': {},
  'shorttime': {
    hour: 'numeric',
    minute: 'numeric'
  },
  'shortyear': {
    year: '2-digit'
  },
  'year': {
    year: 'numeric'
  }
};
Object.defineProperty(intlFormats, 'shortdateshorttime', {
  get: function () {
    const defaultOptions = Intl.DateTimeFormat(_core.default.locale()).resolvedOptions();
    return {
      year: defaultOptions.year,
      month: defaultOptions.month,
      day: defaultOptions.day,
      hour: 'numeric',
      minute: 'numeric'
    };
  }
});
const getIntlFormat = format => {
  return typeof format === 'string' && intlFormats[format.toLowerCase()];
};
const monthNameStrategies = {
  standalone: function (monthIndex, monthFormat) {
    const date = new Date(1999, monthIndex, 13, 1);
    const dateString = getIntlFormatter({
      month: monthFormat
    })(date);
    return dateString;
  },
  format: function (monthIndex, monthFormat) {
    const date = new Date(0, monthIndex, 13, 1);
    const dateString = normalizeMonth(getIntlFormatter({
      day: 'numeric',
      month: monthFormat
    })(date));
    const parts = dateString.split(' ').filter(part => {
      return part.indexOf('13') < 0;
    });
    if (parts.length === 1) {
      return parts[0];
    } else if (parts.length === 2) {
      return parts[0].length > parts[1].length ? parts[0] : parts[1]; // NOTE: For "lt" locale
    }
    return monthNameStrategies.standalone(monthIndex, monthFormat);
  }
};
var _default = exports["default"] = {
  engine: function () {
    return 'intl';
  },
  getMonthNames: function (format, type) {
    const intlFormats = {
      wide: 'long',
      abbreviated: 'short',
      narrow: 'narrow'
    };
    const monthFormat = intlFormats[format || 'wide'];
    type = type === 'format' ? type : 'standalone';
    return Array.apply(null, new Array(12)).map((_, monthIndex) => {
      return monthNameStrategies[type](monthIndex, monthFormat);
    });
  },
  getDayNames: function (format) {
    const intlFormats = {
      wide: 'long',
      abbreviated: 'short',
      short: 'narrow',
      narrow: 'narrow'
    };
    const getIntlDayNames = format => {
      return Array.apply(null, new Array(7)).map((_, dayIndex) => {
        return getIntlFormatter({
          weekday: format
        })(new Date(0, 0, dayIndex));
      });
    };
    const result = getIntlDayNames(intlFormats[format || 'wide']);
    return result;
  },
  getPeriodNames: function () {
    const hour12Formatter = getIntlFormatter({
      hour: 'numeric',
      hour12: true
    });
    return [1, 13].map(hours => {
      const hourNumberText = formatNumber(1); // NOTE: For "bn" locale
      const timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);
      if (timeParts.length !== 2) {
        return '';
      }
      const biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
      return biggerPart.trim();
    });
  },
  format: function (date, format) {
    if (!date) {
      return;
    }
    if (!format) {
      return date;
    }

    // TODO: refactor (extract code form base)
    if (typeof format !== 'function' && !format.formatter) {
      format = format.type || format;
    }
    const intlFormat = getIntlFormat(format);
    if (intlFormat) {
      return getIntlFormatter(intlFormat)(date);
    }
    const formatType = typeof format;
    if (format.formatter || formatType === 'function' || formatType === 'string') {
      return this.callBase.apply(this, arguments);
    }
    return getIntlFormatter(format)(date);
  },
  parse: function (dateString, format) {
    let formatter;
    if (format && !format.parser && typeof dateString === 'string') {
      dateString = normalizeMonth(dateString);
      formatter = date => {
        return normalizeMonth(this.format(date, format));
      };
    }
    return this.callBase(dateString, formatter || format);
  },
  _parseDateBySimpleFormat: function (dateString, format) {
    dateString = normalizeNumerals(dateString);
    const formatParts = this.getFormatParts(format);
    const dateParts = dateString.split(/\D+/).filter(part => {
      return part.length > 0;
    });
    if (formatParts.length !== dateParts.length) {
      return;
    }
    const dateArgs = this._generateDateArgs(formatParts, dateParts);
    const constructDate = (dateArgs, ampmShift) => {
      const hoursShift = ampmShift ? 12 : 0;
      return new Date(dateArgs.year, dateArgs.month, dateArgs.day, (dateArgs.hours + hoursShift) % 24, dateArgs.minutes, dateArgs.seconds);
    };
    const constructValidDate = ampmShift => {
      const parsedDate = constructDate(dateArgs, ampmShift);
      if (dateStringEquals(normalizeNumerals(this.format(parsedDate, format)), dateString)) {
        return parsedDate;
      }
    };
    return constructValidDate(false) || constructValidDate(true);
  },
  _generateDateArgs: function (formatParts, dateParts) {
    const currentDate = new Date();
    const dateArgs = {
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(),
      day: currentDate.getDate(),
      hours: 0,
      minutes: 0,
      seconds: 0
    };
    formatParts.forEach((formatPart, index) => {
      const datePart = dateParts[index];
      let parsed = parseInt(datePart, 10);
      if (formatPart === 'month') {
        parsed = parsed - 1;
      }
      dateArgs[formatPart] = parsed;
    });
    return dateArgs;
  },
  formatUsesMonthName: function (format) {
    if (typeof format === 'object' && !(format.type || format.format)) {
      return format.month === 'long';
    }
    return this.callBase.apply(this, arguments);
  },
  formatUsesDayName: function (format) {
    if (typeof format === 'object' && !(format.type || format.format)) {
      return format.weekday === 'long';
    }
    return this.callBase.apply(this, arguments);
  },
  getTimeSeparator: function () {
    const formatOptions = {
      hour: 'numeric',
      minute: 'numeric',
      hour12: false
    };
    return normalizeNumerals(formatDateTime(new Date(2001, 1, 1, 11, 11), formatOptions)).replace(/\d/g, '');
  },
  getFormatParts: function (format) {
    if (typeof format === 'string') {
      return this.callBase(format);
    }
    const intlFormat = (0, _extend.extend)({}, intlFormats[format.toLowerCase()]);
    const date = new Date(2001, 2, 4, 5, 6, 7);
    let formattedDate = getIntlFormatter(intlFormat)(date);
    formattedDate = normalizeNumerals(formattedDate);
    const formatParts = [{
      name: 'year',
      value: 1
    }, {
      name: 'month',
      value: 3
    }, {
      name: 'day',
      value: 4
    }, {
      name: 'hours',
      value: 5
    }, {
      name: 'minutes',
      value: 6
    }, {
      name: 'seconds',
      value: 7
    }];
    return formatParts.map(part => {
      return {
        name: part.name,
        index: formattedDate.indexOf(part.value)
      };
    }).filter(part => {
      return part.index > -1;
    }).sort((a, b) => {
      return a.index - b.index;
    }).map(part => {
      return part.name;
    });
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 38702:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _core = _interopRequireDefault(__webpack_require__(91331));
var _open_xml_currency_format = _interopRequireDefault(__webpack_require__(44592));
var _accounting_formats = _interopRequireDefault(__webpack_require__(71868));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* globals Intl */

const CURRENCY_STYLES = ['standard', 'accounting'];
const MAX_FRACTION_DIGITS = 20;
const detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
const formattersCache = {};
const getFormatter = format => {
  const key = _core.default.locale() + '/' + JSON.stringify(format);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.NumberFormat(_core.default.locale(), format).format;
  }
  return formattersCache[key];
};
const getCurrencyFormatter = currency => {
  return new Intl.NumberFormat(_core.default.locale(), {
    style: 'currency',
    currency: currency
  });
};
var _default = exports["default"] = {
  engine: function () {
    return 'intl';
  },
  _formatNumberCore: function (value, format, formatConfig) {
    if (format === 'exponential') {
      return this.callBase.apply(this, arguments);
    }
    return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value);
  },
  _normalizeFormatConfig: function (format, formatConfig, value) {
    let config;
    if (format === 'decimal') {
      const fractionDigits = String(value).split('.')[1];
      config = {
        minimumIntegerDigits: formatConfig.precision || undefined,
        useGrouping: false,
        maximumFractionDigits: fractionDigits && fractionDigits.length,
        round: value < 0 ? 'ceil' : 'floor'
      };
    } else {
      config = this._getPrecisionConfig(formatConfig.precision);
    }
    if (format === 'percent') {
      config.style = 'percent';
    } else if (format === 'currency') {
      const useAccountingStyle = formatConfig.useCurrencyAccountingStyle ?? (0, _config.default)().defaultUseCurrencyAccountingStyle;
      config.style = 'currency';
      config.currency = formatConfig.currency || (0, _config.default)().defaultCurrency;
      config.currencySign = CURRENCY_STYLES[+useAccountingStyle];
    }
    return config;
  },
  _getPrecisionConfig: function (precision) {
    let config;
    if (precision === null) {
      config = {
        minimumFractionDigits: 0,
        maximumFractionDigits: MAX_FRACTION_DIGITS
      };
    } else {
      config = {
        minimumFractionDigits: precision || 0,
        maximumFractionDigits: precision || 0
      };
    }
    return config;
  },
  format: function (value, format) {
    if ('number' !== typeof value) {
      return value;
    }
    format = this._normalizeFormat(format);
    if (format.currency === 'default') {
      format.currency = (0, _config.default)().defaultCurrency;
    }
    if (!format || 'function' !== typeof format && !format.type && !format.formatter) {
      return getFormatter(format)(value);
    }
    return this.callBase.apply(this, arguments);
  },
  _getCurrencySymbolInfo: function (currency) {
    const formatter = getCurrencyFormatter(currency);
    return this._extractCurrencySymbolInfo(formatter.format(0));
  },
  _extractCurrencySymbolInfo: function (currencyValueString) {
    const match = detectCurrencySymbolRegex.exec(currencyValueString) || [];
    const position = match[1] ? 'before' : 'after';
    const symbol = match[1] || match[4] || '';
    const delimiter = match[2] || match[3] || '';
    return {
      position: position,
      symbol: symbol,
      delimiter: delimiter
    };
  },
  getCurrencySymbol: function (currency) {
    if (!currency) {
      currency = (0, _config.default)().defaultCurrency;
    }
    const symbolInfo = this._getCurrencySymbolInfo(currency);
    return {
      'symbol': symbolInfo.symbol
    };
  },
  getOpenXmlCurrencyFormat: function (currency) {
    const targetCurrency = currency || (0, _config.default)().defaultCurrency;
    const currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
    const closestAccountingFormat = _core.default.getValueByClosestLocale(locale => _accounting_formats.default[locale]);
    return (0, _open_xml_currency_format.default)(currencySymbol, closestAccountingFormat);
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 9821:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getLanguageId = getLanguageId;
var _core = _interopRequireDefault(__webpack_require__(91331));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LANGUAGE_CODES = {
  'ar': 1,
  'bg': 2,
  'ca': 3,
  'zh-Hans': 4,
  'cs': 5,
  'da': 6,
  'de': 7,
  'el': 8,
  'en': 9,
  'es': 10,
  'fi': 11,
  'fr': 12,
  'he': 13,
  'hu': 14,
  'is': 15,
  'it': 16,
  'ja': 17,
  'ko': 18,
  'nl': 19,
  'no': 20,
  'pl': 21,
  'pt': 22,
  'rm': 23,
  'ro': 24,
  'ru': 25,
  'hr': 26,
  'sk': 27,
  'sq': 28,
  'sv': 29,
  'th': 30,
  'tr': 31,
  'ur': 32,
  'id': 33,
  'uk': 34,
  'be': 35,
  'sl': 36,
  'et': 37,
  'lv': 38,
  'lt': 39,
  'tg': 40,
  'fa': 41,
  'vi': 42,
  'hy': 43,
  'az': 44,
  'eu': 45,
  'hsb': 46,
  'mk': 47,
  'tn': 50,
  'xh': 52,
  'zu': 53,
  'af': 54,
  'ka': 55,
  'fo': 56,
  'hi': 57,
  'mt': 58,
  'se': 59,
  'ga': 60,
  'ms': 62,
  'kk': 63,
  'ky': 64,
  'sw': 65,
  'tk': 66,
  'uz': 67,
  'tt': 68,
  'bn': 69,
  'pa': 70,
  'gu': 71,
  'or': 72,
  'ta': 73,
  'te': 74,
  'kn': 75,
  'ml': 76,
  'as': 77,
  'mr': 78,
  'sa': 79,
  'mn': 80,
  'bo': 81,
  'cy': 82,
  'km': 83,
  'lo': 84,
  'gl': 86,
  'kok': 87,
  'syr': 90,
  'si': 91,
  'iu': 93,
  'am': 94,
  'tzm': 95,
  'ne': 97,
  'fy': 98,
  'ps': 99,
  'fil': 100,
  'dv': 101,
  'ha': 104,
  'yo': 106,
  'quz': 107,
  'nso': 108,
  'ba': 109,
  'lb': 110,
  'kl': 111,
  'ig': 112,
  'ii': 120,
  'arn': 122,
  'moh': 124,
  'br': 126,
  'ug': 128,
  'mi': 129,
  'oc': 130,
  'co': 131,
  'gsw': 132,
  'sah': 133,
  'qut': 134,
  'rw': 135,
  'wo': 136,
  'prs': 140,
  'gd': 145,
  'ar-SA': 1025,
  'bg-BG': 1026,
  'ca-ES': 1027,
  'zh-TW': 1028,
  'cs-CZ': 1029,
  'da-DK': 1030,
  'de-DE': 1031,
  'el-GR': 1032,
  'en-US': 1033,
  'fi-FI': 1035,
  'fr-FR': 1036,
  'he-IL': 1037,
  'hu-HU': 1038,
  'is-IS': 1039,
  'it-IT': 1040,
  'ja-JP': 1041,
  'ko-KR': 1042,
  'nl-NL': 1043,
  'nb-NO': 1044,
  'pl-PL': 1045,
  'pt-BR': 1046,
  'rm-CH': 1047,
  'ro-RO': 1048,
  'ru-RU': 1049,
  'hr-HR': 1050,
  'sk-SK': 1051,
  'sq-AL': 1052,
  'sv-SE': 1053,
  'th-TH': 1054,
  'tr-TR': 1055,
  'ur-PK': 1056,
  'id-ID': 1057,
  'uk-UA': 1058,
  'be-BY': 1059,
  'sl-SI': 1060,
  'et-EE': 1061,
  'lv-LV': 1062,
  'lt-LT': 1063,
  'tg-Cyrl-TJ': 1064,
  'fa-IR': 1065,
  'vi-VN': 1066,
  'hy-AM': 1067,
  'az-Latn-AZ': 1068,
  'eu-ES': 1069,
  'hsb-DE': 1070,
  'mk-MK': 1071,
  'tn-ZA': 1074,
  'xh-ZA': 1076,
  'zu-ZA': 1077,
  'af-ZA': 1078,
  'ka-GE': 1079,
  'fo-FO': 1080,
  'hi-IN': 1081,
  'mt-MT': 1082,
  'se-NO': 1083,
  'ms-MY': 1086,
  'kk-KZ': 1087,
  'ky-KG': 1088,
  'sw-KE': 1089,
  'tk-TM': 1090,
  'uz-Latn-UZ': 1091,
  'tt-RU': 1092,
  'bn-IN': 1093,
  'pa-IN': 1094,
  'gu-IN': 1095,
  'or-IN': 1096,
  'ta-IN': 1097,
  'te-IN': 1098,
  'kn-IN': 1099,
  'ml-IN': 1100,
  'as-IN': 1101,
  'mr-IN': 1102,
  'sa-IN': 1103,
  'mn-MN': 1104,
  'bo-CN': 1105,
  'cy-GB': 1106,
  'km-KH': 1107,
  'lo-LA': 1108,
  'gl-ES': 1110,
  'kok-IN': 1111,
  'syr-SY': 1114,
  'si-LK': 1115,
  'iu-Cans-CA': 1117,
  'am-ET': 1118,
  'ne-NP': 1121,
  'fy-NL': 1122,
  'ps-AF': 1123,
  'fil-PH': 1124,
  'dv-MV': 1125,
  'ha-Latn-NG': 1128,
  'yo-NG': 1130,
  'quz-BO': 1131,
  'nso-ZA': 1132,
  'ba-RU': 1133,
  'lb-LU': 1134,
  'kl-GL': 1135,
  'ig-NG': 1136,
  'ii-CN': 1144,
  'arn-CL': 1146,
  'moh-CA': 1148,
  'br-FR': 1150,
  'ug-CN': 1152,
  'mi-NZ': 1153,
  'oc-FR': 1154,
  'co-FR': 1155,
  'gsw-FR': 1156,
  'sah-RU': 1157,
  'qut-GT': 1158,
  'rw-RW': 1159,
  'wo-SN': 1160,
  'prs-AF': 1164,
  'gd-GB': 1169,
  'ar-IQ': 2049,
  'zh-CN': 2052,
  'de-CH': 2055,
  'en-GB': 2057,
  'es-MX': 2058,
  'fr-BE': 2060,
  'it-CH': 2064,
  'nl-BE': 2067,
  'nn-NO': 2068,
  'pt-PT': 2070,
  'sr-Latn-CS': 2074,
  'sv-FI': 2077,
  'az-Cyrl-AZ': 2092,
  'dsb-DE': 2094,
  'se-SE': 2107,
  'ga-IE': 2108,
  'ms-BN': 2110,
  'uz-Cyrl-UZ': 2115,
  'bn-BD': 2117,
  'mn-Mong-CN': 2128,
  'iu-Latn-CA': 2141,
  'tzm-Latn-DZ': 2143,
  'quz-EC': 2155,
  'ar-EG': 3073,
  'zh-HK': 3076,
  'de-AT': 3079,
  'en-AU': 3081,
  'es-ES': 3082,
  'fr-CA': 3084,
  'sr-Cyrl-CS': 3098,
  'se-FI': 3131,
  'quz-PE': 3179,
  'ar-LY': 4097,
  'zh-SG': 4100,
  'de-LU': 4103,
  'en-CA': 4105,
  'es-GT': 4106,
  'fr-CH': 4108,
  'hr-BA': 4122,
  'smj-NO': 4155,
  'ar-DZ': 5121,
  'zh-MO': 5124,
  'de-LI': 5127,
  'en-NZ': 5129,
  'es-CR': 5130,
  'fr-LU': 5132,
  'bs-Latn-BA': 5146,
  'smj-SE': 5179,
  'ar-MA': 6145,
  'en-IE': 6153,
  'es-PA': 6154,
  'fr-MC': 6156,
  'sr-Latn-BA': 6170,
  'sma-NO': 6203,
  'ar-TN': 7169,
  'en-ZA': 7177,
  'es-DO': 7178,
  'sr-Cyrl-BA': 7194,
  'sma-SE': 7227,
  'ar-OM': 8193,
  'en-JM': 8201,
  'es-VE': 8202,
  'bs-Cyrl-BA': 8218,
  'sms-FI': 8251,
  'ar-YE': 9217,
  'en-029': 9225,
  'es-CO': 9226,
  'sr-Latn-RS': 9242,
  'smn-FI': 9275,
  'ar-SY': 10241,
  'en-BZ': 10249,
  'es-PE': 10250,
  'sr-Cyrl-RS': 10266,
  'ar-JO': 11265,
  'en-TT': 11273,
  'es-AR': 11274,
  'sr-Latn-ME': 11290,
  'ar-LB': 12289,
  'en-ZW': 12297,
  'es-EC': 12298,
  'sr-Cyrl-ME': 12314,
  'ar-KW': 13313,
  'en-PH': 13321,
  'es-CL': 13322,
  'ar-AE': 14337,
  'es-UY': 14346,
  'ar-BH': 15361,
  'es-PY': 15370,
  'ar-QA': 16385,
  'en-IN': 16393,
  'es-BO': 16394,
  'en-MY': 17417,
  'es-SV': 17418,
  'en-SG': 18441,
  'es-HN': 18442,
  'es-NI': 19466,
  'es-PR': 20490,
  'es-US': 21514,
  'bs-Cyrl': 25626,
  'bs-Latn': 26650,
  'sr-Cyrl': 27674,
  'sr-Latn': 28698,
  'smn': 28731,
  'az-Cyrl': 29740,
  'sms': 29755,
  'zh': 30724,
  'nn': 30740,
  'bs': 30746,
  'az-Latn': 30764,
  'sma': 30779,
  'uz-Cyrl': 30787,
  'mn-Cyrl': 30800,
  'iu-Cans': 30813,
  'zh-Hant': 31748,
  'nb': 31764,
  'sr': 31770,
  'tg-Cyrl': 31784,
  'dsb': 31790,
  'smj': 31803,
  'uz-Latn': 31811,
  'mn-Mong': 31824,
  'iu-Latn': 31837,
  'tzm-Latn': 31839,
  'ha-Latn': 31848
};
function getLanguageId() {
  return LANGUAGE_CODES[_core.default.locale()];
}

/***/ }),

/***/ 59937:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getFormat = void 0;
var _number = _interopRequireDefault(__webpack_require__(18016));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ARABIC_COMMA = '\u060C';
const FORMAT_SEPARATORS = ' .,:;/\\<>()-[]' + ARABIC_COMMA;
const AM_PM_PATTERN = '. m.';
const checkDigit = function (char) {
  const code = char && _number.default.convertDigits(char, false).charCodeAt(0);
  const zeroCode = _number.default.convertDigits('0', false).charCodeAt(0);
  return zeroCode <= code && code < zeroCode + 10;
};
const checkPatternContinue = function (text, patterns, index, isDigit) {
  const char = text[index];
  const nextChar = text[index + 1];
  if (!isDigit) {
    if (char === '.' || char === ' ' && text.slice(index - 1, index + 3) === AM_PM_PATTERN) {
      return true;
    }
    if (char === '-' && !checkDigit(nextChar)) {
      return true;
    }
  }
  const isDigitChanged = isDigit && patterns.some(pattern => text[index] !== pattern[index]);
  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);
};
const getPatternStartIndex = function (defaultPattern, index) {
  if (!checkDigit(defaultPattern[index])) {
    while (index > 0 && !checkDigit(defaultPattern[index - 1]) && (defaultPattern[index - 1] === '.' || FORMAT_SEPARATORS.indexOf(defaultPattern[index - 1]) < 0)) {
      index--;
    }
  }
  return index;
};
const getDifference = function (defaultPattern, patterns, processedIndexes, isDigit) {
  let i = 0;
  const result = [];
  const patternsFilter = function (pattern) {
    return defaultPattern[i] !== pattern[i] && (isDigit === undefined || checkDigit(defaultPattern[i]) === isDigit);
  };
  if (!Array.isArray(patterns)) {
    patterns = [patterns];
  }
  for (i = 0; i < defaultPattern.length; i++) {
    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
      i = getPatternStartIndex(defaultPattern, i);
      do {
        isDigit = checkDigit(defaultPattern[i]);
        if (!result.length && !isDigit && checkDigit(patterns[0][i])) {
          break;
        }
        result.push(i);
        processedIndexes.unshift(i);
        i++;
      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));
      break;
    }
  }
  if (result.length === 1 && (defaultPattern[processedIndexes[0] - 1] === '0' || defaultPattern[processedIndexes[0] - 1] === '')) {
    processedIndexes.unshift(processedIndexes[0] - 1);
  }
  return result;
};
const replaceCharsCore = function (pattern, indexes, char, patternPositions) {
  const baseCharIndex = indexes[0];
  const patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
  indexes.forEach(function (_, index) {
    pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1);
  });
  if (indexes.length === 1) {
    pattern = pattern.replace('0' + char, char + char);
    pattern = pattern.replace('' + char, char + char);
  }
  return pattern;
};
const replaceChars = function (pattern, indexes, char, patternPositions) {
  let i;
  let index;
  let patternIndex;
  if (!checkDigit(pattern[indexes[0]] || '0')) {
    const letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
    while (indexes.length > letterCount) {
      index = indexes.pop();
      patternIndex = patternPositions[index];
      patternPositions[index] = -1;
      for (i = index + 1; i < patternPositions.length; i++) {
        patternPositions[i]--;
      }
      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);
    }
    index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;
    while (indexes.length < letterCount) {
      indexes.push(indexes[indexes.length - 1] + 1);
      for (i = index; i < patternPositions.length; i++) {
        patternPositions[i]++;
      }
      pattern = pattern.substr(0, patternIndex) + ' ' + pattern.substr(patternIndex);
    }
  }
  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
  return pattern;
};
const formatValue = function (value, formatter) {
  if (Array.isArray(value)) {
    return value.map(function (value) {
      return (formatter(value) || '').toString();
    });
  }
  return (formatter(value) || '').toString();
};
const ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;
const escapeChars = function (pattern, defaultPattern, processedIndexes, patternPositions) {
  const escapeIndexes = defaultPattern.split('').map(function (char, index) {
    if (processedIndexes.indexOf(index) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || char === '\'')) {
      return patternPositions[index];
    }
    return -1;
  });
  pattern = pattern.split('').map(function (char, index) {
    let result = char;
    const isCurrentCharEscaped = escapeIndexes.indexOf(index) >= 0;
    const isPrevCharEscaped = index > 0 && escapeIndexes.indexOf(index - 1) >= 0;
    const isNextCharEscaped = escapeIndexes.indexOf(index + 1) >= 0;
    if (isCurrentCharEscaped) {
      if (!isPrevCharEscaped) {
        result = '\'' + result;
      }
      if (!isNextCharEscaped) {
        result = result + '\'';
      }
    }
    return result;
  }).join('');
  return pattern;
};
const getFormat = function (formatter) {
  const processedIndexes = [];
  const defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);
  const patternPositions = defaultPattern.split('').map(function (_, index) {
    return index;
  });
  let result = defaultPattern;
  const replacedPatterns = {};
  const datePatterns = [{
    date: new Date(2009, 8, 8, 6, 5, 4, 111),
    pattern: 'S'
  }, {
    date: new Date(2009, 8, 8, 6, 5, 2),
    pattern: 's'
  }, {
    date: new Date(2009, 8, 8, 6, 2, 4),
    pattern: 'm'
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: 'H',
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 2, 5, 4),
    pattern: 'h',
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: 'a',
    isDigit: false
  }, {
    date: new Date(2009, 8, 1, 6, 5, 4),
    pattern: 'd'
  }, {
    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
    pattern: 'E'
  }, {
    date: new Date(2009, 9, 6, 6, 5, 4),
    pattern: 'M'
  }, {
    date: new Date(1998, 8, 8, 6, 5, 4),
    pattern: 'y'
  }];
  if (!result) return;
  datePatterns.forEach(function (test) {
    const diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);
    const pattern = test.pattern === 'M' && !replacedPatterns['d'] ? 'L' : test.pattern;
    result = replaceChars(result, diff, pattern, patternPositions);
    replacedPatterns[pattern] = diff.length;
  });
  result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);
  if (processedIndexes.length) {
    return result;
  }
};
exports.getFormat = getFormat;

/***/ }),

/***/ 40594:
/***/ (function(__unused_webpack_module, exports) {



exports.getFormatter = void 0;
function leftPad(text, length) {
  while (text.length < length) {
    text = '0' + text;
  }
  return text;
}
const FORMAT_TYPES = {
  '3': 'abbreviated',
  '4': 'wide',
  '5': 'narrow'
};
const LDML_FORMATTERS = {
  y: function (date, count, useUtc) {
    let year = date[useUtc ? 'getUTCFullYear' : 'getFullYear']();
    if (count === 2) {
      year = year % 100;
    }
    return leftPad(year.toString(), count);
  },
  M: function (date, count, useUtc, dateParts) {
    const month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, 'format')[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  L: function (date, count, useUtc, dateParts) {
    const month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, 'standalone')[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  Q: function (date, count, useUtc, dateParts) {
    const month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    const quarter = Math.floor(month / 3);
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getQuarterNames(formatType)[quarter];
    }
    return leftPad((quarter + 1).toString(), Math.min(count, 2));
  },
  E: function (date, count, useUtc, dateParts) {
    const day = date[useUtc ? 'getUTCDay' : 'getDay']();
    const formatType = FORMAT_TYPES[count < 3 ? 3 : count];
    return dateParts.getDayNames(formatType)[day];
  },
  a: function (date, count, useUtc, dateParts) {
    const hours = date[useUtc ? 'getUTCHours' : 'getHours']();
    const period = hours < 12 ? 0 : 1;
    const formatType = FORMAT_TYPES[count];
    return dateParts.getPeriodNames(formatType)[period];
  },
  d: function (date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCDate' : 'getDate']().toString(), Math.min(count, 2));
  },
  H: function (date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCHours' : 'getHours']().toString(), Math.min(count, 2));
  },
  h: function (date, count, useUtc) {
    const hours = date[useUtc ? 'getUTCHours' : 'getHours']();
    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
  },
  m: function (date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCMinutes' : 'getMinutes']().toString(), Math.min(count, 2));
  },
  s: function (date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCSeconds' : 'getSeconds']().toString(), Math.min(count, 2));
  },
  S: function (date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCMilliseconds' : 'getMilliseconds']().toString(), 3).substr(0, count);
  },
  x: function (date, count, useUtc) {
    const timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
    const signPart = timezoneOffset > 0 ? '-' : '+';
    const timezoneOffsetAbs = Math.abs(timezoneOffset);
    const hours = Math.floor(timezoneOffsetAbs / 60);
    const minutes = timezoneOffsetAbs % 60;
    const hoursPart = leftPad(hours.toString(), 2);
    const minutesPart = leftPad(minutes.toString(), 2);
    return signPart + hoursPart + (count >= 3 ? ':' : '') + (count > 1 || minutes ? minutesPart : '');
  },
  X: function (date, count, useUtc) {
    if (useUtc || !date.getTimezoneOffset()) {
      return 'Z';
    }
    return LDML_FORMATTERS.x(date, count, useUtc);
  },
  Z: function (date, count, useUtc) {
    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
  }
};
const getFormatter = function (format, dateParts) {
  return function (date) {
    let charIndex;
    let formatter;
    let char;
    let charCount = 0;
    const separator = '\'';
    let isEscaping = false;
    let isCurrentCharEqualsNext;
    let result = '';
    if (!date) return null;
    if (!format) return date;
    const useUtc = format[format.length - 1] === 'Z' || format.slice(-3) === '\'Z\'';
    for (charIndex = 0; charIndex < format.length; charIndex++) {
      char = format[charIndex];
      formatter = LDML_FORMATTERS[char];
      isCurrentCharEqualsNext = char === format[charIndex + 1];
      charCount++;
      if (!isCurrentCharEqualsNext) {
        if (formatter && !isEscaping) {
          result += formatter(date, charCount, useUtc, dateParts);
        }
        charCount = 0;
      }
      if (char === separator && !isCurrentCharEqualsNext) {
        isEscaping = !isEscaping;
      } else if (isEscaping || !formatter) {
        result += char;
      }
      if (char === separator && isCurrentCharEqualsNext) {
        charIndex++;
      }
    }
    return result;
  };
};
exports.getFormatter = getFormatter;

/***/ }),

/***/ 2892:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.isPossibleForParsingFormat = exports.getRegExpInfo = exports.getPatternSetters = exports.getParser = void 0;
var _common = __webpack_require__(20576);
var _console = __webpack_require__(30869);
const FORMAT_TYPES = {
  '3': 'abbreviated',
  '4': 'wide',
  '5': 'narrow'
};
const monthRegExpGenerator = function (count, dateParts) {
  if (count > 2) {
    return Object.keys(FORMAT_TYPES).map(function (count) {
      return ['format', 'standalone'].map(function (type) {
        return dateParts.getMonthNames(FORMAT_TYPES[count], type).join('|');
      }).join('|');
    }).join('|');
  }
  return count === 2 ? '1[012]|0?[1-9]' : '0??[1-9]|1[012]';
};
const PATTERN_REGEXPS = {
  ':': function (count, dateParts) {
    const countSuffix = count > 1 ? `{${count}}` : '';
    let timeSeparator = (0, _common.escapeRegExp)(dateParts.getTimeSeparator());
    timeSeparator !== ':' && (timeSeparator = `${timeSeparator}|:`);
    return `${timeSeparator}${countSuffix}`;
  },
  y: function (count) {
    return count === 2 ? `[0-9]{${count}}` : '[0-9]+?';
  },
  M: monthRegExpGenerator,
  L: monthRegExpGenerator,
  Q: function (count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], 'format').join('|');
    }
    return '0?[1-4]';
  },
  E: function (count, dateParts) {
    return '\\D*';
  },
  a: function (count, dateParts) {
    return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format').join('|');
  },
  d: function (count) {
    return count === 2 ? '3[01]|[12][0-9]|0?[1-9]' : '0??[1-9]|[12][0-9]|3[01]';
  },
  H: function (count) {
    return count === 2 ? '2[0-3]|1[0-9]|0?[0-9]' : '0??[0-9]|1[0-9]|2[0-3]';
  },
  h: function (count) {
    return count === 2 ? '1[012]|0?[1-9]' : '0??[1-9]|1[012]';
  },
  m: function (count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  },
  s: function (count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  },
  S: function (count) {
    return `[0-9]{1,${count}}`;
  },
  w: function (count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  },
  x: function (count) {
    return count === 3 ? '[+-](?:2[0-3]|[01][0-9]):(?:[0-5][0-9])|Z' : '[+-](?:2[0-3]|[01][0-9])(?:[0-5][0-9])|Z';
  }
};
const parseNumber = Number;
const caseInsensitiveIndexOf = function (array, value) {
  return array.map(item => item.toLowerCase()).indexOf(value.toLowerCase());
};
const monthPatternParser = function (text, count, dateParts) {
  if (count > 2) {
    return ['format', 'standalone'].map(function (type) {
      return Object.keys(FORMAT_TYPES).map(function (count) {
        const monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);
        return caseInsensitiveIndexOf(monthNames, text);
      });
    }).reduce(function (a, b) {
      return a.concat(b);
    }).filter(function (index) {
      return index >= 0;
    })[0];
  }
  return parseNumber(text) - 1;
};
const PATTERN_PARSERS = {
  y: function (text, count) {
    const year = parseNumber(text);
    if (count === 2) {
      return year < 30 ? 2000 + year : 1900 + year;
    }
    return year;
  },
  M: monthPatternParser,
  L: monthPatternParser,
  Q: function (text, count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], 'format').indexOf(text);
    }
    return parseNumber(text) - 1;
  },
  E: function (text, count, dateParts) {
    const dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format');
    return caseInsensitiveIndexOf(dayNames, text);
  },
  a: function (text, count, dateParts) {
    const periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format');
    return caseInsensitiveIndexOf(periodNames, text);
  },
  d: parseNumber,
  H: parseNumber,
  h: parseNumber,
  m: parseNumber,
  s: parseNumber,
  S: function (text, count) {
    count = Math.max(count, 3);
    text = text.slice(0, 3);
    while (count < 3) {
      text = text + '0';
      count++;
    }
    return parseNumber(text);
  }
};
const ORDERED_PATTERNS = ['y', 'M', 'd', 'h', 'm', 's', 'S'];
const PATTERN_SETTERS = {
  y: 'setFullYear',
  M: 'setMonth',
  L: 'setMonth',
  a: function (date, value, datePartValues) {
    let hours = date.getHours();
    const hourPartValue = datePartValues['h'];
    if (hourPartValue !== undefined && hourPartValue !== hours) {
      hours--;
    }
    if (!value && hours === 12) {
      hours = 0;
    } else if (value && hours !== 12) {
      hours += 12;
    }
    date.setHours(hours);
  },
  d: 'setDate',
  H: 'setHours',
  h: 'setHours',
  m: 'setMinutes',
  s: 'setSeconds',
  S: 'setMilliseconds'
};
const getSameCharCount = function (text, index) {
  const char = text[index];
  if (!char) {
    return 0;
  }
  let count = 0;
  do {
    index++;
    count++;
  } while (text[index] === char);
  return count;
};
const createPattern = function (char, count) {
  let result = '';
  for (let i = 0; i < count; i++) {
    result += char;
  }
  return result;
};
const getRegExpInfo = function (format, dateParts) {
  let regexpText = '';
  let stubText = '';
  let isEscaping;
  const patterns = [];
  const addPreviousStub = function () {
    if (stubText) {
      patterns.push(`'${stubText}'`);
      regexpText += `${(0, _common.escapeRegExp)(stubText)})`;
      stubText = '';
    }
  };
  for (let i = 0; i < format.length; i++) {
    const char = format[i];
    const isEscapeChar = char === '\'';
    const regexpPart = PATTERN_REGEXPS[char];
    if (isEscapeChar) {
      isEscaping = !isEscaping;
      if (format[i - 1] !== '\'') {
        continue;
      }
    }
    if (regexpPart && !isEscaping) {
      const count = getSameCharCount(format, i);
      const pattern = createPattern(char, count);
      addPreviousStub();
      patterns.push(pattern);
      regexpText += `(${regexpPart(count, dateParts)})`;
      i += count - 1;
    } else {
      if (!stubText) {
        regexpText += '(';
      }
      stubText += char;
    }
  }
  addPreviousStub();
  if (!isPossibleForParsingFormat(patterns)) {
    _console.logger.warn(`The following format may be parsed incorrectly: ${format}.`);
  }
  return {
    patterns: patterns,
    regexp: new RegExp(`^${regexpText}$`, 'i')
  };
};
exports.getRegExpInfo = getRegExpInfo;
const digitFieldSymbols = ['d', 'H', 'h', 'm', 's', 'w', 'M', 'L', 'Q'];
const isPossibleForParsingFormat = function (patterns) {
  const isDigitPattern = pattern => {
    if (!pattern) {
      return false;
    }
    const char = pattern[0];
    return ['y', 'S'].includes(char) || digitFieldSymbols.includes(char) && pattern.length < 3;
  };
  const isAmbiguousDigitPattern = pattern => {
    return pattern[0] !== 'S' && pattern.length !== 2;
  };
  let possibleForParsing = true;
  let ambiguousDigitPatternsCount = 0;
  return patterns.every((pattern, index, patterns) => {
    if (isDigitPattern(pattern)) {
      if (isAmbiguousDigitPattern(pattern)) {
        possibleForParsing = ++ambiguousDigitPatternsCount < 2;
      }
      if (!isDigitPattern(patterns[index + 1])) {
        ambiguousDigitPatternsCount = 0;
      }
    }
    return possibleForParsing;
  });
};
exports.isPossibleForParsingFormat = isPossibleForParsingFormat;
const getPatternSetters = function () {
  return PATTERN_SETTERS;
};
exports.getPatternSetters = getPatternSetters;
const setPatternPart = function (date, pattern, text, dateParts, datePartValues) {
  const patternChar = pattern[0];
  const partSetter = PATTERN_SETTERS[patternChar];
  const partParser = PATTERN_PARSERS[patternChar];
  if (partSetter && partParser) {
    const value = partParser(text, pattern.length, dateParts);
    datePartValues[pattern] = value;
    if (date[partSetter]) {
      date[partSetter](value);
    } else {
      partSetter(date, value, datePartValues);
    }
  }
};
const setPatternPartFromNow = function (date, pattern, now) {
  const setterName = PATTERN_SETTERS[pattern];
  const getterName = 'g' + setterName.substr(1);
  const value = now[getterName]();
  date[setterName](value);
};
const getShortPatterns = function (fullPatterns) {
  return fullPatterns.map(function (pattern) {
    if (pattern[0] === '\'') {
      return '';
    } else {
      return pattern[0] === 'H' ? 'h' : pattern[0];
    }
  });
};
const getMaxOrderedPatternIndex = function (patterns) {
  const indexes = patterns.map(function (pattern) {
    return ORDERED_PATTERNS.indexOf(pattern);
  });
  return Math.max.apply(Math, indexes);
};
const getOrderedFormatPatterns = function (formatPatterns) {
  const otherPatterns = formatPatterns.filter(function (pattern) {
    return ORDERED_PATTERNS.indexOf(pattern) < 0;
  });
  return ORDERED_PATTERNS.concat(otherPatterns);
};
const getParser = function (format, dateParts) {
  const regExpInfo = getRegExpInfo(format, dateParts);
  return function (text) {
    const regExpResult = regExpInfo.regexp.exec(text);
    if (regExpResult) {
      const now = new Date();
      const date = new Date(now.getFullYear(), 0, 1);
      const formatPatterns = getShortPatterns(regExpInfo.patterns);
      const maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
      const orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
      const datePartValues = {};
      orderedFormatPatterns.forEach(function (pattern, index) {
        if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {
          return;
        }
        const patternIndex = formatPatterns.indexOf(pattern);
        if (patternIndex >= 0) {
          const regExpPattern = regExpInfo.patterns[patternIndex];
          const regExpText = regExpResult[patternIndex + 1];
          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
        } else {
          setPatternPartFromNow(date, pattern, now);
        }
      });
      return date;
    }
    return null;
  };
};
exports.getParser = getParser;

/***/ }),

/***/ 70629:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getFormat = getFormat;
exports.getFormatter = getFormatter;
var _math = __webpack_require__(60810);
var _utils = __webpack_require__(97360);
const DEFAULT_CONFIG = {
  thousandsSeparator: ',',
  decimalSeparator: '.'
};
const ESCAPING_CHAR = '\'';
const MAXIMUM_NUMBER_LENGTH = 15;
const PERCENT_EXPONENT_SHIFT = 2; // '1e2'

function getGroupSizes(formatString) {
  return formatString.split(',').slice(1).map(function (str) {
    let singleQuotesLeft = 0;
    return str.split('').filter(function (char, index) {
      singleQuotesLeft += char === '\'';
      const isDigit = char === '#' || char === '0';
      const isInStub = singleQuotesLeft % 2;
      return isDigit && !isInStub;
    }).length;
  });
}
function getSignParts(format) {
  const signParts = format.split(';');
  if (signParts.length === 1) {
    signParts.push('-' + signParts[0]);
  }
  return signParts;
}
function reverseString(str) {
  return str.toString().split('').reverse().join('');
}
function isPercentFormat(format) {
  return format.indexOf('%') !== -1 && !format.match(/'[^']*%[^']*'/g);
}
function removeStubs(str) {
  return str.replace(/'.+'/g, '');
}
function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) return 0;
  const format = removeStubs(floatFormat);
  return format.length - format.replace(/[#]/g, '').length;
}
function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) return 0;
  const format = removeStubs(floatFormat);
  return format.length - format.replace(/[0]/g, '').length;
}
function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) return '';
  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }
  while (valuePart.length > minDigitCount && valuePart.slice(-1) === '0') {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }
  while (valuePart.length < minDigitCount) {
    valuePart += '0';
  }
  return valuePart;
}
function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) return valueString;
  const groups = [];
  let index = 0;
  while (valueString) {
    const groupSize = groupSizes[index];
    if (!groupSize) {
      break;
    }
    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);
    if (index < groupSizes.length - 1) {
      index++;
    }
  }
  return groups.join(thousandsSeparator);
}
function formatNumberPart(format, valueString) {
  return format.split(ESCAPING_CHAR).map(function (formatPart, escapeIndex) {
    const isEscape = escapeIndex % 2;
    if (!formatPart && isEscape) {
      return ESCAPING_CHAR;
    }
    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join('');
}
function getFloatPointIndex(format) {
  let isEscape = false;
  for (let index = 0; index < format.length; index++) {
    if (format[index] === '\'') {
      isEscape = !isEscape;
    }
    if (format[index] === '.' && !isEscape) {
      return index;
    }
  }
  return format.length;
}
function getFormatter(format, config) {
  config = config || DEFAULT_CONFIG;
  return function (value) {
    if (typeof value !== 'number' || isNaN(value)) return '';
    const signFormatParts = getSignParts(format);
    const isPositiveZero = 1 / value === Infinity;
    const isPositive = value > 0 || isPositiveZero;
    const numberFormat = signFormatParts[isPositive ? 0 : 1];
    const floatPointIndex = getFloatPointIndex(numberFormat);
    const floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    const minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    const maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    if (isPercentFormat(numberFormat)) {
      value = (0, _math.multiplyInExponentialForm)(value, PERCENT_EXPONENT_SHIFT);
    }
    if (!isPositive) {
      value = -value;
    }
    const minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    const maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config.unlimitedIntegerDigits ? undefined : minIntegerPrecision;
    const integerLength = Math.floor(value).toString().length;
    const floatPrecision = (0, _math.fitIntoRange)(maxFloatPrecision, 0, MAXIMUM_NUMBER_LENGTH - integerLength);
    const groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    const valueParts = (0, _utils.toFixed)(value, floatPrecision < 0 ? 0 : floatPrecision).split('.');
    let valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    const valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config.thousandsSeparator);
    const integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    const floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : '';
    const result = integerString + (floatString.match(/\d/) ? config.decimalSeparator : '') + floatString;
    return result;
  };
}
function parseValue(text, isPercent, isNegative) {
  const value = (isPercent ? 0.01 : 1) * parseFloat(text) || 0;
  return isNegative ? -value : value;
}
function prepareValueText(valueText, formatter, isPercent, isIntegerPart) {
  let nextValueText = valueText;
  let char;
  let text;
  let nextText;
  do {
    if (nextText) {
      char = text.length === nextText.length ? '0' : '1';
      valueText = isIntegerPart ? char + valueText : valueText + char;
    }
    text = nextText || formatter(parseValue(nextValueText, isPercent));
    nextValueText = isIntegerPart ? '1' + nextValueText : nextValueText + '1';
    nextText = formatter(parseValue(nextValueText, isPercent));
  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));
  if (isIntegerPart && nextText.length > text.length) {
    const hasGroups = formatter(12345).indexOf('12345') === -1;
    do {
      valueText = '1' + valueText;
    } while (hasGroups && parseValue(valueText, isPercent) < 100000);
  }
  return valueText;
}
function getFormatByValueText(valueText, formatter, isPercent, isNegative) {
  let format = formatter(parseValue(valueText, isPercent, isNegative));
  const valueTextParts = valueText.split('.');
  const valueTextWithModifiedFloat = valueTextParts[0] + '.3' + valueTextParts[1].slice(1);
  const valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);
  const decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf('3') - 1;
  format = format.replace(/(\d)\D(\d)/g, '$1,$2');
  if (decimalSeparatorIndex >= 0) {
    format = format.slice(0, decimalSeparatorIndex) + '.' + format.slice(decimalSeparatorIndex + 1);
  }
  format = format.replace(/1+/, '1').replace(/1/g, '#');
  if (!isPercent) {
    format = format.replace(/%/g, '\'%\'');
  }
  return format;
}
function getFormat(formatter) {
  let valueText = '.';
  const isPercent = formatter(1).indexOf('100') >= 0;
  valueText = prepareValueText(valueText, formatter, isPercent, true);
  valueText = prepareValueText(valueText, formatter, isPercent, false);
  const positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);
  const negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);
  return negativeFormat === '-' + positiveFormat ? positiveFormat : positiveFormat + ';' + negativeFormat;
}

/***/ }),

/***/ 28109:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _extend = __webpack_require__(13306);
var _string = __webpack_require__(68752);
var _inflector = __webpack_require__(78008);
var _core = _interopRequireDefault(__webpack_require__(91331));
var _default_messages = __webpack_require__(18121);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const baseDictionary = (0, _extend.extend)(true, {}, _default_messages.defaultMessages);
const getDataByLocale = (localeData, locale) => {
  var _Object$entries$find;
  return localeData[locale] || (locale === null || locale === void 0 ? void 0 : locale.toLowerCase) && ((_Object$entries$find = Object.entries(localeData).find(_ref => {
    let [key] = _ref;
    return key.toLowerCase() === locale.toLowerCase();
  })) === null || _Object$entries$find === void 0 ? void 0 : _Object$entries$find[1]) || {};
};
const newMessages = {};
const messageLocalization = (0, _dependency_injector.default)({
  engine: function () {
    return 'base';
  },
  _dictionary: baseDictionary,
  load: function (messages) {
    (0, _extend.extend)(true, this._dictionary, messages);
  },
  _localizablePrefix: '@',
  setup: function (localizablePrefix) {
    this._localizablePrefix = localizablePrefix;
  },
  localizeString: function (text) {
    const that = this;
    const regex = new RegExp('(^|[^a-zA-Z_0-9' + that._localizablePrefix + '-]+)(' + that._localizablePrefix + '{1,2})([a-zA-Z_0-9-]+)', 'g');
    const escapeString = that._localizablePrefix + that._localizablePrefix;
    return text.replace(regex, (str, prefix, escape, localizationKey) => {
      const defaultResult = that._localizablePrefix + localizationKey;
      let result;
      if (escape !== escapeString) {
        result = that.format(localizationKey);
      }
      if (!result) {
        newMessages[localizationKey] = (0, _inflector.humanize)(localizationKey);
      }
      return prefix + (result || defaultResult);
    });
  },
  getMessagesByLocales: function () {
    return this._dictionary;
  },
  getDictionary: function (onlyNew) {
    if (onlyNew) {
      return newMessages;
    }
    return (0, _extend.extend)({}, newMessages, this.getMessagesByLocales()[_core.default.locale()]);
  },
  getFormatter: function (key) {
    return this._getFormatterBase(key) || this._getFormatterBase(key, 'en');
  },
  _getFormatterBase: function (key, locale) {
    const message = _core.default.getValueByClosestLocale(locale => getDataByLocale(this._dictionary, locale)[key]);
    if (message) {
      return function () {
        const args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        args.unshift(message);
        return _string.format.apply(this, args);
      };
    }
  },
  format: function (key) {
    const formatter = this.getFormatter(key);
    const values = Array.prototype.slice.call(arguments, 1);
    return formatter && formatter.apply(this, values) || '';
  }
});
var _default = exports["default"] = messageLocalization;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 18016:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _number = __webpack_require__(70629);
var _config = _interopRequireDefault(__webpack_require__(80209));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _utils = __webpack_require__(97360);
var _currency = _interopRequireDefault(__webpack_require__(89740));
var _number2 = _interopRequireDefault(__webpack_require__(38702));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const hasIntl = typeof Intl !== 'undefined';
const MAX_LARGE_NUMBER_POWER = 4;
const DECIMAL_BASE = 10;
const NUMERIC_FORMATS = ['currency', 'fixedpoint', 'exponential', 'percent', 'decimal'];
const LargeNumberFormatPostfixes = {
  1: 'K',
  // kilo
  2: 'M',
  // mega
  3: 'B',
  // billions
  4: 'T' // tera
};
const LargeNumberFormatPowers = {
  'largenumber': 'auto',
  'thousands': 1,
  'millions': 2,
  'billions': 3,
  'trillions': 4
};
const numberLocalization = (0, _dependency_injector.default)({
  engine: function () {
    return 'base';
  },
  numericFormats: NUMERIC_FORMATS,
  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
  _parseNumberFormatString: function (formatType) {
    const formatObject = {};
    if (!formatType || typeof formatType !== 'string') return;
    const formatList = formatType.toLowerCase().split(' ');
    (0, _iterator.each)(formatList, (index, value) => {
      if (NUMERIC_FORMATS.includes(value)) {
        formatObject.formatType = value;
      } else if (value in LargeNumberFormatPowers) {
        formatObject.power = LargeNumberFormatPowers[value];
      }
    });
    if (formatObject.power && !formatObject.formatType) {
      formatObject.formatType = 'fixedpoint';
    }
    if (formatObject.formatType) {
      return formatObject;
    }
  },
  _calculateNumberPower: function (value, base, minPower, maxPower) {
    let number = Math.abs(value);
    let power = 0;
    if (number > 1) {
      while (number && number >= base && (maxPower === undefined || power < maxPower)) {
        power++;
        number = number / base;
      }
    } else if (number > 0 && number < 1) {
      while (number < 1 && (minPower === undefined || power > minPower)) {
        power--;
        number = number * base;
      }
    }
    return power;
  },
  _getNumberByPower: function (number, power, base) {
    let result = number;
    while (power > 0) {
      result = result / base;
      power--;
    }
    while (power < 0) {
      result = result * base;
      power++;
    }
    return result;
  },
  _formatNumber: function (value, formatObject, formatConfig) {
    if (formatObject.power === 'auto') {
      formatObject.power = this._calculateNumberPower(value, 1000, 0, MAX_LARGE_NUMBER_POWER);
    }
    if (formatObject.power) {
      value = this._getNumberByPower(value, formatObject.power, 1000);
    }
    const powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || '';
    let result = this._formatNumberCore(value, formatObject.formatType, formatConfig);
    result = result.replace(/(\d|.$)(\D*)$/, '$1' + powerPostfix + '$2');
    return result;
  },
  _formatNumberExponential: function (value, formatConfig) {
    let power = this._calculateNumberPower(value, DECIMAL_BASE);
    let number = this._getNumberByPower(value, power, DECIMAL_BASE);
    if (formatConfig.precision === undefined) {
      formatConfig.precision = 1;
    }
    if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {
      power++;
      number = number / DECIMAL_BASE;
    }
    const powString = (power >= 0 ? '+' : '') + power.toString();
    return this._formatNumberCore(number, 'fixedpoint', formatConfig) + 'E' + powString;
  },
  _addZeroes: function (value, precision) {
    const multiplier = Math.pow(10, precision);
    const sign = value < 0 ? '-' : '';
    value = (Math.abs(value) * multiplier >>> 0) / multiplier;
    let result = value.toString();
    while (result.length < precision) {
      result = '0' + result;
    }
    return sign + result;
  },
  _addGroupSeparators: function (value) {
    const parts = value.toString().split('.');
    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, (0, _config.default)().thousandsSeparator) + (parts[1] ? (0, _config.default)().decimalSeparator + parts[1] : '');
  },
  _formatNumberCore: function (value, format, formatConfig) {
    if (format === 'exponential') {
      return this._formatNumberExponential(value, formatConfig);
    }
    if (format !== 'decimal' && formatConfig.precision !== null) {
      formatConfig.precision = formatConfig.precision || 0;
    }
    if (format === 'percent') {
      value = value * 100;
    }
    if (formatConfig.precision !== undefined) {
      if (format === 'decimal') {
        value = this._addZeroes(value, formatConfig.precision);
      } else {
        value = formatConfig.precision === null ? value.toPrecision() : (0, _utils.toFixed)(value, formatConfig.precision);
      }
    }
    if (format !== 'decimal') {
      value = this._addGroupSeparators(value);
    } else {
      value = value.toString().replace('.', (0, _config.default)().decimalSeparator);
    }
    if (format === 'percent') {
      value += '%';
    }
    return value;
  },
  _normalizeFormat: function (format) {
    if (!format) {
      return {};
    }
    if (typeof format === 'function') {
      return format;
    }
    if (!(0, _type.isPlainObject)(format)) {
      format = {
        type: format
      };
    }
    return format;
  },
  _getSeparators: function () {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function () {
    return this.format(10000, 'fixedPoint')[2];
  },
  getDecimalSeparator: function () {
    return this.format(1.2, {
      type: 'fixedPoint',
      precision: 1
    })[1];
  },
  convertDigits: function (value, toStandard) {
    const digits = this.format(90, 'decimal');
    if (typeof value !== 'string' || digits[1] === '0') {
      return value;
    }
    const fromFirstDigit = toStandard ? digits[1] : '0';
    const toFirstDigit = toStandard ? '0' : digits[1];
    const fromLastDigit = toStandard ? digits[0] : '9';
    const regExp = new RegExp('[' + fromFirstDigit + '-' + fromLastDigit + ']', 'g');
    return value.replace(regExp, char => {
      return String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0)));
    });
  },
  getNegativeEtalonRegExp: function (format) {
    const separators = this._getSeparators();
    const digitalRegExp = new RegExp('[0-9' + (0, _common.escapeRegExp)(separators.decimalSeparator + separators.thousandsSeparator) + ']+', 'g');
    const specialCharacters = ['\\', '(', ')', '[', ']', '*', '+', '$', '^', '?', '|', '{', '}'];
    let negativeEtalon = this.format(-1, format).replace(digitalRegExp, '1');
    specialCharacters.forEach(char => {
      negativeEtalon = negativeEtalon.replace(new RegExp(`\\${char}`, 'g'), `\\${char}`);
    });
    negativeEtalon = negativeEtalon.replace(/ /g, '\\s');
    negativeEtalon = negativeEtalon.replace(/1/g, '.*');
    return new RegExp(negativeEtalon, 'g');
  },
  getSign: function (text, format) {
    if (!format) {
      if (text.replace(/[^0-9-]/g, '').charAt(0) === '-') {
        return -1;
      }
      return 1;
    }
    const negativeEtalon = this.getNegativeEtalonRegExp(format);
    return text.match(negativeEtalon) ? -1 : 1;
  },
  format: function (value, format) {
    if (typeof value !== 'number') {
      return value;
    }
    if (typeof format === 'number') {
      return value;
    }
    format = format && format.formatter || format;
    if (typeof format === 'function') {
      return format(value);
    }
    format = this._normalizeFormat(format);
    if (!format.type) {
      format.type = 'decimal';
    }
    const numberConfig = this._parseNumberFormatString(format.type);
    if (!numberConfig) {
      const formatterConfig = this._getSeparators();
      formatterConfig.unlimitedIntegerDigits = format.unlimitedIntegerDigits;
      return this.convertDigits((0, _number.getFormatter)(format.type, formatterConfig)(value));
    }
    return this._formatNumber(value, numberConfig, format);
  },
  parse: function (text, format) {
    if (!text) {
      return;
    }
    if (format && format.parser) {
      return format.parser(text);
    }
    text = this.convertDigits(text, true);
    if (format && typeof format !== 'string') {
      // Current parser functionality provided as-is and is independent of the most of capabilities of formatter.
      _errors.default.log('W0011');
    }
    const decimalSeparator = this.getDecimalSeparator();
    const regExp = new RegExp('[^0-9' + (0, _common.escapeRegExp)(decimalSeparator) + ']', 'g');
    const cleanedText = text.replace(regExp, '').replace(decimalSeparator, '.').replace(/\.$/g, '');
    if (cleanedText === '.' || cleanedText === '') {
      return null;
    }
    if (this._calcSignificantDigits(cleanedText) > 15) {
      return NaN;
    }
    let parsed = +cleanedText * this.getSign(text, format);
    format = this._normalizeFormat(format);
    const formatConfig = this._parseNumberFormatString(format.type);
    let power = formatConfig === null || formatConfig === void 0 ? void 0 : formatConfig.power;
    if (power) {
      if (power === 'auto') {
        const match = text.match(/\d(K|M|B|T)/);
        if (match) {
          power = Object.keys(LargeNumberFormatPostfixes).find(power => {
            return LargeNumberFormatPostfixes[power] === match[1];
          });
        }
      }
      parsed = parsed * Math.pow(10, 3 * power);
    }
    if ((formatConfig === null || formatConfig === void 0 ? void 0 : formatConfig.formatType) === 'percent') {
      parsed /= 100;
    }
    return parsed;
  },
  _calcSignificantDigits: function (text) {
    const [integer, fractional] = text.split('.');
    const calcDigitsAfterLeadingZeros = digits => {
      let index = -1;
      for (let i = 0; i < digits.length; i++) {
        if (digits[i] !== '0') {
          index = i;
          break;
        }
      }
      return index > -1 ? digits.length - index : 0;
    };
    let result = 0;
    if (integer) {
      result += calcDigitsAfterLeadingZeros(integer.split(''));
    }
    if (fractional) {
      result += calcDigitsAfterLeadingZeros(fractional.split('').reverse());
    }
    return result;
  }
});
numberLocalization.inject(_currency.default);
if (hasIntl) {
  numberLocalization.inject(_number2.default);
}
var _default = exports["default"] = numberLocalization;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 44592:
/***/ (function(module, exports) {



exports["default"] = void 0;
var _default = (currencySymbol, accountingFormat) => {
  if (!accountingFormat) {
    return;
  }
  let encodedCurrencySymbol = currencySymbol;
  if (typeof currencySymbol === 'string') {
    encodedCurrencySymbol = '';
    for (let i = 0; i < currencySymbol.length; i++) {
      if (currencySymbol[i] !== '$') {
        encodedCurrencySymbol += '\\';
      }
      encodedCurrencySymbol += currencySymbol[i];
    }
  }
  const encodeSymbols = {
    '.00': '{0}',
    '\'': '\\\'',
    '\\(': '\\(',
    '\\)': '\\)',
    ' ': '\\ ',
    '"': '&quot;',
    '\\': encodedCurrencySymbol
  };
  const result = accountingFormat.split(';');
  for (let i = 0; i < result.length; i++) {
    for (const symbol in encodeSymbols) {
      if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
        result[i] = result[i].replace(new RegExp(symbol, 'g'), encodeSymbols[symbol]);
      }
    }
  }
  return result.length === 2 ? result[0] + '_);' + result[1] : result[0];
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 49198:
/***/ (function(module, exports) {



exports["default"] = void 0;
/* eslint-disable import/no-commonjs */
const PARENT_LOCALE_SEPARATOR = '-';
var _default = (parentLocales, locale) => {
  const parentLocale = parentLocales[locale];
  if (parentLocale) {
    return parentLocale !== 'root' && parentLocale;
  }
  return locale.substr(0, locale.lastIndexOf(PARENT_LOCALE_SEPARATOR));
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97360:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.toFixed = toFixed;
var _math = __webpack_require__(60810);
const DECIMAL_BASE = 10;
function roundByAbs(value) {
  const valueSign = (0, _math.sign)(value);
  return valueSign * Math.round(Math.abs(value));
}
function adjustValue(value, precision) {
  const precisionMultiplier = Math.pow(DECIMAL_BASE, precision);
  const intermediateValue = (0, _math.multiplyInExponentialForm)(value, precision);
  return roundByAbs(intermediateValue) / precisionMultiplier;
}
function toFixed(value, precision) {
  const valuePrecision = precision || 0;
  const adjustedValue = valuePrecision > 0 ? adjustValue(...arguments) : value;
  return adjustedValue.toFixed(valuePrecision);
}

/***/ }),

/***/ 4928:
/***/ (function(__unused_webpack_module, exports) {



exports.hideCallback = void 0;
const hideCallback = exports.hideCallback = function () {
  let callbacks = [];
  return {
    add: function (callback) {
      if (!callbacks.includes(callback)) {
        callbacks.push(callback);
      }
    },
    remove: function (callback) {
      const indexOfCallback = callbacks.indexOf(callback);
      if (indexOfCallback !== -1) {
        callbacks.splice(indexOfCallback, 1);
      }
    },
    fire: function () {
      const callback = callbacks.pop();
      const result = !!callback;
      if (result) {
        callback();
      }
      return result;
    },
    hasCallback: function () {
      return callbacks.length > 0;
    }
  };
}();

/***/ }),

/***/ 60628:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _hide_callback = __webpack_require__(4928);
function _default() {
  return _hide_callback.hideCallback.fire();
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 88185:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.p = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _extend = __webpack_require__(13306);
var _resize_callbacks = _interopRequireDefault(__webpack_require__(55814));
var _support = __webpack_require__(60137);
var _style = __webpack_require__(80968);
var _devices = _interopRequireDefault(__webpack_require__(20530));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const initMobileViewport = function (options) {
  options = (0, _extend.extend)({}, options);
  let realDevice = _devices.default.real();
  const allowZoom = options.allowZoom;
  const allowPan = options.allowPan;
  const allowSelection = 'allowSelection' in options ? options.allowSelection : realDevice.platform === 'generic';
  const metaSelector = 'meta[name=viewport]';
  if (!(0, _renderer.default)(metaSelector).length) {
    (0, _renderer.default)('<meta>').attr('name', 'viewport').appendTo('head');
  }
  const metaVerbs = ['width=device-width'];
  const msTouchVerbs = [];
  if (allowZoom) {
    msTouchVerbs.push('pinch-zoom');
  } else {
    metaVerbs.push('initial-scale=1.0', 'maximum-scale=1.0, user-scalable=no');
  }
  if (allowPan) {
    msTouchVerbs.push('pan-x', 'pan-y');
  }
  if (!allowPan && !allowZoom) {
    (0, _renderer.default)('html, body').css({
      'msContentZooming': 'none',
      'msUserSelect': 'none',
      'overflow': 'hidden'
    });
  } else {
    (0, _renderer.default)('html').css('msOverflowStyle', '-ms-autohiding-scrollbar');
  }
  if (!allowSelection && (0, _support.supportProp)('userSelect')) {
    (0, _renderer.default)('.dx-viewport').css((0, _style.styleProp)('userSelect'), 'none');
  }
  (0, _renderer.default)(metaSelector).attr('content', metaVerbs.join());
  (0, _renderer.default)('html').css('msTouchAction', msTouchVerbs.join(' ') || 'none');
  realDevice = _devices.default.real();
  if (_support.touch) {
    _events_engine.default.off(_dom_adapter.default.getDocument(), '.dxInitMobileViewport');
    _events_engine.default.on(_dom_adapter.default.getDocument(), 'dxpointermove.dxInitMobileViewport', function (e) {
      const count = e.pointers.length;
      const isTouchEvent = e.pointerType === 'touch';
      const zoomDisabled = !allowZoom && count > 1;
      const panDisabled = !allowPan && count === 1 && !e.isScrollingEvent;
      if (isTouchEvent && (zoomDisabled || panDisabled)) {
        e.preventDefault();
      }
    });
  }
  if (realDevice.ios) {
    const isPhoneGap = _dom_adapter.default.getLocation().protocol === 'file:';
    if (!isPhoneGap) {
      // NOTE: fix app size after device rotation in Safari when keyboard was shown
      _resize_callbacks.default.add(function () {
        const windowWidth = (0, _size.getWidth)(window);
        (0, _size.setWidth)((0, _renderer.default)('body'), windowWidth);
      });
    }
  }
  if (realDevice.android) {
    _resize_callbacks.default.add(function () {
      setTimeout(function () {
        const activeElement = _dom_adapter.default.getActiveElement();
        activeElement.scrollIntoViewIfNeeded ? activeElement.scrollIntoViewIfNeeded() : activeElement.scrollIntoView(false);
      });
    });
  }
};
exports.p = initMobileViewport;

/***/ }),

/***/ 44194:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "exportDataGrid", ({
  enumerable: true,
  get: function () {
    return _export_data_grid.exportDataGrid;
  }
}));
Object.defineProperty(exports, "exportDataGridWithAutoTable", ({
  enumerable: true,
  get: function () {
    return _export_data_grid2.exportDataGrid;
  }
}));
Object.defineProperty(exports, "exportGantt", ({
  enumerable: true,
  get: function () {
    return _export_gantt.exportGantt;
  }
}));
var _export_data_grid = __webpack_require__(654);
var _export_data_grid2 = __webpack_require__(83152);
var _export_gantt = __webpack_require__(29982);

/***/ }),

/***/ 27135:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _inferno = __webpack_require__(78089);
var _keyboard_processor = _interopRequireDefault(__webpack_require__(51661));
var _inferno_renderer = _interopRequireDefault(__webpack_require__(15334));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _extend = __webpack_require__(13306);
var _element = __webpack_require__(6415);
var _type = __webpack_require__(35922);
var _template_wrapper = __webpack_require__(93407);
var _update_props_immutable = __webpack_require__(36583);
__webpack_require__(95429);
__webpack_require__(91633);
__webpack_require__(24028);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const setDefaultOptionValue = (options, defaultValueGetter) => name => {
  if (Object.prototype.hasOwnProperty.call(options, name) && options[name] === undefined) {
    options[name] = defaultValueGetter(name);
  }
};
class ComponentWrapper extends _dom_component.default {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(element, options) {
    super(element, options);
    this._shouldRaiseContentReady = false;
    this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const supportedKeyNames = this.getSupportedKeyNames();
    const hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    const hasComponentKeyDownMethod = typeof this._viewComponent.prototype.keyDown === 'function';
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  }
  get viewRef() {
    var _this$_viewRef;
    return (_this$_viewRef = this._viewRef) === null || _this$_viewRef === void 0 ? void 0 : _this$_viewRef.current;
  }
  _checkContentReadyOption(fullName) {
    const contentReadyOptions = this._getContentReadyOptions().reduce((options, name) => {
      options[name] = true;
      return options;
    }, {});
    this._checkContentReadyOption = optionName => !!contentReadyOptions[optionName];
    return this._checkContentReadyOption(fullName);
  }
  _getContentReadyOptions() {
    return ['rtlEnabled'];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const viewDefaultProps = this._getViewComponentDefaultProps();
    return (0, _extend.extend)(true, super._getDefaultOptions(), viewDefaultProps, this._propsInfo.twoWay.reduce((options, _ref) => {
      let [name, defaultName, eventName] = _ref;
      return _extends({}, options, {
        [name]: viewDefaultProps[defaultName],
        [eventName]: value => this.option(name, value)
      });
    }, {}), this._propsInfo.templates.reduce((options, name) => _extends({}, options, {
      [name]: null
    }), {}));
  }
  _getUnwrappedOption() {
    const unwrappedProps = {};
    Object.keys(this.option()).forEach(key => {
      unwrappedProps[key] = this.option(key);
    });
    return unwrappedProps;
  }
  _initializeComponent() {
    var _this$_templateManage;
    super._initializeComponent();
    (_this$_templateManage = this._templateManager) === null || _this$_templateManage === void 0 || _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    const optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach(template => {
      this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
    });
    Object.keys(this._getActionConfigsFull()).forEach(name => this._addAction(name));
    this._viewRef = (0, _inferno.createRef)();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const props = this.getProps();
    this._renderWrapper(props);
  }
  _renderWrapper(props) {
    const containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      _inferno_renderer.default.onPreRender();
    }
    _inferno_renderer.default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      _inferno_renderer.default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  }
  _silent(name, value) {
    this._options.silent(name, value);
  }
  _render() {}
  _removeWidget() {
    _inferno_renderer.default.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget();
    super._dispose();
  }
  get elementAttr() {
    const element = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes
      } = element;
      const attrs = Array.from(attributes).filter(attr => {
        var _attributes$attr$name;
        return !this._propsInfo.templates.includes(attr.name) && ((_attributes$attr$name = attributes[attr.name]) === null || _attributes$attr$name === void 0 ? void 0 : _attributes$attr$name.specified);
      }).reduce((result, _ref2) => {
        let {
          name,
          value
        } = _ref2;
        const updatedAttributes = result;
        const isDomAttr = (name in element);
        updatedAttributes[name] = value === '' && isDomAttr ? element[name] : value;
        return updatedAttributes;
      }, {});
      this._elementAttr = attrs;
      this._storedClasses = element.getAttribute('class') || '';
    }
    const elemStyle = element.style;
    const style = {};
    for (let i = 0; i < elemStyle.length; i += 1) {
      style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
    }
    this._elementAttr.style = style;
    this._elementAttr.class = this._storedClasses;
    return this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ['disabled', 'readOnly']
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(options) {
    const {
      allowNull,
      elements,
      props,
      twoWay
    } = this._propsInfo;
    const viewDefaultProps = this._getViewComponentDefaultProps();
    const defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    const defaultOptions = this._getDefaultOptions();
    const {
      children,
      onKeyboardHandled,
      ref
    } = options;
    const onKeyDown = onKeyboardHandled ? (_, event_options) => {
      onKeyboardHandled(event_options);
    } : undefined;
    const widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [...props, ...this._getAdditionalProps()].forEach(propName => {
      if (Object.prototype.hasOwnProperty.call(options, propName)) {
        widgetProps[propName] = options[propName];
      }
    });
    allowNull.forEach(setDefaultOptionValue(widgetProps, () => null));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue(widgetProps, name => defaultOptions[name]));
    twoWay.forEach(_ref3 => {
      let [name, defaultName] = _ref3;
      setDefaultOptionValue(widgetProps, () => defaultOptions[defaultName])(name);
    });
    elements.forEach(name => {
      if (name in widgetProps) {
        const value = widgetProps[name];
        if ((0, _type.isRenderer)(value)) {
          widgetProps[name] = this._patchElementParam(value);
        }
      }
    });
    return widgetProps;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(props) {
    if (typeof props.style === 'string') {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  }
  getProps() {
    const {
      elementAttr
    } = this.option();
    const options = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach(template => {
      options[template] = this._componentTemplates[template];
    });
    return this.prepareStyleProp(_extends({}, options, this.elementAttr, elementAttr, {
      className: [...(this.elementAttr.class ?? '').split(' '), ...((elementAttr === null || elementAttr === void 0 ? void 0 : elementAttr.class) ?? '').split(' ')].filter((c, i, a) => c && a.indexOf(c) === i).join(' ').trim(),
      class: ''
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const defaultTemplates = Object.values(this._templatesInfo);
    const result = {};
    defaultTemplates.forEach(template => {
      result[template] = 'dx-renovation-template-mock';
    });
    return result;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(options) {
    const templateOptions = Object.entries(this._templatesInfo).reduce((result, _ref4) => {
      let [templateName, templateValue] = _ref4;
      return _extends({}, result, {
        [templateName]: options[templateName] ?? templateValue
      });
    }, {});
    return _extends({}, options, templateOptions);
  }
  _init() {
    super._init();
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const result = {};
    const keys = this.getSupportedKeyNames();
    keys.forEach(key => {
      result[key] = e => this.viewRef.keyDown(_keyboard_processor.default.createKeyDownOptions(e));
    });
    return result;
  }
  _addAction(event, actionToAdd) {
    let action = actionToAdd;
    if (!action) {
      const actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = actArgs => {
        Object.keys(actArgs).forEach(name => {
          if ((0, _type.isDefined)(actArgs[name]) && _dom_adapter.default.isNode(actArgs[name])) {
            actArgs[name] = (0, _element.getPublicElement)((0, _renderer.default)(actArgs[name]));
          }
        });
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  }
  _optionChanged(option) {
    const {
      fullName,
      name,
      previousValue,
      value
    } = option;
    (0, _update_props_immutable.updatePropsImmutable)(this._props, this.option(), name, fullName);
    if (this._propsInfo.templates.includes(name) && value !== previousValue) {
      this._componentTemplates[name] = this._createTemplateComponent(value);
    }
    if (name && this._getActionConfigsFull()[name]) {
      this._addAction(name);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    super._optionChanged(option);
    this._invalidate();
  }
  _extractDefaultSlot() {
    if (this.option('_hasAnonymousTemplateContent')) {
      return _inferno_renderer.default.createElement(_template_wrapper.TemplateWrapper, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  }
  _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return undefined;
    }
    const template = this._getTemplate(templateOption);
    if ((0, _type.isString)(template) && template === 'dx-renovation-template-mock') {
      return undefined;
    }
    const templateWrapper = model => _inferno_renderer.default.createElement(_template_wrapper.TemplateWrapper, (0, _template_wrapper.buildTemplateArgs)(model, template));
    return templateWrapper;
  }
  _wrapKeyDownHandler(initialHandler) {
    return options => {
      const {
        keyName,
        originalEvent,
        which
      } = options;
      const keys = this.customKeyHandlers;
      const func = keys[keyName] || keys[which];
      if (func !== undefined) {
        const handler = func.bind(this);
        const result = handler(originalEvent, options);
        if (!result) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return initialHandler === null || initialHandler === void 0 ? void 0 : initialHandler(originalEvent, options);
    };
  }
  _toPublicElement(element) {
    return (0, _element.getPublicElement)((0, _renderer.default)(element));
  }
  _patchElementParam(value) {
    try {
      const result = (0, _renderer.default)(value);
      const element = result === null || result === void 0 ? void 0 : result.get(0);
      return element !== null && element !== void 0 && element.nodeType ? element : value;
    } catch (error) {
      return value;
    }
  }
  repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  }
  _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  }
  setAria(name, value) {
    this._aria[name] = value;
    this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
}
exports["default"] = ComponentWrapper;
ComponentWrapper.IS_RENOVATED_WIDGET = false;
ComponentWrapper.IS_RENOVATED_WIDGET = true;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 93407:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.TemplateWrapper = void 0;
exports.buildTemplateArgs = buildTemplateArgs;
var _inferno = __webpack_require__(33791);
var _inferno2 = __webpack_require__(78089);
var _dom = __webpack_require__(3532);
var _shallow_equals = __webpack_require__(33502);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _element = __webpack_require__(6415);
var _type = __webpack_require__(35922);
const _excluded = ["isEqual"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function isDxElementWrapper(element) {
  return !!element.toArray;
}
function buildTemplateArgs(model, template) {
  const args = {
    template,
    model: _extends({}, model)
  };
  const _ref = model.data ?? {},
    {
      isEqual
    } = _ref,
    data = _objectWithoutPropertiesLoose(_ref, _excluded);
  if (isEqual) {
    args.model.data = data;
    args.isEqual = isEqual;
  }
  return args;
}
function renderTemplateContent(props, container) {
  const {
    data,
    index
  } = props.model ?? {
    data: {}
  };
  if (data) {
    Object.keys(data).forEach(name => {
      if (data[name] && _dom_adapter.default.isNode(data[name])) {
        data[name] = (0, _element.getPublicElement)((0, _renderer.default)(data[name]));
      }
    });
  }
  const rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data
  } : {}, !props.transclude && Number.isFinite(index) ? {
    index
  } : {}));
  if (rendered === undefined) {
    return [];
  }
  return isDxElementWrapper(rendered) ? rendered.toArray() : [(0, _renderer.default)(rendered).get(0)];
}
function removeDifferentElements(oldChildren, newChildren) {
  newChildren.forEach(newElement => {
    const hasOldChild = !!oldChildren.find(oldElement => newElement === oldElement);
    if (!hasOldChild && newElement.parentNode) {
      (0, _renderer.default)(newElement).remove();
    }
  });
}
class TemplateWrapper extends _inferno.InfernoComponent {
  constructor(props) {
    super(props);
    this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const node = (0, _inferno2.findDOMfromVNode)(this.$LI, true);
    if (!(node !== null && node !== void 0 && node.parentNode)) {
      return () => {};
    }
    const container = node.parentNode;
    const $container = (0, _renderer.default)(container);
    const $oldContainerContent = $container.contents().toArray();
    const content = renderTemplateContent(this.props, (0, _element.getPublicElement)($container));
    (0, _dom.replaceWith)((0, _renderer.default)(node), (0, _renderer.default)(content));
    return () => {
      const $actualContainerContent = (0, _renderer.default)(container).contents().toArray();
      removeDifferentElements($oldContainerContent, $actualContainerContent);
      container.appendChild(node);
    };
  }
  shouldComponentUpdate(nextProps) {
    const {
      model,
      template
    } = this.props;
    const {
      isEqual,
      model: nextModel,
      template: nextTemplate
    } = nextProps;
    const equalityComparer = isEqual ?? _shallow_equals.shallowEquals;
    if (template !== nextTemplate) {
      return true;
    }
    if (!(0, _type.isDefined)(model) || !(0, _type.isDefined)(nextModel)) {
      return model !== nextModel;
    }
    const {
      data,
      index
    } = model;
    const {
      data: nextData,
      index: nextIndex
    } = nextModel;
    if (index !== nextIndex) {
      return true;
    }
    return !equalityComparer(data, nextData);
  }
  createEffects() {
    return [new _inferno.InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {}
  render() {
    return null;
  }
}
exports.TemplateWrapper = TemplateWrapper;

/***/ }),

/***/ 36583:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.updatePropsImmutable = updatePropsImmutable;
var _type = __webpack_require__(35922);
var _data = __webpack_require__(47617);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function cloneObjectValue(value) {
  return Array.isArray(value) ? [...value] : _extends({}, value);
}
function cloneObjectProp(value, prevValue, fullNameParts) {
  const result = fullNameParts.length > 0 && prevValue && value !== prevValue ? cloneObjectValue(prevValue) : cloneObjectValue(value);
  const name = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result[name] = cloneObjectProp(value[name], prevValue === null || prevValue === void 0 ? void 0 : prevValue[name], fullNameParts.slice(1));
  } else if (name) {
    if ((0, _type.isPlainObject)(value[name])) {
      result[name] = cloneObjectValue(value[name]);
    } else {
      result[name] = value[name];
    }
  }
  return result;
}
function updatePropsImmutable(props, option, name, fullName) {
  const currentPropsValue = option[name];
  const prevPropsValue = props[name];
  const result = props;
  if ((0, _type.isPlainObject)(currentPropsValue) || name !== fullName && Array.isArray(currentPropsValue)) {
    result[name] = cloneObjectProp(currentPropsValue, prevPropsValue, (0, _data.getPathParts)(fullName).slice(1));
  } else {
    result[name] = currentPropsValue;
  }
}

/***/ }),

/***/ 25050:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _toMilliseconds = __webpack_require__(78503);
Object.keys(_toMilliseconds).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _toMilliseconds[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _toMilliseconds[key];
    }
  });
});

/***/ }),

/***/ 78503:
/***/ (function(__unused_webpack_module, exports) {



exports.toMilliseconds = toMilliseconds;
const timeIntervals = {
  millisecond: 1,
  second: 1000,
  minute: 1000 * 60,
  hour: 1000 * 60 * 60,
  day: 1000 * 60 * 60 * 24,
  week: 1000 * 60 * 60 * 24 * 7,
  month: 1000 * 60 * 60 * 24 * 30,
  quarter: 1000 * 60 * 60 * 24 * 30 * 3,
  year: 1000 * 60 * 60 * 24 * 365
};
function toMilliseconds(value) {
  return timeIntervals[value];
}

/***/ }),

/***/ 23842:
/***/ (function(__unused_webpack_module, exports) {



exports.VALIDATE_WHEEL_TIMEOUT = exports.TopPocketState = exports.ShowScrollbarMode = exports.SCROLL_LINE_HEIGHT = exports.SCROLLVIEW_TOP_POCKET_CLASS = exports.SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = exports.SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = exports.SCROLLVIEW_REACHBOTTOM_CLASS = exports.SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = exports.SCROLLVIEW_PULLDOWN_TEXT_CLASS = exports.SCROLLVIEW_PULLDOWN_READY_CLASS = exports.SCROLLVIEW_PULLDOWN_LOADING_CLASS = exports.SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = exports.SCROLLVIEW_PULLDOWN_IMAGE_CLASS = exports.SCROLLVIEW_PULLDOWN = exports.SCROLLVIEW_CONTENT_CLASS = exports.SCROLLVIEW_BOTTOM_POCKET_CLASS = exports.SCROLLABLE_WRAPPER_CLASS = exports.SCROLLABLE_SIMULATED_CLASS = exports.SCROLLABLE_SCROLL_CONTENT_CLASS = exports.SCROLLABLE_SCROLL_CLASS = exports.SCROLLABLE_SCROLLBAR_SIMULATED = exports.SCROLLABLE_SCROLLBAR_CLASS = exports.SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = exports.SCROLLABLE_SCROLLBARS_HIDDEN = exports.SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = exports.SCROLLABLE_DISABLED_CLASS = exports.SCROLLABLE_CONTENT_CLASS = exports.SCROLLABLE_CONTAINER_CLASS = exports.PULLDOWN_ICON_CLASS = exports.KEY_CODES = exports.HOVER_ENABLED_STATE = exports.HIDE_SCROLLBAR_TIMEOUT = exports.DIRECTION_VERTICAL = exports.DIRECTION_HORIZONTAL = exports.DIRECTION_BOTH = void 0;
const SCROLL_LINE_HEIGHT = exports.SCROLL_LINE_HEIGHT = 40;
const DIRECTION_VERTICAL = exports.DIRECTION_VERTICAL = 'vertical';
const DIRECTION_HORIZONTAL = exports.DIRECTION_HORIZONTAL = 'horizontal';
const DIRECTION_BOTH = exports.DIRECTION_BOTH = 'both';
const SCROLLABLE_SIMULATED_CLASS = exports.SCROLLABLE_SIMULATED_CLASS = 'dx-scrollable-simulated';
const SCROLLABLE_CONTENT_CLASS = exports.SCROLLABLE_CONTENT_CLASS = 'dx-scrollable-content';
const SCROLLABLE_WRAPPER_CLASS = exports.SCROLLABLE_WRAPPER_CLASS = 'dx-scrollable-wrapper';
const SCROLLABLE_CONTAINER_CLASS = exports.SCROLLABLE_CONTAINER_CLASS = 'dx-scrollable-container';
const SCROLLABLE_DISABLED_CLASS = exports.SCROLLABLE_DISABLED_CLASS = 'dx-scrollable-disabled';
const SCROLLABLE_SCROLLBAR_SIMULATED = exports.SCROLLABLE_SCROLLBAR_SIMULATED = 'dx-scrollable-scrollbar-simulated';
const SCROLLABLE_SCROLLBARS_HIDDEN = exports.SCROLLABLE_SCROLLBARS_HIDDEN = 'dx-scrollable-scrollbars-hidden';
const SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = exports.SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = 'dx-scrollable-scrollbars-alwaysvisible';
const SCROLLABLE_SCROLLBAR_CLASS = exports.SCROLLABLE_SCROLLBAR_CLASS = 'dx-scrollable-scrollbar';
const SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = exports.SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = 'dx-scrollable-scrollbar-active';
const SCROLLABLE_SCROLL_CLASS = exports.SCROLLABLE_SCROLL_CLASS = 'dx-scrollable-scroll';
const SCROLLABLE_SCROLL_CONTENT_CLASS = exports.SCROLLABLE_SCROLL_CONTENT_CLASS = 'dx-scrollable-scroll-content';
const HOVER_ENABLED_STATE = exports.HOVER_ENABLED_STATE = 'dx-scrollbar-hoverable';
const SCROLLVIEW_CONTENT_CLASS = exports.SCROLLVIEW_CONTENT_CLASS = 'dx-scrollview-content';
const SCROLLVIEW_TOP_POCKET_CLASS = exports.SCROLLVIEW_TOP_POCKET_CLASS = 'dx-scrollview-top-pocket';
const SCROLLVIEW_PULLDOWN = exports.SCROLLVIEW_PULLDOWN = 'dx-scrollview-pull-down';
const SCROLLVIEW_PULLDOWN_LOADING_CLASS = exports.SCROLLVIEW_PULLDOWN_LOADING_CLASS = 'dx-scrollview-pull-down-loading';
const SCROLLVIEW_PULLDOWN_READY_CLASS = exports.SCROLLVIEW_PULLDOWN_READY_CLASS = 'dx-scrollview-pull-down-ready';
const SCROLLVIEW_PULLDOWN_IMAGE_CLASS = exports.SCROLLVIEW_PULLDOWN_IMAGE_CLASS = 'dx-scrollview-pull-down-image';
const SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = exports.SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = 'dx-scrollview-pull-down-indicator';
const SCROLLVIEW_PULLDOWN_TEXT_CLASS = exports.SCROLLVIEW_PULLDOWN_TEXT_CLASS = 'dx-scrollview-pull-down-text';
const SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = exports.SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = 'dx-scrollview-pull-down-text-visible';
const PULLDOWN_ICON_CLASS = exports.PULLDOWN_ICON_CLASS = 'dx-icon-pulldown';
const SCROLLVIEW_BOTTOM_POCKET_CLASS = exports.SCROLLVIEW_BOTTOM_POCKET_CLASS = 'dx-scrollview-bottom-pocket';
const SCROLLVIEW_REACHBOTTOM_CLASS = exports.SCROLLVIEW_REACHBOTTOM_CLASS = 'dx-scrollview-scrollbottom';
const SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = exports.SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = 'dx-scrollview-scrollbottom-indicator';
const SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = exports.SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = 'dx-scrollview-scrollbottom-text';
const TopPocketState = exports.TopPocketState = {
  STATE_RELEASED: 0,
  STATE_READY: 1,
  STATE_REFRESHING: 2,
  STATE_LOADING: 3,
  STATE_TOUCHED: 4,
  STATE_PULLED: 5
};
const ShowScrollbarMode = exports.ShowScrollbarMode = {
  HOVER: 'onHover',
  ALWAYS: 'always',
  NEVER: 'never',
  SCROLL: 'onScroll'
};
const KEY_CODES = exports.KEY_CODES = {
  PAGE_UP: 'pageUp',
  PAGE_DOWN: 'pageDown',
  END: 'end',
  HOME: 'home',
  LEFT: 'leftArrow',
  UP: 'upArrow',
  RIGHT: 'rightArrow',
  DOWN: 'downArrow'
};
const VALIDATE_WHEEL_TIMEOUT = exports.VALIDATE_WHEEL_TIMEOUT = 500;
const HIDE_SCROLLBAR_TIMEOUT = exports.HIDE_SCROLLBAR_TIMEOUT = 500;

/***/ }),

/***/ 60650:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getElementLocationInternal = getElementLocationInternal;
var _inflector = __webpack_require__(78008);
var _get_relative_offset = __webpack_require__(1515);
var _consts = __webpack_require__(23842);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function getElementLocationInternal(targetElement, direction, containerElement, scrollOffset, offset) {
  const additionalOffset = _extends({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }, offset);
  const isVertical = direction === _consts.DIRECTION_VERTICAL;
  const prop = isVertical ? 'top' : 'left';
  const inverseProp = isVertical ? 'bottom' : 'right';
  const dimension = isVertical ? 'height' : 'width';
  const containerOffsetSize = containerElement[`offset${(0, _inflector.titleize)(dimension)}`];
  const containerClientSize = containerElement[`client${(0, _inflector.titleize)(dimension)}`];
  const containerSize = containerElement.getBoundingClientRect()[dimension];
  const elementSize = targetElement.getBoundingClientRect()[dimension];
  let scale = 1;
  if (Math.abs(containerSize - containerOffsetSize) > 1) {
    scale = containerSize / containerOffsetSize;
  }
  const relativeElementOffset = (0, _get_relative_offset.getRelativeOffset)(_consts.SCROLLABLE_CONTENT_CLASS, targetElement)[prop] / scale;
  const containerScrollOffset = scrollOffset[prop];
  const relativeStartOffset = containerScrollOffset - relativeElementOffset + additionalOffset[prop];
  const relativeEndOffset = containerScrollOffset - relativeElementOffset - elementSize / scale + containerClientSize - additionalOffset[inverseProp];
  if (relativeStartOffset <= 0 && relativeEndOffset >= 0) {
    return containerScrollOffset;
  }
  return containerScrollOffset - (Math.abs(relativeStartOffset) > Math.abs(relativeEndOffset) ? relativeEndOffset : relativeStartOffset);
}

/***/ }),

/***/ 1515:
/***/ (function(__unused_webpack_module, exports) {



exports.getRelativeOffset = getRelativeOffset;
function getRelativeOffset(targetElementClass, sourceElement) {
  const offset = {
    left: 0,
    top: 0
  };
  let element = sourceElement;
  while ((_element = element) !== null && _element !== void 0 && _element.offsetParent && !element.classList.contains(targetElementClass)) {
    var _element;
    const parentElement = element.offsetParent;
    const elementRect = element.getBoundingClientRect();
    const parentElementRect = parentElement.getBoundingClientRect();
    offset.left += elementRect.left - parentElementRect.left;
    offset.top += elementRect.top - parentElementRect.top;
    element = element.offsetParent;
  }
  return offset;
}

/***/ }),

/***/ 33502:
/***/ (function(__unused_webpack_module, exports) {



exports.shallowEquals = void 0;
const shallowEquals = (firstObject, secondObject) => {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.keys(firstObject).every(key => firstObject[key] === secondObject[key]);
};
exports.shallowEquals = shallowEquals;

/***/ }),

/***/ 88673:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Z = void 0;
var _m_utils_time_zone = _interopRequireDefault(__webpack_require__(57880));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const getTimeZones = exports.Z = _m_utils_time_zone.default.getTimeZones;

/***/ }),

/***/ 42160:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_draggable = _interopRequireDefault(__webpack_require__(86988));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_draggable.default;
/**
 * @section Utils
 * @default null
 * @name dxDraggableOptions.onDrop
 * @type function(e)
 * @type_function_param1 e:object
 * @type_function_param1_field1 component:this
 * @type_function_param1_field2 element:DxElement
 * @type_function_param1_field3 model:object
 * @type_function_param1_field4 event:event
 * @type_function_param1_field5 itemData:any
 * @type_function_param1_field6 itemElement:DxElement
 * @type_function_param1_field7 fromComponent:dxSortable|dxDraggable
 * @type_function_param1_field8 toComponent:dxSortable|dxDraggable
 * @type_function_param1_field9 fromData:any
 * @type_function_param1_field10 toData:any
 * @action
 * @hidden
 */
/**
 * @name DraggableBaseOptions.contentTemplate
 * @type template|function
 * @type_function_return string|Element|jQuery
 * @hidden
 * @default "content"
 */
/**
 * @name dxDraggableOptions.filter
 * @type string
 * @default ""
 * @hidden
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 96452:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_editor = _interopRequireDefault(__webpack_require__(50843));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_editor.default;
/**
 * @name EditorOptions.name
 * @type string
 * @default ""
 * @hidden
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 2492:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_load_indicator = _interopRequireDefault(__webpack_require__(94742));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_load_indicator.default; // STYLE loadIndicator
/**
 * @name dxLoadIndicatorOptions.disabled
 * @hidden
 */
/**
 * @name dxLoadIndicatorOptions.activeStateEnabled
 * @hidden
 */
/**
 * @name dxLoadIndicatorOptions.hoverStateEnabled
 * @default false
 * @hidden
 */
/**
 * @name dxLoadIndicatorOptions.focusStateEnabled
 * @hidden
 */
/**
 * @name dxLoadIndicatorOptions.accessKey
 * @hidden
 */
/**
 * @name dxLoadIndicatorOptions.tabIndex
 * @hidden
 */
/**
 * @name dxLoadIndicator.registerKeyHandler
 * @publicName registerKeyHandler(key, handler)
 * @hidden
 */
/**
 * @name dxLoadIndicator.focus
 * @publicName focus()
 * @hidden
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97218:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_load_panel = _interopRequireDefault(__webpack_require__(70395));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_load_panel.default; // STYLE loadPanel
/**
 * @name dxLoadPanelOptions.disabled
 * @hidden
 */
/**
 * @name dxLoadPanelOptions.contentTemplate
 * @type template
 * @hidden
 */
/**
 * @name dxLoadPanelOptions.accessKey
 * @hidden
 */
/**
 * @name dxLoadPanelOptions.tabIndex
 * @hidden
 */
/**
 * @name dxLoadPanel.registerKeyHandler
 * @publicName registerKeyHandler(key, handler)
 * @hidden
 */
/**
 * @name dxLoadPanel.focus
 * @publicName focus()
 * @hidden
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 89799:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_overlay = _interopRequireDefault(__webpack_require__(46356));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_overlay.default;
/**
 * @name dxOverlayOptions.activeStateEnabled
 * @hidden
 */
/**
 * @name ui.dxOverlay
 * @section utils
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 4741:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_scroll_view = _interopRequireDefault(__webpack_require__(79521));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_scroll_view.default; // STYLE scrollView
/**
 * @name dxScrollView.toggleLoading
 * @publicName toggleLoading(showOrHide)
 * @param1 showOrHide:boolean
 * @hidden
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 18740:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
const DEFAULT_DATE_INTERVAL = ['year', 'month', 'day'];
const DEFAULT_DATETIME_INTERVAL = ['year', 'month', 'day', 'hour', 'minute'];
const isDateType = function (dataType) {
  return dataType === 'date' || dataType === 'datetime';
};
const getGroupInterval = function (column) {
  let index;
  let result = [];
  const dateIntervals = ['year', 'month', 'day', 'hour', 'minute', 'second'];
  const groupInterval = column.headerFilter && column.headerFilter.groupInterval;
  const interval = groupInterval === 'quarter' ? 'month' : groupInterval;
  if (isDateType(column.dataType) && groupInterval !== null) {
    result = column.dataType === 'datetime' ? DEFAULT_DATETIME_INTERVAL : DEFAULT_DATE_INTERVAL;
    index = dateIntervals.indexOf(interval);
    if (index >= 0) {
      result = dateIntervals.slice(0, index);
      result.push(groupInterval);
      return result;
    }
    return result;
  } else if ((0, _type.isDefined)(groupInterval)) {
    return Array.isArray(groupInterval) ? groupInterval : [groupInterval];
  }
};
var _default = exports["default"] = function () {
  const getFilterSelector = function (column, target) {
    let selector = column.dataField || column.selector;
    if (target === 'search') {
      selector = column.displayField || column.calculateDisplayValue || selector;
    }
    return selector;
  };
  const isZeroTime = function (date) {
    return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1;
  };
  const getDateValues = function (dateValue) {
    if ((0, _type.isDate)(dateValue)) {
      return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()];
    }
    return (0, _iterator.map)(('' + dateValue).split('/'), function (value, index) {
      return index === 1 ? Number(value) - 1 : Number(value);
    });
  };
  const getFilterExpressionByRange = function (filterValue, target) {
    const column = this;
    let endFilterValue;
    let startFilterExpression;
    let endFilterExpression;
    const selector = getFilterSelector(column, target);
    if (Array.isArray(filterValue) && (0, _type.isDefined)(filterValue[0]) && (0, _type.isDefined)(filterValue[1])) {
      startFilterExpression = [selector, '>=', filterValue[0]];
      endFilterExpression = [selector, '<=', filterValue[1]];
      if (isDateType(column.dataType) && isZeroTime(filterValue[1])) {
        endFilterValue = new Date(filterValue[1].getTime());
        if (column.dataType === 'date') {
          endFilterValue.setDate(filterValue[1].getDate() + 1);
        }
        endFilterExpression = [selector, '<', endFilterValue];
      }
      return [startFilterExpression, 'and', endFilterExpression];
    }
  };
  const getFilterExpressionForDate = function (filterValue, selectedFilterOperation, target) {
    const column = this;
    let dateStart;
    let dateEnd;
    let dateInterval;
    const values = getDateValues(filterValue);
    const selector = getFilterSelector(column, target);
    if (target === 'headerFilter') {
      dateInterval = getGroupInterval(column)[values.length - 1];
    } else if (column.dataType === 'datetime') {
      dateInterval = 'minute';
    }
    switch (dateInterval) {
      case 'year':
        dateStart = new Date(values[0], 0, 1);
        dateEnd = new Date(values[0] + 1, 0, 1);
        break;
      case 'month':
        dateStart = new Date(values[0], values[1], 1);
        dateEnd = new Date(values[0], values[1] + 1, 1);
        break;
      case 'quarter':
        dateStart = new Date(values[0], 3 * values[1], 1);
        dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
        break;
      case 'hour':
        dateStart = new Date(values[0], values[1], values[2], values[3]);
        dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
        break;
      case 'minute':
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
        break;
      case 'second':
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
        break;
      default:
        dateStart = new Date(values[0], values[1], values[2]);
        dateEnd = new Date(values[0], values[1], values[2] + 1);
    }
    switch (selectedFilterOperation) {
      case '<':
        return [selector, '<', dateStart];
      case '<=':
        return [selector, '<', dateEnd];
      case '>':
        return [selector, '>=', dateEnd];
      case '>=':
        return [selector, '>=', dateStart];
      case '<>':
        return [[selector, '<', dateStart], 'or', [selector, '>=', dateEnd]];
      default:
        return [[selector, '>=', dateStart], 'and', [selector, '<', dateEnd]];
    }
  };
  const getFilterExpressionForNumber = function (filterValue, selectedFilterOperation, target) {
    const column = this;
    const selector = getFilterSelector(column, target);
    const groupInterval = getGroupInterval(column);
    if (target === 'headerFilter' && groupInterval && (0, _type.isDefined)(filterValue)) {
      const values = ('' + filterValue).split('/');
      const value = Number(values[values.length - 1]);
      const interval = groupInterval[values.length - 1];
      const startFilterValue = [selector, '>=', value];
      const endFilterValue = [selector, '<', value + interval];
      const condition = [startFilterValue, 'and', endFilterValue];
      return condition;
    }
    return [selector, selectedFilterOperation || '=', filterValue];
  };
  return {
    defaultCalculateFilterExpression: function (filterValue, selectedFilterOperation, target) {
      const column = this;
      const selector = getFilterSelector(column, target);
      const isSearchByDisplayValue = column.calculateDisplayValue && target === 'search';
      const dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType;
      let filter = null;
      if ((target === 'headerFilter' || target === 'filterBuilder') && filterValue === null) {
        filter = [selector, selectedFilterOperation || '=', null];
        if (dataType === 'string') {
          filter = [filter, selectedFilterOperation === '=' ? 'or' : 'and', [selector, selectedFilterOperation || '=', '']];
        }
      } else if (dataType === 'string' && (!column.lookup || isSearchByDisplayValue)) {
        filter = [selector, selectedFilterOperation || 'contains', filterValue];
      } else if (selectedFilterOperation === 'between') {
        return getFilterExpressionByRange.apply(column, [filterValue, target]);
      } else if (isDateType(dataType) && (0, _type.isDefined)(filterValue)) {
        return getFilterExpressionForDate.apply(column, arguments);
      } else if (dataType === 'number') {
        return getFilterExpressionForNumber.apply(column, arguments);
      } else {
        filter = [selector, selectedFilterOperation || '=', filterValue];
      }
      return filter;
    },
    getGroupInterval: getGroupInterval
  };
}();
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 75811:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.attachCssClasses = attachCssClasses;
exports.current = current;
exports["default"] = void 0;
exports.detachCssClasses = detachCssClasses;
exports.init = init;
exports.initialized = initialized;
exports.isCompact = isCompact;
exports.isDark = isDark;
exports.isFluent = isFluent;
exports.isGeneric = isGeneric;
exports.isMaterial = isMaterial;
exports.isMaterialBased = isMaterialBased;
exports.isPendingThemeLoaded = isPendingThemeLoaded;
exports.isWebFontLoaded = isWebFontLoaded;
exports.ready = themeReady;
exports.resetTheme = resetTheme;
exports.setDefaultTimeout = setDefaultTimeout;
exports.waitForThemeLoad = waitForThemeLoad;
exports.waitWebFont = waitWebFont;
var _size = __webpack_require__(58664);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _deferred = __webpack_require__(62754);
var _html_parser = __webpack_require__(61371);
var _iterator = __webpack_require__(95479);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _view_port = __webpack_require__(77695);
var _window = __webpack_require__(58201);
var _themes_callback = __webpack_require__(89729);
var _ui = _interopRequireDefault(__webpack_require__(96688));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const ready = _ready_callbacks.default.add;
const viewPort = _view_port.value;
const viewPortChanged = _view_port.changeCallback;
let initDeferred = new _deferred.Deferred();
const DX_LINK_SELECTOR = 'link[rel=dx-theme]';
const THEME_ATTR = 'data-theme';
const ACTIVE_ATTR = 'data-active';
const DX_HAIRLINES_CLASS = 'dx-hairlines';
const ANY_THEME = 'any';
let context;
let $activeThemeLink;
let knownThemes;
let currentThemeName;
let pendingThemeName;
let defaultTimeout = 15000;
const THEME_MARKER_PREFIX = 'dx.';
function readThemeMarker() {
  if (!(0, _window.hasWindow)()) {
    return null;
  }
  const element = (0, _renderer.default)('<div>', context).addClass('dx-theme-marker').appendTo(context.documentElement);
  let result;
  try {
    result = window.getComputedStyle(element.get(0))['fontFamily'];
    if (!result) {
      return null;
    }
    result = result.replace(/["']/g, '');
    if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
      return null;
    }
    return result.substr(THEME_MARKER_PREFIX.length);
  } finally {
    element.remove();
  }
}

// FYI
// http://stackoverflow.com/q/2635814
// http://stackoverflow.com/a/3078636
function waitForThemeLoad(themeName) {
  let waitStartTime;
  let timerId;
  let intervalCleared = true;
  pendingThemeName = themeName;
  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;
    _themes_callback.themeReadyCallback.fire();
    _themes_callback.themeReadyCallback.empty();
    initDeferred.resolve();
  }
  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }
      return;
    }
    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function () {
      const isLoaded = isPendingThemeLoaded();
      const isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;
      if (isTimeout) {
        _ui.default.log('W0004', pendingThemeName);
      }
      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}
function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }
  const anyThemePending = pendingThemeName === ANY_THEME;
  if (initDeferred.state() === 'resolved' && anyThemePending) {
    return true;
  }
  const themeMarker = readThemeMarker();
  if (themeMarker && anyThemePending) {
    return true;
  }
  return themeMarker === pendingThemeName;
}
function processMarkup() {
  const $allThemeLinks = (0, _renderer.default)(DX_LINK_SELECTOR, context);
  if (!$allThemeLinks.length) {
    return;
  }
  knownThemes = {};
  $activeThemeLink = (0, _renderer.default)((0, _html_parser.parseHTML)('<link rel=stylesheet>'), context);
  $allThemeLinks.each(function () {
    const link = (0, _renderer.default)(this, context);
    const fullThemeName = link.attr(THEME_ATTR);
    const url = link.attr('href');
    const isActive = link.attr(ACTIVE_ATTR) === 'true';
    knownThemes[fullThemeName] = {
      url: url,
      isActive: isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}
function resolveFullThemeName(desiredThemeName) {
  const desiredThemeParts = desiredThemeName ? desiredThemeName.split('.') : [];
  let result = null;
  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }
    (0, _iterator.each)(knownThemes, function (knownThemeName, themeData) {
      const knownThemeParts = knownThemeName.split('.');
      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }
      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }
      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }
      if (!result || themeData.isActive) {
        result = knownThemeName;
      }
      if (themeData.isActive) {
        return false;
      }
    });
  }
  return result;
}
function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    // Cross-origin permission error
    knownThemes = null;
  }
  context = newContext;
}
function init(options) {
  options = options || {};
  initContext(options.context || _dom_adapter.default.getDocument());
  if (!context) return;
  processMarkup();
  currentThemeName = undefined;
  current(options);
}
function current(options) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }
  detachCssClasses(viewPort());
  options = options || {};
  if (typeof options === 'string') {
    options = {
      theme: options
    };
  }
  const isAutoInit = options._autoInit;
  const loadCallback = options.loadCallback;
  let currentThemeData;
  currentThemeName = resolveFullThemeName(options.theme || currentThemeName);
  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }
  if (loadCallback) {
    _themes_callback.themeReadyCallback.add(loadCallback);
  }
  if (currentThemeData) {
    $activeThemeLink.attr('href', knownThemes[currentThemeName].url);
    if (_themes_callback.themeReadyCallback.has() || initDeferred.state() !== 'resolved' || options._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else {
    if (isAutoInit) {
      if ((0, _window.hasWindow)()) {
        waitForThemeLoad(ANY_THEME);
      }
      _themes_callback.themeReadyCallback.fire();
      _themes_callback.themeReadyCallback.empty();
    } else {
      throw _ui.default.Error('E0021', currentThemeName);
    }
  }
  initDeferred.done(() => attachCssClasses((0, _view_port.originalViewPort)(), currentThemeName));
}
function getCssClasses(themeName) {
  themeName = themeName || current();
  const result = [];
  const themeNameParts = themeName && themeName.split('.');
  if (themeNameParts) {
    result.push('dx-theme-' + themeNameParts[0], 'dx-theme-' + themeNameParts[0] + '-typography');
    if (themeNameParts.length > 1) {
      result.push('dx-color-scheme-' + themeNameParts[1] + (isMaterialBased(themeName) ? '-' + themeNameParts[2] : ''));
    }
  }
  return result;
}
let themeClasses;
function attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(' ');
  (0, _renderer.default)(element).addClass(themeClasses);
  const activateHairlines = function () {
    const pixelRatio = (0, _window.hasWindow)() && window.devicePixelRatio;
    if (!pixelRatio || pixelRatio < 2) {
      return;
    }
    const $tester = (0, _renderer.default)('<div>');
    $tester.css('border', '.5px solid transparent');
    (0, _renderer.default)('body').append($tester);
    if ((0, _size.getOuterHeight)($tester) === 1) {
      (0, _renderer.default)(element).addClass(DX_HAIRLINES_CLASS);
      themeClasses += ' ' + DX_HAIRLINES_CLASS;
    }
    $tester.remove();
  };
  activateHairlines();
}
function detachCssClasses(element) {
  (0, _renderer.default)(element).removeClass(themeClasses);
}
function themeReady(callback) {
  _themes_callback.themeReadyCallback.add(callback);
}
function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }
  return new RegExp(themeRegExp).test(themeName);
}
function isMaterialBased(themeName) {
  return isMaterial(themeName) || isFluent(themeName);
}
function isMaterial(themeName) {
  return isTheme('material', themeName);
}
function isFluent(themeName) {
  return isTheme('fluent', themeName);
}
function isGeneric(themeName) {
  return isTheme('generic', themeName);
}
function isDark(themeName) {
  return isTheme('dark', themeName);
}
function isCompact(themeName) {
  return isTheme('compact', themeName);
}
function isWebFontLoaded(text, fontWeight) {
  const testedFont = 'Roboto, RobotoFallback, Arial';
  const etalonFont = 'Arial';
  const document = _dom_adapter.default.getDocument();
  const testElement = document.createElement('span');
  testElement.style.position = 'absolute';
  testElement.style.top = '-9999px';
  testElement.style.left = '-9999px';
  testElement.style.visibility = 'hidden';
  testElement.style.fontFamily = etalonFont;
  testElement.style.fontSize = '250px';
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document.body.appendChild(testElement);
  const etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = testedFont;
  const testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}
function waitWebFont(text, fontWeight) {
  const interval = 15;
  const timeout = 2000;
  return new Promise(resolve => {
    const check = () => {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    };
    const clear = () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };
    const intervalId = setInterval(check, interval);
    const timeoutId = setTimeout(clear, timeout);
  });
}
function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });
  if ((0, _renderer.default)(DX_LINK_SELECTOR, context).length) {
    throw _ui.default.Error('E0022');
  }
}
if ((0, _window.hasWindow)()) {
  autoInit();
} else {
  ready(autoInit);
}
viewPortChanged.add(function (viewPort, prevViewPort) {
  initDeferred.done(function () {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort);
  });
});
_devices.default.changed.add(function () {
  init({
    _autoInit: true
  });
});
function resetTheme() {
  $activeThemeLink && $activeThemeLink.attr('href', 'about:blank');
  currentThemeName = null;
  pendingThemeName = null;
  initDeferred = new _deferred.Deferred();
}
function initialized(callback) {
  initDeferred.done(callback);
}
function setDefaultTimeout(timeout) {
  defaultTimeout = timeout;
}

/**
 * Added default export according to our documentation
 * https://js.devexpress.com/Documentation/ApiReference/Common/Utils/ui/themes/
 * */
var _default = exports["default"] = {
  setDefaultTimeout,
  initialized,
  resetTheme,
  ready: themeReady,
  waitWebFont,
  isWebFontLoaded,
  isCompact,
  isDark,
  isGeneric,
  isMaterial,
  isFluent,
  isMaterialBased,
  detachCssClasses,
  attachCssClasses,
  current,
  waitForThemeLoad,
  isPendingThemeLoaded
};

/***/ }),

/***/ 89729:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.themeReadyCallback = void 0;
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const themeReadyCallback = exports.themeReadyCallback = (0, _callbacks.default)();

/***/ }),

/***/ 90964:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_validation_engine = _interopRequireDefault(__webpack_require__(23661));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_validation_engine.default; // STYLE validation
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 8336:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_validation_message = _interopRequireDefault(__webpack_require__(47111));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_validation_message.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 31421:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.tabbable = exports.focused = exports.focusable = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const focusableFn = function (element, tabIndex) {
  if (!visible(element)) {
    return false;
  }
  const nodeName = element.nodeName.toLowerCase();
  const isTabIndexNotNaN = !isNaN(tabIndex);
  const isDisabled = element.disabled;
  const isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
  const isHyperlink = nodeName === 'a';
  let isFocusable;
  const isContentEditable = element.isContentEditable;
  if (isDefaultFocus || isContentEditable) {
    isFocusable = !isDisabled;
  } else {
    if (isHyperlink) {
      isFocusable = element.href || isTabIndexNotNaN;
    } else {
      isFocusable = isTabIndexNotNaN;
    }
  }
  return isFocusable;
};
function visible(element) {
  const $element = (0, _renderer.default)(element);
  return $element.is(':visible') && $element.css('visibility') !== 'hidden' && $element.parents().css('visibility') !== 'hidden';
}
const focusable = function (index, element) {
  return focusableFn(element, (0, _renderer.default)(element).attr('tabIndex'));
};
exports.focusable = focusable;
const tabbable = function (index, element) {
  const tabIndex = (0, _renderer.default)(element).attr('tabIndex');
  return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
};
// note: use this method instead of is(":focus")
exports.tabbable = tabbable;
const focused = function ($element) {
  const element = (0, _renderer.default)($element).get(0);
  return _dom_adapter.default.getActiveElement(element) === element;
};
exports.focused = focused;

/***/ }),

/***/ 92591:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _view_port = __webpack_require__(77695);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SWATCH_CONTAINER_CLASS_PREFIX = 'dx-swatch-';
const getSwatchContainer = element => {
  const $element = (0, _renderer.default)(element);
  const swatchContainer = $element.closest(`[class^="${SWATCH_CONTAINER_CLASS_PREFIX}"], [class*=" ${SWATCH_CONTAINER_CLASS_PREFIX}"]`);
  const viewport = (0, _view_port.value)();
  if (!swatchContainer.length) return viewport;
  const swatchClassRegex = new RegExp(`(\\s|^)(${SWATCH_CONTAINER_CLASS_PREFIX}.*?)(\\s|$)`);
  const swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
  let viewportSwatchContainer = viewport.children('.' + swatchClass);
  if (!viewportSwatchContainer.length) {
    viewportSwatchContainer = (0, _renderer.default)('<div>').addClass(swatchClass).appendTo(viewport);
  }
  return viewportSwatchContainer;
};
var _default = exports["default"] = {
  getSwatchContainer: getSwatchContainer
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 96688:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _error = _interopRequireDefault(__webpack_require__(95640));
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
* @docid
* @name ErrorsUIWidgets
*/
var _default = exports["default"] = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  /**
  * @name ErrorsUIWidgets.E1001
  */
  E1001: 'Module \'{0}\'. Controller \'{1}\' is already registered',
  /**
  * @name ErrorsUIWidgets.E1002
  */
  E1002: 'Module \'{0}\'. Controller \'{1}\' does not inherit from DevExpress.ui.dxDataGrid.Controller',
  /**
  * @name ErrorsUIWidgets.E1003
  */
  E1003: 'Module \'{0}\'. View \'{1}\' is already registered',
  /**
  * @name ErrorsUIWidgets.E1004
  */
  E1004: 'Module \'{0}\'. View \'{1}\' does not inherit from DevExpress.ui.dxDataGrid.View',
  /**
  * @name ErrorsUIWidgets.E1005
  */
  E1005: 'Public method \'{0}\' is already registered',
  /**
  * @name ErrorsUIWidgets.E1006
  */
  E1006: 'Public method \'{0}.{1}\' does not exist',
  /**
  * @name ErrorsUIWidgets.E1007
  */
  E1007: 'State storing cannot be provided due to the restrictions of the browser',
  /**
  * @name ErrorsUIWidgets.E1010
  */
  E1010: 'The template does not contain the TextBox widget',
  /**
  * @name ErrorsUIWidgets.E1011
  */
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
  /**
  * @name ErrorsUIWidgets.E1012
  */
  E1012: 'Editing type \'{0}\' with the name \'{1}\' is unsupported',
  /**
  * @name ErrorsUIWidgets.E1016
  */
  E1016: 'Unexpected type of data source is provided for a lookup column',
  /**
  * @name ErrorsUIWidgets.E1018
  */
  E1018: 'The \'collapseAll\' method cannot be called if you use a remote data source',
  /**
  * @name ErrorsUIWidgets.E1019
  */
  E1019: 'Search mode \'{0}\' is unavailable',
  /**
  * @name ErrorsUIWidgets.E1020
  */
  E1020: 'The type cannot be changed after initialization',
  /**
  * @name ErrorsUIWidgets.E1021
  */
  E1021: '{0} \'{1}\' you are trying to remove does not exist',
  /**
  * @name ErrorsUIWidgets.E1022
  */
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',
  /**
  * @name ErrorsUIWidgets.E1023
  */
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',
  /**
  * @name ErrorsUIWidgets.E1025
  */
  E1025: 'This layout is too complex to render',
  /**
  * @name ErrorsUIWidgets.E1026
  */
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
  /**
  * @name ErrorsUIWidgets.E1031
  */
  E1031: 'Unknown subscription in the Scheduler widget: \'{0}\'',
  /**
  * @name ErrorsUIWidgets.E1032
  */
  E1032: 'Unknown start date in an appointment: \'{0}\'',
  /**
  * @name ErrorsUIWidgets.E1033
  */
  E1033: 'Unknown step in the date navigator: \'{0}\'',
  /**
  * @name ErrorsUIWidgets.E1034
  */
  E1034: 'The browser does not implement an API for saving files',
  /**
   * @name ErrorsUIWidgets.E1035
   */
  E1035: 'The editor cannot be created: {0}',
  /**
   * @name ErrorsUIWidgets.E1037
   */
  E1037: 'Invalid structure of grouped data',
  /**
   * @name ErrorsUIWidgets.E1038
   */
  E1038: 'The browser does not support local storages for local web pages',
  /**
  * @name ErrorsUIWidgets.E1039
  */
  E1039: 'A cell\'s position cannot be calculated',
  /**
   * @name ErrorsUIWidgets.E1040
   */
  E1040: 'The \'{0}\' key value is not unique within the data array',
  /**
   * @name ErrorsUIWidgets.E1041
   */
  E1041: 'The \'{0}\' script is referenced after the DevExtreme scripts or not referenced at all',
  /**
  * @name ErrorsUIWidgets.E1042
  */
  E1042: '{0} requires the key field to be specified',
  /**
  * @name ErrorsUIWidgets.E1043
  */
  E1043: 'Changes cannot be processed due to the incorrectly set key',
  /**
  * @name ErrorsUIWidgets.E1044
  */
  E1044: 'The key field specified by the keyExpr option does not match the key field specified in the data store',
  /**
  * @name ErrorsUIWidgets.E1045
  */
  E1045: 'Editing requires the key field to be specified in the data store',
  /**
  * @name ErrorsUIWidgets.E1046
  */
  E1046: 'The \'{0}\' key field is not found in data objects',
  /**
  * @name ErrorsUIWidgets.E1047
  */
  E1047: 'The "{0}" field is not found in the fields array',
  /**
  * @name ErrorsUIWidgets.E1048
  */
  E1048: 'The "{0}" operation is not found in the filterOperations array',
  /**
  * @name ErrorsUIWidgets.E1049
  */
  E1049: 'Column \'{0}\': filtering is allowed but the \'dataField\' or \'name\' option is not specified',
  /**
  * @name ErrorsUIWidgets.E1050
  */
  E1050: 'The validationRules option does not apply to third-party editors defined in the editCellTemplate',
  /**
   * @name ErrorsUIWidgets.E1051
   */
  E1051: 'HtmlEditor\'s valueType is "{0}", but the {0} converter was not imported.',
  /**
  * @name ErrorsUIWidgets.E1052
  */
  E1052: '{0} should have the "dataSource" option specified',
  /**
  * @name ErrorsUIWidgets.E1053
  */
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',
  /**
  * @name ErrorsUIWidgets.E1054
  */
  E1054: 'All text editor buttons must have names',
  /**
  * @name ErrorsUIWidgets.E1055
  */
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
  /**
  * @name ErrorsUIWidgets.E1056
  */
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  // NOTE:
  // E1057 is reserved. See https://js.devexpress.com/Documentation/19_2/ApiReference/UI_Widgets/Errors_and_Warnings/#E1057

  /**
  * @name ErrorsUIWidgets.E1058
  */
  E1058: 'The "startDayHour" and "endDayHour" options must be integers in the [0, 24] range, with "endDayHour" being greater than "startDayHour".',
  /**
  * @name ErrorsUIWidgets.E1059
  */
  E1059: 'The following column names are not unique: {0}',
  /**
  * @name ErrorsUIWidgets.E1060
  */
  E1060: 'All editable columns must have names',
  /**
   * @name ErrorsUIWidgets.E1061
   */
  E1061: 'The "offset" option must be an integer in the [-1440, 1440] range, divisible by 5 without a remainder.',
  /**
   * @name ErrorsUIWidgets.E1062
   */
  E1062: 'The "cellDuration" must be a positive integer, evenly dividing the ("endDayHour" - "startDayHour") interval into minutes.',
  /**
  * @name ErrorsUIWidgets.W1001
  */
  W1001: 'The "key" option cannot be modified after initialization',
  /**
  * @name ErrorsUIWidgets.W1002
  */
  W1002: 'An item with the key \'{0}\' does not exist',
  /**
  * @name ErrorsUIWidgets.W1003
  */
  W1003: 'A group with the key \'{0}\' in which you are trying to select items does not exist',
  /**
  * @name ErrorsUIWidgets.W1004
  */
  W1004: 'The item \'{0}\' you are trying to select in the group \'{1}\' does not exist',
  /**
  * @name ErrorsUIWidgets.W1005
  */
  W1005: 'Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.',
  /**
  * @name ErrorsUIWidgets.W1006
  */
  W1006: 'The map service returned the following error: \'{0}\'',
  /**
   * @name ErrorsUIWidgets.W1007
   */
  W1007: 'No item with key {0} was found in the data source, but this key was used as the parent key for item {1}',
  /**
   * @name ErrorsUIWidgets.W1008
   */
  W1008: 'Cannot scroll to the \'{0}\' date because it does not exist on the current view',
  /**
   * @name ErrorsUIWidgets.W1009
   */
  W1009: 'Searching works only if data is specified using the dataSource option',
  /**
   * @name ErrorsUIWidgets.W1010
   */
  W1010: 'The capability to select all items works with source data of plain structure only',
  /**
   * @name ErrorsUIWidgets.W1011
   */
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: 'The \'{0}\' key field is not found in data objects',
  /**
  * @name ErrorsUIWidgets.W1013
  */
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
  /**
  * @name ErrorsUIWidgets.W1014
  */
  W1014: 'The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.',
  /**
  * @name ErrorsUIWidgets.W1016
  */
  W1016: 'The \'{0}\' field in the HTML Editor toolbar item configuration was renamed to \'{1}\'. Please make a corresponding change in your code.',
  /**
  * @name ErrorsUIWidgets.W1017
  */
  W1017: 'The \'key\' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.',
  /**
  * @name ErrorsUIWidgets.W1018
  */
  W1018: 'Infinite scrolling may not work properly with multiple selection. To use these features together, set \'selection.deferred\' to true or set \'selection.selectAllMode\' to \'page\'.',
  /**
  * @name ErrorsUIWidgets.W1019
  */
  W1019: 'Filter query string exceeds maximum length limit of {0} characters.',
  /**
  * @name ErrorsUIWidgets.W1020
  */
  W1020: 'hideEvent is ignored when the shading property is true',
  /**
  * @name ErrorsUIWidgets.W1021
  */
  W1021: 'The \'{0}\' is not rendered because none of the DOM elements match the value of the "container" property.',
  /**
   * @name ErrorsUIWidgets.W1022
   */
  W1022: '{0} JSON parsing error: \'{1}\'',
  /**
   * @name ErrorsUIWidgets.W1023
   */
  W1023: 'Appointments require unique keys. Otherwise, the agenda view may not work correctly.',
  /**
   * @name ErrorsUIWidgets.W1024
   */
  W1024: 'The client-side export is enabled. Implement the \'onExporting\' function.',
  /**
   * @name ErrorsUIWidgets.W1025
   */
  W1025: '\'scrolling.mode\' is set to \'virtual\' or \'infinite\'. Specify the height of the component.'
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 14390:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _widget = _interopRequireDefault(__webpack_require__(94700));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _widget.default;
/**
 * @section Utils
 * @type function
 * @default null
 * @type_function_param1 e:object
 * @type_function_param1_field1 component:this
 * @type_function_param1_field2 element:DxElement
 * @type_function_param1_field3 model:object
 * @name WidgetOptions.onFocusIn
 * @action
 * @hidden
 */
/**
 * @section Utils
 * @type function
 * @default null
 * @type_function_param1 e:object
 * @type_function_param1_field1 component:this
 * @type_function_param1_field2 element:DxElement
 * @type_function_param1_field3 model:object
 * @name WidgetOptions.onFocusOut
 * @action
 * @hidden
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 53805:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _default = exports["default"] = {
  logarithmic: 'logarithmic',
  discrete: 'discrete',
  numeric: 'numeric',
  left: 'left',
  right: 'right',
  top: 'top',
  bottom: 'bottom',
  center: 'center',
  horizontal: 'horizontal',
  vertical: 'vertical',
  convertTicksToValues: function (ticks) {
    return (0, _utils.map)(ticks || [], function (item) {
      return item.value;
    });
  },
  validateOverlappingMode: function (mode) {
    return mode === 'ignore' || mode === 'none' ? mode : 'hide';
  },
  getTicksCountInRange: function (ticks, valueKey, range) {
    let i = 1;
    if (ticks.length > 1) {
      for (; i < ticks.length; i++) {
        if (Math.abs(ticks[i].coords[valueKey] - ticks[0].coords[valueKey]) >= range) {
          break;
        }
      }
    }
    return i;
  },
  areLabelsOverlap: function (bBox1, bBox2, spacing, alignment) {
    const horizontalInverted = bBox1.x > bBox2.x;
    const verticalInverted = bBox1.y > bBox2.y;
    let x1 = bBox1.x;
    let x2 = bBox2.x;
    const width1 = bBox1.width;
    const width2 = bBox2.width;
    if (alignment === 'left') {
      x1 += width1 / 2;
      x2 += width2 / 2;
    } else if (alignment === 'right') {
      x1 -= width1 / 2;
      x2 -= width2 / 2;
    }
    const hasHorizontalOverlapping = horizontalInverted ? x2 + width2 + spacing > x1 : x1 + width1 + spacing > x2;
    const hasVerticalOverlapping = verticalInverted ? bBox2.y + bBox2.height > bBox1.y : bBox1.y + bBox1.height > bBox2.y;
    return hasHorizontalOverlapping && hasVerticalOverlapping;
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 32945:
/***/ (function(__unused_webpack_module, exports) {



exports.measureLabels = exports.calculateCanvasMargins = void 0;
const _max = Math.max;
const calculateCanvasMargins = function (bBoxes, canvas) {
  const cLeft = canvas.left;
  const cTop = canvas.top;
  const cRight = canvas.width - canvas.right;
  const cBottom = canvas.height - canvas.bottom;
  return bBoxes.reduce(function (margins, bBox) {
    if (!bBox || bBox.isEmpty) {
      return margins;
    }
    return {
      left: _max(margins.left, cLeft - bBox.x),
      top: _max(margins.top, cTop - bBox.y),
      right: _max(margins.right, bBox.x + bBox.width - cRight),
      bottom: _max(margins.bottom, bBox.y + bBox.height - cBottom)
    };
  }, {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  });
};
exports.calculateCanvasMargins = calculateCanvasMargins;
const measureLabels = function (items) {
  items.forEach(function (item) {
    const label = item.getContentContainer();
    item.labelBBox = label ? label.getBBox() : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  });
};
exports.measureLabels = measureLabels;

/***/ }),

/***/ 41278:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Axis = void 0;
var _smart_formatter = __webpack_require__(41583);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _axes_constants = _interopRequireDefault(__webpack_require__(53805));
var _extend = __webpack_require__(13306);
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _parse_utils = __webpack_require__(8587);
var _tick_generator = __webpack_require__(45971);
var _translator2d = __webpack_require__(87276);
var _range = __webpack_require__(21177);
var _tick = __webpack_require__(41013);
var _math2 = __webpack_require__(60810);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _date = _interopRequireDefault(__webpack_require__(91198));
var _common = __webpack_require__(20576);
var _xy_axes = _interopRequireDefault(__webpack_require__(99415));
var polarMethods = _interopRequireWildcard(__webpack_require__(4331));
var _constant_line = _interopRequireDefault(__webpack_require__(87713));
var _strip = _interopRequireDefault(__webpack_require__(54978));
var _deferred = __webpack_require__(62754);
var _axes_utils = __webpack_require__(32945);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const convertTicksToValues = _axes_constants.default.convertTicksToValues;
const _math = Math;
const _abs = _math.abs;
const _max = _math.max;
const _min = _math.min;
const _isArray = Array.isArray;
const DEFAULT_AXIS_LABEL_SPACING = 5;
const MAX_GRID_BORDER_ADHENSION = 4;
const TOP = _axes_constants.default.top;
const BOTTOM = _axes_constants.default.bottom;
const LEFT = _axes_constants.default.left;
const RIGHT = _axes_constants.default.right;
const CENTER = _axes_constants.default.center;
const KEEP = 'keep';
const SHIFT = 'shift';
const RESET = 'reset';
const ROTATE = 'rotate';
const DEFAULT_AXIS_DIVISION_FACTOR = 50;
const DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;
const SCROLL_THRESHOLD = 5;
const MIN_BAR_MARGIN = 5;
const MAX_MARGIN_VALUE = 0.8;
const dateIntervals = {
  day: 86400000,
  week: 604800000
};
function getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {
  var _options$workWeek;
  let {
    allowNegatives,
    linearThreshold
  } = _ref;
  return (0, _tick_generator.tickGenerator)({
    axisType: options.type,
    dataType: options.dataType,
    logBase: options.logarithmBase,
    allowNegatives,
    linearThreshold,
    axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),
    minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),
    numberMultipliers: options.numberMultipliers,
    calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,
    allowDecimals: options.allowDecimals,
    endOnTick: options.endOnTick,
    incidentOccurred: incidentOccurred,
    firstDayOfWeek: (_options$workWeek = options.workWeek) === null || _options$workWeek === void 0 ? void 0 : _options$workWeek[0],
    skipTickGeneration: skipTickGeneration,
    skipCalculationLimits: options.skipCalculationLimits,
    generateExtraTick: options.generateExtraTick,
    minTickInterval: options.minTickInterval,
    rangeIsEmpty
  });
}
function createMajorTick(axis, renderer, skippedCategory) {
  const options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, options.tick, options.grid, skippedCategory, false);
}
function createMinorTick(axis, renderer) {
  const options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, options.minorTick, options.minorGrid);
}
function createBoundaryTick(axis, renderer, isFirst) {
  const options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, (0, _extend.extend)({}, options.tick, {
    visible: options.showCustomBoundaryTicks
  }), options.grid, undefined, false, isFirst ? -1 : 1);
}
function callAction(elements, action, actionArgument1, actionArgument2) {
  (elements || []).forEach(e => e[action](actionArgument1, actionArgument2));
}
function initTickCoords(ticks) {
  callAction(ticks, 'initCoords');
}
function drawTickMarks(ticks, options) {
  callAction(ticks, 'drawMark', options);
}
function drawGrids(ticks, drawLine) {
  callAction(ticks, 'drawGrid', drawLine);
}
function updateTicksPosition(ticks, options, animate) {
  callAction(ticks, 'updateTickPosition', options, animate);
}
function updateGridsPosition(ticks, animate) {
  callAction(ticks, 'updateGridPosition', animate);
}
function cleanUpInvalidTicks(ticks) {
  let i = ticks.length - 1;
  for (i; i >= 0; i--) {
    if (!removeInvalidTick(ticks, i)) {
      break;
    }
  }
  for (i = 0; i < ticks.length; i++) {
    if (removeInvalidTick(ticks, i)) {
      i--;
    } else {
      break;
    }
  }
}
function removeInvalidTick(ticks, i) {
  if (ticks[i].coords.x === null || ticks[i].coords.y === null) {
    ticks.splice(i, 1);
    return true;
  }
  return false;
}
function validateAxisOptions(options) {
  const labelOptions = options.label;
  let position = options.position;
  const defaultPosition = options.isHorizontal ? BOTTOM : LEFT;
  const secondaryPosition = options.isHorizontal ? TOP : RIGHT;
  let labelPosition = labelOptions.position;
  if (position !== defaultPosition && position !== secondaryPosition) {
    position = defaultPosition;
  }
  if (!labelPosition || labelPosition === 'outside') {
    labelPosition = position;
  } else if (labelPosition === 'inside') {
    labelPosition = {
      [TOP]: BOTTOM,
      [BOTTOM]: TOP,
      [LEFT]: RIGHT,
      [RIGHT]: LEFT
    }[position];
  }
  if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {
    labelPosition = position;
  }
  if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {
    labelOptions.alignment = {
      [TOP]: CENTER,
      [BOTTOM]: CENTER,
      [LEFT]: RIGHT,
      [RIGHT]: LEFT
    }[labelPosition];
  }
  options.position = position;
  labelOptions.position = labelPosition;
  options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : 'none';
  labelOptions.minSpacing = labelOptions.minSpacing ?? DEFAULT_AXIS_LABEL_SPACING;
  options.type && (options.type = options.type.toLowerCase());
  options.argumentType && (options.argumentType = options.argumentType.toLowerCase());
  options.valueType && (options.valueType = options.valueType.toLowerCase());
}
function getOptimalAngle(boxes, labelOpt) {
  const angle = _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) * 180 / _math.PI;
  return angle < 45 ? -45 : -90;
}
function updateLabels(ticks, step, func) {
  ticks.forEach(function (tick, index) {
    if (tick.getContentContainer()) {
      if (index % step !== 0) {
        tick.removeLabel();
      } else if (func) {
        func(tick, index);
      }
    }
  });
}
function getZoomBoundValue(optionValue, dataValue) {
  if (optionValue === undefined) {
    return dataValue;
  } else if (optionValue === null) {
    return undefined;
  } else {
    return optionValue;
  }
}
function configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {
  const tickGeneratorOptions = (0, _extend.extend)({}, options, {
    endOnTick: true,
    axisDivisionFactor,
    skipCalculationLimits: true,
    generateExtraTick: true,
    minTickInterval
  });
  return function (tickInterval, skipTickGeneration, min, max, breaks) {
    return getTickGenerator(tickGeneratorOptions, _common.noop, skipTickGeneration, viewPort.isEmpty(), v => v, viewPort)({
      min: min,
      max: max,
      categories: viewPort.categories,
      isSpacedMargin: viewPort.isSpacedMargin
    }, screenDelta, tickInterval, (0, _type.isDefined)(tickInterval), undefined, undefined, undefined, breaks);
  };
}
function getConstantLineSharpDirection(coord, axisCanvas) {
  return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1;
}
function checkDeprecatedOptions(isValueAxis, options) {
  if (isValueAxis && options.visualRangeUpdateMode === 'shift') {
    _errors.default.log('W0016', 'valueAxis.visualRangeUpdateMode', 'shift', '23.1', 'Specify another value');
  }
}
const Axis = function (renderSettings) {
  const that = this;
  that._renderer = renderSettings.renderer;
  that._incidentOccurred = renderSettings.incidentOccurred;
  that._eventTrigger = renderSettings.eventTrigger;
  that._stripsGroup = renderSettings.stripsGroup;
  that._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;
  that._labelsAxesGroup = renderSettings.labelsAxesGroup;
  that._constantLinesGroup = renderSettings.constantLinesGroup;
  that._scaleBreaksGroup = renderSettings.scaleBreaksGroup;
  that._axesContainerGroup = renderSettings.axesContainerGroup;
  that._gridContainerGroup = renderSettings.gridGroup;
  that._axisCssPrefix = renderSettings.widgetClass + '-' + (renderSettings.axisClass ? renderSettings.axisClass + '-' : '');
  that._setType(renderSettings.axisType, renderSettings.drawingType);
  that._createAxisGroups();
  that._translator = that._createTranslator();
  that.isArgumentAxis = renderSettings.isArgumentAxis;
  that._viewport = {};
  that._prevDataInfo = {};
  that._firstDrawing = true;
  that._initRange = {};
  that._getTemplate = renderSettings.getTemplate;
};
exports.Axis = Axis;
Axis.prototype = {
  constructor: Axis,
  _drawAxis() {
    const options = this._options;
    if (!options.visible) {
      return;
    }
    this._axisElement = this._createAxisElement();
    this._updateAxisElementPosition();
    this._axisElement.attr({
      'stroke-width': options.width,
      stroke: options.color,
      'stroke-opacity': options.opacity
    }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup);
  },
  _createPathElement(points, attr, sharpDirection) {
    return this.sharp(this._renderer.path(points, 'line').attr(attr), sharpDirection);
  },
  sharp(svgElement) {
    let sharpDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return svgElement.sharp(this._getSharpParam(), sharpDirection);
  },
  customPositionIsAvailable() {
    return false;
  },
  getOrthogonalAxis: _common.noop,
  getCustomPosition: _common.noop,
  getCustomBoundaryPosition: _common.noop,
  resolveOverlappingForCustomPositioning: _common.noop,
  hasNonBoundaryPosition() {
    return false;
  },
  customPositionIsBoundaryOrthogonalAxis() {
    return false;
  },
  getResolvedBoundaryPosition() {
    return this.getOptions().position;
  },
  getAxisSharpDirection() {
    const position = this.getResolvedBoundaryPosition();
    return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1;
  },
  getSharpDirectionByCoords(coords) {
    const canvas = this._getCanvasStartEnd();
    const maxCoord = Math.max(canvas.start, canvas.end);
    return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? 'x' : 'y'] ? 1 : -1;
  },
  _getGridLineDrawer: function () {
    const that = this;
    return function (tick, gridStyle) {
      const grid = that._getGridPoints(tick.coords);
      if (grid.points) {
        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords));
      }
      return null;
    };
  },
  _getGridPoints: function (coords) {
    const that = this;
    const isHorizontal = this._isHorizontal;
    const tickPositionField = isHorizontal ? 'x' : 'y';
    const orthogonalPositions = this._orthogonalPositions;
    const positionFrom = orthogonalPositions.start;
    const positionTo = orthogonalPositions.end;
    const borderOptions = that.borderOptions;
    const canvasStart = isHorizontal ? LEFT : TOP;
    const canvasEnd = isHorizontal ? RIGHT : BOTTOM;
    const axisCanvas = that.getCanvas();
    const canvas = {
      left: axisCanvas.left,
      right: axisCanvas.width - axisCanvas.right,
      top: axisCanvas.top,
      bottom: axisCanvas.height - axisCanvas.bottom
    };
    const firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : undefined;
    const lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : undefined;
    const minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;
    const maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;
    if (that.areCoordsOutsideAxis(coords) || coords[tickPositionField] === undefined || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {
      return {
        points: null
      };
    }
    return {
      points: isHorizontal ? coords[tickPositionField] !== null ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : coords[tickPositionField] !== null ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null
    };
  },
  _getConstantLinePos: function (parsedValue, canvasStart, canvasEnd) {
    const value = this._getTranslatedCoord(parsedValue);
    if (!(0, _type.isDefined)(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {
      return undefined;
    }
    return value;
  },
  _getConstantLineGraphicAttributes: function (value) {
    const positionFrom = this._orthogonalPositions.start;
    const positionTo = this._orthogonalPositions.end;
    return {
      points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]
    };
  },
  _createConstantLine: function (value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()));
  },
  _drawConstantLineLabelText: function (text, x, y, _ref2, group) {
    let {
      font,
      cssClass
    } = _ref2;
    return this._renderer.text(text, x, y).css((0, _utils.patchFontOptions)((0, _extend.extend)({}, this._options.label.font, font))).attr({
      align: 'center',
      'class': cssClass
    }).append(group);
  },
  _drawConstantLineLabels: function (parsedValue, lineLabelOptions, value, group) {
    const that = this;
    let text = lineLabelOptions.text;
    const options = that._options;
    const labelOptions = options.label;
    that._checkAlignmentConstantLineLabels(lineLabelOptions);
    text = text ?? that.formatLabel(parsedValue, labelOptions);
    const coords = that._getConstantLineLabelsCoords(value, lineLabelOptions);
    return that._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group);
  },
  _getStripPos: function (startValue, endValue, canvasStart, canvasEnd, range) {
    const isContinuous = !!(range.minVisible || range.maxVisible);
    const categories = (range.categories || []).reduce(function (result, cat) {
      result.push(cat.valueOf());
      return result;
    }, []);
    let start;
    let end;
    let swap;
    let startCategoryIndex;
    let endCategoryIndex;
    if (!isContinuous) {
      if ((0, _type.isDefined)(startValue) && (0, _type.isDefined)(endValue)) {
        const parsedStartValue = this.parser(startValue);
        const parsedEndValue = this.parser(endValue);
        startCategoryIndex = categories.indexOf((parsedStartValue === null || parsedStartValue === void 0 ? void 0 : parsedStartValue.valueOf()) ?? undefined);
        endCategoryIndex = categories.indexOf((parsedEndValue === null || parsedEndValue === void 0 ? void 0 : parsedEndValue.valueOf()) ?? undefined);
        if (startCategoryIndex === -1 || endCategoryIndex === -1) {
          return {
            from: 0,
            to: 0,
            outOfCanvas: true
          };
        }
        if (startCategoryIndex > endCategoryIndex) {
          swap = endValue;
          endValue = startValue;
          startValue = swap;
        }
      }
    }
    if ((0, _type.isDefined)(startValue)) {
      startValue = this.validateUnit(startValue, 'E2105', 'strip');
      start = this._getTranslatedCoord(startValue, -1);
    } else {
      start = canvasStart;
    }
    if ((0, _type.isDefined)(endValue)) {
      endValue = this.validateUnit(endValue, 'E2105', 'strip');
      end = this._getTranslatedCoord(endValue, 1);
    } else {
      end = canvasEnd;
    }
    const stripPosition = start < end ? {
      from: start,
      to: end
    } : {
      from: end,
      to: start
    };
    const visibleArea = this.getVisibleArea();
    if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {
      stripPosition.outOfCanvas = true;
    }
    return stripPosition;
  },
  _getStripGraphicAttributes: function (fromPoint, toPoint) {
    let x;
    let y;
    let width;
    let height;
    const orthogonalPositions = this._orthogonalPositions;
    const positionFrom = orthogonalPositions.start;
    const positionTo = orthogonalPositions.end;
    if (this._isHorizontal) {
      x = fromPoint;
      y = _min(positionFrom, positionTo);
      width = toPoint - fromPoint;
      height = _abs(positionFrom - positionTo);
    } else {
      x = _min(positionFrom, positionTo);
      y = fromPoint;
      width = _abs(positionFrom - positionTo);
      height = _abs(fromPoint - toPoint);
    }
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  _createStrip: function (attrs) {
    return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height);
  },
  _adjustStripLabels: function () {
    const that = this;
    this._strips.forEach(function (strip) {
      if (strip.label) {
        strip.label.attr(that._getAdjustedStripLabelCoords(strip));
      }
    });
  },
  _adjustLabelsCoord(offset, maxWidth, checkCanvas) {
    const that = this;
    const getContainerAttrs = tick => this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);
    that._majorTicks.forEach(function (tick) {
      if (tick.label) {
        tick.updateMultilineTextAlignment();
        tick.label.attr(getContainerAttrs(tick));
      } else {
        tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick));
      }
    });
  },
  _adjustLabels: function (offset) {
    const that = this;
    const options = that.getOptions();
    const positionsAreConsistent = options.position === options.label.position;
    const maxSize = that._majorTicks.reduce(function (size, tick) {
      if (!tick.getContentContainer()) return size;
      const bBox = tick.labelRotationAngle ? (0, _utils.rotateBBox)(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;
      return {
        width: _max(size.width || 0, bBox.width),
        height: _max(size.height || 0, bBox.height),
        offset: _max(size.offset || 0, tick.labelOffset || 0)
      };
    }, {});
    const additionalOffset = positionsAreConsistent ? that._isHorizontal ? maxSize.height : maxSize.width : 0;
    that._adjustLabelsCoord(offset, maxSize.width);
    return offset + additionalOffset + (additionalOffset && that._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0);
  },
  _getLabelAdjustedCoord: function (tick, offset, maxWidth) {
    offset = offset || 0;
    const that = this;
    const options = that._options;
    const templateBox = tick.templateContainer && tick.templateContainer.getBBox();
    const box = templateBox || (0, _utils.rotateBBox)(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);
    const textAlign = tick.labelAlignment || options.label.alignment;
    const isDiscrete = that._options.type === 'discrete';
    const isFlatLabel = tick.labelRotationAngle % 90 === 0;
    const indentFromAxis = options.label.indentFromAxis;
    const labelPosition = options.label.position;
    const axisPosition = that._axisPosition;
    const labelCoords = tick.labelCoords;
    const labelX = labelCoords.x;
    let translateX;
    let translateY;
    if (that._isHorizontal) {
      if (labelPosition === BOTTOM) {
        translateY = axisPosition + indentFromAxis - box.y + offset;
      } else {
        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset;
      }
      if (textAlign === RIGHT) {
        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width;
      } else if (textAlign === LEFT) {
        translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x;
      } else {
        translateX = labelX - box.x - box.width / 2;
      }
    } else {
      translateY = labelCoords.y - box.y - box.height / 2;
      if (labelPosition === LEFT) {
        if (textAlign === LEFT) {
          translateX = axisPosition - indentFromAxis - maxWidth - box.x;
        } else if (textAlign === CENTER) {
          translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2;
        } else {
          translateX = axisPosition - indentFromAxis - box.x - box.width;
        }
        translateX -= offset;
      } else {
        if (textAlign === RIGHT) {
          translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width;
        } else if (textAlign === CENTER) {
          translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2;
        } else {
          translateX = axisPosition + indentFromAxis - box.x;
        }
        translateX += offset;
      }
    }
    return {
      translateX: translateX,
      translateY: translateY
    };
  },
  _createAxisConstantLineGroups: function () {
    const that = this;
    const renderer = that._renderer;
    const classSelector = that._axisCssPrefix;
    const constantLinesClass = classSelector + 'constant-lines';
    const insideGroup = renderer.g().attr({
      'class': constantLinesClass
    });
    const outsideGroup1 = renderer.g().attr({
      'class': constantLinesClass
    });
    const outsideGroup2 = renderer.g().attr({
      'class': constantLinesClass
    });
    return {
      inside: insideGroup,
      outside1: outsideGroup1,
      left: outsideGroup1,
      top: outsideGroup1,
      outside2: outsideGroup2,
      right: outsideGroup2,
      bottom: outsideGroup2,
      remove: function () {
        this.inside.remove();
        this.outside1.remove();
        this.outside2.remove();
      },
      clear: function () {
        this.inside.clear();
        this.outside1.clear();
        this.outside2.clear();
      }
    };
  },
  _createAxisGroups: function () {
    const that = this;
    const renderer = that._renderer;
    const classSelector = that._axisCssPrefix;
    that._axisGroup = renderer.g().attr({
      'class': classSelector + 'axis'
    }).enableLinks();
    that._axisStripGroup = renderer.g().attr({
      'class': classSelector + 'strips'
    });
    that._axisGridGroup = renderer.g().attr({
      'class': classSelector + 'grid'
    });
    that._axisElementsGroup = renderer.g().attr({
      'class': classSelector + 'elements'
    });
    that._axisLineGroup = renderer.g().attr({
      'class': classSelector + 'line'
    }).linkOn(that._axisGroup, 'axisLine').linkAppend();
    that._axisTitleGroup = renderer.g().attr({
      'class': classSelector + 'title'
    }).append(that._axisGroup);
    that._axisConstantLineGroups = {
      above: that._createAxisConstantLineGroups(),
      under: that._createAxisConstantLineGroups()
    };
    that._axisStripLabelGroup = renderer.g().attr({
      'class': classSelector + 'axis-labels'
    });
  },
  _clearAxisGroups: function () {
    const that = this;
    that._axisGroup.remove();
    that._axisStripGroup.remove();
    that._axisStripLabelGroup.remove();
    that._axisConstantLineGroups.above.remove();
    that._axisConstantLineGroups.under.remove();
    that._axisGridGroup.remove();
    that._axisTitleGroup.clear();
    if (!that._options.label.template || !that.isRendered()) {
      // for react async templates
      that._axisElementsGroup.remove();
      that._axisElementsGroup.clear();
    }
    that._axisLineGroup && that._axisLineGroup.clear();
    that._axisStripGroup && that._axisStripGroup.clear();
    that._axisGridGroup && that._axisGridGroup.clear();
    that._axisConstantLineGroups.above.clear();
    that._axisConstantLineGroups.under.clear();
    that._axisStripLabelGroup && that._axisStripLabelGroup.clear();
  },
  _getLabelFormatObject: function (value, labelOptions, range, point, tickInterval, ticks) {
    range = range || this._getViewportRange();
    const formatObject = {
      value: value,
      valueText: (0, _smart_formatter.smartFormatter)(value, {
        labelOptions: labelOptions,
        ticks: ticks || convertTicksToValues(this._majorTicks),
        tickInterval: tickInterval ?? this._tickInterval,
        dataType: this._options.dataType,
        logarithmBase: this._options.logarithmBase,
        type: this._options.type,
        showTransition: !this._options.marker.visible,
        point: point
      }) || '',
      // B252346
      min: range.minVisible,
      max: range.maxVisible
    };

    // for crosshair's customizeText
    if (point) {
      formatObject.point = point;
    }
    return formatObject;
  },
  formatLabel: function (value, labelOptions, range, point, tickInterval, ticks) {
    const formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);
    return (0, _type.isFunction)(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText;
  },
  formatHint: function (value, labelOptions, range) {
    const formatObject = this._getLabelFormatObject(value, labelOptions, range);
    return (0, _type.isFunction)(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : undefined;
  },
  formatRange(startValue, endValue, interval, argumentFormat) {
    return (0, _smart_formatter.formatRange)({
      startValue,
      endValue,
      tickInterval: interval,
      argumentFormat,
      axisOptions: this.getOptions()
    });
  },
  _setTickOffset: function () {
    const options = this._options;
    const discreteAxisDivisionMode = options.discreteAxisDivisionMode;
    this._tickOffset = +(discreteAxisDivisionMode !== 'crossLabels' || !discreteAxisDivisionMode);
  },
  // T1068023,T948359
  aggregatedPointBetweenTicks() {
    return this._options.aggregatedPointsPosition === 'crossTicks';
  },
  resetApplyingAnimation: function (isFirstDrawing) {
    this._resetApplyingAnimation = true;
    if (isFirstDrawing) {
      this._firstDrawing = true;
    }
  },
  isFirstDrawing() {
    return this._firstDrawing;
  },
  getMargins: function () {
    const that = this;
    const {
      position,
      offset,
      customPosition,
      placeholderSize,
      grid,
      tick,
      crosshairMargin
    } = that._options;
    const isDefinedCustomPositionOption = (0, _type.isDefined)(customPosition);
    const boundaryPosition = that.getResolvedBoundaryPosition();
    const canvas = that.getCanvas();
    const cLeft = canvas.left;
    const cTop = canvas.top;
    const cRight = canvas.width - canvas.right;
    const cBottom = canvas.height - canvas.bottom;
    const edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);
    const constantLineAboveSeries = that._axisConstantLineGroups.above;
    const constantLineUnderSeries = that._axisConstantLineGroups.under;
    const boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(group => group && group.getBBox()).concat(function (group) {
      const box = group && group.getBBox();
      if (!box || box.isEmpty) {
        return box;
      }
      if (that._isHorizontal) {
        box.x = cLeft;
        box.width = cRight - cLeft;
      } else {
        box.y = cTop;
        box.height = cBottom - cTop;
      }
      return box;
    }(that._axisTitleGroup));
    const margins = (0, _axes_utils.calculateCanvasMargins)(boxes, canvas);
    margins[position] += crosshairMargin;
    if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {
      margins[boundaryPosition] = 0;
    }
    if (placeholderSize) {
      margins[position] = placeholderSize;
    }
    if (edgeMarginCorrection) {
      if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {
        margins.right = edgeMarginCorrection;
      }
      if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {
        margins.bottom = edgeMarginCorrection;
      }
    }
    if (!isDefinedCustomPositionOption && (0, _type.isDefined)(offset)) {
      const moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));
      margins[boundaryPosition] -= moveByOffset ? offset : 0;
    }
    return margins;
  },
  validateUnit: function (unit, idError, parameters) {
    const that = this;
    unit = that.parser(unit);
    if (unit === undefined && idError) {
      that._incidentOccurred(idError, [parameters]);
    }
    return unit;
  },
  _setType: function (axisType, drawingType) {
    const that = this;
    let axisTypeMethods;
    switch (axisType) {
      case 'xyAxes':
        axisTypeMethods = _xy_axes.default;
        break;
      case 'polarAxes':
        axisTypeMethods = polarMethods;
        break;
    }
    (0, _extend.extend)(that, axisTypeMethods[drawingType]);
  },
  _getSharpParam: function () {
    return true;
  },
  _disposeBreaksGroup: _common.noop,
  // public
  dispose: function () {
    const that = this;
    [that._axisElementsGroup, that._axisStripGroup, that._axisGroup].forEach(function (g) {
      g.dispose();
    });
    that._strips = that._title = null;
    that._axisStripGroup = that._axisConstantLineGroups = that._axisStripLabelGroup = that._axisBreaksGroup = null;
    that._axisLineGroup = that._axisElementsGroup = that._axisGridGroup = null;
    that._axisGroup = that._axisTitleGroup = null;
    that._axesContainerGroup = that._stripsGroup = that._constantLinesGroup = that._labelsAxesGroup = null;
    that._renderer = that._options = that._textOptions = that._textFontStyles = null;
    that._translator = null;
    that._majorTicks = that._minorTicks = null;
    that._disposeBreaksGroup();
    that._templatesRendered && that._templatesRendered.reject();
  },
  getOptions: function () {
    return this._options;
  },
  setPane: function (pane) {
    this.pane = pane;
    this._options.pane = pane;
  },
  setTypes: function (type, axisType, typeSelector) {
    this._options.type = type || this._options.type;
    this._options[typeSelector] = axisType || this._options[typeSelector];
    this._updateTranslator();
  },
  resetTypes: function (typeSelector) {
    this._options.type = this._initTypes.type;
    this._options[typeSelector] = this._initTypes[typeSelector];
  },
  getTranslator: function () {
    return this._translator;
  },
  updateOptions: function (options) {
    const that = this;
    const labelOpt = options.label;
    validateAxisOptions(options);
    checkDeprecatedOptions(!that.isArgumentAxis, options);
    that._options = options;
    options.tick = options.tick || {};
    options.minorTick = options.minorTick || {};
    options.grid = options.grid || {};
    options.minorGrid = options.minorGrid || {};
    options.title = options.title || {};
    options.marker = options.marker || {};
    that._initTypes = {
      type: options.type,
      argumentType: options.argumentType,
      valueType: options.valueType
    };
    that._setTickOffset();
    that._isHorizontal = options.isHorizontal;
    that.pane = options.pane;
    that.name = options.name;
    that.priority = options.priority;
    that._hasLabelFormat = labelOpt.format !== '' && (0, _type.isDefined)(labelOpt.format);
    that._textOptions = {
      opacity: labelOpt.opacity,
      align: 'center',
      'class': labelOpt.cssClass
    };
    that._textFontStyles = (0, _utils.patchFontOptions)(labelOpt.font);
    if (options.type === _axes_constants.default.logarithmic) {
      if (options.logarithmBaseError) {
        that._incidentOccurred('E2104');
        delete options.logarithmBaseError;
      }
    }
    that._updateTranslator();
    that._createConstantLines();
    that._strips = (options.strips || []).map(o => (0, _strip.default)(that, o));
    that._majorTicks = that._minorTicks = null;
    that._firstDrawing = true;
  },
  calculateInterval: function (value, prevValue) {
    const options = this._options;
    if (!options || options.type !== _axes_constants.default.logarithmic) {
      return _abs(value - prevValue);
    }
    const {
      allowNegatives,
      linearThreshold
    } = new _range.Range(this.getTranslator().getBusinessRange());
    return _abs((0, _utils.getLogExt)(value, options.logarithmBase, allowNegatives, linearThreshold) - (0, _utils.getLogExt)(prevValue, options.logarithmBase, allowNegatives, linearThreshold));
  },
  getCanvasRange() {
    const translator = this._translator;
    return {
      startValue: translator.from(translator.translate('canvas_position_start')),
      endValue: translator.from(translator.translate('canvas_position_end'))
    };
  },
  _processCanvas: function (canvas) {
    return canvas;
  },
  updateCanvas: function (canvas, canvasRedesign) {
    if (!canvasRedesign) {
      const positions = this._orthogonalPositions = {
        start: !this._isHorizontal ? canvas.left : canvas.top,
        end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom
      };
      positions.center = positions.start + (positions.end - positions.start) / 2;
    } else {
      this._orthogonalPositions = null;
    }
    this._canvas = canvas;
    this._translator.updateCanvas(this._processCanvas(canvas));
    this._initAxisPositions();
  },
  getCanvas: function () {
    return this._canvas;
  },
  getAxisShift() {
    return this._axisShift || 0;
  },
  hideTitle: function () {
    const that = this;
    if (that._options.title.text) {
      that._incidentOccurred('W2105', [that._isHorizontal ? 'horizontal' : 'vertical']);
      that._axisTitleGroup.clear();
    }
  },
  getTitle: function () {
    return this._title;
  },
  hideOuterElements: function () {
    const that = this;
    const options = that._options;
    if ((options.label.visible || that._outsideConstantLines.length) && !that._translator.getBusinessRange().isEmpty()) {
      that._incidentOccurred('W2106', [that._isHorizontal ? 'horizontal' : 'vertical']);
      that._axisElementsGroup.clear();
      callAction(that._outsideConstantLines, 'removeLabel');
    }
  },
  _resolveLogarithmicOptionsForRange(range) {
    const options = this._options;
    if (options.type === _axes_constants.default.logarithmic) {
      range.addRange({
        allowNegatives: options.allowNegatives !== undefined ? options.allowNegatives : range.min <= 0
      });
      if (!isNaN(options.linearThreshold)) {
        range.linearThreshold = options.linearThreshold;
      }
    }
  },
  adjustViewport(businessRange) {
    const that = this;
    const options = that._options;
    const isDiscrete = options.type === _axes_constants.default.discrete;
    let categories = that._seriesData && that._seriesData.categories || [];
    const wholeRange = that.adjustRange((0, _utils.getVizRangeObject)(options.wholeRange));
    const visualRange = that.getViewport() || {};
    const result = new _range.Range(businessRange);
    that._addConstantLinesToRange(result);
    let minDefined = (0, _type.isDefined)(visualRange.startValue);
    let maxDefined = (0, _type.isDefined)(visualRange.endValue);
    if (!isDiscrete) {
      minDefined = minDefined && (!(0, _type.isDefined)(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);
      maxDefined = maxDefined && (!(0, _type.isDefined)(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue);
    }
    const minVisible = minDefined ? visualRange.startValue : result.minVisible;
    const maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;
    if (!isDiscrete) {
      result.min = wholeRange.startValue ?? result.min;
      result.max = wholeRange.endValue ?? result.max;
    } else {
      const categoriesInfo = (0, _utils.getCategoriesInfo)(categories, wholeRange.startValue, wholeRange.endValue);
      categories = categoriesInfo.categories;
      result.categories = categories;
    }
    const adjustedVisualRange = (0, _utils.adjustVisualRange)({
      axisType: options.type,
      dataType: options.dataType,
      base: options.logarithmBase
    }, {
      startValue: minDefined ? visualRange.startValue : undefined,
      endValue: maxDefined ? visualRange.endValue : undefined,
      length: visualRange.length
    }, {
      categories,
      min: wholeRange.startValue,
      max: wholeRange.endValue
    }, {
      categories,
      min: minVisible,
      max: maxVisible
    });
    result.minVisible = adjustedVisualRange.startValue;
    result.maxVisible = adjustedVisualRange.endValue;
    !(0, _type.isDefined)(result.min) && (result.min = result.minVisible);
    !(0, _type.isDefined)(result.max) && (result.max = result.maxVisible);
    result.addRange({}); // controlValuesByVisibleBounds
    that._resolveLogarithmicOptionsForRange(result);
    return result;
  },
  adjustRange(range) {
    range = range || {};
    const isDiscrete = this._options.type === _axes_constants.default.discrete;
    const isLogarithmic = this._options.type === _axes_constants.default.logarithmic;
    const disabledNegatives = this._options.allowNegatives === false;
    if (isLogarithmic) {
      range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;
      range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue;
    }
    if (!isDiscrete && (0, _type.isDefined)(range.startValue) && (0, _type.isDefined)(range.endValue) && range.startValue > range.endValue) {
      const tmp = range.endValue;
      range.endValue = range.startValue;
      range.startValue = tmp;
    }
    return range;
  },
  _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {
    let value = this._options.visualRangeUpdateMode;
    const translator = this._translator;
    const range = this._seriesData;
    const prevDataInfo = this._prevDataInfo;
    if (prevDataInfo.isEmpty && !prevDataInfo.containsConstantLine) {
      return KEEP;
    }
    if (!this.isArgumentAxis) {
      const viewport = this.getViewport();
      if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue) && !(0, _type.isDefined)(viewport.length)) {
        return RESET;
      }
    }
    if (this.isArgumentAxis) {
      if ([SHIFT, KEEP, RESET].indexOf(value) === -1) {
        if (range.axisType === _axes_constants.default.discrete) {
          const categories = range.categories;
          const newCategories = newRange.categories;
          const visualRange = this.visualRange();
          if (categories && newCategories && categories.length && newCategories.map(c => c.valueOf()).join(',').indexOf(categories.map(c => c.valueOf()).join(',')) !== -1 && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {
            value = KEEP;
          } else {
            value = RESET;
          }
        } else {
          const minPoint = translator.translate(range.min);
          const minVisiblePoint = translator.translate(viewport.startValue);
          const maxPoint = translator.translate(range.max);
          const maxVisiblePoint = translator.translate(viewport.endValue);
          if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {
            value = RESET;
          } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {
            value = SHIFT;
          } else {
            value = KEEP;
          }
        }
        if (value === KEEP && prevDataInfo.isEmpty && prevDataInfo.containsConstantLine) {
          value = RESET;
        }
      }
    } else {
      if ([KEEP, RESET].indexOf(value) === -1) {
        if (oppositeValue === KEEP) {
          value = KEEP;
        } else {
          value = RESET;
        }
      }
    }
    return value;
  },
  _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {
    const that = this;
    const visualRange = this.visualRange();
    if (axisReinitialized || that._translator.getBusinessRange().isEmpty()) {
      return;
    }
    const visualRangeUpdateMode = that._lastVisualRangeUpdateMode = that._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);
    if (visualRangeUpdateMode === KEEP) {
      that._setVisualRange([visualRange.startValue, visualRange.endValue]);
    } else if (visualRangeUpdateMode === RESET) {
      that._setVisualRange([null, null]);
    } else if (visualRangeUpdateMode === SHIFT) {
      that._setVisualRange({
        length: that.getVisualRangeLength()
      });
    }
  },
  getVisualRangeLength(range) {
    const currentBusinessRange = range || this._translator.getBusinessRange();
    const {
      type
    } = this._options;
    let length;
    if (type === _axes_constants.default.logarithmic) {
      length = (0, _math2.adjust)(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible));
    } else if (type === _axes_constants.default.discrete) {
      const categoriesInfo = (0, _utils.getCategoriesInfo)(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);
      length = categoriesInfo.categories.length;
    } else {
      length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible;
    }
    return length;
  },
  getVisualRangeCenter(range, useMerge) {
    const translator = this.getTranslator();
    const businessRange = translator.getBusinessRange();
    const currentBusinessRange = useMerge ? (0, _extend.extend)(true, {}, businessRange, range || {}) : range || businessRange;
    const {
      type,
      logarithmBase
    } = this._options;
    let center;
    if (!(0, _type.isDefined)(currentBusinessRange.minVisible) || !(0, _type.isDefined)(currentBusinessRange.maxVisible)) {
      return;
    }
    if (type === _axes_constants.default.logarithmic) {
      const {
        allowNegatives,
        linearThreshold,
        minVisible,
        maxVisible
      } = currentBusinessRange;
      center = (0, _utils.raiseToExt)((0, _math2.adjust)((0, _utils.getLogExt)(maxVisible, logarithmBase, allowNegatives, linearThreshold) + (0, _utils.getLogExt)(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold);
    } else if (type === _axes_constants.default.discrete) {
      const categoriesInfo = (0, _utils.getCategoriesInfo)(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);
      const index = Math.ceil(categoriesInfo.categories.length / 2) - 1;
      center = businessRange.categories.indexOf(categoriesInfo.categories[index]);
    } else {
      center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2);
    }
    return center;
  },
  setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {
    const that = this;
    const options = that._options;
    const isDiscrete = options.type === _axes_constants.default.discrete;
    that._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);
    that._seriesData = new _range.Range(range);
    const dataIsEmpty = that._seriesData.isEmpty();
    const rangeWithConstantLines = new _range.Range(that._seriesData);
    that._addConstantLinesToRange(rangeWithConstantLines);
    that._prevDataInfo = {
      isEmpty: dataIsEmpty,
      containsConstantLine: rangeWithConstantLines.containsConstantLine
    };
    that._seriesData.addRange({
      categories: options.categories,
      dataType: options.dataType,
      axisType: options.type,
      base: options.logarithmBase,
      invert: options.inverted
    });
    that._resolveLogarithmicOptionsForRange(that._seriesData);
    if (!isDiscrete) {
      if (!(0, _type.isDefined)(that._seriesData.min) && !(0, _type.isDefined)(that._seriesData.max)) {
        const visualRange = that.getViewport();
        visualRange && that._seriesData.addRange({
          min: visualRange.startValue,
          max: visualRange.endValue
        });
      }
      const synchronizedValue = options.synchronizedValue;
      if ((0, _type.isDefined)(synchronizedValue)) {
        that._seriesData.addRange({
          min: synchronizedValue,
          max: synchronizedValue
        });
      }
    }
    that._seriesData.minVisible = that._seriesData.minVisible ?? that._seriesData.min;
    that._seriesData.maxVisible = that._seriesData.maxVisible ?? that._seriesData.max;
    if (!that.isArgumentAxis && options.showZero) {
      that._seriesData.correctValueZeroLevel();
    }
    that._seriesData.sortCategories(that.getCategoriesSorter(argCategories));
    that._seriesData.userBreaks = that._seriesData.isEmpty() ? [] : that._getScaleBreaks(options, that._seriesData, that._series, that.isArgumentAxis);
    that._translator.updateBusinessRange(that._getViewportRange());
  },
  _addConstantLinesToRange(dataRange) {
    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(cl => {
      if (cl.options.extendAxis) {
        const value = cl.getParsedValue();
        dataRange.addRange({
          containsConstantLine: true,
          minVisible: value,
          maxVisible: value,
          min: !(0, _type.isDefined)(dataRange.min) ? value : dataRange.min,
          max: !(0, _type.isDefined)(dataRange.max) ? value : dataRange.max
        });
      }
    });
  },
  setGroupSeries: function (series) {
    this._series = series;
  },
  getLabelsPosition: function () {
    const that = this;
    const options = that._options;
    const position = options.position;
    const labelShift = options.label.indentFromAxis + (that._axisShift || 0) + that._constantLabelOffset;
    const axisPosition = that._axisPosition;
    return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift;
  },
  getFormattedValue: function (value, options, point) {
    const labelOptions = this._options.label;
    return (0, _type.isDefined)(value) ? this.formatLabel(value, (0, _extend.extend)(true, {}, labelOptions, options), undefined, point) : null;
  },
  _getBoundaryTicks: function (majors, viewPort) {
    const that = this;
    const length = majors.length;
    const options = that._options;
    const customBounds = options.customBoundTicks;
    const min = viewPort.minVisible;
    const max = viewPort.maxVisible;
    const addMinMax = options.showCustomBoundaryTicks ? that._boundaryTicksVisibility : {};
    let boundaryTicks = [];
    if (options.type === _axes_constants.default.discrete) {
      if (that._tickOffset && majors.length !== 0) {
        boundaryTicks = [majors[0], majors[majors.length - 1]];
      }
    } else {
      if (customBounds) {
        if (addMinMax.min && (0, _type.isDefined)(customBounds[0])) {
          boundaryTicks.push(customBounds[0]);
        }
        if (addMinMax.max && (0, _type.isDefined)(customBounds[1])) {
          boundaryTicks.push(customBounds[1]);
        }
      } else {
        if (addMinMax.min && (length === 0 || majors[0] > min)) {
          boundaryTicks.push(min);
        }
        if (addMinMax.max && (length === 0 || majors[length - 1] < max)) {
          boundaryTicks.push(max);
        }
      }
    }
    return boundaryTicks;
  },
  setPercentLabelFormat: function () {
    if (!this._hasLabelFormat) {
      this._options.label.format = 'percent';
    }
  },
  resetAutoLabelFormat: function () {
    if (!this._hasLabelFormat) {
      delete this._options.label.format;
    }
  },
  getMultipleAxesSpacing: function () {
    return this._options.multipleAxesSpacing || 0;
  },
  getTicksValues: function () {
    return {
      majorTicksValues: convertTicksToValues(this._majorTicks),
      minorTicksValues: convertTicksToValues(this._minorTicks)
    };
  },
  estimateTickInterval: function (canvas) {
    const that = this;
    that.updateCanvas(canvas);
    return that._tickInterval !== that._getTicks(that._getViewportRange(), _common.noop, true).tickInterval;
  },
  setTicks: function (ticks) {
    const majors = ticks.majorTicks || [];
    this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));
    this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));
    this._isSynchronized = true;
  },
  _adjustDivisionFactor: function (val) {
    return val;
  },
  _getTicks: function (viewPort, incidentOccurred, skipTickGeneration) {
    const that = this;
    const options = that._options;
    const customTicks = options.customTicks;
    const customMinorTicks = options.customMinorTicks;
    return getTickGenerator(options, incidentOccurred || that._incidentOccurred, skipTickGeneration, that._translator.getBusinessRange().isEmpty(), that._adjustDivisionFactor.bind(that), viewPort)({
      min: viewPort.minVisible,
      max: viewPort.maxVisible,
      categories: viewPort.categories,
      isSpacedMargin: viewPort.isSpacedMargin
    }, that._getScreenDelta(), options.tickInterval, options.label.overlappingBehavior === 'ignore' || options.forceUserTickInterval, {
      majors: customTicks,
      minors: customMinorTicks
    }, options.minorTickInterval, options.minorTickCount, that._initialBreaks);
  },
  _createTicksAndLabelFormat: function (range, incidentOccurred) {
    const options = this._options;
    const ticks = this._getTicks(range, incidentOccurred, false);
    if (!range.isEmpty() && options.type === _axes_constants.default.discrete && options.dataType === 'datetime' && !this._hasLabelFormat && ticks.ticks.length) {
      options.label.format = _format_helper.default.getDateFormatByTicks(ticks.ticks);
    }
    return ticks;
  },
  getAggregationInfo(useAllAggregatedPoints, range) {
    var _that$_seriesData;
    const that = this;
    const options = that._options;
    const marginOptions = that._marginOptions;
    const businessRange = new _range.Range(that.getTranslator().getBusinessRange()).addRange(range);
    const visualRange = that.getViewport();
    const minVisible = (visualRange === null || visualRange === void 0 ? void 0 : visualRange.startValue) ?? businessRange.minVisible;
    const maxVisible = (visualRange === null || visualRange === void 0 ? void 0 : visualRange.endValue) ?? businessRange.maxVisible;
    let ticks = [];
    if (options.type === _axes_constants.default.discrete && options.aggregateByCategory) {
      return {
        aggregateByCategory: true
      };
    }
    const aggregationInterval = options.aggregationInterval;
    let aggregationGroupWidth = options.aggregationGroupWidth;
    if (!aggregationGroupWidth && marginOptions) {
      if (marginOptions.checkInterval) {
        aggregationGroupWidth = options.axisDivisionFactor;
      }
      if (marginOptions.sizePointNormalState) {
        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor);
      }
    }
    const minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;
    const generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, that._getScreenDelta(), minInterval);
    const tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, (_that$_seriesData = that._seriesData) === null || _that$_seriesData === void 0 ? void 0 : _that$_seriesData.breaks).tickInterval;
    if (options.type !== _axes_constants.default.discrete) {
      const min = useAllAggregatedPoints ? businessRange.min : minVisible;
      const max = useAllAggregatedPoints ? businessRange.max : maxVisible;
      if ((0, _type.isDefined)(min) && (0, _type.isDefined)(max)) {
        const add = (0, _utils.getAddFunction)({
          base: options.logarithmBase,
          axisType: options.type,
          dataType: options.dataType
        }, false);
        let start = min;
        let end = max;
        if (!useAllAggregatedPoints && (0, _type.isDefined)(tickInterval)) {
          const maxMinDistance = Math.max(that.calculateInterval(max, min), options.dataType === 'datetime' ? _date.default.dateToMilliseconds(tickInterval) : tickInterval);
          start = add(min, maxMinDistance, -1);
          end = add(max, maxMinDistance);
        }
        start = start < businessRange.min ? businessRange.min : start;
        end = end > businessRange.max ? businessRange.max : end;
        const breaks = that._getScaleBreaks(options, {
          minVisible: start,
          maxVisible: end
        }, that._series, that.isArgumentAxis);
        const filteredBreaks = that._filterBreaks(breaks, {
          minVisible: start,
          maxVisible: end
        }, options.breakStyle);
        ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks;
      }
    }
    that._aggregationInterval = tickInterval;
    return {
      interval: tickInterval,
      ticks: ticks
    };
  },
  getTickInterval() {
    return this._tickInterval;
  },
  getAggregationInterval() {
    return this._aggregationInterval;
  },
  createTicks: function (canvas) {
    const that = this;
    const renderer = that._renderer;
    const options = that._options;
    if (!canvas) {
      return;
    }
    that._isSynchronized = false;
    that.updateCanvas(canvas);
    const range = that._getViewportRange();
    that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);
    that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _common.noop, true).tickInterval; // tickInterval calculation

    const margins = this._calculateValueMargins();
    range.addRange({
      minVisible: margins.minValue,
      maxVisible: margins.maxValue,
      isSpacedMargin: margins.isSpacedMargin
    });
    const ticks = that._createTicksAndLabelFormat(range);
    const boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());
    if (options.showCustomBoundaryTicks && boundaryTicks.length) {
      that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));
      if (boundaryTicks.length > 1) {
        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)));
      }
    } else {
      that._boundaryTicks = [];
    }
    const minors = (ticks.minorTicks || []).filter(function (minor) {
      return !boundaryTicks.some(function (boundary) {
        return (0, _utils.valueOf)(boundary) === (0, _utils.valueOf)(minor);
      });
    });
    that._tickInterval = ticks.tickInterval;
    that._minorTickInterval = ticks.minorTickInterval;
    const oldMajorTicks = that._majorTicks || [];
    const majorTicksByValues = oldMajorTicks.reduce((r, t) => {
      r[t.value.valueOf()] = t;
      return r;
    }, {});
    const sameType = (0, _type.type)(ticks.ticks[0]) === (0, _type.type)(oldMajorTicks[0] && oldMajorTicks[0].value);
    const skippedCategory = that._getSkippedCategory(ticks.ticks);
    const majorTicks = ticks.ticks.map(v => {
      const tick = majorTicksByValues[v.valueOf()];
      if (tick && sameType) {
        delete majorTicksByValues[v.valueOf()];
        tick.setSkippedCategory(skippedCategory);
        return tick;
      } else {
        return createMajorTick(that, renderer, skippedCategory)(v);
      }
    });
    that._majorTicks = majorTicks;
    const oldMinorTicks = that._minorTicks || [];
    that._minorTicks = minors.map((v, i) => {
      const minorTick = oldMinorTicks[i];
      if (minorTick) {
        minorTick.updateValue(v);
        return minorTick;
      }
      return createMinorTick(that, renderer)(v);
    });
    that._ticksToRemove = Object.keys(majorTicksByValues).map(k => majorTicksByValues[k]).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));
    that._ticksToRemove.forEach(t => {
      var _t$label;
      return (_t$label = t.label) === null || _t$label === void 0 ? void 0 : _t$label.removeTitle();
    });
    if (ticks.breaks) {
      that._seriesData.breaks = ticks.breaks;
    }
    that._reinitTranslator(that._getViewportRange());
  },
  _reinitTranslator: function (range) {
    const that = this;
    const translator = that._translator;
    if (that._isSynchronized) {
      return;
    }
    translator.updateBusinessRange(range);
  },
  _getViewportRange() {
    return this.adjustViewport(this._seriesData);
  },
  setMarginOptions: function (options) {
    this._marginOptions = options;
  },
  getMarginOptions() {
    return this._marginOptions ?? {};
  },
  _calculateRangeInterval: function (interval) {
    const isDateTime = this._options.dataType === 'datetime';
    const minArgs = [];
    const addToArgs = function (value) {
      (0, _type.isDefined)(value) && minArgs.push(isDateTime ? _date.default.dateToMilliseconds(value) : value);
    };
    addToArgs(this._tickInterval);
    addToArgs(this._estimatedTickInterval);
    (0, _type.isDefined)(interval) && minArgs.push(interval);
    addToArgs(this._aggregationInterval);
    return this._calculateWorkWeekInterval(_min.apply(this, minArgs));
  },
  _calculateWorkWeekInterval(businessInterval) {
    const options = this._options;
    if (options.dataType === 'datetime' && options.workdaysOnly && businessInterval) {
      const workWeek = options.workWeek.length * dateIntervals.day;
      const weekend = dateIntervals.week - workWeek;
      if (workWeek !== businessInterval && weekend < businessInterval) {
        const weekendsCount = Math.ceil(businessInterval / dateIntervals.week);
        businessInterval = businessInterval - weekend * weekendsCount;
      } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {
        businessInterval = dateIntervals.day;
      }
    }
    return businessInterval;
  },
  _getConvertIntervalCoefficient(intervalInPx, screenDelta) {
    const ratioOfCanvasRange = this._translator.ratioOfCanvasRange();
    return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta));
  },
  _calculateValueMargins(ticks) {
    this._resetMargins();
    const that = this;
    const margins = that.getMarginOptions();
    const marginSize = (margins.size || 0) / 2;
    const options = that._options;
    const dataRange = that._getViewportRange();
    const viewPort = that.getViewport();
    const screenDelta = that._getScreenDelta();
    const isDiscrete = (options.type || '').indexOf(_axes_constants.default.discrete) !== -1;
    const valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !that.customPositionIsBoundaryOrthogonalAxis();
    const translator = that._translator;
    const minValueMargin = options.minValueMargin;
    const maxValueMargin = options.maxValueMargin;
    let minPadding = 0;
    let maxPadding = 0;
    let interval = 0;
    let rangeInterval;
    if (dataRange.stubData || !screenDelta) {
      return {
        startPadding: 0,
        endPadding: 0
      };
    }
    if (that.isArgumentAxis && margins.checkInterval) {
      rangeInterval = that._calculateRangeInterval(dataRange.interval);
      const pxInterval = translator.getInterval(rangeInterval);
      if (isFinite(pxInterval)) {
        interval = Math.ceil(pxInterval / (2 * that._getConvertIntervalCoefficient(pxInterval, screenDelta)));
      } else {
        rangeInterval = 0;
      }
    }
    let minPercentPadding;
    let maxPercentPadding;
    const maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;
    if (valueMarginsEnabled) {
      if ((0, _type.isDefined)(minValueMargin)) {
        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0;
      } else if (!that.isArgumentAxis && margins.checkInterval && (0, _utils.valueOf)(dataRange.minVisible) > 0 && (0, _utils.valueOf)(dataRange.minVisible) === (0, _utils.valueOf)(dataRange.min)) {
        minPadding = MIN_BAR_MARGIN;
      } else {
        minPadding = Math.max(marginSize, interval);
        minPadding = Math.min(maxPaddingValue, minPadding);
      }
      if ((0, _type.isDefined)(maxValueMargin)) {
        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0;
      } else if (!that.isArgumentAxis && margins.checkInterval && (0, _utils.valueOf)(dataRange.maxVisible) < 0 && (0, _utils.valueOf)(dataRange.maxVisible) === (0, _utils.valueOf)(dataRange.max)) {
        maxPadding = MIN_BAR_MARGIN;
      } else {
        maxPadding = Math.max(marginSize, interval);
        maxPadding = Math.min(maxPaddingValue, maxPadding);
      }
    }
    const percentStick = margins.percentStick && !this.isArgumentAxis;
    if (percentStick) {
      if (_abs(dataRange.max) === 1) {
        maxPadding = 0;
      }
      if (_abs(dataRange.min) === 1) {
        minPadding = 0;
      }
    }
    const canvasStartEnd = that._getCanvasStartEnd();
    const commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);
    const screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;
    if (minPercentPadding !== undefined || maxPercentPadding !== undefined) {
      if (minPercentPadding !== undefined) {
        minPadding = screenDeltaWithMargins * minPercentPadding;
      }
      if (maxPercentPadding !== undefined) {
        maxPadding = screenDeltaWithMargins * maxPercentPadding;
      }
    }
    let minValue;
    let maxValue;
    if (options.type !== _axes_constants.default.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && options.endOnTick !== false) {
      const length = ticks.length;
      const firstTickPosition = translator.translate(ticks[0].value);
      const lastTickPosition = translator.translate(ticks[length - 1].value);
      const invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;
      const minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);
      const maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);
      if (minTickPadding > minPadding || maxTickPadding > maxPadding) {
        const commonPadding = maxTickPadding + minTickPadding;
        const coeff = that._getConvertIntervalCoefficient(commonPadding, screenDelta);
        if (minTickPadding >= minPadding) {
          minValue = ticks[0].value;
        }
        if (maxTickPadding >= maxPadding) {
          maxValue = ticks[length - 1].value;
        }
        minPadding = _max(minTickPadding, minPadding) / coeff;
        maxPadding = _max(maxTickPadding, maxPadding) / coeff;
      }
    }
    minPercentPadding = minPercentPadding === undefined ? minPadding / screenDeltaWithMargins : minPercentPadding;
    maxPercentPadding = maxPercentPadding === undefined ? maxPadding / screenDeltaWithMargins : maxPercentPadding;
    if (!isDiscrete) {
      if (this._translator.isInverted()) {
        minValue = minValue ?? translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);
        maxValue = maxValue ?? translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1);
      } else {
        minValue = minValue ?? translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);
        maxValue = maxValue ?? translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1);
      }
    }
    const {
      correctedMin,
      correctedMax,
      start,
      end
    } = that.getCorrectedValuesToZero(minValue, maxValue);
    minPadding = start ?? minPadding;
    maxPadding = end ?? maxPadding;
    return {
      startPadding: translator.isInverted() ? maxPadding : minPadding,
      endPadding: translator.isInverted() ? minPadding : maxPadding,
      minValue: correctedMin ?? minValue,
      maxValue: correctedMax ?? maxValue,
      interval: rangeInterval,
      isSpacedMargin: minPadding === maxPadding && minPadding !== 0
    };
  },
  getCorrectedValuesToZero(minValue, maxValue) {
    const that = this;
    const translator = that._translator;
    const canvasStartEnd = that._getCanvasStartEnd();
    const dataRange = that._getViewportRange();
    const screenDelta = that._getScreenDelta();
    const options = that._options;
    let start;
    let end;
    let correctedMin;
    let correctedMax;
    const correctZeroLevel = (minPoint, maxPoint) => {
      const minExpectedPadding = _abs(canvasStartEnd.start - minPoint);
      const maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);
      const coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);
      start = minExpectedPadding / coeff;
      end = maxExpectedPadding / coeff;
    };
    if (!that.isArgumentAxis && options.dataType !== 'datetime') {
      if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {
        correctZeroLevel(translator.translate(0), translator.translate(maxValue));
        correctedMin = 0;
      }
      if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {
        correctZeroLevel(translator.translate(minValue), translator.translate(0));
        correctedMax = 0;
      }
    }
    return {
      start: isFinite(start) ? start : null,
      end: isFinite(end) ? end : null,
      correctedMin,
      correctedMax
    };
  },
  applyMargins() {
    if (this._isSynchronized) {
      return;
    }
    const margins = this._calculateValueMargins(this._majorTicks);
    const canvas = (0, _extend.extend)({}, this._canvas, {
      startPadding: margins.startPadding,
      endPadding: margins.endPadding
    });
    this._translator.updateCanvas(this._processCanvas(canvas));
    if (isFinite(margins.interval)) {
      const br = this._translator.getBusinessRange();
      br.addRange({
        interval: margins.interval
      });
      this._translator.updateBusinessRange(br);
    }
  },
  _resetMargins: function () {
    this._reinitTranslator(this._getViewportRange());
    if (this._canvas) {
      this._translator.updateCanvas(this._processCanvas(this._canvas));
    }
  },
  _createConstantLines() {
    const constantLines = (this._options.constantLines || []).map(o => (0, _constant_line.default)(this, o));
    this._outsideConstantLines = constantLines.filter(l => l.labelPosition === 'outside');
    this._insideConstantLines = constantLines.filter(l => l.labelPosition === 'inside');
  },
  draw: function (canvas, borderOptions) {
    const that = this;
    const options = this._options;
    that.borderOptions = borderOptions || {
      visible: false
    };
    that._resetMargins();
    that.createTicks(canvas);
    that.applyMargins();
    that._clearAxisGroups();
    initTickCoords(that._majorTicks);
    initTickCoords(that._minorTicks);
    initTickCoords(that._boundaryTicks);
    that._axisGroup.append(that._axesContainerGroup);
    that._drawAxis();
    that._drawTitle();
    drawTickMarks(that._majorTicks, options.tick);
    drawTickMarks(that._minorTicks, options.minorTick);
    drawTickMarks(that._boundaryTicks, options.tick);
    const drawGridLine = that._getGridLineDrawer();
    drawGrids(that._majorTicks, drawGridLine);
    drawGrids(that._minorTicks, drawGridLine);
    callAction(that._majorTicks, 'drawLabel', that._getViewportRange(), that._getTemplate(options.label.template));
    that._templatesRendered && that._templatesRendered.reject();
    that._templatesRendered = new _deferred.Deferred();
    that._majorTicks.forEach(function (tick) {
      tick.labelRotationAngle = 0;
      tick.labelAlignment = undefined;
      tick.labelOffset = 0;
    });
    callAction(that._outsideConstantLines.concat(that._insideConstantLines), 'draw');
    callAction(that._strips, 'draw');
    that._dateMarkers = that._drawDateMarkers() || [];
    that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);
    that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);
    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);
    that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);
    if (that._constantLinesGroup) {
      that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);
      that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);
      that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);
      that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);
      that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);
      that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under);
    }
    that._measureTitle();
    (0, _axes_utils.measureLabels)(that._majorTicks);
    !options.label.template && that._applyWordWrap();
    (0, _axes_utils.measureLabels)(that._outsideConstantLines);
    (0, _axes_utils.measureLabels)(that._insideConstantLines);
    (0, _axes_utils.measureLabels)(that._strips);
    (0, _axes_utils.measureLabels)(that._dateMarkers);
    that._adjustConstantLineLabels(that._insideConstantLines);
    that._adjustStripLabels();
    let offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);
    if (!that._translator.getBusinessRange().isEmpty()) {
      that._setLabelsPlacement();
      offset = that._adjustLabels(offset);
    }
    _deferred.when.apply(this, that._majorTicks.map(tick => tick.getTemplateDeferred())).done(() => {
      that._templatesRendered.resolve();
    });
    offset = that._adjustDateMarkers(offset);
    that._adjustTitle(offset);
  },
  getTemplatesDef() {
    return this._templatesRendered;
  },
  setRenderedState(state) {
    this._drawn = state;
  },
  isRendered() {
    return this._drawn;
  },
  _applyWordWrap() {
    const that = this;
    let convertedTickInterval;
    let textWidth;
    let textHeight;
    const options = this._options;
    const tickInterval = that._tickInterval;
    if ((0, _type.isDefined)(tickInterval)) {
      convertedTickInterval = that.getTranslator().getInterval(options.dataType === 'datetime' ? _date.default.dateToMilliseconds(tickInterval) : tickInterval);
    }
    const displayMode = that._validateDisplayMode(options.label.displayMode);
    const overlappingMode = that._validateOverlappingMode(options.label.overlappingBehavior, displayMode);
    const wordWrapMode = options.label.wordWrap || 'none';
    const overflowMode = options.label.textOverflow || 'none';
    if ((wordWrapMode !== 'none' || overflowMode !== 'none') && displayMode !== ROTATE && overlappingMode !== ROTATE && overlappingMode !== 'auto') {
      const usefulSpace = (0, _type.isDefined)(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : undefined;
      if (that._isHorizontal) {
        textWidth = convertedTickInterval;
        textHeight = usefulSpace;
      } else {
        textWidth = usefulSpace;
        textHeight = convertedTickInterval;
      }
      let correctByWidth = false;
      let correctByHeight = false;
      if (textWidth) {
        if (that._majorTicks.some(tick => tick.labelBBox.width > textWidth)) {
          correctByWidth = true;
        }
      }
      if (textHeight) {
        if (that._majorTicks.some(tick => tick.labelBBox.height > textHeight)) {
          correctByHeight = true;
        }
      }
      if (correctByWidth || correctByHeight) {
        that._majorTicks.forEach(tick => {
          tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label);
        });
        (0, _axes_utils.measureLabels)(that._majorTicks);
      }
    }
  },
  _measureTitle: _common.noop,
  animate() {
    callAction(this._majorTicks, 'animateLabels');
  },
  updateSize(canvas, animate) {
    let updateTitle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    const that = this;
    that.updateCanvas(canvas);
    if (updateTitle) {
      that._checkTitleOverflow();
      that._measureTitle();
      that._updateTitleCoords();
    }
    that._reinitTranslator(that._getViewportRange());
    that.applyMargins();
    const animationEnabled = !that._firstDrawing && animate;
    const options = that._options;
    initTickCoords(that._majorTicks);
    initTickCoords(that._minorTicks);
    initTickCoords(that._boundaryTicks);
    if (that._resetApplyingAnimation && !that._firstDrawing) {
      that._resetStartCoordinates();
    }
    cleanUpInvalidTicks(that._majorTicks);
    cleanUpInvalidTicks(that._minorTicks);
    cleanUpInvalidTicks(that._boundaryTicks);
    if (that._axisElement) {
      that._updateAxisElementPosition();
    }
    updateTicksPosition(that._majorTicks, options.tick, animationEnabled);
    updateTicksPosition(that._minorTicks, options.minorTick, animationEnabled);
    updateTicksPosition(that._boundaryTicks, options.tick);
    callAction(that._majorTicks, 'updateLabelPosition', animationEnabled);
    that._outsideConstantLines.concat(that._insideConstantLines || []).forEach(l => l.updatePosition(animationEnabled));
    callAction(that._strips, 'updatePosition', animationEnabled);
    updateGridsPosition(that._majorTicks, animationEnabled);
    updateGridsPosition(that._minorTicks, animationEnabled);
    if (animationEnabled) {
      callAction(that._ticksToRemove || [], 'fadeOutElements');
    }
    that.prepareAnimation();
    that._ticksToRemove = null;
    if (!that._translator.getBusinessRange().isEmpty()) {
      that._firstDrawing = false;
    }
    that._resetApplyingAnimation = false;
    that._updateLabelsPosition();
  },
  _updateLabelsPosition: _common.noop,
  prepareAnimation() {
    const that = this;
    const action = 'saveCoords';
    callAction(that._majorTicks, action);
    callAction(that._minorTicks, action);
    callAction(that._insideConstantLines, action);
    callAction(that._outsideConstantLines, action);
    callAction(that._strips, action);
  },
  _resetStartCoordinates() {
    const that = this;
    const action = 'resetCoordinates';
    callAction(that._majorTicks, action);
    callAction(that._minorTicks, action);
    callAction(that._insideConstantLines, action);
    callAction(that._outsideConstantLines, action);
    callAction(that._strips, action);
  },
  applyClipRects: function (elementsClipID, canvasClipID) {
    this._axisGroup.attr({
      'clip-path': canvasClipID
    });
    this._axisStripGroup.attr({
      'clip-path': elementsClipID
    });
    this._axisElementsGroup.attr({
      'clip-path': canvasClipID
    });
  },
  _validateVisualRange(optionValue) {
    const range = (0, _utils.getVizRangeObject)(optionValue);
    if (range.startValue !== undefined) {
      range.startValue = this.validateUnit(range.startValue);
    }
    if (range.endValue !== undefined) {
      range.endValue = this.validateUnit(range.endValue);
    }
    return (0, _utils.convertVisualRangeObject)(range, !_isArray(optionValue));
  },
  _validateOptions(options) {
    options.wholeRange = this._validateVisualRange(options.wholeRange);
    options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);
    this._setVisualRange(options._customVisualRange);
  },
  validate() {
    const that = this;
    const options = that._options;
    const dataType = that.isArgumentAxis ? options.argumentType : options.valueType;
    const parser = dataType ? (0, _parse_utils.getParser)(dataType) : function (unit) {
      return unit;
    };
    that.parser = parser;
    options.dataType = dataType;
    that._validateOptions(options);
  },
  resetVisualRange(isSilent) {
    this._seriesData.minVisible = this._seriesData.min;
    this._seriesData.maxVisible = this._seriesData.max;
    this.handleZooming([null, null], {
      start: !!isSilent,
      end: !!isSilent
    });
  },
  _setVisualRange(visualRange, allowPartialUpdate) {
    const range = this.adjustRange((0, _utils.getVizRangeObject)(visualRange));
    if (allowPartialUpdate) {
      (0, _type.isDefined)(range.startValue) && (this._viewport.startValue = range.startValue);
      (0, _type.isDefined)(range.endValue) && (this._viewport.endValue = range.endValue);
    } else {
      this._viewport = range;
    }
  },
  _applyZooming(visualRange, allowPartialUpdate) {
    const that = this;
    that._resetVisualRangeOption();
    that._setVisualRange(visualRange, allowPartialUpdate);
    const viewPort = that.getViewport();
    that._seriesData.userBreaks = that._getScaleBreaks(that._options, {
      minVisible: viewPort.startValue,
      maxVisible: viewPort.endValue
    }, that._series, that.isArgumentAxis);
    that._translator.updateBusinessRange(that._getViewportRange());
  },
  getZoomStartEventArg(event, actionType) {
    return {
      axis: this,
      range: this.visualRange(),
      cancel: false,
      event,
      actionType
    };
  },
  _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {
    const newRange = this.visualRange();
    return {
      axis: this,
      previousRange,
      range: newRange,
      cancel: false,
      event,
      actionType,
      zoomFactor,
      shift,
      // backwards
      rangeStart: newRange.startValue,
      rangeEnd: newRange.endValue
    };
  },
  getZoomBounds() {
    const wholeRange = (0, _utils.getVizRangeObject)(this._options.wholeRange);
    const range = this.getTranslator().getBusinessRange();
    const secondPriorityRange = {
      startValue: getZoomBoundValue(this._initRange.startValue, range.min),
      endValue: getZoomBoundValue(this._initRange.endValue, range.max)
    };
    return {
      startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),
      endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)
    };
  },
  setInitRange() {
    this._initRange = {};
    if (Object.keys(this._options.wholeRange || {}).length === 0) {
      this._initRange = this.getZoomBounds();
    }
  },
  _resetVisualRangeOption() {
    this._options._customVisualRange = {};
  },
  getTemplatesGroups() {
    const ticks = this._majorTicks;
    if (ticks) {
      return this._majorTicks.map(tick => {
        return tick.templateContainer;
      }).filter(item => (0, _type.isDefined)(item));
    } else {
      return [];
    }
  },
  setCustomVisualRange(range) {
    this._options._customVisualRange = range;
  },
  // API
  visualRange() {
    const that = this;
    const args = arguments;
    let visualRange;
    if (args.length === 0) {
      const adjustedRange = that._getAdjustedBusinessRange();
      let startValue = adjustedRange.minVisible;
      let endValue = adjustedRange.maxVisible;
      if (that._options.type === _axes_constants.default.discrete) {
        startValue = startValue ?? adjustedRange.categories[0];
        endValue = endValue ?? adjustedRange.categories[adjustedRange.categories.length - 1];
        return {
          startValue,
          endValue,
          categories: (0, _utils.getCategoriesInfo)(adjustedRange.categories, startValue, endValue).categories
        };
      }
      return {
        startValue,
        endValue
      };
    } else if (_isArray(args[0])) {
      visualRange = args[0];
    } else if ((0, _type.isPlainObject)(args[0])) {
      visualRange = (0, _extend.extend)({}, args[0]);
    } else {
      visualRange = [args[0], args[1]];
    }
    const zoomResults = that.handleZooming(visualRange, args[1]);
    if (!zoomResults.isPrevented) {
      that._visualRange(that, zoomResults);
    }
  },
  handleZooming(visualRange, preventEvents, domEvent, action) {
    const that = this;
    preventEvents = preventEvents || {};
    if ((0, _type.isDefined)(visualRange)) {
      visualRange = that._validateVisualRange(visualRange);
      visualRange.action = action;
    }
    const zoomStartEvent = that.getZoomStartEventArg(domEvent, action);
    const previousRange = zoomStartEvent.range;
    !preventEvents.start && that._eventTrigger('zoomStart', zoomStartEvent);
    const zoomResults = {
      isPrevented: zoomStartEvent.cancel,
      skipEventRising: preventEvents.skipEventRising,
      range: visualRange || zoomStartEvent.range
    };
    if (!zoomStartEvent.cancel) {
      (0, _type.isDefined)(visualRange) && that._applyZooming(visualRange, preventEvents.allowPartialUpdate);
      if (!(0, _type.isDefined)(that._storedZoomEndParams)) {
        that._storedZoomEndParams = {
          startRange: previousRange,
          type: this.getOptions().type
        };
      }
      that._storedZoomEndParams.event = domEvent;
      that._storedZoomEndParams.action = action;
      that._storedZoomEndParams.prevent = !!preventEvents.end;
    }
    return zoomResults;
  },
  handleZoomEnd() {
    const that = this;
    if ((0, _type.isDefined)(that._storedZoomEndParams) && !that._storedZoomEndParams.prevent) {
      const previousRange = that._storedZoomEndParams.startRange;
      const domEvent = that._storedZoomEndParams.event;
      const action = that._storedZoomEndParams.action;
      const previousBusinessRange = {
        minVisible: previousRange.startValue,
        maxVisible: previousRange.endValue,
        categories: previousRange.categories
      };
      const typeIsNotChanged = that.getOptions().type === that._storedZoomEndParams.type;
      const shift = typeIsNotChanged ? (0, _math2.adjust)(that.getVisualRangeCenter() - that.getVisualRangeCenter(previousBusinessRange, false)) : NaN;
      const zoomFactor = typeIsNotChanged ? +(Math.round(that.getVisualRangeLength(previousBusinessRange) / (that.getVisualRangeLength() || 1) + 'e+2') + 'e-2') : NaN;
      const zoomEndEvent = that._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);
      zoomEndEvent.cancel = that.checkZoomingLowerLimitOvercome(zoomFactor === 1 ? 'pan' : 'zoom', zoomFactor).stopInteraction;
      that._eventTrigger('zoomEnd', zoomEndEvent);
      if (zoomEndEvent.cancel) {
        that._restorePreviousVisualRange(previousRange);
      }
      that._storedZoomEndParams = null;
    }
  },
  _restorePreviousVisualRange(previousRange) {
    const that = this;
    that._storedZoomEndParams = null;
    that._applyZooming(previousRange);
    that._visualRange(that, previousRange);
  },
  checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {
    const that = this;
    const options = that._options;
    const translator = that._translator;
    let minZoom = options.minVisualRangeLength;
    let correctedRange = range;
    let visualRange;
    let isOvercoming = actionType === 'zoom' && zoomFactor >= 1;
    const businessRange = translator.getBusinessRange();
    if (range) {
      visualRange = that.adjustRange((0, _utils.getVizRangeObject)(range));
      visualRange = {
        minVisible: visualRange.startValue,
        maxVisible: visualRange.endValue,
        categories: businessRange.categories
      };
    }
    const beforeVisualRangeLength = that.getVisualRangeLength(businessRange);
    const afterVisualRangeLength = that.getVisualRangeLength(visualRange);
    if ((0, _type.isDefined)(minZoom) || options.type === 'discrete') {
      minZoom = translator.convert(minZoom);
      if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {
        correctedRange = (0, _utils.getVizRangeObject)(translator.getRangeByMinZoomValue(minZoom, visualRange));
        isOvercoming = false;
      } else {
        isOvercoming &= minZoom > afterVisualRangeLength;
      }
    } else {
      const canvasLength = that._translator.canvasLength;
      const fullRange = {
        minVisible: businessRange.min,
        maxVisible: businessRange.max,
        categories: businessRange.categories
      };
      isOvercoming &= that.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength;
    }
    return {
      stopInteraction: !!isOvercoming,
      correctedRange: correctedRange
    };
  },
  isExtremePosition(isMax) {
    let extremeDataValue;
    let seriesData;
    if (this._options.type === 'discrete') {
      seriesData = this._translator.getBusinessRange();
      extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0];
    } else {
      seriesData = this.getZoomBounds(); // T702708
      extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue;
    }
    const translator = this.getTranslator();
    const extremePoint = translator.translate(extremeDataValue);
    const visualRange = this.visualRange();
    const visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);
    return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD;
  },
  getViewport() {
    return this._viewport;
  },
  getFullTicks: function () {
    const majors = this._majorTicks || [];
    if (this._options.type === _axes_constants.default.discrete) {
      return convertTicksToValues(majors);
    } else {
      return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function (a, b) {
        return (0, _utils.valueOf)(a) - (0, _utils.valueOf)(b);
      });
    }
  },
  measureLabels: function (canvas, withIndents) {
    const that = this;
    const options = that._options;
    const widthAxis = options.visible ? options.width : 0;
    let ticks;
    const indent = withIndents ? options.label.indentFromAxis + options.tick.length * 0.5 : 0;
    let tickInterval;
    const viewportRange = that._getViewportRange();
    if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {
      return {
        height: widthAxis,
        width: widthAxis,
        x: 0,
        y: 0
      };
    }
    if (that._majorTicks) {
      ticks = convertTicksToValues(that._majorTicks);
    } else {
      that.updateCanvas(canvas);
      ticks = that._createTicksAndLabelFormat(viewportRange, _common.noop);
      tickInterval = ticks.tickInterval;
      ticks = ticks.ticks;
    }
    const maxText = ticks.reduce(function (prevLabel, tick, index) {
      const label = that.formatLabel(tick, options.label, viewportRange, undefined, tickInterval, ticks);
      if (prevLabel.length < label.length) {
        return label;
      } else {
        return prevLabel;
      }
    }, that.formatLabel(ticks[0], options.label, viewportRange, undefined, tickInterval, ticks));
    const text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);
    const box = text.getBBox();
    text.remove();
    return {
      x: box.x,
      y: box.y,
      width: box.width + indent,
      height: box.height + indent
    };
  },
  _setLabelsPlacement: function () {
    if (!this._options.label.visible) {
      return;
    }
    const that = this;
    const labelOpt = that._options.label;
    const displayMode = that._validateDisplayMode(labelOpt.displayMode);
    const overlappingMode = that._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);
    const ignoreOverlapping = overlappingMode === 'none' || overlappingMode === 'ignore';
    const behavior = {
      rotationAngle: labelOpt.rotationAngle,
      staggeringSpacing: labelOpt.staggeringSpacing
    };
    let notRecastStep;
    const boxes = that._majorTicks.map(function (tick) {
      return tick.labelBBox;
    });
    let step = that._getStep(boxes);
    switch (displayMode) {
      case ROTATE:
        if (ignoreOverlapping) {
          notRecastStep = true;
          step = 1;
        }
        that._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);
        break;
      case 'stagger':
        if (ignoreOverlapping) {
          step = 2;
        }
        that._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);
        break;
      default:
        that._applyLabelOverlapping(boxes, overlappingMode, step, behavior);
    }
  },
  _applyLabelOverlapping: function (boxes, mode, step, behavior) {
    const that = this;
    const labelOpt = that._options.label;
    const majorTicks = that._majorTicks;
    if (mode === 'none' || mode === 'ignore') {
      return;
    }
    const checkLabels = function (box, index, array) {
      if (index === 0) {
        return false;
      }
      return _axes_constants.default.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment);
    };
    if (step > 1 && boxes.some(checkLabels)) {
      that._applyLabelMode(mode, step, boxes, behavior);
    }
    that._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);
    that._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment);
  },
  _applyLabelMode: function (mode, step, boxes, behavior, notRecastStep) {
    const that = this;
    const majorTicks = that._majorTicks;
    const labelOpt = that._options.label;
    const angle = behavior.rotationAngle;
    let labelHeight;
    let alignment;
    let func;
    switch (mode) {
      case ROTATE:
        if (!labelOpt.userAlignment) {
          alignment = angle < 0 ? RIGHT : LEFT;
          if (angle % 90 === 0) {
            alignment = CENTER;
          }
        }
        step = notRecastStep ? step : that._getStep(boxes, angle);
        func = function (tick) {
          const contentContainer = tick.getContentContainer();
          if (!contentContainer) {
            return;
          }
          contentContainer.rotate(angle);
          tick.labelRotationAngle = angle;
          alignment && (tick.labelAlignment = alignment);
        };
        updateLabels(majorTicks, step, func);
        break;
      case 'stagger':
        labelHeight = that._getMaxLabelHeight(boxes, behavior.staggeringSpacing);
        func = function (tick, index) {
          if (index / (step - 1) % 2 !== 0) {
            tick.labelOffset = labelHeight;
          }
        };
        updateLabels(majorTicks, step - 1, func);
        break;
      case 'auto':
      case '_auto':
        if (step === 2) {
          that._applyLabelMode('stagger', step, boxes, behavior);
        } else {
          that._applyLabelMode(ROTATE, step, boxes, {
            rotationAngle: getOptimalAngle(boxes, labelOpt)
          });
        }
        break;
      default:
        updateLabels(majorTicks, step);
        break;
    }
  },
  getMarkerTrackers: _common.noop,
  _drawDateMarkers: _common.noop,
  _adjustDateMarkers: _common.noop,
  coordsIn: _common.noop,
  areCoordsOutsideAxis: _common.noop,
  _getSkippedCategory: _common.noop,
  _initAxisPositions: _common.noop,
  _drawTitle: _common.noop,
  _updateTitleCoords: _common.noop,
  _adjustConstantLineLabels: _common.noop,
  _createTranslator: function () {
    return new _translator2d.Translator2D({}, {}, {});
  },
  _updateTranslator: function () {
    const translator = this._translator;
    translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions());
  },
  _getTranslatorOptions: function () {
    var _options$workWeek2, _options$breakStyle;
    const options = this._options;
    return {
      isHorizontal: this._isHorizontal,
      shiftZeroValue: !this.isArgumentAxis,
      interval: options.semiDiscreteInterval,
      firstDayOfWeek: (_options$workWeek2 = options.workWeek) === null || _options$workWeek2 === void 0 ? void 0 : _options$workWeek2[0],
      stick: this._getStick(),
      breaksSize: ((_options$breakStyle = options.breakStyle) === null || _options$breakStyle === void 0 ? void 0 : _options$breakStyle.width) ?? 0
    };
  },
  getVisibleArea() {
    const canvas = this._getCanvasStartEnd();
    return [canvas.start, canvas.end].sort((a, b) => a - b);
  },
  _getCanvasStartEnd: function () {
    const isHorizontal = this._isHorizontal;
    const canvas = this._canvas || {};
    const invert = this._translator.getBusinessRange().invert;
    const coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];
    invert && coords.reverse();
    return {
      start: coords[0],
      end: coords[1]
    };
  },
  _getScreenDelta: function () {
    const that = this;
    const canvas = that._getCanvasStartEnd();
    const breaks = that._seriesData ? that._seriesData.breaks || [] : [];
    const breaksLength = breaks.length;
    const screenDelta = _abs(canvas.start - canvas.end);
    return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0);
  },
  _getScaleBreaks: function () {
    return [];
  },
  _filterBreaks: function () {
    return [];
  },
  _adjustTitle: _common.noop,
  _checkTitleOverflow: _common.noop,
  getSpiderTicks: _common.noop,
  setSpiderTicks: _common.noop,
  _checkBoundedLabelsOverlapping: _common.noop,
  _checkShiftedLabels: _common.noop,
  drawScaleBreaks: _common.noop,
  _visualRange: _common.noop,
  _rotateConstantLine: _common.noop,
  applyVisualRangeSetter(visualRangeSetter) {
    this._visualRange = visualRangeSetter;
  },
  // T642779, T714928, T810801
  getCategoriesSorter(argCategories) {
    let sort;
    if (this.isArgumentAxis) {
      sort = argCategories;
    } else {
      const categoriesSortingMethod = this._options.categoriesSortingMethod;
      sort = categoriesSortingMethod ?? this._options.categories;
    }
    return sort;
  },
  _getAdjustedBusinessRange() {
    return this.adjustViewport(this._translator.getBusinessRange());
  }
};

/***/ }),

/***/ 87713:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = createConstantLine;
var _type = __webpack_require__(35922);
function createConstantLine(axis, options) {
  const labelOptions = options.label || {};
  const labelPosition = labelOptions.position || 'inside';
  let parsedValue;
  let valueIsParsed = false;
  let lastStoredCoordinates;
  axis._checkAlignmentConstantLineLabels(labelOptions);
  let storedCoord;
  return {
    options,
    labelOptions,
    labelPosition,
    label: null,
    line: null,
    getParsedValue() {
      if (!valueIsParsed) {
        parsedValue = axis.validateUnit(options.value, 'E2105', 'constantLine');
        valueIsParsed = true;
        return parsedValue;
      }
      return parsedValue;
    },
    draw() {
      if (!(0, _type.isDefined)(options.value) || axis._translator.getBusinessRange().isEmpty()) {
        return this;
      }
      const canvas = axis._getCanvasStartEnd();
      const parsedValue = this.getParsedValue();
      this.coord = axis._getConstantLinePos(parsedValue, canvas.start, canvas.end);
      const rootGroup = options.displayBehindSeries ? axis._axisConstantLineGroups.under : axis._axisConstantLineGroups.above;
      let group = rootGroup[labelPosition];
      if (!group) {
        const side = axis._isHorizontal ? labelOptions.verticalAlignment : labelOptions.horizontalAlignment;
        group = rootGroup[side];
      }
      if (!(0, _type.isDefined)(this.coord)) {
        return this;
      }
      const path = axis._createConstantLine(this.coord, {
        stroke: options.color,
        'stroke-width': options.width,
        dashStyle: options.dashStyle
      });
      this.line = path.append(rootGroup.inside);
      this.label = labelOptions.visible ? axis._drawConstantLineLabels(parsedValue, labelOptions, this.coord, group) : null;
      this.updatePosition();
      return this;
    },
    getContentContainer() {
      return this.label;
    },
    removeLabel() {
      this.label && this.label.remove();
    },
    updatePosition(animate) {
      const canvas = axis._getCanvasStartEnd();
      const coord = axis._getConstantLinePos(this.getParsedValue(), canvas.start, canvas.end);
      if (!(0, _type.isDefined)(coord)) {
        return;
      }
      this.coord = coord;
      if (animate && storedCoord) {
        this.label && this.label.attr(axis._getConstantLineLabelsCoords(storedCoord, this.labelOptions));
        this.line && this.line.attr(axis._getConstantLineGraphicAttributes(storedCoord));
        this.label && this.label.animate(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));
        this.line && this.line.animate(axis._getConstantLineGraphicAttributes(this.coord));
      } else {
        this.label && this.label.attr(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));
        this.line && this.line.attr(axis._getConstantLineGraphicAttributes(this.coord));
        axis._rotateConstantLine(this.line, this.coord);
      }
    },
    saveCoords() {
      lastStoredCoordinates = storedCoord;
      storedCoord = this.coord;
    },
    resetCoordinates() {
      storedCoord = lastStoredCoordinates;
    }
  };
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 89530:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.generateDateBreaks = generateDateBreaks;
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const days = [0, 1, 2, 3, 4, 5, 6];
function getWeekendDays(workdays) {
  return days.filter(function (day) {
    return !workdays.some(function (workDay) {
      return workDay === day;
    });
  });
}
function getNextDayIndex(dayIndex) {
  return (dayIndex + 1) % 7;
}
function dayBetweenWeekend(weekend, day) {
  let start = weekend.start;
  const end = weekend.end;
  while (start !== end) {
    if (start === day) {
      return true;
    }
    start = getNextDayIndex(start);
  }
  return false;
}
function getDaysDistance(day, end) {
  let length = 0;
  while (day !== end) {
    day = getNextDayIndex(day);
    length++;
  }
  return length;
}
function separateBreak(scaleBreak, day) {
  const result = [];
  const dayEnd = new Date(day);
  dayEnd.setDate(day.getDate() + 1);
  if (day > scaleBreak.from) {
    result.push({
      from: scaleBreak.from,
      to: day
    });
  }
  if (dayEnd < scaleBreak.to) {
    result.push({
      from: dayEnd,
      to: scaleBreak.to
    });
  }
  return result;
}
function getWeekEndDayIndices(workDays) {
  const indices = getWeekendDays(workDays);
  if (indices.length < 7) {
    while (getNextDayIndex(indices[indices.length - 1]) === indices[0]) {
      indices.unshift(indices.pop());
    }
  }
  return indices;
}
function generateDateBreaksForWeekend(min, max, weekendDayIndices) {
  let day = min.getDate();
  const breaks = [];
  const weekends = weekendDayIndices.reduce(function (obj, day) {
    let currentWeekEnd = obj[1];
    if (currentWeekEnd.start === undefined) {
      currentWeekEnd = {
        start: day,
        end: getNextDayIndex(day)
      };
      obj[0].push(currentWeekEnd);
      return [obj[0], currentWeekEnd];
    } else if (currentWeekEnd.end === day) {
      currentWeekEnd.end = getNextDayIndex(day);
      return obj;
    }
    currentWeekEnd = {
      start: day,
      end: getNextDayIndex(day)
    };
    obj[0].push(currentWeekEnd);
    return [obj[0], currentWeekEnd];
  }, [[], {}]);
  weekends[0].forEach(function (weekend) {
    let currentDate = new Date(min);
    currentDate = _date.default.trimTime(currentDate);
    while (currentDate < max) {
      day = currentDate.getDay();
      const date = currentDate.getDate();
      if (dayBetweenWeekend(weekend, day)) {
        const from = new Date(currentDate);
        currentDate.setDate(date + getDaysDistance(day, weekend.end));
        const to = new Date(currentDate);
        breaks.push({
          from: from,
          to: to
        });
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }
  });
  return breaks;
}
function excludeWorkDaysFromWeekEndBreaks(breaks, exactWorkDays) {
  const result = breaks.slice();
  let i;
  const processWorkDay = function (workday) {
    workday = _date.default.trimTime(new Date(workday));
    if (result[i].from <= workday && result[i].to > workday) {
      const separatedBreak = separateBreak(result[i], workday);
      if (separatedBreak.length === 2) {
        result.splice(i, 1, separatedBreak[0], separatedBreak[1]);
      } else if (separatedBreak.length === 1) {
        result.splice(i, 1, separatedBreak[0]);
      } else {
        result.splice(i, 1);
      }
    }
  };
  for (i = 0; i < result.length; i++) {
    exactWorkDays.forEach(processWorkDay);
  }
  return result;
}
function generateBreaksForHolidays(min, max, holidays, weekendDayIndices) {
  let day;
  const dayInWeekend = function (dayIndex) {
    return dayIndex === day;
  };
  const adjustedMin = _date.default.trimTime(min);
  const adjustedMax = _date.default.trimTime(max);
  adjustedMax.setDate(max.getDate() + 1);
  return holidays.reduce(function (breaks, holiday) {
    let holidayStart;
    let holidayEnd;
    holiday = new Date(holiday);
    day = holiday.getDay();
    if (!weekendDayIndices.some(dayInWeekend) && holiday >= adjustedMin && holiday <= adjustedMax) {
      holidayStart = _date.default.trimTime(holiday);
      holidayEnd = new Date(holidayStart);
      holidayEnd.setDate(holidayStart.getDate() + 1);
      breaks.push({
        from: holidayStart,
        to: holidayEnd
      });
    }
    return breaks;
  }, []);
}
function calculateGaps(breaks) {
  return breaks.map(function (b) {
    return {
      from: b.from,
      to: b.to,
      gapSize: _date.default.convertMillisecondsToDateUnits(b.to - b.from)
    };
  });
}
function generateDateBreaks(min, max, workWeek, singleWorkdays, holidays) {
  const weekendDayIndices = getWeekEndDayIndices(workWeek);
  const breaks = generateDateBreaksForWeekend(min, max, weekendDayIndices);
  breaks.push.apply(breaks, generateBreaksForHolidays(min, max, holidays || [], weekendDayIndices));
  return calculateGaps(excludeWorkDaysFromWeekEndBreaks(breaks, singleWorkdays || []));
}

/***/ }),

/***/ 4331:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.linearSpider = exports.linear = exports.circularSpider = exports.circular = void 0;
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _axes_constants = _interopRequireDefault(__webpack_require__(53805));
var _xy_axes = _interopRequireDefault(__webpack_require__(99415));
var _tick = __webpack_require__(41013);
var _axes_utils = __webpack_require__(32945);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  PI,
  abs,
  atan,
  round
} = Math;
const _min = Math.min;
const _max = Math.max;
const xyAxesLinear = _xy_axes.default.linear;
const HALF_PI_ANGLE = 90;
function getPolarQuarter(angle) {
  let quarter;
  angle = (0, _utils.normalizeAngle)(angle);
  if (angle >= 315 && angle <= 360 || angle < 45 && angle >= 0) {
    quarter = 1;
  } else if (angle >= 45 && angle < 135) {
    quarter = 2;
  } else if (angle >= 135 && angle < 225) {
    quarter = 3;
  } else if (angle >= 225 && angle < 315) {
    quarter = 4;
  }
  return quarter;
}
const circularAxes = {
  _calculateValueMargins(ticks) {
    let {
      minVisible,
      maxVisible
    } = this._getViewportRange();
    if (ticks && ticks.length > 1) {
      minVisible = minVisible < ticks[0].value ? minVisible : ticks[0].value;
      maxVisible = minVisible > ticks[ticks.length - 1].value ? maxVisible : ticks[ticks.length - 1].value;
    }
    return {
      minValue: minVisible,
      maxValue: maxVisible
    };
  },
  applyMargins() {
    const margins = this._calculateValueMargins(this._majorTicks);
    const br = this._translator.getBusinessRange();
    br.addRange({
      minVisible: margins.minValue,
      maxVisible: margins.maxValue,
      interval: this._calculateRangeInterval(br.interval)
    });
    this._translator.updateBusinessRange(br);
  },
  _getTranslatorOptions: function () {
    return {
      isHorizontal: true,
      conversionValue: true,
      addSpiderCategory: this._getSpiderCategoryOption(),
      stick: this._getStick()
    };
  },
  getCenter: function () {
    return this._center;
  },
  getRadius: function () {
    return this._radius;
  },
  getAngles: function () {
    const options = this._options;
    return [options.startAngle, options.endAngle];
  },
  _updateRadius(canvas) {
    const rad = _min(canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom) / 2;
    this._radius = rad < 0 ? 0 : rad;
  },
  _updateCenter: function (canvas) {
    this._center = {
      x: canvas.left + (canvas.width - canvas.right - canvas.left) / 2,
      y: canvas.top + (canvas.height - canvas.top - canvas.bottom) / 2
    };
  },
  _processCanvas: function (canvas) {
    this._updateRadius(canvas);
    this._updateCenter(canvas);
    return {
      left: 0,
      right: 0,
      width: this._getScreenDelta()
    };
  },
  _createAxisElement: function () {
    return this._renderer.circle();
  },
  _updateAxisElementPosition: function () {
    const center = this.getCenter();
    this._axisElement.attr({
      cx: center.x,
      cy: center.y,
      r: this.getRadius()
    });
  },
  _boundaryTicksVisibility: {
    min: true
  },
  _getSpiderCategoryOption: function () {
    // TODO rename spider
    return this._options.firstPointOnStartAngle;
  },
  _validateOptions(options) {
    const that = this;
    let originValue = options.originValue;
    const wholeRange = options.wholeRange = {};
    const period = options.period;
    if ((0, _type.isDefined)(originValue)) {
      originValue = that.validateUnit(originValue);
    }
    if (period > 0 && options.argumentType === _axes_constants.default.numeric) {
      originValue = originValue || 0;
      wholeRange.endValue = originValue + period;
      that._viewport = (0, _utils.getVizRangeObject)([originValue, wholeRange.endValue]);
    }
    if ((0, _type.isDefined)(originValue)) {
      wholeRange.startValue = originValue;
    }
  },
  getMargins() {
    const tickOptions = this._options.tick;
    const tickOuterLength = _max(tickOptions.visible ? tickOptions.length / 2 + tickOptions.shift : 0, 0);
    const radius = this.getRadius();
    const {
      x,
      y
    } = this._center;
    const labelBoxes = this._majorTicks.map(t => t.label && t.label.getBBox()).filter(b => b);
    const canvas = (0, _extend.extend)({}, this._canvas, {
      left: x - radius,
      top: y - radius,
      right: this._canvas.width - (x + radius),
      bottom: this._canvas.height - (y + radius)
    });
    const margins = (0, _axes_utils.calculateCanvasMargins)(labelBoxes, canvas);
    Object.keys(margins).forEach(k => margins[k] = margins[k] < tickOuterLength ? tickOuterLength : margins[k]);
    return margins;
  },
  _updateLabelsPosition() {
    const that = this;
    (0, _axes_utils.measureLabels)(that._majorTicks);
    that._adjustLabelsCoord(0, 0, true);
    that._checkBoundedLabelsOverlapping(this._majorTicks, this._majorTicks.map(t => t.labelBBox));
  },
  _setVisualRange: _common.noop,
  applyVisualRangeSetter: _common.noop,
  _getStick: function () {
    return this._options.firstPointOnStartAngle || this._options.type !== _axes_constants.default.discrete;
  },
  _getTranslatedCoord: function (value, offset) {
    return this._translator.translate(value, offset) - HALF_PI_ANGLE;
  },
  _getCanvasStartEnd: function () {
    return {
      start: 0 - HALF_PI_ANGLE,
      end: 360 - HALF_PI_ANGLE
    };
  },
  _getStripGraphicAttributes: function (fromAngle, toAngle) {
    const center = this.getCenter();
    const angle = this.getAngles()[0];
    const r = this.getRadius();
    return {
      x: center.x,
      y: center.y,
      innerRadius: 0,
      outerRadius: r,
      startAngle: -toAngle - angle,
      endAngle: -fromAngle - angle
    };
  },
  _createStrip: function (coords) {
    return this._renderer.arc(coords.x, coords.y, coords.innerRadius, coords.outerRadius, coords.startAngle, coords.endAngle);
  },
  _getStripLabelCoords: function (from, to) {
    const that = this;
    const coords = that._getStripGraphicAttributes(from, to);
    const angle = coords.startAngle + (coords.endAngle - coords.startAngle) / 2;
    const cosSin = (0, _utils.getCosAndSin)(angle);
    const halfRad = that.getRadius() / 2;
    const center = that.getCenter();
    const x = round(center.x + halfRad * cosSin.cos);
    const y = round(center.y - halfRad * cosSin.sin);
    return {
      x: x,
      y: y,
      align: _axes_constants.default.center
    };
  },
  _getConstantLineGraphicAttributes: function (value) {
    const center = this.getCenter();
    const r = this.getRadius();
    return {
      points: [center.x, center.y, center.x + r, center.y]
    };
  },
  _createConstantLine: function (value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr);
  },
  _rotateConstantLine(line, value) {
    const {
      x,
      y
    } = this.getCenter();
    line.rotate(value + this.getAngles()[0], x, y);
  },
  _getConstantLineLabelsCoords: function (value) {
    const that = this;
    const cosSin = (0, _utils.getCosAndSin)(-value - that.getAngles()[0]);
    const halfRad = that.getRadius() / 2;
    const center = that.getCenter();
    const x = round(center.x + halfRad * cosSin.cos);
    const y = round(center.y - halfRad * cosSin.sin);
    return {
      x: x,
      y: y
    };
  },
  _checkAlignmentConstantLineLabels: _common.noop,
  _adjustDivisionFactor: function (val) {
    return val * 180 / (this.getRadius() * PI);
  },
  _getScreenDelta: function () {
    const angles = this.getAngles();
    return abs(angles[0] - angles[1]);
  },
  _getTickMarkPoints: function (coords, length, _ref) {
    let {
      shift = 0
    } = _ref;
    const center = this.getCenter();
    const corrections = {
      inside: -1,
      center: -0.5,
      outside: 0
    };
    const radiusWithTicks = this.getRadius() + length * corrections[this._options.tickOrientation || 'center'];
    return [center.x + radiusWithTicks + shift, center.y, center.x + radiusWithTicks + length + shift, center.y];
  },
  _getLabelAdjustedCoord: function (tick, _offset, _maxWidth, checkCanvas) {
    const that = this;
    const labelCoords = tick.labelCoords;
    const labelY = labelCoords.y;
    const labelAngle = labelCoords.angle;
    const cosSin = (0, _utils.getCosAndSin)(labelAngle);
    const cos = cosSin.cos;
    const sin = cosSin.sin;
    const box = tick.labelBBox;
    const halfWidth = box.width / 2;
    const halfHeight = box.height / 2;
    const indentFromAxis = that._options.label.indentFromAxis || 0;
    const x = labelCoords.x + indentFromAxis * cos;
    const y = labelY + (labelY - box.y - halfHeight) + indentFromAxis * sin;
    let shiftX = 0;
    let shiftY = 0;
    switch (getPolarQuarter(labelAngle)) {
      case 1:
        shiftX = halfWidth;
        shiftY = halfHeight * sin;
        break;
      case 2:
        shiftX = halfWidth * cos;
        shiftY = halfHeight;
        break;
      case 3:
        shiftX = -halfWidth;
        shiftY = halfHeight * sin;
        break;
      case 4:
        shiftX = halfWidth * cos;
        shiftY = -halfHeight;
        break;
    }
    if (checkCanvas) {
      const canvas = that._canvas;
      const boxShiftX = x - labelCoords.x + shiftX;
      const boxShiftY = y - labelCoords.y + shiftY;
      if (box.x + boxShiftX < canvas.originalLeft) {
        shiftX -= box.x + boxShiftX - canvas.originalLeft;
      }
      if (box.x + box.width + boxShiftX > canvas.width - canvas.originalRight) {
        shiftX -= box.x + box.width + boxShiftX - (canvas.width - canvas.originalRight);
      }
      if (box.y + boxShiftY < canvas.originalTop) {
        shiftY -= box.y + boxShiftY - canvas.originalTop;
      }
      if (box.y + box.height + boxShiftY > canvas.height - canvas.originalBottom) {
        shiftY -= box.y + box.height + boxShiftY - (canvas.height - canvas.originalBottom);
      }
    }
    return {
      x: x + shiftX,
      y: y + shiftY
    };
  },
  _getGridLineDrawer: function () {
    const that = this;
    return function (tick, gridStyle) {
      const center = that.getCenter();
      return that._createPathElement(that._getGridPoints().points, gridStyle).rotate(tick.coords.angle, center.x, center.y);
    };
  },
  _getGridPoints: function () {
    const r = this.getRadius();
    const center = this.getCenter();
    return {
      points: [center.x, center.y, center.x + r, center.y]
    };
  },
  _getTranslatedValue: function (value, offset) {
    const startAngle = this.getAngles()[0];
    const angle = this._translator.translate(value, -offset);
    const coords = (0, _utils.convertPolarToXY)(this.getCenter(), startAngle, angle, this.getRadius());
    return {
      x: coords.x,
      y: coords.y,
      angle: this.getTranslatedAngle(angle)
    };
  },
  _getAdjustedStripLabelCoords: function (strip) {
    const box = strip.labelBBox;
    return {
      translateY: strip.label.attr('y') - box.y - box.height / 2
    };
  },
  coordsIn: function (x, y) {
    return (0, _utils.convertXYToPolar)(this.getCenter(), x, y).r > this.getRadius();
  },
  _rotateTick: function (element, coords) {
    const center = this.getCenter();
    element.rotate(coords.angle, center.x, center.y);
  },
  _validateOverlappingMode: function (mode) {
    return _axes_constants.default.validateOverlappingMode(mode);
  },
  _validateDisplayMode: function () {
    return 'standard';
  },
  _getStep: function (boxes) {
    const that = this;
    const radius = that.getRadius() + (that._options.label.indentFromAxis || 0);
    const maxLabelBox = boxes.reduce(function (prevValue, box) {
      const curValue = prevValue;
      if (prevValue.width < box.width) {
        curValue.width = box.width;
      }
      if (prevValue.height < box.height) {
        curValue.height = box.height;
      }
      return curValue;
    }, {
      width: 0,
      height: 0
    });
    const angle1 = abs(2 * atan(maxLabelBox.height / (2 * radius - maxLabelBox.width)) * 180 / PI);
    const angle2 = abs(2 * atan(maxLabelBox.width / (2 * radius - maxLabelBox.height)) * 180 / PI);
    return _axes_constants.default.getTicksCountInRange(that._majorTicks, 'angle', _max(angle1, angle2));
  },
  _checkBoundedLabelsOverlapping: function (majorTicks, boxes, mode) {
    const labelOpt = this._options.label;
    mode = mode || this._validateOverlappingMode(labelOpt.overlappingBehavior);
    if (mode !== 'hide') {
      return;
    }
    const lastVisibleLabelIndex = majorTicks.reduce((lastVisibleLabelIndex, tick, index) => tick.label ? index : lastVisibleLabelIndex, null);
    if (!lastVisibleLabelIndex) {
      return;
    }
    if (_axes_constants.default.areLabelsOverlap(boxes[0], boxes[lastVisibleLabelIndex], labelOpt.minSpacing, _axes_constants.default.center)) {
      labelOpt.hideFirstOrLast === 'first' ? majorTicks[0].removeLabel() : majorTicks[lastVisibleLabelIndex].removeLabel();
    }
  },
  shift: function (margins) {
    this._axisGroup.attr({
      translateX: margins.right,
      translateY: margins.bottom
    });
    this._axisElementsGroup.attr({
      translateX: margins.right,
      translateY: margins.bottom
    });
  },
  getTranslatedAngle(angle) {
    const startAngle = this.getAngles()[0];
    return angle + startAngle - HALF_PI_ANGLE;
  }
};
const circular = exports.circular = circularAxes;
const circularSpider = exports.circularSpider = (0, _extend.extend)({}, circularAxes, {
  _createAxisElement: function () {
    return this._renderer.path([], 'area');
  },
  _updateAxisElementPosition: function () {
    this._axisElement.attr({
      points: (0, _utils.map)(this.getSpiderTicks(), function (tick) {
        return {
          x: tick.coords.x,
          y: tick.coords.y
        };
      })
    });
  },
  _getStick: function () {
    return true;
  },
  _getSpiderCategoryOption: function () {
    return true;
  },
  getSpiderTicks: function () {
    const that = this;
    const ticks = that.getFullTicks();
    that._spiderTicks = ticks.map((0, _tick.tick)(that, that.renderer, {}, {}, that._getSkippedCategory(ticks), true));
    that._spiderTicks.forEach(function (tick) {
      tick.initCoords();
    });
    return that._spiderTicks;
  },
  _getStripGraphicAttributes: function (fromAngle, toAngle) {
    const center = this.getCenter();
    const spiderTicks = this.getSpiderTicks();
    let firstTick;
    let lastTick;
    let nextTick;
    let tick;
    const points = [];
    let i = 0;
    const len = spiderTicks.length;
    while (i < len) {
      tick = spiderTicks[i].coords;
      if (tick.angle >= fromAngle && tick.angle <= toAngle) {
        if (!firstTick) {
          firstTick = (spiderTicks[i - 1] || spiderTicks[spiderTicks.length - 1]).coords;
          points.push((tick.x + firstTick.x) / 2, (tick.y + firstTick.y) / 2);
        }
        points.push(tick.x, tick.y);
        nextTick = (spiderTicks[i + 1] || spiderTicks[0]).coords;
        lastTick = {
          x: (tick.x + nextTick.x) / 2,
          y: (tick.y + nextTick.y) / 2
        };
      }
      i++;
    }
    points.push(lastTick.x, lastTick.y);
    points.push(center.x, center.y);
    return {
      points: points
    };
  },
  _createStrip: function (_ref2) {
    let {
      points
    } = _ref2;
    return this._renderer.path(points, 'area');
  },
  _getTranslatedCoord: function (value, offset) {
    return this._translator.translate(value, offset) - HALF_PI_ANGLE;
  },
  _setTickOffset: function () {
    this._tickOffset = false;
  }
});
const linear = exports.linear = {
  _resetMargins() {
    this._reinitTranslator(this._getViewportRange());
  },
  _getStick: xyAxesLinear._getStick,
  _getSpiderCategoryOption: _common.noop,
  _getTranslatorOptions: function () {
    return {
      isHorizontal: true,
      stick: this._getStick()
    };
  },
  getRadius: circularAxes.getRadius,
  getCenter: circularAxes.getCenter,
  getAngles: circularAxes.getAngles,
  _updateRadius: circularAxes._updateRadius,
  _updateCenter: circularAxes._updateCenter,
  _processCanvas(canvas) {
    this._updateRadius(canvas);
    this._updateCenter(canvas);
    return {
      left: 0,
      right: 0,
      startPadding: canvas.startPadding,
      endPadding: canvas.endPadding,
      width: this.getRadius()
    };
  },
  _createAxisElement: xyAxesLinear._createAxisElement,
  _updateAxisElementPosition: function () {
    const centerCoord = this.getCenter();
    this._axisElement.attr({
      points: [centerCoord.x, centerCoord.y, centerCoord.x + this.getRadius(), centerCoord.y]
    }).rotate(this.getAngles()[0] - HALF_PI_ANGLE, centerCoord.x, centerCoord.y);
  },
  _getScreenDelta: function () {
    return this.getRadius();
  },
  _getTickMarkPoints: function (coords, length) {
    return [coords.x - length / 2, coords.y, coords.x + length / 2, coords.y];
  },
  _getLabelAdjustedCoord: function (tick) {
    const that = this;
    const labelCoords = tick.labelCoords;
    const labelY = labelCoords.y;
    const cosSin = (0, _utils.getCosAndSin)(labelCoords.angle);
    const indentFromAxis = that._options.label.indentFromAxis || 0;
    const box = tick.labelBBox;
    const x = labelCoords.x - abs(indentFromAxis * cosSin.sin) + abs(box.width / 2 * cosSin.cos) - box.width / 2;
    const y = labelY + (labelY - box.y) - abs(box.height / 2 * cosSin.sin) + abs(indentFromAxis * cosSin.cos);
    return {
      x: x,
      y: y
    };
  },
  _getGridLineDrawer: function () {
    const that = this;
    return function (tick, gridStyle) {
      const grid = that._getGridPoints(tick.coords);
      return that._renderer.circle(grid.cx, grid.cy, grid.r).attr(gridStyle).sharp();
    };
  },
  _getGridPoints: function (coords) {
    const pos = this.getCenter();
    const radius = (0, _utils.getDistance)(pos.x, pos.y, coords.x, coords.y);
    if (radius > this.getRadius()) {
      return {
        cx: null,
        cy: null,
        r: null
      };
    }
    return {
      cx: pos.x,
      cy: pos.y,
      r: radius
    };
  },
  _getTranslatedValue: function (value, offset) {
    const startAngle = this.getAngles()[0];
    const xy = (0, _utils.convertPolarToXY)(this.getCenter(), startAngle, 0, this._translator.translate(value, offset));
    return {
      x: xy.x,
      y: xy.y,
      angle: startAngle - HALF_PI_ANGLE
    };
  },
  _getTranslatedCoord: function (value, offset) {
    return this._translator.translate(value, offset);
  },
  _getCanvasStartEnd() {
    const invert = this.getTranslator().getBusinessRange().invert;
    const coords = [0, this.getRadius()];
    invert && coords.reverse();
    return {
      start: coords[0],
      end: coords[1]
    };
  },
  _getStripGraphicAttributes: function (fromPoint, toPoint) {
    const center = this.getCenter();
    return {
      x: center.x,
      y: center.y,
      innerRadius: fromPoint,
      outerRadius: toPoint
    };
  },
  _createStrip: function (attrs) {
    return this._renderer.arc(attrs.x, attrs.y, attrs.innerRadius, attrs.outerRadius, 0, 360);
  },
  _getAdjustedStripLabelCoords: circularAxes._getAdjustedStripLabelCoords,
  _getStripLabelCoords: function (from, to) {
    const that = this;
    const labelPos = from + (to - from) / 2;
    const center = that.getCenter();
    const y = round(center.y - labelPos);
    return {
      x: center.x,
      y: y,
      align: _axes_constants.default.center
    };
  },
  _getConstantLineGraphicAttributes: function (value) {
    const center = this.getCenter();
    return {
      cx: center.x,
      cy: center.y,
      r: value
    };
  },
  _createConstantLine: function (value, attr) {
    const attrs = this._getConstantLineGraphicAttributes(value);
    return this._renderer.circle(attrs.cx, attrs.cy, attrs.r).attr(attr).sharp();
  },
  _getConstantLineLabelsCoords: function (value) {
    const that = this;
    const center = that.getCenter();
    const y = round(center.y - value);
    return {
      x: center.x,
      y: y
    };
  },
  _checkAlignmentConstantLineLabels: _common.noop,
  _rotateTick: function (element, coords, isGridLine) {
    !isGridLine && element.rotate(coords.angle + HALF_PI_ANGLE, coords.x, coords.y);
  },
  _validateOverlappingMode: circularAxes._validateOverlappingMode,
  _validateDisplayMode: circularAxes._validateDisplayMode,
  _getStep: function (boxes) {
    const quarter = getPolarQuarter(this.getAngles()[0]);
    const spacing = this._options.label.minSpacing;
    const func = quarter === 2 || quarter === 4 ? function (box) {
      return box.width + spacing;
    } : function (box) {
      return box.height;
    };
    const maxLabelLength = boxes.reduce((prevValue, box) => _max(prevValue, func(box)), 0);
    return _axes_constants.default.getTicksCountInRange(this._majorTicks, quarter === 2 || quarter === 4 ? 'x' : 'y', maxLabelLength);
  }
};
const linearSpider = exports.linearSpider = (0, _extend.extend)({}, linear, {
  _createPathElement: function (points, attr) {
    return this._renderer.path(points, 'area').attr(attr).sharp();
  },
  setSpiderTicks: function (ticks) {
    this._spiderTicks = ticks;
  },
  _getGridLineDrawer: function () {
    const that = this;
    return function (tick, gridStyle) {
      return that._createPathElement(that._getGridPoints(tick.coords).points, gridStyle);
    };
  },
  _getGridPoints: function (coords) {
    const pos = this.getCenter();
    const radius = (0, _utils.getDistance)(pos.x, pos.y, coords.x, coords.y);
    return this._getGridPointsByRadius(radius);
  },
  _getGridPointsByRadius: function (radius) {
    const pos = this.getCenter();
    if (radius > this.getRadius()) {
      return {
        points: null
      };
    }
    return {
      points: (0, _utils.map)(this._spiderTicks, function (tick) {
        const cosSin = (0, _utils.getCosAndSin)(tick.coords.angle);
        return {
          x: round(pos.x + radius * cosSin.cos),
          y: round(pos.y + radius * cosSin.sin)
        };
      })
    };
  },
  _getStripGraphicAttributes: function (fromPoint, toPoint) {
    const innerPoints = this._getGridPointsByRadius(toPoint).points;
    const outerPoints = this._getGridPointsByRadius(fromPoint).points;
    return {
      points: [outerPoints, innerPoints.reverse()]
    };
  },
  _createStrip: circularSpider._createStrip,
  _getConstantLineGraphicAttributes: function (value) {
    return this._getGridPointsByRadius(value);
  },
  _createConstantLine: function (value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr);
  }
});

/***/ }),

/***/ 41583:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.formatRange = formatRange;
exports.smartFormatter = smartFormatter;
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _type = __webpack_require__(35922);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _math = __webpack_require__(60810);
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _format = _format_helper.default.format;
const {
  abs,
  floor
} = Math;
const EXPONENTIAL = 'exponential';
const formats = ['fixedPoint', 'thousands', 'millions', 'billions', 'trillions', EXPONENTIAL];
const dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];
const INTERVALS_MAP = {
  'week': 'day',
  'quarter': 'month',
  'shorttime': 'hour',
  'longtime': 'second'
};
function patchFirstTickDiff(differences, tickFormatIndex) {
  for (let i = tickFormatIndex; i < dateUnitIntervals.length - 1; i++) {
    const dateUnitInterval = dateUnitIntervals[i];
    if (i === tickFormatIndex) {
      setDateUnitInterval(differences, tickFormatIndex + (differences['millisecond'] ? 2 : 1));
      break;
    } else if (differences[dateUnitInterval] && differences.count > 1) {
      resetDateUnitInterval(differences, i);
      break;
    }
  }
}
function patchTickDiff(differences, tickFormatIndex) {
  let patched = false;
  for (let i = dateUnitIntervals.length - 1; i >= tickFormatIndex; i--) {
    const dateUnitInterval = dateUnitIntervals[i];
    if (differences[dateUnitInterval]) {
      if (i - tickFormatIndex > 1) {
        for (let j = 0; j <= tickFormatIndex; j++) {
          resetDateUnitInterval(differences, j);
          patched = true;
        }
        break;
      }
    }
  }
  return patched;
}
function getDatesDifferences(prevDate, curDate, nextDate, tickIntervalFormat) {
  tickIntervalFormat = INTERVALS_MAP[tickIntervalFormat] || tickIntervalFormat;
  const tickFormatIndex = dateUnitIntervals.indexOf(tickIntervalFormat);
  if (nextDate) {
    const nextDifferences = _date.default.getDatesDifferences(curDate, nextDate);
    if (nextDifferences[tickIntervalFormat]) {
      patchFirstTickDiff(nextDifferences, tickFormatIndex);
    }
    return nextDifferences;
  } else {
    const prevDifferences = _date.default.getDatesDifferences(prevDate, curDate);
    const patched = patchTickDiff(prevDifferences, tickFormatIndex);
    if (!patched && prevDifferences.count === 1) {
      setDateUnitInterval(prevDifferences, tickFormatIndex);
    }
    return prevDifferences;
  }
}
function resetDateUnitInterval(differences, intervalIndex) {
  const dateUnitInterval = dateUnitIntervals[intervalIndex];
  if (differences[dateUnitInterval]) {
    differences[dateUnitInterval] = false;
    differences.count--;
  }
}
function setDateUnitInterval(differences, intervalIndex) {
  const dateUnitInterval = dateUnitIntervals[intervalIndex];
  if (differences[dateUnitInterval] === false) {
    differences[dateUnitInterval] = true;
    differences.count++;
  }
}
function getNoZeroIndex(str) {
  return str.length - parseInt(str).toString().length;
}
function getTransitionTickIndex(ticks, value) {
  let i;
  let curDiff;
  let minDiff;
  let nearestTickIndex = 0;
  minDiff = abs(value - ticks[0]);
  for (i = 1; i < ticks.length; i++) {
    curDiff = abs(value - ticks[i]);
    if (curDiff < minDiff) {
      minDiff = curDiff;
      nearestTickIndex = i;
    }
  }
  return nearestTickIndex;
}
function splitDecimalNumber(value) {
  return value.toString().split('.');
}
function createFormat(type) {
  let formatter;
  if ((0, _type.isFunction)(type)) {
    formatter = type;
    type = null;
  }
  return {
    type,
    formatter
  };
}
function formatLogarithmicNumber(tick) {
  const log10Tick = (0, _utils.getAdjustedLog10)(abs(tick));
  let type;
  if (log10Tick > 0) {
    type = formats[floor(log10Tick / 3)] || EXPONENTIAL;
  } else {
    if (log10Tick < -4) {
      type = EXPONENTIAL;
    } else {
      return _format((0, _math.adjust)(tick));
    }
  }
  return _format(tick, {
    type,
    precision: 0
  });
}
function getDateTimeFormat(tick, _ref) {
  let {
    showTransition,
    ticks,
    tickInterval
  } = _ref;
  let typeFormat = _date.default.getDateFormatByTickInterval(tickInterval);
  let prevDateIndex;
  let nextDateIndex;
  if (showTransition && ticks.length) {
    const indexOfTick = ticks.map(Number).indexOf(+tick);
    if (ticks.length === 1 && indexOfTick === 0) {
      typeFormat = _format_helper.default.getDateFormatByTicks(ticks);
    } else {
      if (indexOfTick === -1) {
        prevDateIndex = getTransitionTickIndex(ticks, tick);
      } else {
        prevDateIndex = indexOfTick === 0 ? ticks.length - 1 : indexOfTick - 1;
        nextDateIndex = indexOfTick === 0 ? 1 : -1;
      }
      const datesDifferences = getDatesDifferences(ticks[prevDateIndex], tick, ticks[nextDateIndex], typeFormat);
      typeFormat = _format_helper.default.getDateFormatByDifferences(datesDifferences, typeFormat);
    }
  }
  return createFormat(typeFormat);
}
function getFormatExponential(tick, tickInterval) {
  const stringTick = abs(tick).toString();
  if ((0, _type.isExponential)(tick)) {
    return Math.max(abs((0, _math.getExponent)(tick) - (0, _math.getExponent)(tickInterval)), abs((0, _math.getPrecision)(tick) - (0, _math.getPrecision)(tickInterval)));
  } else {
    return abs(getNoZeroIndex(stringTick.split('.')[1]) - (0, _math.getExponent)(tickInterval) + 1);
  }
}
function getFormatWithModifier(tick, tickInterval) {
  const tickIntervalIndex = floor((0, _utils.getAdjustedLog10)(tickInterval));
  let tickIndex;
  let precision = 0;
  let actualIndex = tickIndex = floor((0, _utils.getAdjustedLog10)(abs(tick)));
  if (tickIndex - tickIntervalIndex >= 2) {
    actualIndex = tickIntervalIndex;
  }
  let indexOfFormat = floor(actualIndex / 3);
  const offset = indexOfFormat * 3;
  if (indexOfFormat < 0) {
    indexOfFormat = 0;
  }
  const typeFormat = formats[indexOfFormat] || formats[formats.length - 1];
  if (offset > 0) {
    const separatedTickInterval = splitDecimalNumber(tickInterval / Math.pow(10, offset));
    if (separatedTickInterval[1]) {
      precision = separatedTickInterval[1].length;
    }
  }
  return {
    precision,
    type: typeFormat
  };
}
function getHighDiffFormat(diff) {
  let stop = false;
  for (const i in diff) {
    if (diff[i] === true || i === 'hour' || stop) {
      diff[i] = false;
      stop = true;
    } else if (diff[i] === false) {
      diff[i] = true;
    }
  }
  return createFormat(_format_helper.default.getDateFormatByDifferences(diff));
}
function getHighAndSelfDiffFormat(diff, interval) {
  let stop = false;
  for (const i in diff) {
    if (stop) {
      diff[i] = false;
    } else if (i === interval) {
      stop = true;
    } else {
      diff[i] = true;
    }
  }
  return createFormat(_format_helper.default.getDateFormatByDifferences(diff));
}
function formatDateRange(startValue, endValue, tickInterval) {
  const diff = getDatesDifferences(startValue, endValue);
  const typeFormat = _date.default.getDateFormatByTickInterval(tickInterval);
  const diffFormatType = _format_helper.default.getDateFormatByDifferences(diff, typeFormat);
  const diffFormat = createFormat(diffFormatType);
  const values = [];
  if (tickInterval in diff) {
    const rangeFormat = getHighAndSelfDiffFormat(getDatesDifferences(startValue, endValue), tickInterval);
    const value = _format(startValue, rangeFormat);
    if (value) {
      values.push(value);
    }
  } else {
    const rangeFormat = getHighDiffFormat(getDatesDifferences(startValue, endValue));
    const highValue = _format(startValue, rangeFormat);
    if (highValue) {
      values.push(highValue);
    }
    values.push(`${_format(startValue, diffFormat)} - ${_format(endValue, diffFormat)}`);
  }
  return values.join(', ');
}
function processDateInterval(interval) {
  if ((0, _type.isObject)(interval)) {
    const dateUnits = Object.keys(interval);
    const sum = dateUnits.reduce((sum, k) => interval[k] + sum, 0);
    if (sum === 1) {
      const dateUnit = dateUnits.filter(k => interval[k] === 1)[0];
      return dateUnit.slice(0, dateUnit.length - 1);
    }
  }
  return interval;
}
function smartFormatter(tick, options) {
  let tickInterval = options.tickInterval;
  const stringTick = abs(tick).toString();
  let format = options.labelOptions.format;
  const ticks = options.ticks;
  const isLogarithmic = options.type === 'logarithmic';
  if (ticks.length === 1 && ticks.indexOf(tick) === 0 && !(0, _type.isDefined)(tickInterval)) {
    tickInterval = abs(tick) >= 1 ? 1 : (0, _math.adjust)(1 - abs(tick), tick);
  }
  if (Object.is(tick, -0)) {
    tick = 0;
  }
  if (!(0, _type.isDefined)(format) && options.type !== 'discrete' && tick && (options.logarithmBase === 10 || !isLogarithmic)) {
    if (options.dataType !== 'datetime' && (0, _type.isDefined)(tickInterval)) {
      if (ticks.length && ticks.indexOf(tick) === -1) {
        const indexOfTick = getTransitionTickIndex(ticks, tick);
        tickInterval = (0, _math.adjust)(abs(tick - ticks[indexOfTick]), tick);
      }
      if (isLogarithmic) {
        return formatLogarithmicNumber(tick);
      } else {
        let separatedTickInterval = splitDecimalNumber(tickInterval);
        if (separatedTickInterval < 2) {
          separatedTickInterval = splitDecimalNumber(tick);
        }
        if (separatedTickInterval.length > 1 && !(0, _type.isExponential)(tickInterval)) {
          format = {
            type: formats[0],
            precision: separatedTickInterval[1].length
          };
        } else {
          if ((0, _type.isExponential)(tickInterval) && (stringTick.indexOf('.') !== -1 || (0, _type.isExponential)(tick))) {
            format = {
              type: EXPONENTIAL,
              precision: getFormatExponential(tick, tickInterval)
            };
          } else {
            format = getFormatWithModifier(tick, tickInterval);
          }
        }
      }
    } else if (options.dataType === 'datetime') {
      format = getDateTimeFormat(tick, options);
    }
  }
  return _format(tick, format);
}
function formatRange(_ref2) {
  let {
    startValue,
    endValue,
    tickInterval,
    argumentFormat,
    axisOptions: {
      dataType,
      type,
      logarithmBase
    }
  } = _ref2;
  if (type === 'discrete') {
    return '';
  }
  if (dataType === 'datetime') {
    return formatDateRange(startValue, endValue, processDateInterval(tickInterval));
  }
  const formatOptions = {
    ticks: [],
    type,
    dataType,
    tickInterval,
    logarithmBase,
    labelOptions: {
      format: argumentFormat
    }
  };
  return `${smartFormatter(startValue, formatOptions)} - ${smartFormatter(endValue, formatOptions)}`;
}

/***/ }),

/***/ 54978:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = createStrip;
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
function createStrip(axis, options) {
  let storedCoord;
  let lastStoredCoordinates;
  const labelOptions = options.label || {};
  return {
    options,
    label: null,
    rect: null,
    _getCoord() {
      const canvas = axis._getCanvasStartEnd();
      const range = axis._translator.getBusinessRange();
      return axis._getStripPos(options.startValue, options.endValue, canvas.start, canvas.end, range);
    },
    _drawLabel(coords) {
      return axis._renderer.text(labelOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)((0, _extend.extend)({}, axis.getOptions().label.font, labelOptions.font))).attr({
        align: 'center',
        'class': labelOptions.cssClass
      }).append(axis._axisStripLabelGroup);
    },
    draw() {
      if (axis._translator.getBusinessRange().isEmpty()) {
        return;
      }
      if (((0, _type.isDefined)(options.startValue) || (0, _type.isDefined)(options.endValue)) && (0, _type.isDefined)(options.color)) {
        const stripPos = this._getCoord();
        this.labelCoords = labelOptions.text ? axis._getStripLabelCoords(stripPos.from, stripPos.to, labelOptions) : null;
        if (stripPos.outOfCanvas || !(0, _type.isDefined)(stripPos.to) || !(0, _type.isDefined)(stripPos.from)) {
          return;
        }
        this.rect = axis._createStrip(axis._getStripGraphicAttributes(stripPos.from, stripPos.to)).attr({
          fill: options.color
        }).append(axis._axisStripGroup);
        this.label = labelOptions.text ? this._drawLabel(this.labelCoords) : null;
      }
    },
    getContentContainer() {
      return this.label;
    },
    removeLabel() {},
    updatePosition(animate) {
      const stripPos = this._getCoord();
      if (animate && storedCoord) {
        this.label && this.label.attr(axis._getStripLabelCoords(storedCoord.from, storedCoord.to, options.label));
        this.rect && this.rect.attr(axis._getStripGraphicAttributes(storedCoord.from, storedCoord.to));
        this.label && this.label.animate(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));
        this.rect && this.rect.animate(axis._getStripGraphicAttributes(stripPos.from, stripPos.to));
      } else {
        this.label && this.label.attr(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));
        this.rect && this.rect.attr(axis._getStripGraphicAttributes(stripPos.from, stripPos.to));
      }
    },
    saveCoords() {
      lastStoredCoordinates = storedCoord;
      storedCoord = this._getCoord();
    },
    resetCoordinates() {
      storedCoord = lastStoredCoordinates;
    }
  };
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 41013:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.tick = createTick;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _deferred = __webpack_require__(62754);
function getPathStyle(options) {
  return {
    stroke: options.color,
    'stroke-width': options.width,
    'stroke-opacity': options.opacity,
    opacity: 1
  };
}
function createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {
  const tickOffset = offset || axis._tickOffset;
  const lineGroup = axis._axisLineGroup;
  const elementsGroup = axis._axisElementsGroup;
  const tickStyle = getPathStyle(tickOptions);
  const gridStyle = getPathStyle(gridOptions);
  const emptyStrRegExp = /^\s+$/;
  const axisOptions = axis.getOptions();
  const labelOptions = axisOptions.label;
  const labelStyle = axis._textOptions;
  function getLabelFontStyle(tick) {
    let fontStyle = axis._textFontStyles;
    const customizeColor = labelOptions.customizeColor;
    if (customizeColor && customizeColor.call) {
      fontStyle = (0, _extend.extend)({}, axis._textFontStyles, {
        fill: customizeColor.call(tick, tick)
      });
    }
    return fontStyle;
  }
  function createLabelHint(tick, range) {
    const labelHint = axis.formatHint(tick.value, labelOptions, range);
    if ((0, _type.isDefined)(labelHint) && labelHint !== '') {
      tick.getContentContainer().setTitle(labelHint);
    }
  }
  return function (value) {
    const tick = {
      value: value,
      updateValue(newValue) {
        this.value = value = newValue;
      },
      initCoords: function () {
        this.coords = axis._getTranslatedValue(value, tickOffset);
        this.labelCoords = axis._getTranslatedValue(value);
      },
      saveCoords() {
        this._lastStoredCoordinates = {
          coords: this._storedCoords,
          labelCoords: this._storedLabelsCoords
        };
        this._storedCoords = this.coords;
        this._storedLabelsCoords = this.templateContainer ? this._getTemplateCoords() : this.labelCoords;
      },
      resetCoordinates() {
        if (this._lastStoredCoordinates) {
          this._storedCoords = this._lastStoredCoordinates.coords;
          this._storedLabelsCoords = this._lastStoredCoordinates.labelCoords;
        }
      },
      drawMark(options) {
        if (!tickOptions.visible || skippedCategory === value) {
          return;
        }
        if (axis.areCoordsOutsideAxis(this.coords)) {
          return;
        }
        if (this.mark) {
          this.mark.append(lineGroup);
          axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));
          this.updateTickPosition(options);
        } else {
          this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);
          this.updateTickPosition(options);
        }
      },
      setSkippedCategory(category) {
        skippedCategory = category;
      },
      _updateLine(lineElement, settings, storedSettings, animate, isGridLine) {
        if (!lineElement) {
          return;
        }
        if (settings.points === null || settings.r === null) {
          lineElement.remove();
          return;
        }
        if (animate && storedSettings && storedSettings.points !== null) {
          settings.opacity = 1;
          lineElement.attr(storedSettings);
          lineElement.animate(settings);
        } else {
          settings.opacity = animate ? 0 : 1;
          lineElement.attr(settings);
          animate && lineElement.animate({
            opacity: 1
          }, {
            delay: 0.5,
            partitionDuration: 0.5
          });
        }
        this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine);
      },
      updateTickPosition: function (options, animate) {
        this._updateLine(this.mark, {
          points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)
        }, this._storedCoords && {
          points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)
        }, animate, false);
      },
      drawLabel: function (range, template) {
        if (this.templateContainer && axis.isRendered()) {
          this.updateLabelPosition();
          return;
        }
        const labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);
        if (!labelIsVisible) {
          if (this.label) {
            this.removeLabel();
          }
          return;
        }
        const templateOption = labelOptions.template;
        const text = axis.formatLabel(value, labelOptions, range);
        if (this.label) {
          this.label.attr({
            text,
            rotate: 0
          }).append(elementsGroup);
          createLabelHint(this, range);
          this.updateLabelPosition();
          return;
        }
        if (templateOption) {
          this.templateContainer = renderer.g().append(elementsGroup);
          this._templateDef && this._templateDef.reject();
          this._templateDef = new _deferred.Deferred();
          template.render({
            model: {
              valueText: text,
              value: this.value,
              labelFontStyle: getLabelFontStyle(this),
              labelStyle
            },
            container: this.templateContainer.element,
            onRendered: () => {
              this.updateLabelPosition();
              this._templateDef && this._templateDef.resolve();
            }
          });
        } else {
          if ((0, _type.isDefined)(text) && text !== '' && !emptyStrRegExp.test(text)) {
            this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).append(elementsGroup);
            this.updateLabelPosition();
            createLabelHint(this, range);
          }
        }
        const containerForData = this.getContentContainer();
        containerForData && containerForData.data('chart-data-argument', this.value);
        this.templateContainer && createLabelHint(this, range);
      },
      getTemplateDeferred() {
        return this._templateDef;
      },
      getContentContainer() {
        return this.templateContainer || this.label;
      },
      fadeOutElements() {
        const startSettings = {
          opacity: 1
        };
        const endSettings = {
          opacity: 0
        };
        const animationSettings = {
          partitionDuration: 0.5
        };
        if (this.getContentContainer()) {
          this._fadeOutLabel();
        }
        if (this.grid) {
          this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings);
        }
        if (this.mark) {
          this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings);
        }
      },
      _fadeInLabel() {
        const group = axis._renderer.g().attr({
          opacity: 0
        }).append(axis._axisElementsGroup).animate({
          opacity: 1
        }, {
          delay: 0.5,
          partitionDuration: 0.5
        });
        this.getContentContainer().append(group);
      },
      _fadeOutLabel() {
        const group = axis._renderer.g().attr({
          opacity: 1
        }).animate({
          opacity: 0
        }, {
          partitionDuration: 0.5
        }).append(axis._axisElementsGroup).toBackground();
        this.getContentContainer().append(group);
      },
      _getTemplateCoords() {
        return axis._getLabelAdjustedCoord(this, (axis._constantLabelOffset || 0) + (tick.labelOffset || 0));
      },
      updateLabelPosition: function (animate) {
        const templateContainer = this.templateContainer;
        if (!this.getContentContainer()) {
          return;
        }
        if (animate && this._storedLabelsCoords) {
          if (templateContainer) {
            templateContainer.attr(this._storedLabelsCoords);
            const lCoords = this._getTemplateCoords();
            templateContainer.animate(lCoords);
          } else {
            this.label.attr({
              x: this._storedLabelsCoords.x,
              y: this._storedLabelsCoords.y
            });
            this.label.animate({
              x: this.labelCoords.x,
              y: this.labelCoords.y
            });
          }
        } else {
          if (templateContainer) {
            const lCoords = this._getTemplateCoords();
            templateContainer.attr(lCoords);
          } else {
            this.label.attr({
              x: this.labelCoords.x,
              y: this.labelCoords.y
            });
          }
          if (animate) {
            this._fadeInLabel();
          }
        }
      },
      updateMultilineTextAlignment() {
        if (labelOptions.template || !this.label) {
          return;
        }
        this.label.attr({
          textsAlignment: this.labelAlignment || axis.getOptions().label.alignment
        });
      },
      drawGrid: function (drawLine) {
        if (gridOptions.visible && skippedCategory !== this.value) {
          if (this.grid) {
            this.grid.append(axis._axisGridGroup);
            axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));
            this.updateGridPosition();
          } else {
            this.grid = drawLine(this, gridStyle);
            this.grid && this.grid.append(axis._axisGridGroup);
          }
        }
      },
      updateGridPosition: function (animate) {
        this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true);
      },
      removeLabel() {
        const contentContainer = this.getContentContainer();
        contentContainer && contentContainer.remove();
        this._templateDef && this._templateDef.reject();
        this._templateDef = this.templateContainer = this.label = null;
      }
    };
    return tick;
  };
}

/***/ }),

/***/ 45971:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.tickGenerator = void 0;
var _utils = __webpack_require__(19157);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
var _extend = __webpack_require__(13306);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const convertDateUnitToMilliseconds = _date.default.convertDateUnitToMilliseconds;
const dateToMilliseconds = _date.default.dateToMilliseconds;
const math = Math;
const mathAbs = math.abs;
const mathFloor = math.floor;
const mathCeil = math.ceil;
const mathPow = math.pow;
const NUMBER_MULTIPLIERS = [1, 2, 2.5, 5];
const LOGARITHMIC_MULTIPLIERS = [1, 2, 3, 5];
const DATETIME_MULTIPLIERS = {
  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],
  second: [1, 2, 3, 5, 10, 15, 20, 30],
  minute: [1, 2, 3, 5, 10, 15, 20, 30],
  hour: [1, 2, 3, 4, 6, 8, 12],
  day: [1, 2],
  week: [1, 2],
  month: [1, 2, 3, 6]
};
const DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND = (0, _extend.extend)({}, DATETIME_MULTIPLIERS, {
  day: [1]
});
const DATETIME_MINOR_MULTIPLIERS = {
  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],
  second: [1, 2, 3, 5, 10, 15, 20, 30],
  minute: [1, 2, 3, 5, 10, 15, 20, 30],
  hour: [1, 2, 3, 4, 6, 8, 12],
  day: [1, 2, 3, 7, 14],
  month: [1, 2, 3, 6]
};
const MINOR_DELIMITERS = [2, 4, 5, 8, 10];
const VISIBILITY_DELIMITER = 3;
const MINUTE = 60 * 1000;
function dummyGenerator(options) {
  return function (data, screenDelta, tickInterval, forceTickInterval) {
    let count = mathFloor(screenDelta / options.axisDivisionFactor);
    count = count < 1 ? 1 : count;
    const interval = screenDelta / count;
    return {
      ticks: interval > 0 ? Array.apply(null, new Array(count + 1)).map((_, i) => interval * i) : [],
      tickInterval: interval
    };
  };
}
function discreteGenerator(options) {
  return function (data, screenDelta, tickInterval, forceTickInterval) {
    const categories = (0, _utils.getCategoriesInfo)(data.categories, data.min, data.max).categories;
    return {
      ticks: categories,
      tickInterval: mathCeil(categories.length * options.axisDivisionFactor / screenDelta)
    };
  };
}
const getValue = value => value;
const getLogValue = (base, allowNegatives, linearThreshold) => value => (0, _utils.getLogExt)(value, base, allowNegatives, linearThreshold);
const raiseTo = (base, allowNegatives, linearThreshold) => value => (0, _utils.raiseToExt)(value, base, allowNegatives, linearThreshold);
const mathRaiseTo = base => value => (0, _utils.raiseTo)(value, base);
const logAbsValue = base => value => value === 0 ? 0 : (0, _utils.getLog)(mathAbs(value), base);
const correctValueByInterval = (post, round, getValue) => (value, interval) => (0, _math.adjust)(post(round((0, _math.adjust)(getValue(value) / interval)) * interval));
function correctMinValueByEndOnTick(floorFunc, ceilFunc, resolveEndOnTick, endOnTick) {
  if ((0, _type.isDefined)(endOnTick)) {
    return endOnTick ? floorFunc : ceilFunc;
  }
  return function (value, interval, businessViewInfo, forceEndOnTick) {
    const floorTickValue = floorFunc(value, interval);
    if (value - floorTickValue === 0 || !(0, _type.isDefined)(businessViewInfo) || resolveEndOnTick(value, floorTickValue, interval, businessViewInfo) || forceEndOnTick) {
      return floorTickValue;
    }
    return ceilFunc(value, interval);
  };
}
function resolveEndOnTick(curValue, tickValue, interval, businessViewInfo) {
  const prevTickDataDiff = interval - mathAbs(tickValue - curValue);
  const intervalCount = math.max(mathCeil(businessViewInfo.businessDelta / interval), 2);
  const businessRatio = businessViewInfo.screenDelta / (intervalCount * interval);
  const potentialTickScreenDiff = math.round(businessRatio * prevTickDataDiff);
  const delimiterFactor = (0, _utils.getLogExt)(businessRatio * interval / businessViewInfo.axisDivisionFactor, 2) + 1;
  const delimiterMultiplier = (businessViewInfo.isSpacedMargin ? 2 : 1) * delimiterFactor;
  const screenDelimiter = math.round(VISIBILITY_DELIMITER * delimiterMultiplier);
  return businessViewInfo.businessDelta > businessViewInfo.interval && potentialTickScreenDiff >= screenDelimiter;
}
function resolveEndOnTickLog(base) {
  return function (curValue, tickValue, interval, businessViewInfo) {
    return resolveEndOnTick((0, _utils.getLogExt)(curValue, base), (0, _utils.getLogExt)(tickValue, base), interval, businessViewInfo);
  };
}
function resolveEndOnTickDate(curValue, tickValue, interval, businessViewInfo) {
  return resolveEndOnTick(curValue.valueOf(), tickValue.valueOf(), dateToMilliseconds(interval), businessViewInfo);
}
function getBusinessDelta(data, breaks) {
  let spacing = 0;
  if (breaks) {
    spacing = breaks.reduce((prev, item) => prev + (item.to - item.from), 0);
  }
  return mathAbs(data.max - data.min - spacing);
}
function getBusinessDeltaLog(base, allowNegatives, linearThreshold) {
  const getLog = getLogValue(base, allowNegatives, linearThreshold);
  return function (data, breaks) {
    let spacing = 0;
    if (breaks) {
      spacing = breaks.reduce((prev, item) => prev + mathAbs(getLog(item.to / item.from)), 0);
    }
    return mathCeil(mathAbs(getLog(data.max) - getLog(data.min)) - spacing);
  };
}
function getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount) {
  let count = screenDelta / axisDivisionFactor - (addTickCount || 0);
  count = count < 1 ? 1 : count;
  return businessDelta / count;
}
function getMultiplierFactor(interval, factorDelta) {
  return mathPow(10, mathFloor((0, _utils.getLogExt)(interval, 10)) + (factorDelta || 0));
}
function calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, _, minTickInterval) {
  const interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount);
  let result = 1;
  const onlyIntegers = allowDecimals === false;
  if (!forceTickInterval || !tickInterval) {
    if (interval >= 1 || !onlyIntegers && interval > 0) {
      result = adjustInterval(interval, multipliers, onlyIntegers);
    }
    if (!tickInterval || !forceTickInterval && tickInterval < result) {
      tickInterval = result;
    }
  }
  if (!forceTickInterval && minTickInterval) {
    minTickInterval = adjustInterval(minTickInterval, multipliers, onlyIntegers);
    if (minTickInterval > tickInterval) {
      tickInterval = minTickInterval;
    }
  }
  return tickInterval;
}
function adjustInterval(interval, multipliers, onlyIntegers) {
  const factor = getMultiplierFactor(interval, -1);
  let result = 1;
  multipliers = multipliers || NUMBER_MULTIPLIERS;
  if (interval > 0) {
    interval /= factor;
    result = multipliers.concat(multipliers[0] * 10).map(m => 10 * m).reduce((r, m) => {
      if (factor === 0.1 && onlyIntegers && m === 25) {
        return r;
      }
      return r < interval ? m : r;
    }, 0);
    result = (0, _math.adjust)(result * factor, factor);
  }
  return result;
}
function calculateMinorTickInterval(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {
  const interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);
  return tickInterval || MINOR_DELIMITERS.reduce((r, d) => {
    const cur = businessDelta / d;
    return cur >= interval ? cur : r;
  }, 0);
}
function getCalculateTickIntervalLog(skipCalculationLimits) {
  return function (businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, _, __, minTickInterval) {
    const interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);
    let result = 0;
    const adjustInterval = getAdjustIntervalLog(skipCalculationLimits);
    if (!forceTickInterval || !tickInterval) {
      if (interval > 0) {
        result = adjustInterval(interval, multipliers);
      }
      if (!tickInterval || !forceTickInterval && tickInterval < result) {
        tickInterval = result;
      }
    }
    if (!forceTickInterval && minTickInterval) {
      minTickInterval = adjustInterval(minTickInterval, multipliers);
      if (minTickInterval > tickInterval) {
        tickInterval = minTickInterval;
      }
    }
    return tickInterval;
  };
}
function getAdjustIntervalLog(skipCalculationLimits) {
  return function (interval, multipliers) {
    let factor = getMultiplierFactor(interval);
    multipliers = multipliers || LOGARITHMIC_MULTIPLIERS;
    if (!skipCalculationLimits && factor < 1) {
      factor = 1;
    }
    return multipliers.concat(multipliers[0] * 10).reduce((r, m) => r < interval ? m * factor : r, 0);
  };
}
function getDataTimeMultipliers(gapSize) {
  if (gapSize && gapSize > 2) {
    return DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND;
  } else {
    return DATETIME_MULTIPLIERS;
  }
}
function numbersReducer(interval, key) {
  return function (r, m) {
    if (!r && interval <= convertDateUnitToMilliseconds(key, m)) {
      r = {};
      r[key + 's'] = m;
    }
    return r;
  };
}
function yearsReducer(interval, factor) {
  return function (r, m) {
    const years = factor * m;
    if (!r && interval <= convertDateUnitToMilliseconds('year', years) && years !== 2.5) {
      r = {
        years: years
      };
    }
    return r;
  };
}
function calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, gapSize, minTickInterval) {
  if (!forceTickInterval || !tickInterval) {
    const result = adjustIntervalDateTime(getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor), multipliers, null, gapSize);
    if (!tickInterval || !forceTickInterval && dateToMilliseconds(tickInterval) <= dateToMilliseconds(result)) {
      tickInterval = result;
    }
  }
  if (!forceTickInterval && minTickInterval) {
    minTickInterval = adjustIntervalDateTime(minTickInterval, multipliers, null, gapSize);
    if (dateToMilliseconds(minTickInterval) > dateToMilliseconds(tickInterval)) {
      tickInterval = minTickInterval;
    }
  }
  return tickInterval;
}
function adjustIntervalDateTime(interval, multipliers, _, gapSize) {
  let result;
  multipliers = multipliers || getDataTimeMultipliers(gapSize);
  for (const key in multipliers) {
    result = multipliers[key].reduce(numbersReducer(interval, key), result);
    if (result) {
      break;
    }
  }
  if (!result) {
    for (let factor = 1;; factor *= 10) {
      result = NUMBER_MULTIPLIERS.reduce(yearsReducer(interval, factor), result);
      if (result) {
        break;
      }
    }
  }
  return result;
}
function calculateMinorTickIntervalDateTime(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {
  return calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, true, axisDivisionFactor, DATETIME_MINOR_MULTIPLIERS);
}
function getTickIntervalByCustomTicks(getValue, postProcess) {
  return ticks => ticks ? postProcess(mathAbs((0, _math.adjust)(getValue(ticks[1]) - getValue(ticks[0])))) || undefined : undefined;
}
function addInterval(value, interval, isNegative) {
  return _date.default.addInterval(value, interval, isNegative);
}
function addIntervalLog(log, raise) {
  return (value, interval, isNegative) => raise(addInterval(log(value), interval, isNegative));
}
function addIntervalDate(value, interval, isNegative) {
  return addInterval(value, interval, isNegative);
}
function addIntervalWithBreaks(addInterval, breaks, correctValue) {
  breaks = breaks.filter(b => !b.gapSize);
  return function (value, interval, isNegative) {
    let breakSize;
    value = addInterval(value, interval, isNegative);
    if (!breaks.every(item => {
      if (value >= addInterval(item.from, interval) && addInterval(value, interval) < item.to) {
        breakSize = item.to - item.from - 2 * (addInterval(item.from, interval) - item.from);
      }
      return !breakSize;
    })) {
      value = correctValue(addInterval(value, breakSize), interval);
    }
    return value;
  };
}
function calculateTicks(addInterval, correctMinValue, adjustInterval, resolveEndOnTick) {
  return function (data, tickInterval, endOnTick, gaps, breaks, businessDelta, screenDelta, axisDivisionFactor, generateExtraTick) {
    const correctTickValue = correctTickValueOnGapSize(addInterval, gaps);
    const min = data.min;
    const max = data.max;
    const businessViewInfo = {
      screenDelta: screenDelta,
      businessDelta: businessDelta,
      axisDivisionFactor: axisDivisionFactor,
      isSpacedMargin: data.isSpacedMargin,
      interval: tickInterval
    };
    let cur = correctMinValue(min, tickInterval, businessViewInfo);
    const ticks = [];
    if (breaks !== null && breaks !== void 0 && breaks.length) {
      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);
    }
    if (cur > max) {
      cur = correctMinValue(min, adjustInterval(businessDelta / 2), businessViewInfo);
      if (cur > max) {
        endOnTick = true;
        cur = correctMinValue(min, tickInterval, businessViewInfo, endOnTick);
      }
    }
    cur = correctTickValue(cur);
    let prev;
    while (cur < max && cur !== prev || generateExtraTick && cur <= max) {
      ticks.push(cur);
      prev = cur;
      cur = correctTickValue(addInterval(cur, tickInterval));
    }
    if (endOnTick || cur - max === 0 || !(0, _type.isDefined)(endOnTick) && resolveEndOnTick(max, cur, tickInterval, businessViewInfo)) {
      ticks.push(cur);
    }
    return ticks;
  };
}
function calculateMinorTicks(updateTickInterval, addInterval, correctMinValue, correctTickValue, ceil) {
  return function (min, max, majorTicks, minorTickInterval, tickInterval, breaks, maxCount) {
    const factor = tickInterval / minorTickInterval;
    const lastMajor = majorTicks[majorTicks.length - 1];
    const firstMajor = majorTicks[0];
    let tickBalance = maxCount - 1;
    if (breaks !== null && breaks !== void 0 && breaks.length) {
      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);
    }
    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, firstMajor, factor);
    if (minorTickInterval === 0) {
      return [];
    }

    // min to first tick
    let cur = correctTickValue(correctMinValue(min, tickInterval, min), minorTickInterval);
    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, cur, factor);
    let ticks = [];
    while (cur < firstMajor && (!tickBalance || tickBalance > 0)) {
      cur >= min && ticks.push(cur);
      tickBalance--;
      cur = addInterval(cur, minorTickInterval);
    }

    // between ticks
    const middleTicks = majorTicks.reduce((r, tick) => {
      tickBalance = maxCount - 1;
      if (r.prevTick === null) {
        r.prevTick = tick;
        return r;
      }
      minorTickInterval = updateTickInterval(minorTickInterval, tick, r.prevTick, factor);
      let cur = correctTickValue(r.prevTick, minorTickInterval);
      while (cur < tick && (!tickBalance || tickBalance > 0)) {
        cur !== r.prevTick && r.minors.push(cur);
        tickBalance--;
        cur = addInterval(cur, minorTickInterval);
      }
      r.prevTick = tick;
      return r;
    }, {
      prevTick: null,
      minors: []
    });
    ticks = ticks.concat(middleTicks.minors);

    // last tick to max
    const maxValue = ceil(max, tickInterval, min);
    minorTickInterval = updateTickInterval(minorTickInterval, maxValue, maxValue, factor);
    cur = correctTickValue(lastMajor, minorTickInterval);
    let prev;
    while (cur < max && cur !== prev) {
      ticks.push(cur);
      prev = cur;
      cur = addInterval(cur, minorTickInterval);
    }
    if (lastMajor - max !== 0 && cur - max === 0) {
      ticks.push(cur);
    }
    return ticks;
  };
}
function filterTicks(ticks, breaks) {
  if (breaks.length) {
    const result = breaks.reduce((result, b) => {
      const tmpTicks = [];
      let i;
      for (i = result[1]; i < ticks.length; i++) {
        const tickValue = ticks[i];
        if (tickValue < b.from) {
          tmpTicks.push(tickValue);
        }
        if (tickValue >= b.to) {
          break;
        }
      }
      return [result[0].concat(tmpTicks), i];
    }, [[], 0]);
    return result[0].concat(ticks.slice(result[1]));
  }
  return ticks;
}
function correctTickValueOnGapSize(addInterval, breaks) {
  return function (value) {
    let gapSize;
    if (!breaks.every(item => {
      if (value >= item.from && value < item.to) {
        gapSize = item.gapSize;
      }
      return !gapSize;
    })) {
      value = addInterval(value, gapSize);
    }
    return value;
  };
}
function generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, getMajorTickIntervalByCustomTicks, getMinorTickIntervalByCustomTicks, convertTickInterval, calculateTicks, calculateMinorTicks, processScaleBreaks) {
  function processCustomTicks(customTicks) {
    return {
      tickInterval: getMajorTickIntervalByCustomTicks(customTicks.majors),
      ticks: customTicks.majors || [],
      minorTickInterval: getMinorTickIntervalByCustomTicks(customTicks.minors),
      minorTicks: customTicks.minors || []
    };
  }
  function correctUserTickInterval(tickInterval, businessDelta, limit) {
    if (tickInterval && businessDelta / convertTickInterval(tickInterval) >= limit + 1) {
      options.incidentOccurred('W2003');
      tickInterval = undefined;
    }
    return tickInterval;
  }
  function generateMajorTicks(ticks, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks) {
    if (customTicks.majors) {
      ticks.breaks = breaks;
      return ticks;
    }
    const gaps = breaks.filter(b => b.gapSize);
    let majorTicks;
    tickInterval = options.skipCalculationLimits ? tickInterval : correctUserTickInterval(tickInterval, businessDelta, screenDelta);
    tickInterval = calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, options.axisDivisionFactor, options.numberMultipliers, options.allowDecimals, breaks.length, gaps[0] && gaps[0].gapSize.days, options.minTickInterval);
    if (!options.skipTickGeneration) {
      majorTicks = calculateTicks(data, tickInterval, options.endOnTick, gaps, breaks, businessDelta, screenDelta, options.axisDivisionFactor, options.generateExtraTick);
      breaks = processScaleBreaks(breaks, majorTicks, tickInterval);
      majorTicks = filterTicks(majorTicks, breaks);
      ticks.breaks = breaks;
      ticks.ticks = ticks.ticks.concat(majorTicks);
    }
    ticks.tickInterval = tickInterval;
    return ticks;
  }
  function generateMinorTicks(ticks, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks) {
    if (!options.calculateMinors) {
      return ticks;
    }
    if (customTicks.minors) {
      return ticks;
    }
    const minorBusinessDelta = convertTickInterval(ticks.tickInterval);
    const minorScreenDelta = screenDelta * minorBusinessDelta / businessDelta;
    const breaks = ticks.breaks;
    if (!minorTickInterval && minorTickCount) {
      minorTickInterval = getMinorTickIntervalByCustomTicks([minorBusinessDelta / (minorTickCount + 1), minorBusinessDelta / (minorTickCount + 1) * 2]);
    } else {
      minorTickCount = undefined;
    }
    minorTickInterval = correctUserTickInterval(minorTickInterval, minorBusinessDelta, minorScreenDelta);
    minorTickInterval = calculateMinorTickInterval(minorBusinessDelta, minorScreenDelta, minorTickInterval, options.minorAxisDivisionFactor);
    ticks.minorTicks = filterTicks(ticks.minorTicks.concat(calculateMinorTicks(data.min, data.max, ticks.ticks, minorTickInterval, ticks.tickInterval, breaks, minorTickCount)), breaks);
    ticks.minorTickInterval = minorTickInterval;
    return ticks;
  }
  return function (data, screenDelta, tickInterval, forceTickInterval, customTicks, minorTickInterval, minorTickCount, breaks) {
    customTicks = customTicks || {};
    const businessDelta = getBusinessDelta(data, breaks);
    let result = processCustomTicks(customTicks);
    if (!isNaN(businessDelta)) {
      if (businessDelta === 0 && !customTicks.majors) {
        result.ticks = [data.min];
      } else {
        result = generateMajorTicks(result, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks || []);
        if (!options.skipTickGeneration && businessDelta > 0) {
          result = generateMinorTicks(result, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks);
        }
      }
    }
    return result;
  };
}
function getBaseTick(breakValue, _ref, interval, getValue) {
  let [tick, insideTick] = _ref;
  if (!(0, _type.isDefined)(tick) || mathAbs(getValue(breakValue) - getValue(tick)) / interval > 0.25) {
    if ((0, _type.isDefined)(insideTick) && mathAbs(getValue(insideTick) - getValue(tick)) / interval < 2) {
      tick = insideTick;
    } else if (!(0, _type.isDefined)(tick)) {
      tick = breakValue;
    }
  }
  return tick;
}
function getScaleBreaksProcessor(convertTickInterval, getValue, addCorrection) {
  return function (breaks, ticks, tickInterval) {
    const interval = convertTickInterval(tickInterval);
    const correction = interval * 0.5;
    return breaks.reduce((result, b) => {
      let breakTicks = ticks.filter(tick => tick <= b.from);
      const from = addCorrection(getBaseTick(b.from, [].concat(breakTicks[breakTicks.length - 1], ticks[breakTicks.length]), interval, getValue), correction);
      breakTicks = ticks.filter(tick => tick >= b.to);
      const to = addCorrection(getBaseTick(b.to, [].concat(breakTicks[0], ticks[ticks.length - breakTicks.length - 1]), interval, getValue), -correction);
      if (getValue(to) - getValue(from) < interval && !b.gapSize) {
        return result;
      }
      if (b.gapSize) {
        return result.concat([b]);
      }
      return result.concat([{
        from: from,
        to: to,
        cumulativeWidth: b.cumulativeWidth
      }]);
    }, []);
  };
}
function numericGenerator(options) {
  const floor = correctValueByInterval(getValue, mathFloor, getValue);
  const ceil = correctValueByInterval(getValue, mathCeil, getValue);
  const calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, getValue);
  return generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, getValue, calculateTicks(addInterval, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTick, options.endOnTick), adjustInterval, resolveEndOnTick), calculateMinorTicks(getValue, addInterval, floor, addInterval, getValue), getScaleBreaksProcessor(getValue, getValue, (value, correction) => value + correction));
}
const correctValueByIntervalLog = (post, getRound, getValue) => (value, interval) => (0, _math.sign)(value) * (0, _math.adjust)(post(getRound(value)((0, _math.adjust)(getValue(value) / interval)) * interval));
function logarithmicGenerator(options) {
  const base = options.logBase;
  const raise = raiseTo(base, options.allowNegatives, options.linearThreshold);
  const log = getLogValue(base, options.allowNegatives, options.linearThreshold);
  const absLog = logAbsValue(base);
  const absRaise = mathRaiseTo(base);
  const absFloor = value => value < 0 ? mathCeil : mathFloor;
  const absCeil = value => value < 0 ? mathFloor : mathCeil;
  const floor = correctValueByIntervalLog(absRaise, absFloor, absLog);
  const ceil = correctValueByIntervalLog(absRaise, absCeil, absLog);
  const ceilNumber = correctValueByInterval(getValue, mathCeil, getValue);
  return generator(options, getBusinessDeltaLog(base, options.allowNegatives, options.linearThreshold), getCalculateTickIntervalLog(options.skipCalculationLimits), calculateMinorTickInterval, getTickIntervalByCustomTicks(log, getValue), getTickIntervalByCustomTicks(getValue, getValue), getValue, calculateTicks(addIntervalLog(log, raise), correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickLog(base), options.endOnTick), getAdjustIntervalLog(options.skipCalculationLimits), resolveEndOnTickLog(base)), calculateMinorTicks((_, tick, prevTick, factor) => {
    return Math.max(Math.abs(tick), Math.abs(prevTick)) / factor;
  }, addInterval, floor, ceilNumber, ceil), getScaleBreaksProcessor(getValue, log, (value, correction) => raise(log(value) + correction)));
}
function dateGenerator(options) {
  function floor(value, interval) {
    const floorNumber = correctValueByInterval(getValue, mathFloor, getValue);
    let intervalObject = (0, _type.isString)(interval) ? _date.default.getDateIntervalByString(interval.toLowerCase()) : interval;
    const divider = dateToMilliseconds(interval);
    if (intervalObject.days % 7 === 0 || interval.quarters) {
      intervalObject = adjustIntervalDateTime(divider);
    }
    const correctDateWithUnitBeginning = v => _date.default.correctDateWithUnitBeginning(v, intervalObject, null, options.firstDayOfWeek);
    const floorAtStartDate = v => new Date(mathFloor((v.getTime() - v.getTimezoneOffset() * MINUTE) / divider) * divider + v.getTimezoneOffset() * MINUTE);
    value = correctDateWithUnitBeginning(value);
    if ('years' in intervalObject) {
      value.setFullYear(floorNumber(value.getFullYear(), intervalObject.years));
    } else if ('quarters' in intervalObject) {
      value = correctDateWithUnitBeginning(floorAtStartDate(value));
    } else if ('months' in intervalObject) {
      value.setMonth(floorNumber(value.getMonth(), intervalObject.months));
    } else if ('weeks' in intervalObject || 'days' in intervalObject) {
      value = correctDateWithUnitBeginning(floorAtStartDate(value));
    } else if ('hours' in intervalObject) {
      value.setHours(floorNumber(value.getHours(), intervalObject.hours));
    } else if ('minutes' in intervalObject) {
      value.setMinutes(floorNumber(value.getMinutes(), intervalObject.minutes));
    } else if ('seconds' in intervalObject) {
      value.setSeconds(floorNumber(value.getSeconds(), intervalObject.seconds));
    } else if ('milliseconds' in intervalObject) {
      value = floorAtStartDate(value);
    }
    return value;
  }
  function ceil(value, interval) {
    let newValue = floor(value, interval);
    while (value - newValue > 0) {
      newValue = addIntervalDate(newValue, interval);
    }
    return newValue;
  }
  const calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, _date.default.convertMillisecondsToDateUnits);
  return generator(options, getBusinessDelta, calculateTickIntervalDateTime, calculateMinorTickIntervalDateTime, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, dateToMilliseconds, calculateTicks(addIntervalDate, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickDate, options.endOnTick), adjustIntervalDateTime, resolveEndOnTickDate), calculateMinorTicks(getValue, addIntervalDate, floor, addIntervalDate, getValue), getScaleBreaksProcessor(dateToMilliseconds, getValue, (value, correction) => new Date(value.getTime() + correction)));
}
const tickGenerator = function (options) {
  let result;
  if (options.rangeIsEmpty) {
    result = dummyGenerator(options);
  } else if (options.axisType === 'discrete') {
    result = discreteGenerator(options);
  } else if (options.axisType === 'logarithmic') {
    result = logarithmicGenerator(options);
  } else if (options.dataType === 'datetime') {
    result = dateGenerator(options);
  } else {
    result = numericGenerator(options);
  }
  return result;
};
exports.tickGenerator = tickGenerator;

/***/ }),

/***/ 99415:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _range = __webpack_require__(21177);
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _date = _interopRequireDefault(__webpack_require__(91198));
var _extend = __webpack_require__(13306);
var _datetime_breaks = __webpack_require__(89530);
var _common = __webpack_require__(20576);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _axes_constants = _interopRequireDefault(__webpack_require__(53805));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const getNextDateUnit = _date.default.getNextDateUnit;
const correctDateWithUnitBeginning = _date.default.correctDateWithUnitBeginning;
const _math = Math;
const _max = _math.max;
const TOP = _axes_constants.default.top;
const BOTTOM = _axes_constants.default.bottom;
const LEFT = _axes_constants.default.left;
const RIGHT = _axes_constants.default.right;
const CENTER = _axes_constants.default.center;
const SCALE_BREAK_OFFSET = 3;
const RANGE_RATIO = 0.3;
const WAVED_LINE_CENTER = 2;
const WAVED_LINE_TOP = 0;
const WAVED_LINE_BOTTOM = 4;
const WAVED_LINE_LENGTH = 24;
const TICKS_CORRECTIONS = {
  left: -1,
  top: -1,
  right: 0,
  bottom: 0,
  center: -0.5
};
function prepareDatesDifferences(datesDifferences, tickInterval) {
  let dateUnitInterval;
  let i;
  if (tickInterval === 'week') {
    tickInterval = 'day';
  }
  if (tickInterval === 'quarter') {
    tickInterval = 'month';
  }
  if (datesDifferences[tickInterval]) {
    for (i = 0; i < _date.default.dateUnitIntervals.length; i++) {
      dateUnitInterval = _date.default.dateUnitIntervals[i];
      if (datesDifferences[dateUnitInterval]) {
        datesDifferences[dateUnitInterval] = false;
        datesDifferences.count--;
      }
      if (dateUnitInterval === tickInterval) {
        break;
      }
    }
  }
}
function sortingBreaks(breaks) {
  return breaks.sort(function (a, b) {
    return a.from - b.from;
  });
}
function getMarkerDates(min, max, markerInterval) {
  const origMin = min;
  let dates;
  min = correctDateWithUnitBeginning(min, markerInterval);
  max = correctDateWithUnitBeginning(max, markerInterval);
  dates = _date.default.getSequenceByInterval(min, max, markerInterval);
  if (dates.length && origMin > dates[0]) {
    dates = dates.slice(1);
  }
  return dates;
}
function getStripHorizontalAlignmentPosition(alignment) {
  let position = 'start';
  if (alignment === 'center') {
    position = 'center';
  }
  if (alignment === 'right') {
    position = 'end';
  }
  return position;
}
function getStripVerticalAlignmentPosition(alignment) {
  let position = 'start';
  if (alignment === 'center') {
    position = 'center';
  }
  if (alignment === 'bottom') {
    position = 'end';
  }
  return position;
}
function getMarkerInterval(tickInterval) {
  let markerInterval = getNextDateUnit(tickInterval);
  if (markerInterval === 'quarter') {
    markerInterval = getNextDateUnit(markerInterval);
  }
  return markerInterval;
}
function getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {
  let format = markerInterval;
  const datesDifferences = prevDate && _date.default.getDatesDifferences(prevDate, curDate);
  if (prevDate && tickInterval !== 'year') {
    prepareDatesDifferences(datesDifferences, tickInterval);
    format = _format_helper.default.getDateFormatByDifferences(datesDifferences);
  }
  return format;
}
function getMaxSide(act, boxes) {
  return boxes.reduce(function (prevValue, box) {
    return _max(prevValue, act(box));
  }, 0);
}
function getDistanceByAngle(bBox, rotationAngle) {
  rotationAngle = _math.abs(rotationAngle);
  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;
  const a = rotationAngle * (_math.PI / 180);
  if (a >= _math.atan(bBox.height / bBox.width)) {
    return bBox.height / _math.abs(_math.sin(a));
  } else {
    return bBox.width;
  }
}
function getMaxConstantLinePadding(constantLines) {
  return constantLines.reduce(function (padding, options) {
    return _max(padding, options.paddingTopBottom);
  }, 0);
}
function getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {
  return constantLines.some(function (options) {
    return options.label.verticalAlignment === alignment;
  }) && labelHeight || 0;
}
function getLeftMargin(bBox) {
  return _math.abs(bBox.x) || 0;
}
function getRightMargin(bBox) {
  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;
}
function generateRangesOnPoints(points, edgePoints, getRange) {
  let i;
  let length;
  let maxRange = null;
  const ranges = [];
  let curValue;
  let prevValue;
  let curRange;
  for (i = 1, length = points.length; i < length; i++) {
    curValue = points[i];
    prevValue = points[i - 1];
    curRange = getRange(curValue, prevValue);
    if (edgePoints.indexOf(curValue) >= 0) {
      if (!maxRange || curRange > maxRange.length) {
        maxRange = {
          start: curValue,
          end: prevValue,
          length: curRange
        };
      }
    } else {
      if (maxRange && curRange < maxRange.length) {
        ranges.push(maxRange);
      } else {
        ranges.push({
          start: curValue,
          end: prevValue,
          length: curRange
        });
      }
      maxRange = null;
    }
  }
  if (maxRange) {
    ranges.push(maxRange);
  }
  return ranges;
}
function generateAutoBreaks(_ref, series, _ref2) {
  let {
    logarithmBase,
    type,
    maxAutoBreakCount
  } = _ref;
  let {
    minVisible,
    maxVisible
  } = _ref2;
  const breaks = [];
  const getRange = type === 'logarithmic' ? (min, max) => {
    return (0, _utils.getLog)(max / min, logarithmBase);
  } : (min, max) => {
    return max - min;
  };
  let visibleRange = getRange(minVisible, maxVisible);
  const points = series.reduce((result, s) => {
    const points = s.getPointsInViewPort();
    result[0] = result[0].concat(points[0]);
    result[1] = result[1].concat(points[1]);
    return result;
  }, [[], []]);
  const sortedAllPoints = points[0].concat(points[1]).sort((a, b) => b - a);
  const edgePoints = points[1].filter(p => points[0].indexOf(p) < 0);
  let minDiff = RANGE_RATIO * visibleRange;
  const ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort((a, b) => b.length - a.length);
  const epsilon = _math.min.apply(null, ranges.map(r => r.length)) / 1000;
  const _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;
  for (let i = 0; i < _maxAutoBreakCount; i++) {
    if (ranges[i].length >= minDiff) {
      if (visibleRange <= ranges[i].length) {
        break;
      }
      visibleRange -= ranges[i].length;
      if (visibleRange > epsilon || visibleRange < -epsilon) {
        breaks.push({
          from: ranges[i].start,
          to: ranges[i].end
        });
        minDiff = RANGE_RATIO * visibleRange;
      }
    } else {
      break;
    }
  }
  sortingBreaks(breaks);
  return breaks;
}
var _default = exports["default"] = {
  linear: {
    _getStep: function (boxes, rotationAngle) {
      const spacing = this._options.label.minSpacing;
      const func = this._isHorizontal ? function (box) {
        return box.width + spacing;
      } : function (box) {
        return box.height;
      };
      let maxLabelLength = getMaxSide(func, boxes);
      if (rotationAngle) {
        maxLabelLength = getDistanceByAngle({
          width: maxLabelLength,
          height: this._getMaxLabelHeight(boxes, 0)
        }, rotationAngle);
      }
      return _axes_constants.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? 'x' : 'y', maxLabelLength);
    },
    _getMaxLabelHeight: function (boxes, spacing) {
      return getMaxSide(function (box) {
        return box.height;
      }, boxes) + spacing;
    },
    _validateOverlappingMode: function (mode, displayMode) {
      if (this._isHorizontal && (displayMode === 'rotate' || displayMode === 'stagger') || !this._isHorizontal) {
        return _axes_constants.default.validateOverlappingMode(mode);
      }
      return mode;
    },
    _validateDisplayMode: function (mode) {
      return this._isHorizontal ? mode : 'standard';
    },
    getMarkerTrackers: function () {
      return this._markerTrackers;
    },
    _getSharpParam: function (opposite) {
      return this._isHorizontal ^ opposite ? 'h' : 'v';
    },
    _createAxisElement: function () {
      return this._renderer.path([], 'line');
    },
    _updateAxisElementPosition: function () {
      const axisCoord = this._axisPosition;
      const canvas = this._getCanvasStartEnd();
      this._axisElement.attr({
        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]
      });
    },
    _getTranslatedCoord: function (value, offset) {
      return this._translator.translate(value, offset);
    },
    _initAxisPositions() {
      const that = this;
      if (that.customPositionIsAvailable()) {
        that._customBoundaryPosition = that.getCustomBoundaryPosition();
      }
      if (!that.customPositionIsAvailable() || that.customPositionIsBoundary()) {
        that._axisPosition = that.getPredefinedPosition(that.getResolvedBoundaryPosition());
      } else {
        that._axisPosition = that.getCustomPosition();
      }
    },
    _getTickMarkPoints(coords, length, tickOptions) {
      const isHorizontal = this._isHorizontal;
      const tickOrientation = this._options.tickOrientation;
      const labelPosition = this._options.label.position;
      let tickStartCoord;
      if ((0, _type.isDefined)(tickOrientation)) {
        tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length;
      } else {
        let shift = tickOptions.shift || 0;
        if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {
          shift = -shift;
        }
        tickStartCoord = shift + this.getTickStartPositionShift(length);
      }
      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];
    },
    getTickStartPositionShift(length) {
      const width = this._options.width;
      const position = this.getResolvedBoundaryPosition();
      return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1);
    },
    _getTitleCoords: function () {
      const that = this;
      const horizontal = that._isHorizontal;
      let x = that._axisPosition;
      let y = that._axisPosition;
      const align = that._options.title.alignment;
      const canvas = that._getCanvasStartEnd();
      const fromStartToEnd = horizontal || that._options.position === LEFT;
      const canvasStart = fromStartToEnd ? canvas.start : canvas.end;
      const canvasEnd = fromStartToEnd ? canvas.end : canvas.start;
      const coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;
      if (horizontal) {
        x = coord;
      } else {
        y = coord;
      }
      return {
        x: x,
        y: y
      };
    },
    _drawTitleText: function (group, coords) {
      const options = this._options;
      const titleOptions = options.title;
      const attrs = {
        opacity: titleOptions.opacity,
        align: titleOptions.alignment,
        'class': titleOptions.cssClass
      };
      if (!titleOptions.text || !group) {
        return;
      }
      coords = coords || this._getTitleCoords();
      if (!this._isHorizontal) {
        attrs.rotate = options.position === LEFT ? 270 : 90;
      }
      const text = this._renderer.text(titleOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)(titleOptions.font)).attr(attrs).append(group);
      this._checkTitleOverflow(text);
      return text;
    },
    _updateTitleCoords: function () {
      this._title && this._title.element.attr(this._getTitleCoords());
    },
    _drawTitle: function () {
      const title = this._drawTitleText(this._axisTitleGroup);
      if (title) {
        this._title = {
          element: title
        };
      }
    },
    _measureTitle: function () {
      if (this._title) {
        if (this._title.bBox && !this._title.originalSize) {
          this._title.originalSize = this._title.bBox;
        }
        this._title.bBox = this._title.element.getBBox();
      }
    },
    _drawDateMarker: function (date, options, range) {
      const that = this;
      const markerOptions = that._options.marker;
      const invert = that._translator.getBusinessRange().invert;
      const textIndent = markerOptions.width + markerOptions.textLeftIndent;
      let pathElement;
      if (options.x === null) return;
      if (!options.withoutStick) {
        pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], 'line').attr({
          'stroke-width': markerOptions.width,
          stroke: markerOptions.color,
          'stroke-opacity': markerOptions.opacity,
          sharp: 'h'
        }).append(that._axisElementsGroup);
      }
      const text = String(that.formatLabel(date, options.labelOptions, range));
      return {
        date: date,
        x: options.x,
        y: options.y,
        cropped: options.withoutStick,
        label: that._renderer.text(text, options.x, options.y).css((0, _utils.patchFontOptions)(markerOptions.label.font)).append(that._axisElementsGroup),
        line: pathElement,
        getContentContainer() {
          return this.label;
        },
        getEnd: function () {
          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);
        },
        setTitle: function () {
          this.title = text;
        },
        hideLabel: function () {
          this.label.dispose();
          this.label = null;
          this.title = text;
        },
        hide: function () {
          if (pathElement) {
            pathElement.dispose();
            pathElement = null;
          }
          this.label.dispose();
          this.label = null;
          this.hidden = true;
        }
      };
    },
    _drawDateMarkers: function () {
      const that = this;
      const options = that._options;
      const translator = that._translator;
      const viewport = that._getViewportRange();
      const minBound = viewport.minVisible;
      let dateMarkers = [];
      let dateMarker;
      function draw(markerDate, format, withoutStick) {
        return that._drawDateMarker(markerDate, {
          x: translator.translate(markerDate),
          y: markersAreaTop,
          labelOptions: that._getLabelFormatOptions(format),
          withoutStick: withoutStick
        }, viewport);
      }
      if (viewport.isEmpty() || !options.marker.visible || options.argumentType !== 'datetime' || options.type === 'discrete' || that._majorTicks.length <= 1) {
        return [];
      }
      const markersAreaTop = that._axisPosition + options.marker.topIndent;
      const tickInterval = _date.default.getDateUnitInterval(this._tickInterval);
      const markerInterval = getMarkerInterval(tickInterval);
      const markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);
      if (markerDates.length > 1 || markerDates.length === 1 && minBound < markerDates[0]) {
        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {
          const marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));
          marker && markers.push(marker);
          return markers;
        }, []);
        if (minBound < markerDates[0]) {
          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);
          dateMarker && dateMarkers.unshift(dateMarker);
        }
      }
      return dateMarkers;
    },
    _adjustDateMarkers: function (offset) {
      offset = offset || 0;
      const that = this;
      const markerOptions = this._options.marker;
      const textIndent = markerOptions.width + markerOptions.textLeftIndent;
      const invert = this._translator.getBusinessRange().invert;
      const canvas = that._getCanvasStartEnd();
      const dateMarkers = this._dateMarkers;
      if (!dateMarkers.length) {
        return offset;
      }
      if (dateMarkers[0].cropped) {
        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {
          dateMarkers[0].hideLabel();
        }
      }
      let prevDateMarker;
      dateMarkers.forEach(function (marker, i, markers) {
        if (marker.cropped) {
          return;
        }
        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {
          marker.hideLabel();
        } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {
          prevDateMarker = marker;
        } else {
          marker.hide();
        }
      });
      this._dateMarkers.forEach(function (marker) {
        if (marker.label) {
          const labelBBox = marker.labelBBox;
          const dy = marker.y + markerOptions.textTopIndent - labelBBox.y;
          marker.label.attr({
            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,
            translateY: dy + offset
          });
        }
        if (marker.line) {
          marker.line.attr({
            translateY: offset
          });
        }
      });
      that._initializeMarkersTrackers(offset);
      return offset + markerOptions.topIndent + markerOptions.separatorHeight;
    },
    _checkMarkersPosition: function (invert, dateMarker, prevDateMarker) {
      if (prevDateMarker === undefined) {
        return true;
      }
      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();
    },
    _initializeMarkersTrackers: function (offset) {
      const that = this;
      const separatorHeight = that._options.marker.separatorHeight;
      const renderer = that._renderer;
      const businessRange = this._translator.getBusinessRange();
      const canvas = that._getCanvasStartEnd();
      const group = that._axisElementsGroup;
      that._markerTrackers = this._dateMarkers.filter(function (marker) {
        return !marker.hidden;
      }).map(function (marker, i, markers) {
        const nextMarker = markers[i + 1] || {
          x: canvas.end,
          date: businessRange.max
        };
        const x = marker.x;
        const y = marker.y + offset;
        const markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], 'area').attr({
          'stroke-width': 1,
          stroke: 'grey',
          fill: 'grey',
          opacity: 0.0001
        }).append(group);
        markerTracker.data('range', {
          startValue: marker.date,
          endValue: nextMarker.date
        });
        if (marker.title) {
          markerTracker.setTitle(marker.title);
        }
        return markerTracker;
      });
    },
    _getLabelFormatOptions: function (formatString) {
      const that = this;
      let markerLabelOptions = that._markerLabelOptions;
      if (!markerLabelOptions) {
        that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label);
      }
      if (!(0, _type.isDefined)(that._options.marker.label.format)) {
        markerLabelOptions.format = formatString;
      }
      return markerLabelOptions;
    },
    _adjustConstantLineLabels: function (constantLines) {
      const that = this;
      const axisPosition = that._options.position;
      const canvas = that.getCanvas();
      const canvasLeft = canvas.left;
      const canvasRight = canvas.width - canvas.right;
      const canvasTop = canvas.top;
      const canvasBottom = canvas.height - canvas.bottom;
      const verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;
      const horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;
      let maxLabel = 0;
      constantLines.forEach(function (item) {
        const isHorizontal = that._isHorizontal;
        const linesOptions = item.options;
        const paddingTopBottom = linesOptions.paddingTopBottom;
        const paddingLeftRight = linesOptions.paddingLeftRight;
        const labelOptions = linesOptions.label;
        const labelVerticalAlignment = labelOptions.verticalAlignment;
        const labelHorizontalAlignment = labelOptions.horizontalAlignment;
        const labelIsInside = labelOptions.position === 'inside';
        const label = item.label;
        const box = item.labelBBox;
        let translateX;
        let translateY;
        if (label === null || box.isEmpty) {
          return;
        }
        if (isHorizontal) {
          if (labelIsInside) {
            if (labelHorizontalAlignment === LEFT) {
              translateX = item.coord - paddingLeftRight - box.x - box.width;
            } else {
              translateX = item.coord + paddingLeftRight - box.x;
            }
            switch (labelVerticalAlignment) {
              case CENTER:
                translateY = verticalCenter - box.y - box.height / 2;
                break;
              case BOTTOM:
                translateY = canvasBottom - paddingTopBottom - box.y - box.height;
                break;
              default:
                translateY = canvasTop + paddingTopBottom - box.y;
                break;
            }
          } else {
            if (axisPosition === labelVerticalAlignment) {
              maxLabel = _max(maxLabel, box.height + paddingTopBottom);
            }
            translateX = item.coord - box.x - box.width / 2;
            if (labelVerticalAlignment === BOTTOM) {
              translateY = canvasBottom + paddingTopBottom - box.y;
            } else {
              translateY = canvasTop - paddingTopBottom - box.y - box.height;
            }
          }
        } else {
          if (labelIsInside) {
            if (labelVerticalAlignment === BOTTOM) {
              translateY = item.coord + paddingTopBottom - box.y;
            } else {
              translateY = item.coord - paddingTopBottom - box.y - box.height;
            }
            switch (labelHorizontalAlignment) {
              case CENTER:
                translateX = horizontalCenter - box.x - box.width / 2;
                break;
              case RIGHT:
                translateX = canvasRight - paddingLeftRight - box.x - box.width;
                break;
              default:
                translateX = canvasLeft + paddingLeftRight - box.x;
                break;
            }
          } else {
            if (axisPosition === labelHorizontalAlignment) {
              maxLabel = _max(maxLabel, box.width + paddingLeftRight);
            }
            translateY = item.coord - box.y - box.height / 2;
            if (labelHorizontalAlignment === RIGHT) {
              translateX = canvasRight + paddingLeftRight - box.x;
            } else {
              translateX = canvasLeft - paddingLeftRight - box.x - box.width;
            }
          }
        }
        label.attr({
          translateX: translateX,
          translateY: translateY
        });
      });
      return maxLabel;
    },
    _drawConstantLinesForEstimating: function (constantLines) {
      const that = this;
      const renderer = this._renderer;
      const group = renderer.g();
      constantLines.forEach(function (options) {
        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({
          align: 'center'
        });
      });
      return group.append(renderer.root);
    },
    _estimateLabelHeight: function (bBox, labelOptions) {
      let height = bBox.height;
      const drawingType = labelOptions.drawingType;
      if (this._validateDisplayMode(drawingType) === 'stagger' || this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType) === 'stagger') {
        height = height * 2 + labelOptions.staggeringSpacing;
      }
      if (this._validateDisplayMode(drawingType) === 'rotate' || this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType) === 'rotate') {
        const sinCos = (0, _utils.getCosAndSin)(labelOptions.rotationAngle);
        height = height * sinCos.cos + bBox.width * sinCos.sin;
      }
      return height && (height + labelOptions.indentFromAxis || 0) || 0;
    },
    estimateMargins: function (canvas) {
      this.updateCanvas(canvas);
      const {
        position,
        placeholderSize
      } = this._options;
      const that = this;
      const range = that._getViewportRange();
      const ticksData = this._createTicksAndLabelFormat(range);
      const ticks = ticksData.ticks;
      const tickInterval = ticksData.tickInterval;
      const options = this._options;
      const constantLineOptions = that._outsideConstantLines.filter(l => l.labelOptions.visible).map(l => l.options);
      const rootElement = that._renderer.root;
      const labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;
      const labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, undefined, undefined, tickInterval, ticks);
      const labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);
      const titleElement = that._drawTitleText(rootElement, {
        x: 0,
        y: 0
      });
      const constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);
      const labelBox = !options.label.template && labelElement && labelElement.getBBox() || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      const titleBox = titleElement && titleElement.getBBox() || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      const constantLinesBox = constantLinesLabelsElement.getBBox();
      const titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;
      const labelHeight = that._estimateLabelHeight(labelBox, options.label);
      const constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;
      const height = labelHeight + titleHeight;
      const margins = {
        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),
        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),
        top: (options.position === 'top' ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, 'top', constantLinesHeight),
        bottom: (options.position !== 'top' ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, 'bottom', constantLinesHeight)
      };
      if (placeholderSize) {
        margins[position] = placeholderSize;
      }
      labelElement && labelElement.remove();
      titleElement && titleElement.remove();
      constantLinesLabelsElement && constantLinesLabelsElement.remove();
      return margins;
    },
    _checkAlignmentConstantLineLabels: function (labelOptions) {
      const position = labelOptions.position;
      let verticalAlignment = (labelOptions.verticalAlignment || '').toLowerCase();
      let horizontalAlignment = (labelOptions.horizontalAlignment || '').toLowerCase();
      if (this._isHorizontal) {
        if (position === 'outside') {
          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = CENTER;
        } else {
          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;
        }
      } else {
        if (position === 'outside') {
          verticalAlignment = CENTER;
          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;
        } else {
          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;
        }
      }
      labelOptions.verticalAlignment = verticalAlignment;
      labelOptions.horizontalAlignment = horizontalAlignment;
    },
    _getConstantLineLabelsCoords: function (value, lineLabelOptions) {
      const that = this;
      let x = value;
      let y = value;
      if (that._isHorizontal) {
        y = that._orthogonalPositions[lineLabelOptions.verticalAlignment === 'top' ? 'start' : 'end'];
      } else {
        x = that._orthogonalPositions[lineLabelOptions.horizontalAlignment === 'right' ? 'end' : 'start'];
      }
      return {
        x: x,
        y: y
      };
    },
    _getAdjustedStripLabelCoords: function (strip) {
      const stripOptions = strip.options;
      const paddingTopBottom = stripOptions.paddingTopBottom;
      const paddingLeftRight = stripOptions.paddingLeftRight;
      const horizontalAlignment = stripOptions.label.horizontalAlignment;
      const verticalAlignment = stripOptions.label.verticalAlignment;
      const box = strip.labelBBox;
      const labelHeight = box.height;
      const labelWidth = box.width;
      const labelCoords = strip.labelCoords;
      let y = labelCoords.y - box.y;
      let x = labelCoords.x - box.x;
      if (verticalAlignment === TOP) {
        y += paddingTopBottom;
      } else if (verticalAlignment === CENTER) {
        y -= labelHeight / 2;
      } else if (verticalAlignment === BOTTOM) {
        y -= paddingTopBottom + labelHeight;
      }
      if (horizontalAlignment === LEFT) {
        x += paddingLeftRight;
      } else if (horizontalAlignment === CENTER) {
        x -= labelWidth / 2;
      } else if (horizontalAlignment === RIGHT) {
        x -= paddingLeftRight + labelWidth;
      }
      return {
        translateX: x,
        translateY: y
      };
    },
    _adjustTitle: function (offset) {
      offset = offset || 0;
      if (!this._title) {
        return;
      }
      const that = this;
      const options = that._options;
      const position = options.position;
      const margin = options.title.margin;
      const title = that._title;
      const boxTitle = title.bBox;
      const x = boxTitle.x;
      const y = boxTitle.y;
      const width = boxTitle.width;
      const height = boxTitle.height;
      const axisPosition = that._axisPosition;
      const loCoord = axisPosition - margin - offset;
      const hiCoord = axisPosition + margin + offset;
      const params = {};
      if (that._isHorizontal) {
        if (position === TOP) {
          params.translateY = loCoord - (y + height);
        } else {
          params.translateY = hiCoord - y;
        }
      } else {
        if (position === LEFT) {
          params.translateX = loCoord - (x + width);
        } else {
          params.translateX = hiCoord - x;
        }
      }
      title.element.attr(params);
    },
    _checkTitleOverflow: function (titleElement) {
      if (!this._title && !titleElement) {
        return;
      }
      const canvasLength = this._getScreenDelta();
      const title = titleElement ? {
        bBox: titleElement.getBBox(),
        element: titleElement
      } : this._title;
      const titleOptions = this._options.title;
      const boxTitle = title.bBox;
      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {
        title.element.setMaxSize(canvasLength, undefined, {
          wordWrap: titleOptions.wordWrap || 'none',
          textOverflow: titleOptions.textOverflow || 'ellipsis'
        });
        this._wrapped = titleOptions.wordWrap && titleOptions.wordWrap !== 'none';
      } else {
        const moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);
        !this._wrapped && moreThanOriginalSize && title.element.restoreText();
      }
    },
    coordsIn: function (x, y) {
      const canvas = this.getCanvas();
      const isHorizontal = this._options.isHorizontal;
      const position = this._options.position;
      const coord = isHorizontal ? y : x;
      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {
        return false;
      }
      if (isHorizontal && position === _axes_constants.default.top || !isHorizontal && position === _axes_constants.default.left) {
        return coord < canvas[position];
      }
      return coord > canvas[isHorizontal ? 'height' : 'width'] - canvas[position];
    },
    _boundaryTicksVisibility: {
      min: true,
      max: true
    },
    adjust() {
      const that = this;
      const seriesData = that._seriesData;
      const viewport = that._series.filter(s => s.isVisible()).reduce((range, s) => {
        const seriesRange = s.getViewport();
        range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;
        range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;
        if (s.showZero) {
          range = new _range.Range(range);
          range.correctValueZeroLevel();
        }
        return range;
      }, {});
      if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {
        seriesData.minVisible = viewport.min;
        seriesData.maxVisible = viewport.max;
      }
      seriesData.userBreaks = that._getScaleBreaks(that._options, {
        minVisible: seriesData.minVisible,
        maxVisible: seriesData.maxVisible
      }, that._series, that.isArgumentAxis);
      that._translator.updateBusinessRange(that._getViewportRange());
    },
    hasWrap() {
      return this._wrapped;
    },
    getAxisPosition() {
      return this._axisPosition;
    },
    _getStick: function () {
      return !this._options.valueMarginsEnabled;
    },
    _getStripLabelCoords: function (from, to, stripLabelOptions) {
      const that = this;
      const orthogonalPositions = that._orthogonalPositions;
      const isHorizontal = that._isHorizontal;
      const horizontalAlignment = stripLabelOptions.horizontalAlignment;
      const verticalAlignment = stripLabelOptions.verticalAlignment;
      let x;
      let y;
      if (isHorizontal) {
        if (horizontalAlignment === CENTER) {
          x = from + (to - from) / 2;
        } else if (horizontalAlignment === LEFT) {
          x = from;
        } else if (horizontalAlignment === RIGHT) {
          x = to;
        }
        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];
      } else {
        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];
        if (verticalAlignment === TOP) {
          y = from;
        } else if (verticalAlignment === CENTER) {
          y = to + (from - to) / 2;
        } else if (verticalAlignment === BOTTOM) {
          y = to;
        }
      }
      return {
        x: x,
        y: y
      };
    },
    _getTranslatedValue: function (value, offset) {
      let interval;
      if (this._options.type === 'semidiscrete') {
        interval = this._options.tickInterval;
      }
      const pos1 = this._translator.translate(value, offset, false, interval);
      const pos2 = this._axisPosition;
      const isHorizontal = this._isHorizontal;
      return {
        x: isHorizontal ? pos1 : pos2,
        y: isHorizontal ? pos2 : pos1
      };
    },
    areCoordsOutsideAxis: function (coords) {
      const coord = this._isHorizontal ? coords.x : coords.y;
      const visibleArea = this.getVisibleArea();
      if (coord < visibleArea[0] || coord > visibleArea[1]) {
        return true;
      }
      return false;
    },
    _getSkippedCategory: function (ticks) {
      let skippedCategory;
      if (this._options.type === _axes_constants.default.discrete && this._tickOffset && ticks.length !== 0) {
        skippedCategory = ticks[ticks.length - 1];
      }
      return skippedCategory;
    },
    _filterBreaks: function (breaks, viewport, breakStyle) {
      const minVisible = viewport.minVisible;
      const maxVisible = viewport.maxVisible;
      const breakSize = breakStyle ? breakStyle.width : 0;
      return breaks.reduce(function (result, currentBreak) {
        let from = currentBreak.from;
        let to = currentBreak.to;
        const lastResult = result[result.length - 1];
        let newBreak;
        if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {
          return result;
        }
        if (from > to) {
          to = [from, from = to][0];
        }
        if (result.length && from < lastResult.to) {
          if (to > lastResult.to) {
            lastResult.to = to > maxVisible ? maxVisible : to;
            if (lastResult.gapSize) {
              lastResult.gapSize = undefined;
              lastResult.cumulativeWidth += breakSize;
            }
          }
        } else {
          if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {
            from = from >= minVisible ? from : minVisible;
            to = to <= maxVisible ? to : maxVisible;
            if (to - from < maxVisible - minVisible) {
              newBreak = {
                from: from,
                to: to,
                cumulativeWidth: ((lastResult === null || lastResult === void 0 ? void 0 : lastResult.cumulativeWidth) ?? 0) + breakSize
              };
              if (currentBreak.gapSize) {
                newBreak.gapSize = _date.default.convertMillisecondsToDateUnits(to - from);
                newBreak.cumulativeWidth = (lastResult === null || lastResult === void 0 ? void 0 : lastResult.cumulativeWidth) ?? 0;
              }
              result.push(newBreak);
            }
          }
        }
        return result;
      }, []);
    },
    _getScaleBreaks: function (axisOptions, viewport, series, isArgumentAxis) {
      const that = this;
      let breaks = (axisOptions.breaks || []).map(function (b) {
        return {
          from: that.parser(b.startValue),
          to: that.parser(b.endValue)
        };
      });
      if (axisOptions.type !== 'discrete' && axisOptions.dataType === 'datetime' && axisOptions.workdaysOnly) {
        breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));
      }
      if (!isArgumentAxis && axisOptions.type !== 'discrete' && axisOptions.dataType !== 'datetime' && axisOptions.autoBreaksEnabled && axisOptions.maxAutoBreakCount !== 0) {
        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));
      }
      return sortingBreaks(breaks);
    },
    _drawBreak: function (translatedEnd, positionFrom, positionTo, width, options, group) {
      const that = this;
      const breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);
      const attr = {
        'stroke-width': 1,
        stroke: options.borderColor,
        sharp: !options.isWaved ? options.isHorizontal ? 'h' : 'v' : undefined
      };
      const spaceAttr = {
        stroke: options.color,
        'stroke-width': width
      };
      const getPoints = that._isHorizontal ? rotateLine : function (p) {
        return p;
      };
      const drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);
      drawer(width / 2, spaceAttr);
      drawer(0, attr);
      drawer(width, attr);
    },
    _createBreakClipRect: function (from, to) {
      const that = this;
      const canvas = that._canvas;
      const clipWidth = to - from;
      let clipRect;
      if (that._isHorizontal) {
        clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);
      } else {
        clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);
      }
      that._breaksElements = that._breaksElements || [];
      that._breaksElements.push(clipRect);
      return clipRect.id;
    },
    _createBreaksGroup: function (clipFrom, clipTo) {
      const that = this;
      const group = that._renderer.g().attr({
        'class': that._axisCssPrefix + 'breaks',
        'clip-path': that._createBreakClipRect(clipFrom, clipTo)
      }).append(that._scaleBreaksGroup);
      that._breaksElements = that._breaksElements || [];
      that._breaksElements.push(group);
      return group;
    },
    _disposeBreaksGroup: function () {
      (this._breaksElements || []).forEach(function (clipRect) {
        clipRect.dispose();
      });
      this._breaksElements = null;
    },
    drawScaleBreaks: function (customCanvas) {
      const that = this;
      const options = that._options;
      const breakStyle = options.breakStyle;
      const position = options.position;
      let positionFrom;
      let positionTo;
      const breaks = that._translator.getBusinessRange().breaks || [];
      let additionGroup;
      let additionBreakFrom;
      let additionBreakTo;
      that._disposeBreaksGroup();
      if (!(breaks && breaks.length)) {
        return;
      }
      const breakOptions = {
        color: that._options.containerColor,
        borderColor: breakStyle.color,
        isHorizontal: that._isHorizontal,
        isWaved: breakStyle.line.toLowerCase() !== 'straight'
      };
      if (customCanvas) {
        positionFrom = customCanvas.start;
        positionTo = customCanvas.end;
      } else {
        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);
        positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0);
      }
      const mainGroup = that._createBreaksGroup(positionFrom, positionTo);
      if (that._axisShift && options.visible) {
        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;
        additionBreakTo = additionBreakFrom + SCALE_BREAK_OFFSET * 2;
        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);
      }
      breaks.forEach(function (br) {
        if (!br.gapSize) {
          const breakCoord = that._getTranslatedCoord(br.to);
          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);
          if (that._axisShift && options.visible) {
            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);
          }
        }
      });
    },
    _getSpiderCategoryOption: _common.noop,
    shift: function (margins) {
      const that = this;
      const options = that._options;
      const isHorizontal = options.isHorizontal;
      const axesSpacing = that.getMultipleAxesSpacing();
      const constantLinesGroups = that._axisConstantLineGroups;
      function shiftGroup(side, group) {
        const attr = {
          translateX: 0,
          translateY: 0
        };
        const shift = margins[side] ? margins[side] + axesSpacing : 0;
        attr[isHorizontal ? 'translateY' : 'translateX'] = (side === LEFT || side === TOP ? -1 : 1) * shift;
        (group[side] || group).attr(attr);
        return shift;
      }
      that._axisShift = shiftGroup(options.position, that._axisGroup);
      shiftGroup(options.position, that._axisElementsGroup);
      (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(side => {
        shiftGroup(side, constantLinesGroups.above);
        shiftGroup(side, constantLinesGroups.under);
      });
    },
    getCustomPosition(position) {
      const that = this;
      const orthogonalAxis = that.getOrthogonalAxis();
      const resolvedPosition = position ?? that.getResolvedPositionOption();
      const offset = that.getOptions().offset;
      const orthogonalTranslator = orthogonalAxis.getTranslator();
      const orthogonalAxisType = orthogonalAxis.getOptions().type;
      let validPosition = orthogonalAxis.validateUnit(resolvedPosition);
      let currentPosition;
      if (orthogonalAxisType === 'discrete' && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {
        validPosition = undefined;
      }
      if (that.positionIsBoundary(resolvedPosition)) {
        currentPosition = that.getPredefinedPosition(resolvedPosition);
      } else if (!(0, _type.isDefined)(validPosition)) {
        currentPosition = that.getPredefinedPosition(that.getOptions().position);
      } else {
        currentPosition = orthogonalTranslator.to(validPosition, -1);
      }
      if (isFinite(currentPosition) && isFinite(offset)) {
        currentPosition += offset;
      }
      return currentPosition;
    },
    getCustomBoundaryPosition(position) {
      const that = this;
      const {
        customPosition,
        offset
      } = that.getOptions();
      const resolvedPosition = position ?? that.getResolvedPositionOption();
      const orthogonalAxis = that.getOrthogonalAxis();
      const orthogonalTranslator = orthogonalAxis.getTranslator();
      const visibleArea = orthogonalTranslator.getCanvasVisibleArea();
      if (!(0, _type.isDefined)(orthogonalAxis._orthogonalPositions) || orthogonalTranslator.canvasLength === 0) {
        return undefined;
      }
      const currentPosition = that.getCustomPosition(resolvedPosition);
      if (!(0, _type.isDefined)(currentPosition)) {
        return that.getResolvedBoundaryPosition();
      } else if ((0, _type.isDefined)(customPosition)) {
        if (currentPosition <= visibleArea.min) {
          return that._isHorizontal ? TOP : LEFT;
        } else if (currentPosition >= visibleArea.max) {
          return that._isHorizontal ? BOTTOM : RIGHT;
        }
      } else if ((0, _type.isDefined)(offset)) {
        if (currentPosition <= that._orthogonalPositions.start) {
          return that._isHorizontal ? TOP : LEFT;
        } else if (currentPosition >= that._orthogonalPositions.end) {
          return that._isHorizontal ? BOTTOM : RIGHT;
        }
      }
      return currentPosition;
    },
    getResolvedPositionOption() {
      const options = this.getOptions();
      return options.customPosition ?? options.position;
    },
    customPositionIsAvailable() {
      const options = this.getOptions();
      return (0, _type.isDefined)(this.getOrthogonalAxis()) && ((0, _type.isDefined)(options.customPosition) || isFinite(options.offset));
    },
    hasNonBoundaryPosition() {
      return this.customPositionIsAvailable() && !this.customPositionIsBoundary();
    },
    getResolvedBoundaryPosition() {
      return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position;
    },
    customPositionEqualsToPredefined() {
      return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position;
    },
    customPositionIsBoundary() {
      return this.positionIsBoundary(this._customBoundaryPosition);
    },
    positionIsBoundary(position) {
      return [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0;
    },
    getPredefinedPosition(position) {
      var _this$_orthogonalPosi;
      return (_this$_orthogonalPosi = this._orthogonalPositions) === null || _this$_orthogonalPosi === void 0 ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? 'start' : 'end'];
    },
    resolveOverlappingForCustomPositioning(oppositeAxes) {
      const that = this;
      if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(a => a.hasNonBoundaryPosition())) {
        return;
      }
      const overlappingObj = {
        axes: [],
        ticks: []
      };
      oppositeAxes.filter(orthogonalAxis => orthogonalAxis.pane === that.pane).forEach(orthogonalAxis => {
        for (let i = 0; i < that._majorTicks.length; i++) {
          const tick = that._majorTicks[i];
          const label = tick.label;
          if (label) {
            if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {
              overlappingObj.axes.push(orthogonalAxis);
              that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis);
            }
            for (let j = 0; j < orthogonalAxis._majorTicks.length; j++) {
              const oppositeTick = orthogonalAxis._majorTicks[j];
              const oppositeLabel = oppositeTick.label;
              if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {
                overlappingObj.ticks.push(tick);
                that._shiftThroughAxisOverlappedTick(tick);
                i = that._majorTicks.length;
                break;
              }
            }
          }
          if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {
            if (that._isHorizontal && tick.mark.attr('translateY')) {
              tick.mark.attr({
                translateY: 0
              });
            } else if (!that._isHorizontal && tick.mark.attr('translateX')) {
              tick.mark.attr({
                translateX: 0
              });
            }
          }
        }
      });
    },
    _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {
      const that = this;
      const labelBBox = label.getBBox();
      const orthogonalAxisPosition = orthogonalAxis.getAxisPosition();
      const orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;
      const orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;
      const orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;
      const translateCoordName = that._isHorizontal ? 'translateX' : 'translateY';
      const defaultOrthogonalAxisLabelPosition = that._isHorizontal ? LEFT : TOP;
      const translate = label.attr(translateCoordName);
      const labelCoord = (that._isHorizontal ? labelBBox.x : labelBBox.y) + translate;
      const labelSize = that._isHorizontal ? labelBBox.width : labelBBox.height;
      const outsidePart = orthogonalAxisPosition - labelCoord;
      const insidePart = labelCoord + labelSize - orthogonalAxisPosition;
      const attr = {};
      attr[translateCoordName] = translate;
      if (outsidePart > 0 && insidePart > 0) {
        if (insidePart - outsidePart > 1) {
          attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent;
        } else if (outsidePart - insidePart > 1) {
          attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent;
        } else {
          attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent);
        }
        label.attr(attr);
      }
    },
    _shiftThroughAxisOverlappedTick(tick) {
      var _tick$mark;
      const that = this;
      const label = tick.label;
      if (!label) {
        return;
      }
      const labelBBox = label.getBBox();
      const tickMarkBBox = (_tick$mark = tick.mark) === null || _tick$mark === void 0 ? void 0 : _tick$mark.getBBox();
      const axisPosition = that.getAxisPosition();
      const labelOptions = that.getOptions().label;
      const labelIndent = labelOptions.indentFromAxis;
      const labelPosition = labelOptions.position;
      const defaultLabelPosition = that._isHorizontal ? TOP : LEFT;
      const translateCoordName = that._isHorizontal ? 'translateY' : 'translateX';
      const translate = label.attr(translateCoordName);
      const labelCoord = (that._isHorizontal ? labelBBox.y : labelBBox.x) + translate;
      const labelSize = that._isHorizontal ? labelBBox.height : labelBBox.width;
      const attr = {};
      attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));
      label.attr(attr);
      if (tick.mark) {
        const markerSize = that._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;
        const dir = labelPosition === defaultLabelPosition ? 1 : -1;
        attr[translateCoordName] = dir * (markerSize - 1);
        tick.mark.attr(attr);
      }
    },
    _detectElementsOverlapping(element1, element2) {
      if (!element1 || !element2) {
        return false;
      }
      const bBox1 = element1.getBBox();
      const x1 = bBox1.x + element1.attr('translateX');
      const y1 = bBox1.y + element1.attr('translateY');
      const bBox2 = element2.getBBox();
      const x2 = bBox2.x + element2.attr('translateX');
      const y2 = bBox2.y + element2.attr('translateY');
      return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height);
    }
  }
};
function getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {
  const elementType = isWaved ? 'bezier' : 'line';
  const group = renderer.g().append(root);
  return function (offset, attr) {
    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);
  };
}
function getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {
  if (!isWaved) {
    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];
  }
  breakStart += offset;
  let currentPosition;
  const topPoint = breakStart + WAVED_LINE_TOP;
  const centerPoint = breakStart + WAVED_LINE_CENTER;
  const bottomPoint = breakStart + WAVED_LINE_BOTTOM;
  const points = [[positionFrom, centerPoint]];
  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {
    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);
  }
  return [].concat.apply([], points);
}
function rotateLine(lineCoords) {
  const points = [];
  let i;
  for (i = 0; i < lineCoords.length; i += 2) {
    points.push(lineCoords[i + 1]);
    points.push(lineCoords[i]);
  }
  return points;
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 45888:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _bar_gauge = __webpack_require__(44898);
var _default = exports["default"] = _bar_gauge.dxBarGauge;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 88950:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _bullet = _interopRequireDefault(__webpack_require__(59989));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _bullet.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 99511:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_chart = _interopRequireDefault(__webpack_require__(4096));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_chart.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97574:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Crosshair = Crosshair;
exports.getMargins = getMargins;
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
const math = Math;
const mathAbs = math.abs;
const mathMin = math.min;
const mathMax = math.max;
const mathFloor = math.floor;
const HORIZONTAL = 'horizontal';
const VERTICAL = 'vertical';
const LABEL_BACKGROUND_PADDING_X = 8;
const LABEL_BACKGROUND_PADDING_Y = 4;
const CENTER = 'center';
const RIGHT = 'right';
const LEFT = 'left';
const TOP = 'top';
const BOTTOM = 'bottom';
function getMargins() {
  return {
    x: LABEL_BACKGROUND_PADDING_X,
    y: LABEL_BACKGROUND_PADDING_Y
  };
}
function getRectangleBBox(bBox) {
  return {
    x: bBox.x - LABEL_BACKGROUND_PADDING_X,
    y: bBox.y - LABEL_BACKGROUND_PADDING_Y,
    width: bBox.width + LABEL_BACKGROUND_PADDING_X * 2,
    height: bBox.height + LABEL_BACKGROUND_PADDING_Y * 2
  };
}
function getLabelCheckerPosition(x, y, isHorizontal, canvas) {
  const params = isHorizontal ? ['x', 'width', 'y', 'height', y, 0] : ['y', 'height', 'x', 'width', x, 1];
  return function (bBox, position, coord) {
    const labelCoord = {
      x: coord.x,
      y: coord.y
    };
    const rectangleBBox = getRectangleBBox(bBox);
    const delta = isHorizontal ? coord.y - bBox.y - bBox.height / 2 : coord.y - bBox.y;
    labelCoord.y = isHorizontal || !isHorizontal && position === BOTTOM ? coord.y + delta : coord.y;
    if (rectangleBBox[params[0]] < 0) {
      labelCoord[params[0]] -= rectangleBBox[params[0]];
    } else if (rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] > canvas[params[1]]) {
      labelCoord[params[0]] -= rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] - canvas[params[1]];
    }
    if (params[4] - rectangleBBox[params[3]] / 2 < 0) {
      labelCoord[params[2]] -= params[4] - rectangleBBox[params[3]] / 2;
    } else if (params[4] + rectangleBBox[params[3]] / 2 > canvas[params[3]]) {
      labelCoord[params[2]] -= params[4] + rectangleBBox[params[3]] / 2 - canvas[params[3]];
    }
    return labelCoord;
  };
}
function Crosshair(renderer, options, params, group) {
  const that = this;
  that._renderer = renderer;
  that._crosshairGroup = group;
  that._options = {};
  that.update(options, params);
}
Crosshair.prototype = {
  constructor: Crosshair,
  update: function (options, params) {
    const that = this;
    const canvas = params.canvas;
    that._canvas = {
      top: canvas.top,
      bottom: canvas.height - canvas.bottom,
      left: canvas.left,
      right: canvas.width - canvas.right,
      width: canvas.width,
      height: canvas.height
    };
    that._axes = params.axes;
    that._panes = params.panes;
    that._prepareOptions(options, HORIZONTAL);
    that._prepareOptions(options, VERTICAL);
  },
  dispose: function () {
    const that = this;
    that._renderer = that._crosshairGroup = that._options = that._axes = that._canvas = that._horizontalGroup = that._verticalGroup = that._horizontal = that._vertical = that._circle = that._panes = null;
  },
  _prepareOptions: function (options, direction) {
    const lineOptions = options[direction + 'Line'];
    this._options[direction] = {
      visible: lineOptions.visible,
      line: {
        stroke: lineOptions.color || options.color,
        'stroke-width': lineOptions.width || options.width,
        dashStyle: lineOptions.dashStyle || options.dashStyle,
        opacity: lineOptions.opacity || options.opacity,
        'stroke-linecap': 'butt'
      },
      label: (0, _extend.extend)(true, {}, options.label, lineOptions.label)
    };
  },
  _createLines: function (options, sharpParam, group) {
    const lines = [];
    const canvas = this._canvas;
    const points = [canvas.left, canvas.top, canvas.left, canvas.top];
    for (let i = 0; i < 2; i++) {
      lines.push(this._renderer.path(points, 'line').attr(options).sharp(sharpParam).append(group));
    }
    return lines;
  },
  render: function () {
    const that = this;
    const renderer = that._renderer;
    const options = that._options;
    const verticalOptions = options.vertical;
    const horizontalOptions = options.horizontal;
    const extraOptions = horizontalOptions.visible ? horizontalOptions.line : verticalOptions.line;
    const circleOptions = {
      stroke: extraOptions.stroke,
      'stroke-width': extraOptions['stroke-width'],
      dashStyle: extraOptions.dashStyle,
      opacity: extraOptions.opacity
    };
    const canvas = that._canvas;
    that._horizontal = {};
    that._vertical = {};
    that._circle = renderer.circle(canvas.left, canvas.top, 0).attr(circleOptions).append(that._crosshairGroup);
    that._horizontalGroup = renderer.g().append(that._crosshairGroup);
    that._verticalGroup = renderer.g().append(that._crosshairGroup);
    if (verticalOptions.visible) {
      that._vertical.lines = that._createLines(verticalOptions.line, 'h', that._verticalGroup);
      that._vertical.labels = that._createLabels(that._axes[0], verticalOptions, false, that._verticalGroup);
    }
    if (horizontalOptions.visible) {
      that._horizontal.lines = that._createLines(horizontalOptions.line, 'v', that._horizontalGroup);
      that._horizontal.labels = that._createLabels(that._axes[1], horizontalOptions, true, that._horizontalGroup);
    }
    that.hide();
  },
  _createLabels: function (axes, options, isHorizontal, group) {
    const that = this;
    const canvas = that._canvas;
    const renderer = that._renderer;
    let x;
    let y;
    let text;
    const labels = [];
    let background;
    let currentLabelPos;
    const labelOptions = options.label;
    if (labelOptions.visible) {
      axes.forEach(function (axis) {
        const position = axis.getOptions().position;
        if (axis.getTranslator().getBusinessRange().isEmpty()) {
          return;
        }
        currentLabelPos = axis.getLabelsPosition();
        if (isHorizontal) {
          y = canvas.top;
          x = currentLabelPos;
        } else {
          x = canvas.left;
          y = currentLabelPos;
        }
        const align = position === TOP || position === BOTTOM ? CENTER : position === RIGHT ? LEFT : RIGHT;
        background = renderer.rect(0, 0, 0, 0).attr({
          fill: labelOptions.backgroundColor || options.line.stroke
        }).append(group);
        text = renderer.text('0', 0, 0).css((0, _utils.patchFontOptions)(options.label.font)).attr({
          align: align,
          'class': labelOptions.cssClass
        }).append(group);
        labels.push({
          text: text,
          background: background,
          axis: axis,
          options: labelOptions,
          pos: {
            coord: currentLabelPos,
            side: position
          },
          startXY: {
            x: x,
            y: y
          }
        });
      });
    }
    return labels;
  },
  _updateText: function (value, axisName, labels, point, func) {
    const that = this;
    labels.forEach(function (label) {
      const axis = label.axis;
      const coord = label.startXY;
      const textElement = label.text;
      const backgroundElement = label.background;
      let text = '';
      if (!axis.name || axis.name === axisName) {
        text = axis.getFormattedValue(value, label.options, point);
      }
      if (text) {
        textElement.attr({
          text: text,
          x: coord.x,
          y: coord.y
        });
        textElement.attr(func(textElement.getBBox(), label.pos.side, coord));
        that._updateLinesCanvas(label);
        backgroundElement.attr(getRectangleBBox(textElement.getBBox()));
      } else {
        textElement.attr({
          text: ''
        });
        backgroundElement.attr({
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
    });
  },
  hide: function () {
    this._crosshairGroup.attr({
      visibility: 'hidden'
    });
  },
  _updateLinesCanvas: function (label) {
    const position = label.pos.side;
    const labelCoord = label.pos.coord;
    const coords = this._linesCanvas;
    const canvas = this._canvas;
    coords[position] = coords[position] !== canvas[position] && mathAbs(coords[position] - canvas[position]) < mathAbs(labelCoord - canvas[position]) ? coords[position] : labelCoord;
  },
  _updateLines: function (lines, x, y, r, isHorizontal) {
    const coords = this._linesCanvas;
    const canvas = this._canvas;
    const points = isHorizontal ? [[mathMin(x - r, coords.left), canvas.top, x - r, canvas.top], [x + r, canvas.top, mathMax(coords.right, x + r), canvas.top]] : [[canvas.left, mathMin(coords.top, y - r), canvas.left, y - r], [canvas.left, y + r, canvas.left, mathMax(coords.bottom, y + r)]];
    for (let i = 0; i < 2; i++) {
      lines[i].attr({
        points: points[i]
      }).sharp(isHorizontal ? 'v' : 'h', isHorizontal ? y === canvas.bottom ? -1 : 1 : x === canvas.right ? -1 : 1);
    }
  },
  _resetLinesCanvas: function () {
    const canvas = this._canvas;
    this._linesCanvas = {
      left: canvas.left,
      right: canvas.right,
      top: canvas.top,
      bottom: canvas.bottom
    };
  },
  _getClipRectForPane: function (x, y) {
    const panes = this._panes;
    let i;
    let coords;
    for (i = 0; i < panes.length; i++) {
      coords = panes[i].coords;
      if (coords.left <= x && coords.right >= x && coords.top <= y && coords.bottom >= y) {
        return panes[i].clipRect;
      }
    }
    return {
      id: null
    };
  },
  show: function (data) {
    const that = this;
    const point = data.point;
    const pointData = point.getCrosshairData(data.x, data.y);
    const r = point.getPointRadius();
    const horizontal = that._horizontal;
    const vertical = that._vertical;
    const rad = !r ? 0 : r + 3;
    const canvas = that._canvas;
    const x = mathFloor(pointData.x);
    const y = mathFloor(pointData.y);
    if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {
      that._crosshairGroup.attr({
        visibility: 'visible'
      });
      that._resetLinesCanvas();
      that._circle.attr({
        cx: x,
        cy: y,
        r: rad,
        'clip-path': that._getClipRectForPane(x, y).id
      });
      if (horizontal.lines) {
        that._updateText(pointData.yValue, pointData.axis, horizontal.labels, point, getLabelCheckerPosition(x, y, true, canvas));
        that._updateLines(horizontal.lines, x, y, rad, true);
        that._horizontalGroup.attr({
          translateY: y - canvas.top
        });
      }
      if (vertical.lines) {
        that._updateText(pointData.xValue, pointData.axis, vertical.labels, point, getLabelCheckerPosition(x, y, false, canvas));
        that._updateLines(vertical.lines, x, y, rad, false);
        that._verticalGroup.attr({
          translateX: x - canvas.left
        });
      }
    } else {
      that.hide();
    }
  }
};

/***/ }),

/***/ 61189:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.LayoutManager = LayoutManager;
var _type = __webpack_require__(35922);
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _layout_element = __webpack_require__(73711);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  floor,
  sqrt
} = Math;
const _min = Math.min;
const _max = Math.max;
const DEFAULT_INNER_RADIUS = 0.5;
const RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;
function getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {
  let nearestCoord;
  if (pointCenterCoord < firstCoord) {
    nearestCoord = firstCoord;
  } else if (secondCoord < pointCenterCoord) {
    nearestCoord = secondCoord;
  } else {
    nearestCoord = pointCenterCoord;
  }
  return nearestCoord;
}
function getLabelLayout(point) {
  if (point._label.isVisible() && point._label.getLayoutOptions().position !== 'inside') {
    return point._label.getBoundingRect();
  }
}
function getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR) {
  series.some(function (singleSeries) {
    return singleSeries.getVisiblePoints().reduce(function (radiusIsFound, point) {
      const labelBBox = getLabelLayout(point);
      if (labelBBox) {
        const xCoords = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX);
        const yCoords = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY);
        accessibleRadius = _min(_max(getLengthFromCenter(xCoords, yCoords, paneCenterX, paneCenterY) - RADIAL_LABEL_INDENT, minR), accessibleRadius);
        radiusIsFound = true;
      }
      return radiusIsFound;
    }, false);
  });
  return accessibleRadius;
}
function getSizeLabels(series) {
  return series.reduce(function (res, singleSeries) {
    let maxWidth = singleSeries.getVisiblePoints().reduce(function (width, point) {
      const labelBBox = getLabelLayout(point);
      if (labelBBox && labelBBox.width > width) {
        width = labelBBox.width;
      }
      return width;
    }, 0);
    let rWidth = maxWidth;
    if (maxWidth) {
      res.outerLabelsCount++;
      if (res.outerLabelsCount > 1) {
        maxWidth += _consts.default.pieLabelSpacing;
      }
      rWidth += _consts.default.pieLabelSpacing;
    }
    res.sizes.push(maxWidth);
    res.rSizes.push(rWidth);
    res.common += maxWidth;
    return res;
  }, {
    sizes: [],
    rSizes: [],
    common: 0,
    outerLabelsCount: 0
  });
}
function correctLabelRadius(labelSizes, radius, series, canvas, averageWidthLabels, centerX) {
  let curRadius;
  let i;
  let runningWidth = 0;
  const sizes = labelSizes.sizes;
  const rSizes = labelSizes.rSizes;
  for (i = 0; i < series.length; i++) {
    if (sizes[i] === 0) {
      curRadius && (curRadius += rSizes[i - 1]);
      continue;
    }
    curRadius = floor(curRadius ? curRadius + rSizes[i - 1] : radius);
    series[i].correctLabelRadius(curRadius);
    runningWidth += averageWidthLabels || sizes[i];
    rSizes[i] = averageWidthLabels || rSizes[i];
    series[i].setVisibleArea({
      left: floor(centerX - radius - runningWidth),
      right: floor(canvas.width - (centerX + radius + runningWidth)),
      top: canvas.top,
      bottom: canvas.bottom,
      width: canvas.width,
      height: canvas.height
    });
  }
}
function getLengthFromCenter(x, y, paneCenterX, paneCenterY) {
  return sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY));
}
function getInnerRadius(_ref) {
  let {
    type,
    innerRadius
  } = _ref;
  return type === 'pie' ? 0 : (0, _type.isNumeric)(innerRadius) ? Number(innerRadius) : DEFAULT_INNER_RADIUS;
}
function LayoutManager() {}
function getAverageLabelWidth(centerX, radius, canvas, sizeLabels) {
  return (centerX - radius - RADIAL_LABEL_INDENT - canvas.left) / sizeLabels.outerLabelsCount;
}
function getFullRadiusWithLabels(centerX, canvas, sizeLabels) {
  return centerX - canvas.left - (sizeLabels.outerLabelsCount > 0 ? sizeLabels.common + RADIAL_LABEL_INDENT : 0);
}
function correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY) {
  const sizeLabels = getSizeLabels(series);
  let averageWidthLabels;
  const fullRadiusWithLabels = getFullRadiusWithLabels(paneCenterX, canvas, sizeLabels);
  if (fullRadiusWithLabels < minR) {
    availableRadius = minR;
    averageWidthLabels = getAverageLabelWidth(paneCenterX, availableRadius, canvas, sizeLabels);
  } else {
    availableRadius = _min(getPieRadius(series, paneCenterX, paneCenterY, availableRadius, minR), fullRadiusWithLabels);
  }
  correctLabelRadius(sizeLabels, availableRadius + RADIAL_LABEL_INDENT, series, canvas, averageWidthLabels, paneCenterX);
  return availableRadius;
}
function toLayoutElementCoords(canvas) {
  return new _layout_element.WrapperLayoutElement(null, {
    x: canvas.left,
    y: canvas.top,
    width: canvas.width - canvas.left - canvas.right,
    height: canvas.height - canvas.top - canvas.bottom
  });
}
LayoutManager.prototype = {
  constructor: LayoutManager,
  setOptions: function (options) {
    this._options = options;
  },
  applyPieChartSeriesLayout: function (canvas, series, hideLayoutLabels) {
    const paneSpaceHeight = canvas.height - canvas.top - canvas.bottom;
    const paneSpaceWidth = canvas.width - canvas.left - canvas.right;
    const paneCenterX = paneSpaceWidth / 2 + canvas.left;
    const paneCenterY = paneSpaceHeight / 2 + canvas.top;
    const piePercentage = this._options.piePercentage;
    let availableRadius;
    let minR;
    if ((0, _type.isNumeric)(piePercentage)) {
      availableRadius = minR = piePercentage * _min(canvas.height, canvas.width) / 2;
    } else {
      availableRadius = _min(paneSpaceWidth, paneSpaceHeight) / 2;
      minR = this._options.minPiePercentage * availableRadius;
    }
    if (!hideLayoutLabels) {
      availableRadius = correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY);
    }
    return {
      centerX: floor(paneCenterX),
      centerY: floor(paneCenterY),
      radiusInner: floor(availableRadius * getInnerRadius(series[0])),
      radiusOuter: floor(availableRadius)
    };
  },
  applyEqualPieChartLayout: function (series, layout) {
    const radius = layout.radius;
    return {
      centerX: floor(layout.x),
      centerY: floor(layout.y),
      radiusInner: floor(radius * getInnerRadius(series[0])),
      radiusOuter: floor(radius)
    };
  },
  correctPieLabelRadius: function (series, layout, canvas) {
    const sizeLabels = getSizeLabels(series);
    let averageWidthLabels;
    const radius = layout.radiusOuter + RADIAL_LABEL_INDENT;
    const availableLabelWidth = layout.centerX - canvas.left - radius;
    if (sizeLabels.common + RADIAL_LABEL_INDENT > availableLabelWidth) {
      averageWidthLabels = getAverageLabelWidth(layout.centerX, layout.radiusOuter, canvas, sizeLabels);
    }
    correctLabelRadius(sizeLabels, radius, series, canvas, averageWidthLabels, layout.centerX);
  },
  needMoreSpaceForPanesCanvas(panes, rotated, fixedSizeCallback) {
    const options = this._options;
    const width = options.width;
    const height = options.height;
    const piePercentage = options.piePercentage;
    const percentageIsValid = (0, _type.isNumeric)(piePercentage);
    let needHorizontalSpace = 0;
    let needVerticalSpace = 0;
    panes.forEach(pane => {
      const paneCanvas = pane.canvas;
      const minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : undefined;
      const paneSized = fixedSizeCallback ? fixedSizeCallback(pane) : {
        width: false,
        height: false
      };
      const needPaneHorizontalSpace = !paneSized.width ? (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right) : 0;
      const needPaneVerticalSpace = !paneSized.height ? (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom) : 0;
      if (rotated) {
        needHorizontalSpace += needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0;
        needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace);
      } else {
        needHorizontalSpace = _max(needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0, needHorizontalSpace);
        needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0;
      }
    });
    return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
      width: needHorizontalSpace,
      height: needVerticalSpace
    } : false;
  },
  layoutInsideLegend: function (legend, canvas) {
    const inverseAlign = {
      left: 'right',
      right: 'left',
      top: 'bottom',
      bottom: 'top',
      center: 'center'
    };
    const layoutOptions = legend.getLayoutOptions();
    if (!layoutOptions) {
      return;
    }
    const position = layoutOptions.position;
    const cutSide = layoutOptions.cutSide;
    const my = {
      horizontal: position.horizontal,
      vertical: position.vertical
    };
    canvas[layoutOptions.cutLayoutSide] += layoutOptions.cutSide === 'horizontal' ? layoutOptions.width : layoutOptions.height;
    my[cutSide] = inverseAlign[my[cutSide]];
    legend.position({
      of: toLayoutElementCoords(canvas),
      my: my,
      at: position
    });
  }
};

/***/ }),

/***/ 42597:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _console = __webpack_require__(30869);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _math2 = __webpack_require__(60810);
const _math = Math;
const _floor = _math.floor;
const _max = _math.max;
const _abs = _math.abs;
function getValueAxesPerPanes(valueAxes) {
  const result = {};
  valueAxes.forEach(axis => {
    const pane = axis.pane;
    if (!result[pane]) {
      result[pane] = [];
    }
    result[pane].push(axis);
  });
  return result;
}
const linearConverter = br => ({
  transform: function (v, b) {
    return (0, _math2.adjust)((0, _utils.getLogExt)(v, b, br.allowNegatives, br.linearThreshold));
  },
  getTicks: function (interval, tickValues, base) {
    const ticks = [];
    let tick = this.transform(tickValues[0], base);
    while (ticks.length < tickValues.length) {
      ticks.push(tick);
      tick = (0, _math2.adjust)(tick + interval);
    }
    return ticks;
  }
});
const logConverter = br => ({
  transform: function (v, b) {
    return (0, _math2.adjust)((0, _utils.raiseToExt)(v, b, br.allowNegatives, br.linearThreshold));
  },
  getTicks: function (interval, tickValues, base) {
    const ticks = [];
    let tick;
    for (let i = 0; i < tickValues.length; i += 1) {
      tick = this.transform(tickValues[i], base);
      ticks.push(tick);
    }
    return ticks;
  }
});
function convertAxisInfo(axisInfo, converter) {
  if (!axisInfo.isLogarithmic) {
    return;
  }
  const base = axisInfo.logarithmicBase;
  const tickValues = axisInfo.tickValues;
  axisInfo.minValue = converter.transform(axisInfo.minValue, base);
  axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);
  axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);
  axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);
  axisInfo.tickInterval = _math.round(axisInfo.tickInterval);
  if (axisInfo.tickInterval < 1) {
    axisInfo.tickInterval = 1;
  }
  const ticks = converter.getTicks(axisInfo.tickInterval, tickValues, base);
  ticks.tickInterval = axisInfo.tickInterval;
  axisInfo.tickValues = ticks;
}
function populateAxesInfo(axes) {
  return axes.reduce(function (result, axis) {
    const ticksValues = axis.getTicksValues();
    const majorTicks = ticksValues.majorTicksValues;
    const options = axis.getOptions();
    const businessRange = axis.getTranslator().getBusinessRange();
    const visibleArea = axis.getVisibleArea();
    let axisInfo;
    let tickInterval = axis._tickInterval;
    const synchronizedValue = options.synchronizedValue;
    const action = axis.getViewport().action;
    if (majorTicks && majorTicks.length > 0 && (0, _type.isNumeric)(majorTicks[0]) && options.type !== 'discrete' && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && action !== 'zoom' && action !== 'pan') {
      axis.applyMargins();
      const startValue = axis.getTranslator().from(visibleArea[0]);
      const endValue = axis.getTranslator().from(visibleArea[1]);
      let minValue = startValue < endValue ? startValue : endValue;
      let maxValue = startValue < endValue ? endValue : startValue;
      if (minValue === maxValue && (0, _type.isDefined)(synchronizedValue)) {
        tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;
        minValue = majorTicks[0] - tickInterval;
        maxValue = majorTicks[0] + tickInterval;
      }
      axisInfo = {
        axis: axis,
        isLogarithmic: options.type === 'logarithmic',
        logarithmicBase: businessRange.base,
        tickValues: majorTicks,
        minorValues: ticksValues.minorTicksValues,
        minorTickInterval: axis._minorTickInterval,
        minValue: minValue,
        oldMinValue: minValue,
        maxValue: maxValue,
        oldMaxValue: maxValue,
        inverted: businessRange.invert,
        tickInterval: tickInterval,
        synchronizedValue: synchronizedValue
      };
      convertAxisInfo(axisInfo, linearConverter(axis.getTranslator().getBusinessRange()));
      result.push(axisInfo);
    }
    return result;
  }, []);
}
function updateTickValues(axesInfo) {
  const maxTicksCount = axesInfo.reduce((max, axisInfo) => {
    return _max(max, axisInfo.tickValues.length);
  }, 0);
  axesInfo.forEach(axisInfo => {
    let ticksMultiplier;
    let ticksCount;
    let additionalStartTicksCount = 0;
    const synchronizedValue = axisInfo.synchronizedValue;
    const tickValues = axisInfo.tickValues;
    const tickInterval = axisInfo.tickInterval;
    if ((0, _type.isDefined)(synchronizedValue)) {
      axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;
      axisInfo.tickValues = [axisInfo.baseTickValue];
    } else {
      if (tickValues.length > 1 && tickInterval) {
        ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);
        ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
        additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);
        while (additionalStartTicksCount > 0 && tickValues[0] !== 0) {
          tickValues.unshift((0, _math2.adjust)(tickValues[0] - tickInterval));
          additionalStartTicksCount--;
        }
        while (tickValues.length < ticksCount) {
          tickValues.push((0, _math2.adjust)(tickValues[tickValues.length - 1] + tickInterval));
        }
        axisInfo.tickInterval = tickInterval / ticksMultiplier;
      }
      axisInfo.baseTickValue = tickValues[0];
      axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1];
    }
  });
}
function getAxisRange(axisInfo) {
  return axisInfo.maxValue - axisInfo.minValue || 1; // T153054
}
function getMainAxisInfo(axesInfo) {
  for (let i = 0; i < axesInfo.length; i++) {
    if (!axesInfo[i].stubData) {
      return axesInfo[i];
    }
  }
  return null;
}
function correctMinMaxValues(axesInfo) {
  const mainAxisInfo = getMainAxisInfo(axesInfo);
  const mainAxisInfoTickInterval = mainAxisInfo.tickInterval;
  axesInfo.forEach(axisInfo => {
    let scale;
    let move;
    let mainAxisBaseValueOffset;
    let valueFromAxisInfo;
    if (axisInfo !== mainAxisInfo) {
      if (mainAxisInfoTickInterval && axisInfo.tickInterval) {
        if (axisInfo.stubData && (0, _type.isDefined)(axisInfo.synchronizedValue)) {
          axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
          axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
        }
        scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);
        axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale;
      }
      if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {
        mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;
      } else {
        mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;
      }
      valueFromAxisInfo = getAxisRange(axisInfo);
      move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;
      axisInfo.minValue -= move;
      axisInfo.maxValue -= move;
    }
  });
}
function calculatePaddings(axesInfo) {
  let minPadding;
  let maxPadding;
  let startPadding = 0;
  let endPadding = 0;
  axesInfo.forEach(axisInfo => {
    const inverted = axisInfo.inverted;
    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;
    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;
    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);
    endPadding = _max(endPadding, inverted ? minPadding : maxPadding);
  });
  return {
    start: startPadding,
    end: endPadding
  };
}
function correctMinMaxValuesByPaddings(axesInfo, paddings) {
  axesInfo.forEach(info => {
    const range = getAxisRange(info);
    const inverted = info.inverted;
    info.minValue = (0, _math2.adjust)(info.minValue - paddings[inverted ? 'end' : 'start'] * range);
    info.maxValue = (0, _math2.adjust)(info.maxValue + paddings[inverted ? 'start' : 'end'] * range);
  });
}
function updateTickValuesIfSynchronizedValueUsed(axesInfo) {
  let hasSynchronizedValue = false;
  axesInfo.forEach(info => {
    hasSynchronizedValue = hasSynchronizedValue || (0, _type.isDefined)(info.synchronizedValue);
  });
  axesInfo.forEach(info => {
    const tickInterval = info.tickInterval;
    const tickValues = info.tickValues;
    const maxValue = info.maxValue;
    const minValue = info.minValue;
    let tick;
    if (hasSynchronizedValue && tickInterval) {
      while ((tick = (0, _math2.adjust)(tickValues[0] - tickInterval)) >= minValue) {
        tickValues.unshift(tick);
      }
      tick = tickValues[tickValues.length - 1];
      while ((tick = (0, _math2.adjust)(tick + tickInterval)) <= maxValue) {
        tickValues.push(tick);
      }
    }
    while (tickValues[0] + tickInterval / 10 < minValue) {
      tickValues.shift();
    }
    while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {
      tickValues.pop();
    }
  });
}
function applyMinMaxValues(axesInfo) {
  axesInfo.forEach(info => {
    const axis = info.axis;
    const range = axis.getTranslator().getBusinessRange();
    if (range.min === range.minVisible) {
      range.min = info.minValue;
    }
    if (range.max === range.maxVisible) {
      range.max = info.maxValue;
    }
    range.minVisible = info.minValue;
    range.maxVisible = info.maxValue;
    if (range.min > range.minVisible) {
      range.min = range.minVisible;
    }
    if (range.max < range.maxVisible) {
      range.max = range.maxVisible;
    }
    axis.getTranslator().updateBusinessRange(range);
    axis.setTicks({
      majorTicks: info.tickValues,
      minorTicks: info.minorValues
    });
  });
}
function correctAfterSynchronize(axesInfo) {
  const invalidAxisInfo = [];
  let correctValue;
  axesInfo.forEach(info => {
    if (info.oldMaxValue - info.oldMinValue === 0) {
      invalidAxisInfo.push(info);
    } else {
      if (!(0, _type.isDefined)(correctValue) && !(0, _type.isDefined)(info.synchronizedValue)) {
        correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue));
      }
    }
  });
  if (!(0, _type.isDefined)(correctValue)) {
    return;
  }
  invalidAxisInfo.forEach(info => {
    const firstTick = info.tickValues[0];
    const correctedTick = firstTick * correctValue;
    if (firstTick > 0) {
      info.maxValue = correctedTick;
      info.minValue = 0;
    } else if (firstTick < 0) {
      info.minValue = correctedTick;
      info.maxValue = 0;
    }
  });
}
function updateMinorTicks(axesInfo) {
  axesInfo.forEach(function (axisInfo) {
    if (!axisInfo.minorTickInterval) {
      return;
    }
    const ticks = [];
    const interval = axisInfo.minorTickInterval;
    const tickCount = axisInfo.tickInterval / interval - 1;
    for (let i = 1; i < axisInfo.tickValues.length; i++) {
      let tick = axisInfo.tickValues[i - 1];
      for (let j = 0; j < tickCount; j++) {
        tick += interval;
        ticks.push(tick);
      }
    }
    axisInfo.minorValues = ticks;
  });
}
function allAxesValuesOnSameSideFromZero(axesInfo) {
  let allPositive = true;
  let allNegative = true;
  axesInfo.forEach(axis => {
    if (axis.oldMinValue > 0 || axis.oldMaxValue > 0) {
      allNegative = false;
    }
    if (axis.oldMinValue < 0 || axis.oldMaxValue < 0) {
      allPositive = false;
    }
  });
  return allPositive || allNegative;
}
function correctPaddings(axesInfo, paddings) {
  if (!allAxesValuesOnSameSideFromZero(axesInfo)) {
    return paddings;
  }
  return axesInfo.reduce((prev, info) => {
    const inverted = info.inverted;
    const {
      start,
      end
    } = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue);
    if ((0, _type.isDefined)(start) || (0, _type.isDefined)(end)) {
      return inverted ? {
        start: prev.start,
        end: Math.min(prev.end, end)
      } : {
        start: Math.min(prev.start, start),
        end: prev.end
      };
    }
    return prev;
  }, paddings);
}
const multiAxesSynchronizer = {
  synchronize: function (valueAxes) {
    (0, _iterator.each)(getValueAxesPerPanes(valueAxes), function (_, axes) {
      let axesInfo;
      let paddings;
      if (axes.length > 1) {
        axesInfo = populateAxesInfo(axes);
        if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) return;
        updateTickValues(axesInfo);
        correctMinMaxValues(axesInfo);
        paddings = calculatePaddings(axesInfo);
        paddings = correctPaddings(axesInfo, paddings);
        correctMinMaxValuesByPaddings(axesInfo, paddings);
        correctAfterSynchronize(axesInfo);
        updateTickValuesIfSynchronizedValueUsed(axesInfo);
        updateMinorTicks(axesInfo);
        axesInfo.forEach(info => {
          convertAxisInfo(info, logConverter(info.axis.getTranslator().getBusinessRange()));
        });
        applyMinMaxValues(axesInfo);
      }
    });
  }
};
var _default = exports["default"] = multiAxesSynchronizer;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97882:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ScrollBar = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
var _extend = __webpack_require__(13306);
var _translator2d = __webpack_require__(87276);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _drag = __webpack_require__(23174);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _min = Math.min;
const _max = Math.max;
const MIN_SCROLL_BAR_SIZE = 2;
const ScrollBar = function (renderer, group) {
  this._translator = new _translator2d.Translator2D({}, {}, {});
  this._scroll = renderer.rect().append(group);
  this._addEvents();
};
exports.ScrollBar = ScrollBar;
function _getXCoord(canvas, pos, offset, width) {
  let x = 0;
  if (pos === 'right') {
    x = canvas.width - canvas.right + offset;
  } else if (pos === 'left') {
    x = canvas.left - offset - width;
  }
  return x;
}
function _getYCoord(canvas, pos, offset, width) {
  let y = 0;
  if (pos === 'top') {
    y = canvas.top - offset;
  } else if (pos === 'bottom') {
    y = canvas.height - canvas.bottom + width + offset;
  }
  return y;
}
ScrollBar.prototype = {
  _addEvents: function () {
    const scrollElement = this._scroll.element;
    _events_engine.default.on(scrollElement, _drag.start, e => {
      (0, _index.fireEvent)({
        type: 'dxc-scroll-start',
        originalEvent: e,
        target: scrollElement
      });
    });
    _events_engine.default.on(scrollElement, _drag.move, e => {
      const dX = -e.offset.x * this._scale;
      const dY = -e.offset.y * this._scale;
      const lx = this._offset - (this._layoutOptions.vertical ? dY : dX) / this._scale;
      this._applyPosition(lx, lx + this._translator.canvasLength / this._scale);
      (0, _index.fireEvent)({
        type: 'dxc-scroll-move',
        originalEvent: e,
        target: scrollElement,
        offset: {
          x: dX,
          y: dY
        }
      });
    });
    _events_engine.default.on(scrollElement, _drag.end, e => {
      (0, _index.fireEvent)({
        type: 'dxc-scroll-end',
        originalEvent: e,
        target: scrollElement,
        offset: {
          x: -e.offset.x * this._scale,
          y: -e.offset.y * this._scale
        }
      });
    });
  },
  update: function (options) {
    const that = this;
    let position = options.position;
    const isVertical = options.rotated;
    const defaultPosition = isVertical ? 'right' : 'top';
    const secondaryPosition = isVertical ? 'left' : 'bottom';
    if (position !== defaultPosition && position !== secondaryPosition) {
      position = defaultPosition;
    }
    that._scroll.attr({
      rotate: !options.rotated ? -90 : 0,
      rotateX: 0,
      rotateY: 0,
      fill: options.color,
      width: options.width,
      opacity: options.opacity
    });
    that._layoutOptions = {
      width: options.width,
      offset: options.offset,
      vertical: isVertical,
      position: position
    };
    return that;
  },
  init: function (range, stick) {
    const that = this;
    const isDiscrete = range.axisType === 'discrete';
    that._translateWithOffset = isDiscrete && !stick && 1 || 0;
    that._translator.update((0, _extend.extend)({}, range, {
      minVisible: null,
      maxVisible: null,
      visibleCategories: null
    }, isDiscrete && {
      min: null,
      max: null
    } || {}), that._canvas, {
      isHorizontal: !that._layoutOptions.vertical,
      stick: stick
    });
    return that;
  },
  getOptions: function () {
    return this._layoutOptions;
  },
  setPane: function (panes) {
    const position = this._layoutOptions.position;
    let pane;
    if (position === 'left' || position === 'top') {
      pane = panes[0];
    } else {
      pane = panes[panes.length - 1];
    }
    this.pane = pane.name;
    return this;
  },
  updateSize: function (canvas) {
    this._canvas = (0, _extend.extend)({}, canvas);
    const options = this._layoutOptions;
    const pos = options.position;
    const offset = options.offset;
    const width = options.width;
    this._scroll.attr({
      translateX: _getXCoord(canvas, pos, offset, width),
      translateY: _getYCoord(canvas, pos, offset, width)
    });
  },
  getMultipleAxesSpacing: function () {
    return 0;
  },
  estimateMargins: function () {
    return this.getMargins();
  },
  getMargins: function () {
    const options = this._layoutOptions;
    const margins = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    margins[options.position] = options.width + options.offset;
    return margins;
  },
  shift: function (margins) {
    const that = this;
    const options = that._layoutOptions;
    const side = options.position;
    const isVertical = options.vertical;
    const attr = {
      translateX: that._scroll.attr('translateX') ?? 0,
      translateY: that._scroll.attr('translateY') ?? 0
    };
    const shift = margins[side];
    attr[isVertical ? 'translateX' : 'translateY'] += (side === 'left' || side === 'top' ? -1 : 1) * shift;
    that._scroll.attr(attr);
  },
  // Axis like functions
  hideTitle: _common.noop,
  hideOuterElements: _common.noop,
  // Axis like functions

  setPosition: function (min, max) {
    const that = this;
    const translator = that._translator;
    const minPoint = (0, _type.isDefined)(min) ? translator.translate(min, -that._translateWithOffset) : translator.translate('canvas_position_start');
    const maxPoint = (0, _type.isDefined)(max) ? translator.translate(max, that._translateWithOffset) : translator.translate('canvas_position_end');
    that._offset = _min(minPoint, maxPoint);
    that._scale = translator.getScale(min, max);
    that._applyPosition(_min(minPoint, maxPoint), _max(minPoint, maxPoint));
  },
  customPositionIsAvailable() {
    return false;
  },
  dispose: function () {
    this._scroll.dispose();
    this._scroll = this._translator = null;
  },
  _applyPosition: function (x1, x2) {
    const that = this;
    const visibleArea = that._translator.getCanvasVisibleArea();
    x1 = _max(x1, visibleArea.min);
    x1 = _min(x1, visibleArea.max);
    x2 = _min(x2, visibleArea.max);
    x2 = _max(x2, visibleArea.min);
    const height = Math.abs(x2 - x1);
    that._scroll.attr({
      y: x1,
      height: height < MIN_SCROLL_BAR_SIZE ? MIN_SCROLL_BAR_SIZE : height
    });
  }
};

/***/ }),

/***/ 70714:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _drag = __webpack_require__(23174);
const SHUTTER_EVENTS_NS = '.shutter-zoom';
const DRAG_START_EVENT_NAME = _drag.start + SHUTTER_EVENTS_NS;
const DRAG_UPDATE_EVENT_NAME = _drag.move + SHUTTER_EVENTS_NS;
const DRAG_END_EVENT_NAME = _drag.end + SHUTTER_EVENTS_NS;
function getPointerCoord(rootOffset, canvas, rotated, e) {
  let coord = Math.floor(rotated ? e.pageY - rootOffset.top : e.pageX - rootOffset.left);
  const min = rotated ? canvas.y1 : canvas.x1;
  const max = rotated ? canvas.y2 : canvas.x2;
  if (coord < min) {
    coord = min;
  } else if (coord > max) {
    coord = max;
  }
  return coord;
}
function checkCoords(rootOffset, canvas, e) {
  const x = e.pageX - rootOffset.left;
  const y = e.pageY - rootOffset.top;
  return x >= canvas.x1 && x <= canvas.x2 && y >= canvas.y1 && y <= canvas.y2;
}
function dragStartHandler(ctx) {
  return function (e) {
    const offset = ctx.getRootOffset();
    const canvas = ctx.getCanvas();
    if (!checkCoords(offset, canvas, e)) {
      e.cancel = true;
      return;
    }
    ctx.rootOffset = offset;
    ctx.canvas = canvas;
    ctx.startCoord = getPointerCoord(offset, canvas, ctx.rotated, e);
    ctx.triggerStart();
    ctx.rect.attr({
      x: canvas.x1,
      y: canvas.y1,
      width: canvas.width,
      height: canvas.height
    }).append(ctx.root);
  };
}
function dragHandler(ctx) {
  return function (e) {
    const curCoord = getPointerCoord(ctx.rootOffset, ctx.canvas, ctx.rotated, e);
    const attr = {};
    ctx.curCoord = curCoord;
    attr[ctx.rotated ? 'y' : 'x'] = Math.min(ctx.startCoord, curCoord);
    attr[ctx.rotated ? 'height' : 'width'] = Math.abs(ctx.startCoord - curCoord);
    ctx.rect.attr(attr);
  };
}
function dragEndHandler(ctx) {
  return function (e) {
    ctx.triggerEnd();
    ctx.rect.remove();
  };
}
function shutterZoom(options) {
  const chart = options.chart;
  const renderer = options.renderer;
  const rotated = options.rotated;
  const rect = renderer.rect(0, 0, 0, 0).attr(options.shutterOptions);
  const shutter = {
    rect: rect,
    root: renderer.root,
    rotated: rotated,
    triggerStart: function () {
      chart._eventTrigger('zoomStart');
    },
    triggerEnd: function () {
      const tr = chart._argumentAxes[0].getTranslator();
      const rangeStart = Math.min(this.startCoord, this.curCoord);
      const rangeEnd = Math.max(this.startCoord, this.curCoord);
      chart._eventTrigger('zoomEnd', {
        rangeStart: tr.from(rangeStart),
        rangeEnd: tr.from(rangeEnd)
      });
    },
    dispose: function () {
      renderer.root.off(SHUTTER_EVENTS_NS);
      rect.dispose();
    },
    getRootOffset: function () {
      return renderer.getRootOffset();
    },
    getCanvas: function () {
      const canvas = chart._canvas;
      const panes = chart.panes;
      const firstPane = panes[0].canvas;
      const lastPane = panes[panes.length - 1].canvas;
      return {
        x1: firstPane.left,
        y1: firstPane.top,
        x2: canvas.width - lastPane.right,
        y2: canvas.height - lastPane.bottom,
        width: canvas.width - firstPane.left - lastPane.right,
        height: canvas.height - firstPane.top - lastPane.bottom
      };
    }
  };
  renderer.root.off(SHUTTER_EVENTS_NS).on(DRAG_START_EVENT_NAME, {
    direction: rotated ? 'vertical' : 'horizontal',
    immediate: true
  }, dragStartHandler(shutter)).on(DRAG_UPDATE_EVENT_NAME, dragHandler(shutter)).on(DRAG_END_EVENT_NAME, dragEndHandler(shutter));
  return shutter;
}
var _default = exports["default"] = {
  name: 'shutter_zoom',
  init: function () {
    const options = this.option('shutterZoom') || {};
    if (!options.enabled) {
      return;
    }
    this._shutterZoom = shutterZoom({
      chart: this,
      renderer: this._renderer,
      rotated: this.option('rotated'),
      shutterOptions: options
    });
  },
  dispose: function () {
    this._shutterZoom && this._shutterZoom.dispose();
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 19957:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.PieTracker = exports.ChartTracker = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _click = __webpack_require__(95429);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _utils = __webpack_require__(19157);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _index = __webpack_require__(39611);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _floor = Math.floor;
const eventsConsts = _consts.default.events;
const statesConsts = _consts.default.states;
const HOVER_STATE = statesConsts.hoverMark;
const NORMAL_STATE = statesConsts.normalMark;
const EVENT_NS = 'dxChartTracker';
const DOT_EVENT_NS = '.' + EVENT_NS;
const POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
const LEGEND_CLICK = 'legendClick';
const SERIES_CLICK = 'seriesClick';
const POINT_CLICK = 'pointClick';
const POINT_DATA = 'chart-data-point';
const SERIES_DATA = 'chart-data-series';
const ARG_DATA = 'chart-data-argument';
const DELAY = 100;
const HOLD_TIMEOUT = 300;
const NONE_MODE = 'none';
const ALL_ARGUMENT_POINTS_MODE = 'allargumentpoints';
const INCLUDE_POINTS_MODE = 'includepoints';
const EXLUDE_POINTS_MODE = 'excludepoints';
const LEGEND_HOVER_MODES = [INCLUDE_POINTS_MODE, EXLUDE_POINTS_MODE, NONE_MODE];
function getData(event, dataKey, tryCheckParent) {
  const target = event.target;
  if (target.tagName === 'tspan') {
    return target.parentNode[dataKey];
  }
  const data = target[dataKey];
  if (tryCheckParent && !(0, _type.isDefined)(data)) {
    const getParentData = function (node) {
      if (node.parentNode) {
        if ((0, _type.isDefined)(node.parentNode[dataKey])) {
          return node.parentNode[dataKey];
        } else {
          return getParentData(node.parentNode);
        }
      }
      return undefined;
    };
    return getParentData(target);
  }
  return data;
}
function eventCanceled(_ref, target, clickTarget) {
  let {
    event,
    cancel
  } = _ref;
  const deprecatedCancel = event.cancel; // DEPRECATED_22_1
  const eventCanceled = cancel || deprecatedCancel;
  if (deprecatedCancel) {
    _errors.default.log('W0003', `${clickTarget}Click handler argument`, 'event.cancel', '22.1', 'Use the \'cancel\' field instead');
  }
  return eventCanceled || !target.getOptions();
}
function correctLegendHoverMode(mode) {
  if (LEGEND_HOVER_MODES.indexOf(mode) > -1) {
    return mode;
  } else {
    return INCLUDE_POINTS_MODE;
  }
}
function correctHoverMode(target) {
  const mode = target.getOptions().hoverMode;
  return mode === NONE_MODE ? mode : ALL_ARGUMENT_POINTS_MODE;
}
const baseTrackerPrototype = {
  ctor: function (options) {
    const that = this;
    const data = {
      tracker: that
    };
    that._renderer = options.renderer;
    that._legend = options.legend;
    that._tooltip = options.tooltip;
    that._eventTrigger = options.eventTrigger;
    that._seriesGroup = options.seriesGroup;
    options.seriesGroup.off(DOT_EVENT_NS).on((0, _index.addNamespace)(eventsConsts.showPointTooltip, EVENT_NS), data, that._showPointTooltip).on((0, _index.addNamespace)(eventsConsts.hidePointTooltip, EVENT_NS), data, that._hidePointTooltip);
    that._renderer.root.off(DOT_EVENT_NS).on(POINTER_ACTION, data, that._pointerHandler).on((0, _index.addNamespace)(_pointer.default.up, EVENT_NS), () => clearTimeout(that._holdTimer)).on((0, _index.addNamespace)(_click.name, EVENT_NS), data, that._clickHandler);
  },
  update: function (options) {
    this._chart = options.chart;
  },
  updateSeries(series, resetDecorations) {
    const that = this;
    const noHoveredSeries = !(series !== null && series !== void 0 && series.some(s => s === that.hoveredSeries) || that._hoveredPoint && that._hoveredPoint.series);
    if (that._storedSeries !== series) {
      that._storedSeries = series || [];
    }
    if (noHoveredSeries) {
      that._clean();
      that._renderer.initDefsElements();
    }
    if (resetDecorations) {
      that.clearSelection();
      if (!noHoveredSeries) {
        that._hideTooltip(that.pointAtShownTooltip);
        that.clearHover();
      }
    }
  },
  setCanvases: function (mainCanvas, paneCanvases) {
    this._mainCanvas = mainCanvas;
    this._canvases = paneCanvases;
  },
  repairTooltip: function () {
    const point = this.pointAtShownTooltip;
    if (!point || !point.series || !point.isVisible()) {
      this._hideTooltip(point, true);
    } else {
      this._showTooltip(point);
    }
  },
  _setHoveredPoint: function (point) {
    if (point === this._hoveredPoint) {
      return;
    }
    this._releaseHoveredPoint();
    point.hover();
    this._hoveredPoint = point;
  },
  _releaseHoveredPoint: function (isPointerOut) {
    if (this._hoveredPoint && this._hoveredPoint.getOptions()) {
      this._hoveredPoint.clearHover();
      this._hoveredPoint = null;
      if (this._tooltip.isEnabled()) {
        this._hideTooltip(this._hoveredPoint, false, isPointerOut);
      }
    }
  },
  _setHoveredSeries: function (series, mode) {
    this._releaseHoveredSeries();
    this._releaseHoveredPoint();
    series.hover(mode);
    this.hoveredSeries = series;
  },
  _releaseHoveredSeries() {
    // hoveredPoint only for T273289
    if (this.hoveredSeries) {
      this.hoveredSeries.clearHover();
      this.hoveredSeries = null;
    }
  },
  clearSelection() {
    this._storedSeries.forEach(series => {
      if (series) {
        series.clearSelection();
        series.getPoints().forEach(point => point.clearSelection());
      }
    });
  },
  _clean: function () {
    const that = this;
    that.hoveredPoint = that.hoveredSeries = that._hoveredArgumentPoints = null;
    that._hideTooltip(that.pointAtShownTooltip);
  },
  clearHover: function (isPointerOut) {
    this._resetHoveredArgument();
    this._releaseHoveredSeries();
    this._releaseHoveredPoint(isPointerOut);
  },
  _hideTooltip: function (point, silent, isPointerOut) {
    const that = this;
    if (!that._tooltip || point && that.pointAtShownTooltip !== point) {
      return;
    }
    if (!silent && that.pointAtShownTooltip) {
      that.pointAtShownTooltip = null;
    }
    that._tooltip.hide(!!isPointerOut);
  },
  _showTooltip: function (point) {
    const that = this;
    let tooltipFormatObject;
    const eventData = {
      target: point
    };
    if (point !== null && point !== void 0 && point.getOptions()) {
      tooltipFormatObject = point.getTooltipFormatObject(that._tooltip, that._tooltip.isShared() && that._chart.getStackedPoints(point));
      if (!(0, _type.isDefined)(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible()) {
        return;
      }
      const coords = point.getTooltipParams(that._tooltip.getLocation());
      const rootOffset = that._renderer.getRootOffset();
      coords.x += rootOffset.left;
      coords.y += rootOffset.top;
      const callback = result => {
        result && (that.pointAtShownTooltip = point);
      };
      callback(that._tooltip.show(tooltipFormatObject, coords, eventData, undefined, callback));
    }
  },
  _showPointTooltip: function (event, point) {
    const that = event.data.tracker;
    const pointWithTooltip = that.pointAtShownTooltip;
    if (pointWithTooltip && pointWithTooltip !== point) {
      that._hideTooltip(pointWithTooltip);
    }
    that._showTooltip(point);
  },
  _hidePointTooltip: function (event, point) {
    event.data.tracker._hideTooltip(point, false, true);
  },
  _enableOutHandler: function () {
    if (this._outHandler) {
      return;
    }
    const that = this;
    const handler = function (e) {
      const rootOffset = that._renderer.getRootOffset();
      const x = _floor(e.pageX - rootOffset.left);
      const y = _floor(e.pageY - rootOffset.top);
      if (!(0, _utils.pointInCanvas)(that._mainCanvas, x, y) && !that._isCursorOnTooltip(e)) {
        that._pointerOut();
        that._disableOutHandler();
      }
    };
    _events_engine.default.on(_dom_adapter.default.getDocument(), POINTER_ACTION, handler);
    this._outHandler = handler;
  },
  _isCursorOnTooltip: function (e) {
    return this._tooltip.isEnabled() && this._tooltip.isCursorOnTooltip(e.pageX, e.pageY);
  },
  _disableOutHandler: function () {
    this._outHandler && _events_engine.default.off(_dom_adapter.default.getDocument(), POINTER_ACTION, this._outHandler);
    this._outHandler = null;
  },
  stopCurrentHandling: function () {
    this._pointerOut(true);
  },
  _pointerOut: function (force) {
    this.clearHover(true);
    (force || this._tooltip.isEnabled()) && this._hideTooltip(this.pointAtShownTooltip, false, true);
  },
  _triggerLegendClick: function (eventArgs, elementClick) {
    const eventTrigger = this._eventTrigger;
    eventTrigger(LEGEND_CLICK, eventArgs, function () {
      !eventCanceled(eventArgs, eventArgs.target, 'legend') && eventTrigger(elementClick, eventArgs);
    });
  },
  _hoverLegendItem: function (x, y) {
    const that = this;
    const item = that._legend.getItemByCoord(x, y);
    let series;
    const legendHoverMode = correctLegendHoverMode(that._legend.getOptions().hoverMode);
    if (item) {
      series = that._storedSeries[item.id];
      if (!series.isHovered() || series.lastHoverMode !== legendHoverMode) {
        that._setHoveredSeries(series, legendHoverMode);
      }
      that._tooltip.isEnabled() && that._hideTooltip(that.pointAtShownTooltip);
    } else {
      that.clearHover();
    }
  },
  _hoverArgument: function (argument, argumentIndex) {
    const that = this;
    const hoverMode = that._getArgumentHoverMode();
    if ((0, _type.isDefined)(argument)) {
      that._releaseHoveredPoint();
      that._hoveredArgument = argument;
      that._argumentIndex = argumentIndex;
      that._notifySeries({
        action: 'pointHover',
        notifyLegend: that._notifyLegendOnHoverArgument,
        target: {
          argument: argument,
          fullState: HOVER_STATE,
          argumentIndex: argumentIndex,
          getOptions: function () {
            return {
              hoverMode: hoverMode
            };
          }
        }
      });
    }
  },
  _resetHoveredArgument: function () {
    const that = this;
    let hoverMode;
    if ((0, _type.isDefined)(that._hoveredArgument)) {
      hoverMode = that._getArgumentHoverMode();
      that._notifySeries({
        action: 'clearPointHover',
        notifyLegend: that._notifyLegendOnHoverArgument,
        target: {
          fullState: NORMAL_STATE,
          argumentIndex: that._argumentIndex,
          argument: that._hoveredArgument,
          getOptions: function () {
            return {
              hoverMode: hoverMode
            };
          }
        }
      });
      that._hoveredArgument = null;
    }
  },
  _notifySeries: function (data) {
    this._storedSeries.forEach(function (series) {
      series.notify(data);
    });
  },
  _pointerHandler: function (e) {
    var _series;
    const that = e.data.tracker;
    const rootOffset = that._renderer.getRootOffset();
    const x = _floor(e.pageX - rootOffset.left);
    const y = _floor(e.pageY - rootOffset.top);
    const canvas = that._getCanvas(x, y);
    let series = getData(e, SERIES_DATA);
    let point = getData(e, POINT_DATA) || ((_series = series) === null || _series === void 0 ? void 0 : _series.getPointByCoord(x, y));
    that._isHolding = false;
    clearTimeout(that._holdTimer);
    if (e.type === _pointer.default.down) {
      that._holdTimer = setTimeout(() => that._isHolding = true, HOLD_TIMEOUT);
    }
    if (point && !point.getMarkerVisibility()) {
      point = undefined;
    }
    that._enableOutHandler();
    if (that._legend.coordsIn(x, y)) {
      that._hoverLegendItem(x, y);
      return;
    }
    if (that.hoveredSeries && that.hoveredSeries !== that._stuckSeries) {
      that._releaseHoveredSeries();
    }
    if (that._hoverArgumentAxis(x, y, e)) {
      return;
    }
    if (that._isPointerOut(canvas, point)) {
      that._pointerOut();
    }
    if (!canvas && !point) {
      return;
    }
    if (series && !point) {
      point = series.getNeighborPoint(x, y);
      if (!that._stickyHovering && point && !point.coordsIn(x, y)) {
        point = null;
      }
      if (series !== that.hoveredSeries) {
        that._setTimeout(function () {
          that._setHoveredSeries(series);
          that._setStuckSeries(e, series, x, y);
          that._pointerComplete(point, x, y);
        }, series);
        return;
      }
    } else if (point) {
      if (e.type !== _pointer.default.move && e.pointerType !== 'touch') {
        return;
      }
      if (that.hoveredSeries) {
        that._setTimeout(() => that._pointerOnPoint(point, x, y, e), point);
      } else {
        that._pointerOnPoint(point, x, y, e);
      }
      return;
    } else if (that._setStuckSeries(e, undefined, x, y) && that._stickyHovering) {
      var _point;
      series = that._stuckSeries;
      point = series.getNeighborPoint(x, y);
      that._releaseHoveredSeries();
      ((_point = point) === null || _point === void 0 ? void 0 : _point.getMarkerVisibility()) && that._setHoveredPoint(point);
    } else if (!that._stickyHovering) {
      that._pointerOut();
    }
    that._pointerComplete(point, x, y);
  },
  _pointerOnPoint: function (point, x, y) {
    this._resetHoveredArgument();
    this._setHoveredPoint(point);
    this._pointerComplete(point, x, y);
  },
  _pointerComplete: function (point) {
    this.pointAtShownTooltip !== point && this._tooltip.isEnabled() && this._showTooltip(point);
  },
  _clickHandler: function (e) {
    var _point2;
    const that = e.data.tracker;
    if (that._isHolding) {
      return;
    }
    const rootOffset = that._renderer.getRootOffset();
    const x = _floor(e.pageX - rootOffset.left);
    const y = _floor(e.pageY - rootOffset.top);
    let point = getData(e, POINT_DATA);
    const series = that._stuckSeries || getData(e, SERIES_DATA) || ((_point2 = point) === null || _point2 === void 0 ? void 0 : _point2.series);
    const axis = that._argumentAxis;
    if (that._legend.coordsIn(x, y)) {
      const item = that._legend.getItemByCoord(x, y);
      if (item) {
        that._legendClick(item, e);
      }
    } else if (axis !== null && axis !== void 0 && axis.coordsIn(x, y)) {
      const argument = getData(e, ARG_DATA, true);
      if ((0, _type.isDefined)(argument)) {
        that._eventTrigger('argumentAxisClick', {
          argument: argument,
          event: e
        });
      }
    } else if (series) {
      var _point3;
      point = point || series.getPointByCoord(x, y);
      if ((_point3 = point) !== null && _point3 !== void 0 && _point3.getMarkerVisibility()) {
        that._pointClick(point, e);
      } else {
        getData(e, SERIES_DATA) && that._eventTrigger(SERIES_CLICK, {
          target: series,
          event: e
        });
      }
    }
  },
  dispose: function () {
    const that = this;
    that._disableOutHandler();
    that._renderer.root.off(DOT_EVENT_NS);
    that._seriesGroup.off(DOT_EVENT_NS);
  }
};
const ChartTracker = function (options) {
  this.ctor(options);
};
exports.ChartTracker = ChartTracker;
(0, _extend.extend)(ChartTracker.prototype, baseTrackerPrototype, {
  _pointClick: function (point, event) {
    const that = this;
    const eventTrigger = that._eventTrigger;
    const series = point.series;
    const eventArgs = {
      target: point,
      event: event
    };
    eventTrigger(POINT_CLICK, eventArgs, function () {
      !eventCanceled(eventArgs, series, 'point') && eventTrigger(SERIES_CLICK, {
        target: series,
        event: event
      });
    });
  },
  update: function (options) {
    const that = this;
    baseTrackerPrototype.update.call(this, options);
    that._argumentAxis = options.argumentAxis || {};
    that._axisHoverEnabled = that._argumentAxis && (0, _utils.normalizeEnum)(that._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENT_POINTS_MODE;
    that._rotated = options.rotated;
    that._crosshair = options.crosshair;
    that._stickyHovering = options.stickyHovering;
  },
  _getCanvas: function (x, y) {
    const that = this;
    const canvases = that._canvases || [];
    for (let i = 0; i < canvases.length; i++) {
      const c = canvases[i];
      if ((0, _utils.pointInCanvas)(c, x, y)) {
        return c;
      }
    }
    return null;
  },
  _isPointerOut: function (canvas) {
    return !canvas && this._stuckSeries;
  },
  _hideCrosshair: function () {
    var _this$_crosshair;
    (_this$_crosshair = this._crosshair) === null || _this$_crosshair === void 0 || _this$_crosshair.hide();
  },
  _moveCrosshair: function (point, x, y) {
    if (this._crosshair && point !== null && point !== void 0 && point.isVisible()) {
      this._crosshair.show({
        point: point,
        x: x,
        y: y
      });
    }
  },
  _clean: function () {
    const that = this;
    baseTrackerPrototype._clean.call(that);
    that._resetTimer();
    that._stuckSeries = null;
  },
  _getSeriesForShared: function (x, y) {
    var _point4;
    const that = this;
    const points = [];
    let point = null;
    let distance = Infinity;
    if (that._tooltip.isShared() && !that.hoveredSeries) {
      (0, _iterator.each)(that._storedSeries, function (_, series) {
        const point = series.getNeighborPoint(x, y);
        point && points.push(point);
      });
      (0, _iterator.each)(points, function (_, p) {
        const coords = p.getCrosshairData(x, y);
        const d = (0, _utils.getDistance)(x, y, coords.x, coords.y);
        if (d < distance) {
          point = p;
          distance = d;
        }
      });
    }
    return (_point4 = point) === null || _point4 === void 0 ? void 0 : _point4.series;
  },
  _setTimeout: function (callback, keeper) {
    const that = this;
    if (that._timeoutKeeper !== keeper) {
      that._resetTimer();
      that._hoverTimeout = setTimeout(function () {
        callback();
        that._timeoutKeeper = null;
      }, DELAY);
      that._timeoutKeeper = keeper;
    }
  },
  _resetTimer: function () {
    clearTimeout(this._hoverTimeout);
    this._timeoutKeeper = this._hoverTimeout = null;
  },
  _stopEvent: function (e) {
    if (!(0, _type.isDefined)(e.cancelable) || e.cancelable) {
      e.preventDefault();
      e.stopPropagation(); // T249548
    }
  },
  _setStuckSeries: function (e, series, x, y) {
    if (e.pointerType !== 'mouse') {
      this._stuckSeries = null;
    } else {
      this._stuckSeries = series || this._stuckSeries || this._getSeriesForShared(x, y);
    }
    return !!this._stuckSeries;
  },
  _pointerOut: function () {
    const that = this;
    that._stuckSeries = null;
    that._hideCrosshair();
    that._resetTimer();
    baseTrackerPrototype._pointerOut.apply(that, arguments);
  },
  _hoverArgumentAxis: function (x, y, e) {
    const that = this;
    that._resetHoveredArgument();
    if (that._axisHoverEnabled && that._argumentAxis.coordsIn(x, y)) {
      that._hoverArgument(getData(e, ARG_DATA, true));
      return true;
    }
  },
  _pointerComplete: function (point, x, y) {
    const that = this;
    that.hoveredSeries && that.hoveredSeries.updateHover(x, y);
    that._resetTimer();
    that._moveCrosshair(point, x, y);
    baseTrackerPrototype._pointerComplete.call(that, point);
  },
  _legendClick: function (item, e) {
    const series = this._storedSeries[item.id];
    this._triggerLegendClick({
      target: series,
      event: e
    }, SERIES_CLICK);
  },
  _hoverLegendItem: function (x, y) {
    this._stuckSeries = null;
    this._hideCrosshair();
    baseTrackerPrototype._hoverLegendItem.call(this, x, y);
  },
  _pointerOnPoint: function (point, x, y, e) {
    this._setStuckSeries(e, point.series, x, y);
    this._releaseHoveredSeries();
    baseTrackerPrototype._pointerOnPoint.call(this, point, x, y, e);
  },
  _notifyLegendOnHoverArgument: false,
  _getArgumentHoverMode: function () {
    return correctHoverMode(this._argumentAxis);
  },
  dispose: function () {
    this._resetTimer();
    baseTrackerPrototype.dispose.call(this);
  }
});
const PieTracker = function (options) {
  this.ctor(options);
};
exports.PieTracker = PieTracker;
(0, _extend.extend)(PieTracker.prototype, baseTrackerPrototype, {
  _isPointerOut: function (_, point) {
    return !point;
  },
  _legendClick: function (item, e) {
    const that = this;
    const points = [];
    that._storedSeries.forEach(s => points.push.apply(points, s.getPointsByKeys(item.argument, item.argumentIndex)));
    that._eventTrigger(LEGEND_CLICK, {
      target: item.argument,
      points,
      event: e
    });
  },
  _pointClick: function (point, e) {
    this._eventTrigger(POINT_CLICK, {
      target: point,
      event: e
    });
  },
  _hoverLegendItem: function (x, y) {
    const that = this;
    const item = that._legend.getItemByCoord(x, y);
    if (item && that._hoveredArgument !== item.argument) {
      that._resetHoveredArgument();
      that._hoverArgument(item.argument, item.argumentIndex);
    } else if (!item) {
      that.clearHover();
    }
  },
  _getArgumentHoverMode: function () {
    return correctHoverMode(this._legend);
  },
  _hoverArgumentAxis: _common.noop,
  _setStuckSeries: _common.noop,
  _getCanvas: _common.noop,
  _notifyLegendOnHoverArgument: true
});

/***/ }),

/***/ 59345:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _wheel = __webpack_require__(765);
var transformEvents = _interopRequireWildcard(__webpack_require__(91093));
var _drag = __webpack_require__(23174);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const EVENTS_NS = '.zoomAndPanNS';
const DRAG_START_EVENT_NAME = _drag.start + EVENTS_NS;
const DRAG_EVENT_NAME = _drag.move + EVENTS_NS;
const DRAG_END_EVENT_NAME = _drag.end + EVENTS_NS;

/* eslint-disable import/namespace */
const PINCH_START_EVENT_NAME = transformEvents['pinchstart'] + EVENTS_NS;
const PINCH_EVENT_NAME = transformEvents['pinch'] + EVENTS_NS;
const PINCH_END_EVENT_NAME = transformEvents['pinchend'] + EVENTS_NS;
/* eslint-enable import/namespace */

const SCROLL_BAR_START_EVENT_NAME = 'dxc-scroll-start' + EVENTS_NS;
const SCROLL_BAR_MOVE_EVENT_NAME = 'dxc-scroll-move' + EVENTS_NS;
const SCROLL_BAR_END_EVENT_NAME = 'dxc-scroll-end' + EVENTS_NS;
const GESTURE_TIMEOUT = 300;
const MIN_DRAG_DELTA = 5;
const _min = Math.min;
const _max = Math.max;
const _abs = Math.abs;
function canvasToRect(canvas) {
  return {
    x: canvas.left,
    y: canvas.top,
    width: canvas.width - canvas.left - canvas.right,
    height: canvas.height - canvas.top - canvas.bottom
  };
}
function checkCoords(rect, coords) {
  const x = coords.x;
  const y = coords.y;
  return x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.height + rect.y;
}
function sortAxes(axes, onlyAxisToNotify) {
  if (onlyAxisToNotify) {
    axes = axes.sort((a, b) => {
      if (a === onlyAxisToNotify) {
        return -1;
      }
      if (b === onlyAxisToNotify) {
        return 1;
      }
      return 0;
    });
  }
  return axes;
}
function getFilteredAxes(axes) {
  return axes.filter(a => !a.getTranslator().getBusinessRange().isEmpty());
}
function isAxisAvailablePanning(axes) {
  return axes.some(axis => !axis.isExtremePosition(false) || !axis.isExtremePosition(true));
}
function axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e) {
  const silent = onlyAxisToNotify && axis !== onlyAxisToNotify;
  const range = getRange(axis);
  const {
    stopInteraction,
    correctedRange
  } = axis.checkZoomingLowerLimitOvercome(actionField, scale, range);
  const result = axis.handleZooming(stopInteraction ? null : correctedRange, getParameters(silent), e, actionField);
  stopInteraction && axis.handleZoomEnd();
  return {
    stopInteraction,
    result
  };
}
function zoomAxes(e, axes, getRange, zoom, params, onlyAxisToNotify) {
  axes = sortAxes(axes, onlyAxisToNotify);
  let zoomStarted = false;
  const getParameters = silent => {
    return {
      start: !!silent,
      end: !!silent
    };
  };
  getFilteredAxes(axes).some(axis => {
    const translator = axis.getTranslator();
    const scale = translator.getMinScale(zoom);
    const {
      stopInteraction,
      result
    } = axisZoom(axis, onlyAxisToNotify, getRange(_extends({
      scale,
      translator,
      axis
    }, params)), getParameters, 'zoom', scale, e);
    zoomStarted = !stopInteraction;
    return onlyAxisToNotify && result.isPrevented;
  });
  return zoomStarted;
}
function cancelEvent(e) {
  if (e.originalEvent) {
    cancelEvent(e.originalEvent);
  }
  if (e.cancelable !== false) {
    e.cancel = true;
  }
}
var _default = exports["default"] = {
  name: 'zoom_and_pan',
  init: function () {
    const chart = this;
    const renderer = this._renderer;
    function getAxesCopy(zoomAndPan, actionField) {
      let axes = [];
      const options = zoomAndPan.options;
      const actionData = zoomAndPan.actionData;
      if (options.argumentAxis[actionField]) {
        axes.push(chart.getArgumentAxis());
      }
      if (options.valueAxis[actionField]) {
        axes = axes.concat(actionData.valueAxes);
      }
      return axes;
    }
    function startAxesViewportChanging(zoomAndPan, actionField, e) {
      const axes = getAxesCopy(zoomAndPan, actionField);
      getFilteredAxes(axes).some(axis => axis.handleZooming(null, {
        end: true
      }, e, actionField).isPrevented) && cancelEvent(e);
    }
    function axesViewportChanging(zoomAndPan, actionField, e, offsetCalc, centerCalc) {
      function zoomAxes(axes, criteria, coordField, e, actionData) {
        let zoom = {
          zoomed: false
        };
        criteria && getFilteredAxes(axes).forEach(axis => {
          const options = axis.getOptions();
          const viewport = axis.visualRange();
          const scale = axis.getTranslator().getEventScale(e);
          const translate = -offsetCalc(e, actionData, coordField, scale);
          zoom = (0, _extend.extend)(true, zoom, axis.getTranslator().zoom(translate, scale, axis.getZoomBounds()));
          const range = axis.adjustRange((0, _utils.getVizRangeObject)([zoom.min, zoom.max]));
          const {
            stopInteraction,
            correctedRange
          } = axis.checkZoomingLowerLimitOvercome(actionField, scale, range);
          if (!(0, _type.isDefined)(viewport) || viewport.startValue.valueOf() !== correctedRange.startValue.valueOf() || viewport.endValue.valueOf() !== correctedRange.endValue.valueOf()) {
            axis.handleZooming(stopInteraction ? null : correctedRange, {
              start: true,
              end: true
            }, e, actionField);
            if (!stopInteraction) {
              zoom.zoomed = true;
              zoom.deltaTranslate = translate - zoom.translate;
            }
          } else if (e.pointerType === 'touch' && options.type === 'discrete') {
            const isMinPosition = axis.isExtremePosition(false);
            const isMaxPosition = axis.isExtremePosition(true);
            const zoomInEnabled = scale > 1 && !stopInteraction;
            const zoomOutEnabled = scale < 1 && (!isMinPosition || !isMaxPosition);
            const panningEnabled = scale === 1 && !(isMinPosition && (translate < 0 && !options.inverted || translate > 0 && options.inverted) || isMaxPosition && (translate > 0 && !options.inverted || translate < 0 && options.inverted));
            zoom.enabled = zoomInEnabled || zoomOutEnabled || panningEnabled;
          }
        });
        return zoom;
      }
      function storeOffset(e, actionData, zoom, coordField) {
        if (zoom.zoomed) {
          actionData.offset[coordField] = (e.offset ? e.offset[coordField] : actionData.offset[coordField]) + zoom.deltaTranslate;
        }
      }
      function storeCenter(center, actionData, zoom, coordField) {
        if (zoom.zoomed) {
          actionData.center[coordField] = center[coordField] + zoom.deltaTranslate;
        }
      }
      const rotated = chart.option('rotated');
      const actionData = zoomAndPan.actionData;
      const options = zoomAndPan.options;
      let argZoom = {};
      let valZoom = {};
      if (!actionData.fallback) {
        argZoom = zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? 'y' : 'x', e, actionData);
        valZoom = zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? 'x' : 'y', e, actionData);
        chart._requestChange(['VISUAL_RANGE']);
        storeOffset(e, actionData, argZoom, rotated ? 'y' : 'x');
        storeOffset(e, actionData, valZoom, rotated ? 'x' : 'y');
      }
      const center = centerCalc(e);
      storeCenter(center, actionData, argZoom, rotated ? 'y' : 'x');
      storeCenter(center, actionData, valZoom, rotated ? 'x' : 'y');
      if (!argZoom.zoomed && !valZoom.zoomed) {
        actionData.center = center;
      }
      return argZoom.zoomed || valZoom.zoomed || actionData.fallback || argZoom.enabled || valZoom.enabled;
    }
    function finishAxesViewportChanging(zoomAndPan, actionField, e, offsetCalc) {
      function zoomAxes(axes, coordField, actionData, onlyAxisToNotify) {
        let zoomStarted = false;
        const scale = e.scale || 1;
        const getRange = axis => {
          const zoom = axis.getTranslator().zoom(-offsetCalc(e, actionData, coordField, scale), scale, axis.getZoomBounds());
          return {
            startValue: zoom.min,
            endValue: zoom.max
          };
        };
        const getParameters = silent => {
          return {
            start: true,
            end: silent
          };
        };
        getFilteredAxes(axes).forEach(axis => {
          zoomStarted = !axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e).stopInteraction;
        });
        return zoomStarted;
      }
      const rotated = chart.option('rotated');
      const actionData = zoomAndPan.actionData;
      const options = zoomAndPan.options;
      let zoomStarted = true;
      if (actionData.fallback) {
        zoomStarted &= options.argumentAxis[actionField] && zoomAxes(chart._argumentAxes, rotated ? 'y' : 'x', actionData, chart.getArgumentAxis());
        zoomStarted |= options.valueAxis[actionField] && zoomAxes(actionData.valueAxes, rotated ? 'x' : 'y', actionData);
      } else {
        const axes = getAxesCopy(zoomAndPan, actionField);
        getFilteredAxes(axes).forEach(axis => {
          axis.handleZooming(null, {
            start: true
          }, e, actionField);
        });
        zoomStarted = axes.length;
      }
      zoomStarted && chart._requestChange(['VISUAL_RANGE']);
    }
    function prepareActionData(coords, action) {
      const axes = chart._argumentAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords));
      return {
        fallback: chart._lastRenderingTime > GESTURE_TIMEOUT,
        cancel: !axes.length || !(0, _type.isDefined)(action),
        action: action,
        curAxisRect: axes.length && canvasToRect(axes[0].getCanvas()),
        valueAxes: axes.length && chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords)),
        offset: {
          x: 0,
          y: 0
        },
        center: coords,
        startCenter: coords
      };
    }
    function getPointerCoord(rect, e) {
      const rootOffset = renderer.getRootOffset();
      return {
        x: _min(_max(e.pageX - rootOffset.left, rect.x), rect.width + rect.x),
        y: _min(_max(e.pageY - rootOffset.top, rect.y), rect.height + rect.y)
      };
    }
    function calcCenterForPinch(e) {
      const rootOffset = renderer.getRootOffset();
      const x1 = e.pointers[0].pageX;
      const x2 = e.pointers[1].pageX;
      const y1 = e.pointers[0].pageY;
      const y2 = e.pointers[1].pageY;
      return {
        x: _min(x1, x2) + _abs(x2 - x1) / 2 - rootOffset.left,
        y: _min(y1, y2) + _abs(y2 - y1) / 2 - rootOffset.top
      };
    }
    function calcCenterForDrag(e) {
      const rootOffset = renderer.getRootOffset();
      return {
        x: e.pageX - rootOffset.left,
        y: e.pageY - rootOffset.top
      };
    }
    function calcOffsetForDrag(e, actionData, coordField) {
      return e.offset[coordField] - actionData.offset[coordField];
    }
    function preventDefaults(e) {
      if (e.cancelable !== false) {
        e.preventDefault();
        e.stopPropagation();
      }
      chart._stopCurrentHandling();
    }
    const zoomAndPan = {
      dragStartHandler: function (e) {
        const options = zoomAndPan.options;
        const isTouch = e.pointerType === 'touch';
        const wantPan = options.argumentAxis.pan || options.valueAxis.pan;
        const wantZoom = options.argumentAxis.zoom || options.valueAxis.zoom;
        const panKeyPressed = (0, _type.isDefined)(options.panKey) && e[(0, _utils.normalizeEnum)(options.panKey) + 'Key'];
        const dragToZoom = options.dragToZoom;
        let action;
        e._cancelPreventDefault = true;
        if (isTouch) {
          if (options.allowTouchGestures && wantPan) {
            const cancelPanning = !zoomAndPan.panningVisualRangeEnabled() || zoomAndPan.skipEvent;
            action = cancelPanning ? null : 'pan';
          }
        } else {
          if (dragToZoom && wantPan && panKeyPressed || !dragToZoom && wantPan) {
            action = 'pan';
          } else if (dragToZoom && wantZoom) {
            action = 'zoom';
          }
        }
        const actionData = prepareActionData(calcCenterForDrag(e), action);
        if (actionData.cancel) {
          zoomAndPan.skipEvent = false;
          if (e.cancelable !== false) {
            e.cancel = true;
          }
          return;
        }
        zoomAndPan.actionData = actionData;
        if (action === 'zoom') {
          actionData.startCoords = getPointerCoord(actionData.curAxisRect, e);
          actionData.rect = renderer.rect(0, 0, 0, 0).attr(options.dragBoxStyle).append(renderer.root);
        } else {
          startAxesViewportChanging(zoomAndPan, 'pan', e);
        }
      },
      dragHandler: function (e) {
        const rotated = chart.option('rotated');
        const options = zoomAndPan.options;
        const actionData = zoomAndPan.actionData;
        const isTouch = e.pointerType === 'touch';
        e._cancelPreventDefault = true;
        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled()) {
          return;
        }
        if (actionData.action === 'zoom') {
          preventDefaults(e);
          const curCanvas = actionData.curAxisRect;
          const startCoords = actionData.startCoords;
          const curCoords = getPointerCoord(curCanvas, e);
          const zoomArg = options.argumentAxis.zoom;
          const zoomVal = options.valueAxis.zoom;
          const rect = {
            x: _min(startCoords.x, curCoords.x),
            y: _min(startCoords.y, curCoords.y),
            width: _abs(startCoords.x - curCoords.x),
            height: _abs(startCoords.y - curCoords.y)
          };
          if (!zoomArg || !zoomVal) {
            if (!zoomArg && !rotated || !zoomVal && rotated) {
              rect.x = curCanvas.x;
              rect.width = curCanvas.width;
            } else {
              rect.y = curCanvas.y;
              rect.height = curCanvas.height;
            }
          }
          actionData.rect.attr(rect);
        } else if (actionData.action === 'pan') {
          axesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag, e => e.offset);
          const deltaOffsetY = Math.abs(e.offset.y - actionData.offset.y);
          const deltaOffsetX = Math.abs(e.offset.x - actionData.offset.x);
          if (isTouch && (deltaOffsetY > MIN_DRAG_DELTA && deltaOffsetY > Math.abs(actionData.offset.x) || deltaOffsetX > MIN_DRAG_DELTA && deltaOffsetX > Math.abs(actionData.offset.y))) {
            return;
          }
          preventDefaults(e);
        }
      },
      dragEndHandler: function (e) {
        const rotated = chart.option('rotated');
        const options = zoomAndPan.options;
        const actionData = zoomAndPan.actionData;
        const isTouch = e.pointerType === 'touch';
        const getRange = _ref => {
          let {
            translator,
            startCoord,
            curCoord
          } = _ref;
          return () => {
            return [translator.from(startCoord), translator.from(curCoord)];
          };
        };
        const getCoords = (curCoords, startCoords, field) => {
          return {
            curCoord: curCoords[field],
            startCoord: startCoords[field]
          };
        };
        const needToZoom = (axisOption, coords) => {
          return axisOption.zoom && _abs(coords.curCoord - coords.startCoord) > MIN_DRAG_DELTA;
        };
        const panIsEmpty = actionData && actionData.action === 'pan' && !actionData.fallback && actionData.offset.x === 0 && actionData.offset.y === 0;
        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled() || panIsEmpty) {
          return;
        }
        !isTouch && preventDefaults(e);
        if (actionData.action === 'zoom') {
          const curCoords = getPointerCoord(actionData.curAxisRect, e);
          const argumentCoords = getCoords(curCoords, actionData.startCoords, rotated ? 'y' : 'x');
          const valueCoords = getCoords(curCoords, actionData.startCoords, rotated ? 'x' : 'y');
          const argumentAxesZoomed = needToZoom(options.argumentAxis, argumentCoords) && zoomAxes(e, chart._argumentAxes, getRange, true, argumentCoords, chart.getArgumentAxis());
          const valueAxesZoomed = needToZoom(options.valueAxis, valueCoords) && zoomAxes(e, actionData.valueAxes, getRange, true, valueCoords);
          if (valueAxesZoomed || argumentAxesZoomed) {
            chart._requestChange(['VISUAL_RANGE']);
          }
          actionData.rect.dispose();
        } else if (actionData.action === 'pan') {
          finishAxesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag);
        }
        zoomAndPan.actionData = null;
      },
      pinchStartHandler: function (e) {
        const actionData = prepareActionData(calcCenterForPinch(e), 'zoom');
        if (actionData.cancel) {
          cancelEvent(e);
          return;
        }
        zoomAndPan.actionData = actionData;
        startAxesViewportChanging(zoomAndPan, 'zoom', e);
      },
      pinchHandler: function (e) {
        if (!zoomAndPan.actionData) {
          return;
        }
        axesViewportChanging(zoomAndPan, 'zoom', e, (e, actionData, coordField, scale) => calcCenterForPinch(e)[coordField] - actionData.center[coordField] + (actionData.center[coordField] - actionData.center[coordField] * scale), calcCenterForPinch);
        preventDefaults(e);
      },
      pinchEndHandler: function (e) {
        if (!zoomAndPan.actionData) {
          return;
        }
        finishAxesViewportChanging(zoomAndPan, 'zoom', e, (e, actionData, coordField, scale) => actionData.center[coordField] - actionData.startCenter[coordField] + (actionData.startCenter[coordField] - actionData.startCenter[coordField] * scale));
        zoomAndPan.actionData = null;
      },
      mouseWheelHandler: function (e) {
        const options = zoomAndPan.options;
        const rotated = chart.option('rotated');
        const getRange = _ref2 => {
          let {
            translator,
            coord,
            scale,
            axis
          } = _ref2;
          return () => {
            const zoom = translator.zoom(-(coord - coord * scale), scale, axis.getZoomBounds());
            return {
              startValue: zoom.min,
              endValue: zoom.max
            };
          };
        };
        const coords = calcCenterForDrag(e);
        let axesZoomed = false;
        let targetAxes;
        if (options.valueAxis.zoom) {
          targetAxes = chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords));
          if (targetAxes.length === 0) {
            const targetCanvas = chart._valueAxes.reduce((r, axis) => {
              if (!r && axis.coordsIn(coords.x, coords.y)) {
                r = axis.getCanvas();
              }
              return r;
            }, null);
            if (targetCanvas) {
              targetAxes = chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), {
                x: targetCanvas.left,
                y: targetCanvas.top
              }));
            }
          }
          axesZoomed |= zoomAxes(e, targetAxes, getRange, e.delta > 0, {
            coord: rotated ? coords.x : coords.y
          });
        }
        if (options.argumentAxis.zoom) {
          const canZoom = chart._argumentAxes.some(axis => {
            if (checkCoords(canvasToRect(axis.getCanvas()), coords) || axis.coordsIn(coords.x, coords.y)) {
              return true;
            }
            return false;
          });
          axesZoomed |= canZoom && zoomAxes(e, chart._argumentAxes, getRange, e.delta > 0, {
            coord: rotated ? coords.y : coords.x
          }, chart.getArgumentAxis());
        }
        if (axesZoomed) {
          chart._requestChange(['VISUAL_RANGE']);
          if (targetAxes && isAxisAvailablePanning(targetAxes) || !targetAxes && zoomAndPan.panningVisualRangeEnabled()) {
            preventDefaults(e); // T249548
          }
        }
      },
      cleanup: function () {
        renderer.root.off(EVENTS_NS);
        zoomAndPan.actionData && zoomAndPan.actionData.rect && zoomAndPan.actionData.rect.dispose();
        zoomAndPan.actionData = null;
        renderer.root.css({
          'touch-action': ''
        });
      },
      setup: function (options) {
        zoomAndPan.cleanup();
        if (!options.argumentAxis.pan) {
          renderer.root.on(SCROLL_BAR_START_EVENT_NAME, cancelEvent);
        }
        if (options.argumentAxis.none && options.valueAxis.none) {
          return;
        }
        zoomAndPan.options = options;
        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowMouseWheel) {
          renderer.root.on(_wheel.name + EVENTS_NS, zoomAndPan.mouseWheelHandler);
        }
        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowTouchGestures) {
          renderer.root.on(PINCH_START_EVENT_NAME, {
            passive: false
          }, zoomAndPan.pinchStartHandler).on(PINCH_EVENT_NAME, {
            passive: false
          }, zoomAndPan.pinchHandler).on(PINCH_END_EVENT_NAME, zoomAndPan.pinchEndHandler);
        }
        renderer.root.on(DRAG_START_EVENT_NAME, {
          immediate: true,
          passive: false
        }, zoomAndPan.dragStartHandler).on(DRAG_EVENT_NAME, {
          immediate: true,
          passive: false
        }, zoomAndPan.dragHandler).on(DRAG_END_EVENT_NAME, zoomAndPan.dragEndHandler);
        renderer.root.on(SCROLL_BAR_START_EVENT_NAME, function (e) {
          zoomAndPan.actionData = {
            valueAxes: [],
            offset: {
              x: 0,
              y: 0
            },
            center: {
              x: 0,
              y: 0
            }
          };
          preventDefaults(e);
          startAxesViewportChanging(zoomAndPan, 'pan', e);
        }).on(SCROLL_BAR_MOVE_EVENT_NAME, function (e) {
          preventDefaults(e);
          axesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag, e => e.offset);
        }).on(SCROLL_BAR_END_EVENT_NAME, function (e) {
          preventDefaults(e);
          finishAxesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag);
          zoomAndPan.actionData = null;
        });
      },
      panningVisualRangeEnabled: function () {
        return isAxisAvailablePanning(chart._valueAxes) || isAxisAvailablePanning(chart._argumentAxes);
      }
    };
    this._zoomAndPan = zoomAndPan;
  },
  members: {
    _setupZoomAndPan: function () {
      this._zoomAndPan.setup(this._themeManager.getOptions('zoomAndPan'));
    }
  },
  dispose: function () {
    this._zoomAndPan.cleanup();
  },
  customize: function (constructor) {
    constructor.addChange({
      code: 'ZOOM_AND_PAN',
      handler: function () {
        this._setupZoomAndPan();
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'zoomAndPan'
    });
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 39847:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _circular_gauge = _interopRequireDefault(__webpack_require__(51576));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _circular_gauge.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 99327:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ThemeManager = void 0;
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _base_theme_manager = __webpack_require__(43637);
var _utils = __webpack_require__(19157);
const ThemeManager = exports.ThemeManager = _base_theme_manager.BaseThemeManager.inherit(function () {
  const ctor = function (params) {
    const that = this;
    that.callBase.apply(that, arguments);
    const options = params.options || {};
    that._userOptions = options;
    that._mergeAxisTitleOptions = [];
    that._multiPieColors = {};

    // This is required because chart calls "_getOption" during "_init" stage
    // TODO: Remove it when chart stops doing that
    that._callback = _common.noop;
  };
  const dispose = function () {
    const that = this;
    that.palette && that.palette.dispose();
    that.palette = that._userOptions = that._mergedSettings = that._multiPieColors = null;
    return that.callBase.apply(that, arguments);
  };
  const resetPalette = function () {
    this.palette.reset();
    this._multiPieColors = {};
  };
  const processTitleOptions = function (options) {
    return (0, _type.isString)(options) ? {
      text: options
    } : options;
  };
  const processAxisOptions = function (axisOptions) {
    if (!axisOptions) {
      return {};
    }
    axisOptions = (0, _extend.extend)(true, {}, axisOptions);
    axisOptions.title = processTitleOptions(axisOptions.title);
    if (axisOptions.type === 'logarithmic' && axisOptions.logarithmBase <= 0 || axisOptions.logarithmBase && !(0, _type.isNumeric)(axisOptions.logarithmBase)) {
      axisOptions.logarithmBase = undefined;
      axisOptions.logarithmBaseError = true;
    }
    if (axisOptions.label) {
      if (axisOptions.label.alignment) {
        axisOptions.label['userAlignment'] = true;
      }
    }
    return axisOptions;
  };
  const applyParticularAxisOptions = function (name, userOptions, rotated) {
    const theme = this._theme;
    const position = !(rotated ^ name === 'valueAxis') ? 'horizontalAxis' : 'verticalAxis';
    const processedUserOptions = processAxisOptions(userOptions);
    const commonAxisSettings = processAxisOptions(this._userOptions['commonAxisSettings']);
    const mergeOptions = (0, _extend.extend)(true, {}, theme.commonAxisSettings, theme[position], theme[name], commonAxisSettings, processedUserOptions);
    mergeOptions.workWeek = processedUserOptions.workWeek || theme[name].workWeek;
    mergeOptions.forceUserTickInterval |= (0, _type.isDefined)(processedUserOptions.tickInterval) && !(0, _type.isDefined)(processedUserOptions.axisDivisionFactor);
    return mergeOptions;
  };
  const mergeOptions = function (name, userOptions) {
    userOptions = userOptions || this._userOptions[name];
    const theme = this._theme[name];
    let result = this._mergedSettings[name];
    if (result) {
      return result;
    }
    if ((0, _type.isPlainObject)(theme) && (0, _type.isPlainObject)(userOptions)) {
      result = (0, _extend.extend)(true, {}, theme, userOptions);
    } else {
      result = (0, _type.isDefined)(userOptions) ? userOptions : theme;
    }
    this._mergedSettings[name] = result;
    return result;
  };
  const applyParticularTheme = {
    base: mergeOptions,
    argumentAxis: applyParticularAxisOptions,
    valueAxisRangeSelector: function () {
      return mergeOptions.call(this, 'valueAxis');
    },
    valueAxis: applyParticularAxisOptions,
    series: function (name, userOptions, seriesCount) {
      const that = this;
      const theme = that._theme;
      let userCommonSettings = that._userOptions.commonSeriesSettings || {};
      const themeCommonSettings = theme.commonSeriesSettings;
      const widgetType = that._themeSection.split('.').slice(-1)[0];
      const type = (0, _utils.normalizeEnum)(userOptions.type || userCommonSettings.type || themeCommonSettings.type || widgetType === 'pie' && theme.type); // userCommonSettings.type && themeCommonSettings.type deprecated in 15.2 in pie
      const palette = that.palette;
      const isBar = ~type.indexOf('bar');
      const isLine = ~type.indexOf('line');
      const isArea = ~type.indexOf('area');
      const isBubble = type === 'bubble';
      let mainSeriesColor;
      const resolveLabelsOverlapping = that.getOptions('resolveLabelsOverlapping');
      const containerBackgroundColor = that.getOptions('containerBackgroundColor');
      const seriesTemplate = applyParticularTheme.seriesTemplate.call(this);
      let seriesVisibility;
      if (isBar || isBubble) {
        userOptions = (0, _extend.extend)(true, {}, userCommonSettings, userCommonSettings[type], userOptions);
        seriesVisibility = userOptions.visible;
        userCommonSettings = {
          type: {}
        };
        (0, _extend.extend)(true, userOptions, userOptions.point);
        userOptions.visible = seriesVisibility;
      }
      const settings = (0, _extend.extend)(true, {
        aggregation: {}
      }, themeCommonSettings, themeCommonSettings[type], userCommonSettings, userCommonSettings[type], userOptions);
      settings.aggregation.enabled = widgetType === 'chart' && !!settings.aggregation.enabled;
      settings.type = type;
      settings.widgetType = widgetType;
      settings.containerBackgroundColor = containerBackgroundColor;
      if (widgetType !== 'pie') {
        mainSeriesColor = (0, _utils.extractColor)(settings.color, true) || palette.getNextColor(seriesCount);
      } else {
        mainSeriesColor = function (argument, index, count) {
          const cat = `${argument}-${index}`;
          if (!that._multiPieColors[cat]) {
            that._multiPieColors[cat] = palette.getNextColor(count);
          }
          return that._multiPieColors[cat];
        };
      }
      settings.mainSeriesColor = mainSeriesColor;
      settings.resolveLabelsOverlapping = resolveLabelsOverlapping;
      if (settings.label && (isLine || isArea && type !== 'rangearea' || type === 'scatter')) {
        settings.label.position = 'outside';
      }
      if (seriesTemplate) {
        settings.nameField = seriesTemplate.nameField;
      }
      return settings;
    },
    animation: function (name) {
      let userOptions = this._userOptions[name];
      userOptions = (0, _type.isPlainObject)(userOptions) ? userOptions : (0, _type.isDefined)(userOptions) ? {
        enabled: !!userOptions
      } : {};
      return mergeOptions.call(this, name, userOptions);
    },
    seriesTemplate() {
      const value = mergeOptions.call(this, 'seriesTemplate');
      if (value) {
        value.nameField = value.nameField || 'series';
      }
      return value;
    },
    zoomAndPan() {
      function parseOption(option) {
        option = (0, _utils.normalizeEnum)(option);
        const pan = option === 'pan' || option === 'both';
        const zoom = option === 'zoom' || option === 'both';
        return {
          pan: pan,
          zoom: zoom,
          none: !pan && !zoom
        };
      }
      const options = mergeOptions.call(this, 'zoomAndPan');
      return {
        valueAxis: parseOption(options.valueAxis),
        argumentAxis: parseOption(options.argumentAxis),
        dragToZoom: !!options.dragToZoom,
        dragBoxStyle: {
          class: 'dxc-shutter',
          fill: options.dragBoxStyle.color,
          opacity: options.dragBoxStyle.opacity
        },
        panKey: options.panKey,
        allowMouseWheel: !!options.allowMouseWheel,
        allowTouchGestures: !!options.allowTouchGestures
      };
    }
  };
  return {
    _themeSection: 'chart',
    ctor: ctor,
    dispose: dispose,
    resetPalette: resetPalette,
    getOptions: function (name) {
      return (applyParticularTheme[name] || applyParticularTheme.base).apply(this, arguments);
    },
    refresh: function () {
      this._mergedSettings = {};
      return this.callBase.apply(this, arguments);
    },
    _initializeTheme: function () {
      const that = this;
      that.callBase.apply(that, arguments);
      that.updatePalette();
    },
    resetOptions: function (name) {
      this._mergedSettings[name] = null;
    },
    update: function (options) {
      this._userOptions = options;
    },
    updatePalette: function () {
      const that = this;
      that.palette = that.createPalette(that.getOptions('palette'), {
        useHighlight: true,
        extensionMode: that.getOptions('paletteExtensionMode')
      });
    }
  };
}());

/***/ }),

/***/ 32410:
/***/ (function(module, exports) {



exports["default"] = void 0;
var _default = exports["default"] = {
  events: {
    'mouseover': 'mouseover',
    'mouseout': 'mouseout',
    'mousemove': 'mousemove',
    'touchstart': 'touchstart',
    'touchmove': 'touchmove',
    'touchend': 'touchend',
    'mousedown': 'mousedown',
    'mouseup': 'mouseup',
    click: 'click',
    selectSeries: 'selectseries',
    deselectSeries: 'deselectseries',
    selectPoint: 'selectpoint',
    deselectPoint: 'deselectpoint',
    showPointTooltip: 'showpointtooltip',
    hidePointTooltip: 'hidepointtooltip'
  },
  states: {
    hover: 'hover',
    normal: 'normal',
    selection: 'selection',
    normalMark: 0,
    hoverMark: 1,
    selectedMark: 2,
    applyHover: 'applyHover',
    applySelected: 'applySelected',
    resetItem: 'resetItem'
  },
  radialLabelIndent: 30,
  pieLabelSpacing: 10,
  pieSeriesSpacing: 4
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 45865:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.validateData = validateData;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _parse_utils = __webpack_require__(8587);
const STRING = 'string';
const NUMERIC = 'numeric';
const DATETIME = 'datetime';
const DISCRETE = 'discrete';
const SEMIDISCRETE = 'semidiscrete';
const CONTINUOUS = 'continuous';
const LOGARITHMIC = 'logarithmic';
const VALUE_TYPE = 'valueType';
const ARGUMENT_TYPE = 'argumentType';
const axisTypeParser = (0, _utils.enumParser)([STRING, NUMERIC, DATETIME]);
const _isArray = Array.isArray;
function groupingValues(data, others, valueField, index) {
  if (index >= 0) {
    data.slice(index).forEach(function (cell) {
      if ((0, _type.isDefined)(cell[valueField])) {
        others[valueField] += cell[valueField];
        cell[valueField] = undefined;
      }
    });
  }
}
function processGroups(groups) {
  groups.forEach(function (group) {
    group.valueType = group.valueAxisType = null;
    group.series.forEach(function (series) {
      series.updateDataType({});
    });
    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);
  });
}
function sortValues(data, asc, selector) {
  const func = asc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  };
  data.sort(function (a, b) {
    const valA = selector(a);
    const valB = selector(b);
    const aa = (0, _type.isDefined)(valA) ? 1 : 0;
    const bb = (0, _type.isDefined)(valB) ? 1 : 0;
    return aa && bb ? func(valA, valB) : func(aa, bb);
  });
  return data;
}
function resetArgumentAxes(axes) {
  axes && axes.forEach(function (axis) {
    axis.resetTypes(ARGUMENT_TYPE);
  });
}
function parseCategories(categories, parser) {
  const newArray = [];
  categories.forEach(function (category) {
    const parsedCategory = parser(category);
    parsedCategory !== undefined && newArray.push(parsedCategory);
  });
  return newArray;
}
function parseAxisCategories(groupsData, parsers) {
  const argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;
  groupsData.groups.forEach(function (valueGroup, i) {
    const categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;
    if (categories) {
      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);
    }
  });
  if (argumentCategories) {
    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);
  }
}
function eigen(x) {
  return x;
}
function getType(unit, type) {
  let result = type;
  if (type === STRING || (0, _type.isString)(unit)) {
    result = STRING;
  } else if (type === DATETIME || (0, _type.isDate)(unit)) {
    result = DATETIME;
  } else if ((0, _type.isNumeric)(unit)) {
    result = NUMERIC;
  }
  return result;
}
function correctAxisType(type, axisType, hasCategories, incidentOccurred) {
  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {
    incidentOccurred('E2002');
  }
  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;
}

// Do we really need this one if all it is only for logarithmic case?
function validUnit(unit, field, incidentOccurred) {
  if (unit) {
    incidentOccurred(!(0, _type.isNumeric)(unit) && !(0, _type.isDate)(unit) && !(0, _type.isString)(unit) ? 'E2003' : 'E2004', [field]);
  }
}
function createParserUnit(type, axisType, incidentOccurred) {
  const parser = type ? (0, _parse_utils.getParser)(type) : eigen;
  const filterInfinity = axisType !== DISCRETE ? function (x) {
    return isFinite(x) || x === undefined ? x : null;
  } : eigen;
  return function (unit, field) {
    const parseUnit = filterInfinity(parser(unit));
    if (parseUnit === undefined) {
      validUnit(unit, field, incidentOccurred);
    }
    return parseUnit;
  };
}
function prepareParsers(groupsData, incidentOccurred) {
  const argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);
  let sizeParser;
  let valueParser;
  const categoryParsers = [argumentParser];
  const cache = {};
  const list = [];
  groupsData.groups.forEach(function (group, groupIndex) {
    group.series.forEach(function (series) {
      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);
      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);
      cache[series.getArgumentField()] = argumentParser;
      series.getValueFields().forEach(function (field) {
        categoryParsers[groupIndex + 1] = valueParser;
        cache[field] = valueParser;
      });
      if (series.getSizeField()) {
        cache[series.getSizeField()] = sizeParser;
      }
    });
  });
  for (const field in cache) {
    list.push([field, cache[field]]);
  }
  list.length && parseAxisCategories(groupsData, categoryParsers);
  return list;
}
function getParsedCell(cell, parsers) {
  let i;
  const ii = parsers.length;
  const obj = (0, _extend.extend)({}, cell);
  let field;
  let value;
  for (i = 0; i < ii; ++i) {
    field = parsers[i][0];
    value = cell[field];
    obj[field] = parsers[i][1](value, field);
  }
  return obj;
}
function parse(data, parsers) {
  const parsedData = [];
  let i;
  const ii = data.length;
  parsedData.length = ii;
  for (i = 0; i < ii; ++i) {
    parsedData[i] = getParsedCell(data[i], parsers);
  }
  return parsedData;
}
function findIndexByThreshold(data, valueField, threshold) {
  let i;
  const ii = data.length;
  let value;
  for (i = 0; i < ii; ++i) {
    value = data[i][valueField];
    if ((0, _type.isDefined)(value) && threshold > value) {
      break;
    }
  }
  return i;
}
function groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {
  smallValuesGrouping = smallValuesGrouping || {};
  const mode = smallValuesGrouping.mode;
  const others = {};
  if (!mode || mode === 'none') {
    return;
  }
  others[argumentField] = String(smallValuesGrouping.groupName || 'others');
  others[valueField] = 0;
  const data = sortValues(originalData.slice(), false, function (a) {
    return a[valueField];
  });
  groupingValues(data, others, valueField, mode === 'smallValueThreshold' ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);
  others[valueField] && originalData.push(others);
}
function groupPieData(data, groupsData) {
  const firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];
  const isPie = firstSeries && (firstSeries.type === 'pie' || firstSeries.type === 'doughnut' || firstSeries.type === 'donut');
  if (!isPie) {
    return;
  }
  groupsData.groups.forEach(function (group) {
    group.series.forEach(function (series) {
      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);
    });
  });
}
function addUniqueItemToCollection(item, collection, itemsHash) {
  if (!itemsHash[item]) {
    collection.push(item);
    itemsHash[item] = true;
  }
}
function getUniqueArgumentFields(groupsData) {
  const uniqueArgumentFields = [];
  const hash = {};
  groupsData.groups.forEach(function (group) {
    group.series.forEach(function (series) {
      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);
    });
  });
  return uniqueArgumentFields;
}
function sort(a, b) {
  const result = a - b;
  if (isNaN(result)) {
    if (!(0, _type.isDefined)(a)) {
      return 1;
    }
    if (!(0, _type.isDefined)(b)) {
      return -1;
    }
    return 0;
  }
  return result;
}
function sortByArgument(data, argumentField) {
  return data.slice().sort(function (a, b) {
    return sort(a[argumentField], b[argumentField]);
  });
}
function sortByCallback(data, callback) {
  return data.slice().sort(callback);
}
function checkValueTypeOfGroup(group, cell) {
  group.series.forEach(function (series) {
    series.getValueFields().forEach(function (field) {
      group.valueType = getType(cell[field], group.valueType);
    });
  });
  return group.valueType;
}
function getSortByCategories(categories) {
  const hash = {};
  categories.forEach(function (value, i) {
    hash[value] = i;
  });
  return function (data, argumentField) {
    return sortValues(data.slice(), true, function (a) {
      return hash[a[argumentField]];
    });
  };
}
function sortData(data, groupsData, options, uniqueArgumentFields) {
  const dataByArguments = {};
  const isDiscrete = groupsData.argumentAxisType === DISCRETE;
  const userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;
  let sortFunction = function (data) {
    return data;
  };
  const sortingMethodOption = options.sortingMethod;
  let reSortCategories;
  if (!userCategories && (0, _type.isFunction)(sortingMethodOption)) {
    data = sortByCallback(data, sortingMethodOption);
  }
  if (isDiscrete) {
    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);
  }
  if (userCategories || !(0, _type.isFunction)(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {
    sortFunction = getSortByCategories(groupsData.categories);
  } else if (sortingMethodOption === true && groupsData.argumentType !== STRING) {
    sortFunction = sortByArgument;
    reSortCategories = isDiscrete;
  }
  uniqueArgumentFields.forEach(function (field) {
    dataByArguments[field] = sortFunction(data, field);
  });
  if (reSortCategories) {
    groupsData.categories = groupsData.categories.sort(sort);
  }
  return dataByArguments;
}
function checkItemExistence(collection, item) {
  return collection.map(function (collectionItem) {
    return collectionItem.valueOf();
  }).indexOf(item.valueOf()) === -1;
}
function getCategories(data, uniqueArgumentFields, userCategories) {
  const categories = userCategories ? userCategories.slice() : [];
  uniqueArgumentFields.forEach(function (field) {
    data.forEach(function (item) {
      const dataItem = item[field];
      (0, _type.isDefined)(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);
    });
  });
  return categories;
}
function checkArgumentTypeOfGroup(series, cell, groupsData) {
  series.forEach(function (currentSeries) {
    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);
  });
  return groupsData.argumentType;
}
function checkType(data, groupsData, checkTypeForAllData) {
  const groupsWithUndefinedValueType = [];
  const groupsWithUndefinedArgumentType = [];
  const argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);
  let groupsIndexes;
  groupsData.groups.forEach(function (group) {
    if (!group.series.length) {
      return;
    }
    const valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);
    group.valueType = valueTypeGroup;
    groupsData.argumentType = argumentTypeGroup;
    !valueTypeGroup && groupsWithUndefinedValueType.push(group);
    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);
  });
  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {
    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {
      return index;
    });
    data.some(function (cell) {
      let defineArg;
      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {
        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {
          groupsIndexes.splice(groupIndex, 1);
        }
      });
      if (!defineArg) {
        groupsWithUndefinedArgumentType.forEach(function (group) {
          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);
        });
      }
      if (!checkTypeForAllData && defineArg && groupsIndexes.length === 0) {
        return true;
      }
    });
  }
}
function checkAxisType(groupsData, incidentOccurred) {
  const argumentOptions = groupsData.argumentOptions || {};
  const userArgumentCategories = argumentOptions && argumentOptions.categories || [];
  const argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);
  groupsData.groups.forEach(function (group) {
    const valueOptions = group.valueOptions || {};
    const valueCategories = valueOptions.categories || [];
    const valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);
    group.series.forEach(function (series) {
      const optionsSeries = {};
      optionsSeries.argumentAxisType = argumentAxisType;
      optionsSeries.valueAxisType = valueAxisType;
      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;
      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;
      optionsSeries.argumentType = groupsData.argumentType;
      optionsSeries.valueType = group.valueType;
      optionsSeries.showZero = valueOptions.showZero;
      series.updateDataType(optionsSeries);
    });
    group.valueAxisType = group.valueAxisType || valueAxisType;
    if (group.valueAxis) {
      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);
      group.valueAxis.validate();
    }
  });
  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;
  if (groupsData.argumentAxes) {
    groupsData.argumentAxes.forEach(function (axis) {
      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);
      axis.validate();
    });
  }
}
function verifyData(source, incidentOccurred) {
  const data = [];
  const sourceIsDefined = (0, _type.isDefined)(source);
  let hasError = sourceIsDefined && !_isArray(source);
  let i;
  let ii;
  let k;
  let item;
  if (sourceIsDefined && !hasError) {
    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {
      item = source[i];
      if ((0, _type.isObject)(item)) {
        data[k++] = item;
      } else if (item) {
        // TODO: And what about `null`, `undefined` and `0`?
        hasError = true;
      }
    }
  }
  if (hasError) {
    incidentOccurred('E2001');
  }
  return data;
}
function validateData(data, groupsData, incidentOccurred, options) {
  data = verifyData(data, incidentOccurred);
  groupsData.argumentType = groupsData.argumentAxisType = null;
  processGroups(groupsData.groups);
  resetArgumentAxes(groupsData.argumentAxes);
  checkType(data, groupsData, options.checkTypeForAllData);
  checkAxisType(groupsData, incidentOccurred);
  if (options.convertToAxisDataType) {
    data = parse(data, prepareParsers(groupsData, incidentOccurred));
  }
  groupPieData(data, groupsData);
  const dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));
  return dataByArgumentFields;
}

/***/ }),

/***/ 16342:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.Legend = void 0;
var _utils = __webpack_require__(19157);
var _extend2 = __webpack_require__(13306);
var _layout_element = __webpack_require__(73711);
var _type = __webpack_require__(35922);
var _title = __webpack_require__(17384);
var _object = __webpack_require__(48013);
var _common = __webpack_require__(20576);
var _renderer = __webpack_require__(56453);
var _deferred = __webpack_require__(62754);
const _Number = Number;
const _math = Math;
const _round = _math.round;
const _max = _math.max;
const _min = _math.min;
const _ceil = _math.ceil;
const _isDefined = _type.isDefined;
const _isFunction = _type.isFunction;
const _enumParser = _utils.enumParser;
const _normalizeEnum = _utils.normalizeEnum;
const _extend = _extend2.extend;
const DEFAULT_MARGIN = 10;
const DEFAULT_MARKER_HATCHING_WIDTH = 2;
const DEFAULT_MARKER_HATCHING_STEP = 5;
const CENTER = 'center';
const RIGHT = 'right';
const LEFT = 'left';
const TOP = 'top';
const BOTTOM = 'bottom';
const HORIZONTAL = 'horizontal';
const VERTICAL = 'vertical';
const INSIDE = 'inside';
const OUTSIDE = 'outside';
const NONE = 'none';
const HEIGHT = 'height';
const WIDTH = 'width';
const parseHorizontalAlignment = _enumParser([LEFT, CENTER, RIGHT]);
const parseVerticalAlignment = _enumParser([TOP, BOTTOM]);
const parseOrientation = _enumParser([VERTICAL, HORIZONTAL]);
const parseItemTextPosition = _enumParser([LEFT, RIGHT, TOP, BOTTOM]);
const parsePosition = _enumParser([OUTSIDE, INSIDE]);
const parseItemsAlignment = _enumParser([LEFT, CENTER, RIGHT]);
function getState(state, color, stateName) {
  if (!state) {
    return;
  }
  const colorFromAction = state.fill;
  return (0, _extend2.extend)({}, {
    state: stateName,
    fill: colorFromAction === NONE ? color : colorFromAction,
    opacity: state.opacity,
    filter: state.filter,
    hatching: _extend({}, state.hatching, {
      step: DEFAULT_MARKER_HATCHING_STEP,
      width: DEFAULT_MARKER_HATCHING_WIDTH
    })
  });
}
function getAttributes(item, state, size) {
  const attrs = (0, _renderer.processHatchingAttrs)(item, state);
  if (attrs.fill && attrs.fill.indexOf('DevExpress') === 0) {
    attrs.fill = (0, _renderer.getFuncIri)(attrs.fill);
  }
  attrs.opacity = attrs.opacity >= 0 ? attrs.opacity : 1;
  return (0, _extend2.extend)({}, attrs, {
    size
  });
}
function parseMargins(options) {
  let margin = options.margin;
  if (margin >= 0) {
    margin = _Number(options.margin);
    margin = {
      top: margin,
      bottom: margin,
      left: margin,
      right: margin
    };
  } else {
    margin = {
      top: margin.top >= 0 ? _Number(margin.top) : DEFAULT_MARGIN,
      bottom: margin.bottom >= 0 ? _Number(margin.bottom) : DEFAULT_MARGIN,
      left: margin.left >= 0 ? _Number(margin.left) : DEFAULT_MARGIN,
      right: margin.right >= 0 ? _Number(margin.right) : DEFAULT_MARGIN
    };
  }
  options.margin = margin;
}
function getSizeItem(options, markerBBox, labelBBox) {
  const defaultXMargin = 7;
  const defaultTopMargin = 4;
  let width;
  let height;
  switch (options.itemTextPosition) {
    case LEFT:
    case RIGHT:
      width = markerBBox.width + defaultXMargin + labelBBox.width;
      height = _max(markerBBox.height, labelBBox.height);
      break;
    case TOP:
    case BOTTOM:
      width = _max(markerBBox.width, labelBBox.width);
      height = markerBBox.height + defaultTopMargin + labelBBox.height;
      break;
  }
  return {
    width: width,
    height: height
  };
}
function calculateBBoxLabelAndMarker(markerBBox, labelBBox) {
  const bBox = {};
  bBox.left = _min(markerBBox.x, labelBBox.x);
  bBox.top = _min(markerBBox.y, labelBBox.y);
  bBox.right = _max(markerBBox.x + markerBBox.width, labelBBox.x + labelBBox.width);
  bBox.bottom = _max(markerBBox.y + markerBBox.height, labelBBox.y + labelBBox.height);
  return bBox;
}
function applyMarkerState(id, idToIndexMap, items, stateName) {
  const item = idToIndexMap && items[idToIndexMap[id]];
  if (item) {
    item.renderMarker(item.states[stateName]);
  }
}
function parseOptions(options, textField, allowInsidePosition) {
  if (!options) return null;
  parseMargins(options);
  options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, RIGHT);
  options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, options.horizontalAlignment === CENTER ? BOTTOM : TOP);
  options.orientation = parseOrientation(options.orientation, options.horizontalAlignment === CENTER ? HORIZONTAL : VERTICAL);
  options.itemTextPosition = parseItemTextPosition(options.itemTextPosition, options.orientation === HORIZONTAL ? BOTTOM : RIGHT);
  options.position = allowInsidePosition ? parsePosition(options.position, OUTSIDE) : OUTSIDE;
  options.itemsAlignment = parseItemsAlignment(options.itemsAlignment, null);
  options.hoverMode = _normalizeEnum(options.hoverMode);
  options.customizeText = _isFunction(options.customizeText) ? options.customizeText : function () {
    return this[textField];
  };
  options.customizeHint = _isFunction(options.customizeHint) ? options.customizeHint : _common.noop;
  options._incidentOccurred = options._incidentOccurred || _common.noop;
  return options;
}
function createSquareMarker(renderer, size) {
  return renderer.rect(0, 0, size, size);
}
function createCircleMarker(renderer, size) {
  return renderer.circle(size / 2, size / 2, size / 2);
}
function isCircle(type) {
  return _normalizeEnum(type) === 'circle';
}
function inRect(rect, x, y) {
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}
function checkLinesSize(lines, layoutOptions, countItems, margins) {
  const position = {
    x: 0,
    y: 0
  };
  let maxMeasureLength = 0;
  let maxAltMeasureLength = 0;
  let margin = 0;
  if (layoutOptions.direction === 'y') {
    margin = margins.top + margins.bottom;
  } else {
    margin = margins.left + margins.right;
  }
  lines.forEach(function (line, i) {
    const firstItem = line[0];
    const lineLength = line.length;
    line.forEach(function (item, index) {
      const offset = item.offset || layoutOptions.spacing;
      position[layoutOptions.direction] += item[layoutOptions.measure] + (index !== lineLength - 1 ? offset : 0);
      maxMeasureLength = _max(maxMeasureLength, position[layoutOptions.direction]);
    });
    position[layoutOptions.direction] = 0;
    position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + firstItem.altOffset || layoutOptions.altSpacing;
    maxAltMeasureLength = _max(maxAltMeasureLength, position[layoutOptions.altDirection]);
  });
  if (maxMeasureLength + margin > layoutOptions.length) {
    layoutOptions.countItem = decreaseItemCount(layoutOptions, countItems);
    return true;
  }
}
function decreaseItemCount(layoutOptions, countItems) {
  layoutOptions.altCountItem++;
  return _ceil(countItems / layoutOptions.altCountItem);
}
function getLineLength(line, layoutOptions) {
  return line.reduce((lineLength, item) => {
    const offset = item.offset || layoutOptions.spacing;
    return lineLength + item[layoutOptions.measure] + offset;
  }, 0);
}
function getMaxLineLength(lines, layoutOptions) {
  return lines.reduce((maxLineLength, line) => {
    return _max(maxLineLength, getLineLength(line, layoutOptions));
  }, 0);
}
function getInitPositionForDirection(line, layoutOptions, maxLineLength) {
  const lineLength = getLineLength(line, layoutOptions);
  let initPosition;
  switch (layoutOptions.itemsAlignment) {
    case RIGHT:
      initPosition = maxLineLength - lineLength;
      break;
    case CENTER:
      initPosition = (maxLineLength - lineLength) / 2;
      break;
    default:
      initPosition = 0;
  }
  return initPosition;
}
function getPos(layoutOptions) {
  switch (layoutOptions.itemTextPosition) {
    case BOTTOM:
      return {
        horizontal: CENTER,
        vertical: TOP
      };
    case TOP:
      return {
        horizontal: CENTER,
        vertical: BOTTOM
      };
    case LEFT:
      return {
        horizontal: RIGHT,
        vertical: CENTER
      };
    case RIGHT:
      return {
        horizontal: LEFT,
        vertical: CENTER
      };
  }
}
function getLines(lines, layoutOptions, itemIndex) {
  const tableLine = {};
  if (itemIndex % layoutOptions.countItem === 0) {
    if (layoutOptions.markerOffset) {
      lines.push([], []);
    } else {
      lines.push([]);
    }
  }
  if (layoutOptions.markerOffset) {
    tableLine.firstLine = lines[lines.length - 1];
    tableLine.secondLine = lines[lines.length - 2];
  } else {
    tableLine.firstLine = tableLine.secondLine = lines[lines.length - 1];
  }
  return tableLine;
}
function setMaxInLine(line, measure) {
  const maxLineSize = line.reduce((maxLineSize, item) => {
    const itemMeasure = item ? item[measure] : maxLineSize;
    return _max(maxLineSize, itemMeasure);
  }, 0);
  line.forEach(item => {
    if (item) {
      item[measure] = maxLineSize;
    }
  });
}
function transpose(array) {
  const width = array.length;
  const height = array[0].length;
  let i;
  let j;
  const transposeArray = [];
  for (i = 0; i < height; i++) {
    transposeArray[i] = [];
    for (j = 0; j < width; j++) {
      transposeArray[i][j] = array[j][i];
    }
  }
  return transposeArray;
}
function getAlign(position) {
  switch (position) {
    case TOP:
    case BOTTOM:
      return CENTER;
    case LEFT:
      return RIGHT;
    case RIGHT:
      return LEFT;
  }
}
let getMarkerCreator = function (type) {
  return isCircle(type) ? createCircleMarker : createSquareMarker;
};
function getTitleHorizontalAlignment(options) {
  if (options.horizontalAlignment === CENTER) {
    return CENTER;
  } else {
    if (options.itemTextPosition === RIGHT) {
      return LEFT;
    } else if (options.itemTextPosition === LEFT) {
      return RIGHT;
    } else {
      return CENTER;
    }
  }
}
let Legend = function (settings) {
  const that = this;
  that._renderer = settings.renderer;
  that._legendGroup = settings.group;
  that._backgroundClass = settings.backgroundClass;
  that._itemGroupClass = settings.itemGroupClass;
  that._textField = settings.textField;
  that._getCustomizeObject = settings.getFormatObject;
  that._titleGroupClass = settings.titleGroupClass;
  that._allowInsidePosition = settings.allowInsidePosition;
  that._widget = settings.widget;
  that._updated = false;
};
exports.Legend = Legend;
const _Legend = Legend;
const legendPrototype = _Legend.prototype = (0, _object.clone)(_layout_element.LayoutElement.prototype);
(0, _extend2.extend)(legendPrototype, {
  constructor: _Legend,
  getOptions: function () {
    return this._options;
  },
  update: function () {
    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let options = arguments.length > 1 ? arguments[1] : undefined;
    let themeManagerTitleOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const that = this;
    options = that._options = parseOptions(options, that._textField, that._allowInsidePosition) || {};
    const initMarkerSize = options.markerSize;
    this._updated = true;
    this._data = data.map(dataItem => {
      dataItem.size = _Number(dataItem.size > 0 ? dataItem.size : initMarkerSize);
      dataItem.marker = getAttributes(dataItem, dataItem.states.normal);
      Object.defineProperty(dataItem.marker, 'size', {
        get() {
          return dataItem.size;
        },
        set(value) {
          dataItem.size = value;
        }
      });
      Object.defineProperty(dataItem.marker, 'opacity', {
        get() {
          return dataItem.states.normal.opacity;
        },
        set(value) {
          dataItem.states.normal.opacity = dataItem.states.hover.opacity = dataItem.states.selection.opacity = value;
        }
      });
      return dataItem;
    });
    if (options.customizeItems) {
      that._data = options.customizeItems(data.slice()) || data;
    }
    that._boundingRect = {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    if (that.isVisible()) {
      var _that$_title;
      (_that$_title = that._title) === null || _that$_title === void 0 || _that$_title.dispose();
      that._title = new _title.Title({
        renderer: that._renderer,
        cssClass: that._titleGroupClass,
        root: that._legendGroup
      });
    }
    if (that._title) {
      const titleOptions = options.title;
      themeManagerTitleOptions.horizontalAlignment = getTitleHorizontalAlignment(options);
      that._title.update(themeManagerTitleOptions, titleOptions);
    }
    this.erase();
    return that;
  },
  isVisible: function () {
    return this._options && this._options.visible;
  },
  draw: function (width, height) {
    // TODO check multiple groups creation
    const that = this;
    const items = that._getItemData();
    that.erase();
    if (!(that.isVisible() && items && items.length)) {
      return that;
    }
    that._insideLegendGroup = that._renderer.g().enableLinks().append(that._legendGroup);
    that._title.changeLink(that._insideLegendGroup);
    that._createBackground();
    if (that._title.hasText()) {
      const horizontalPadding = that._background ? 2 * that._options.paddingLeftRight : 0;
      that._title.draw(width - horizontalPadding, height);
    }

    // TODO review pass or process states in legend
    that._markersGroup = that._renderer.g().attr({
      class: that._itemGroupClass
    }).append(that._insideLegendGroup);
    that._createItems(items);
    that._updateElementsPosition(width, height);
    return that;
  },
  _measureElements: function () {
    const options = this._options;
    let maxBBoxHeight = 0;
    this._items.forEach(item => {
      const labelBBox = item.label.getBBox();
      const markerBBox = item.marker.getBBox();
      item.markerBBox = markerBBox;
      item.markerSize = Math.max(markerBBox.width, markerBBox.height);
      const bBox = getSizeItem(options, markerBBox, labelBBox);
      item.labelBBox = labelBBox;
      item.bBox = bBox;
      maxBBoxHeight = _max(maxBBoxHeight, bBox.height);
    });
    if (options.equalRowHeight) {
      this._items.forEach(item => item.bBox.height = maxBBoxHeight);
    }
  },
  _updateElementsPosition: function (width, height) {
    const that = this;
    const options = that._options;
    this._size = {
      width: width,
      height: height
    };
    that._measureElements();
    that._locateElements(options);
    that._finalUpdate(options);
    const size = that.getLayoutOptions();
    if (size.width > width || size.height > height) {
      that.freeSpace();
    }
  },
  _createItems: function (items) {
    const that = this;
    const options = that._options;
    const renderer = that._renderer;
    const createMarker = getMarkerCreator(options.markerShape);
    that._markersId = {};
    const templateFunction = !options.markerTemplate ? (dataItem, group) => {
      const attrs = dataItem.marker;
      createMarker(renderer, attrs.size).attr({
        fill: attrs.fill,
        opacity: attrs.opacity,
        filter: attrs.filter
      }).append({
        element: group
      });
    } : options.markerTemplate;
    const template = that._widget._getTemplate(templateFunction);
    const markersGroup = that._markersGroup;
    markersGroup.css((0, _utils.patchFontOptions)(options.font));
    that._deferredItems = [];
    that._templatesGroups = [];
    that._items = (items || []).map((dataItem, i) => {
      const stateOfDataItem = dataItem.states;
      const normalState = stateOfDataItem.normal;
      const normalStateFill = normalState.fill;
      dataItem.size = dataItem.marker.size;
      const states = {
        normal: (0, _extend2.extend)(normalState, {
          fill: normalStateFill || options.markerColor || options.defaultColor,
          state: 'normal'
        }),
        hover: getState(stateOfDataItem.hover, normalStateFill, 'hovered'),
        selection: getState(stateOfDataItem.selection, normalStateFill, 'selected')
      };
      dataItem.states = states;
      const itemGroup = renderer.g().append(markersGroup);
      const markerGroup = renderer.g().attr({
        class: 'dxl-marker'
      }).append(itemGroup);
      that._deferredItems[i] = new _deferred.Deferred();
      that._templatesGroups.push(markerGroup);
      const item = {
        label: that._createLabel(dataItem, itemGroup),
        marker: markerGroup,
        renderer,
        group: itemGroup,
        tracker: {
          id: dataItem.id,
          argument: dataItem.argument,
          argumentIndex: dataItem.argumentIndex
        },
        states: states,
        itemTextPosition: options.itemTextPosition,
        markerOffset: 0,
        bBoxes: [],
        renderMarker(state) {
          dataItem.marker = getAttributes(item, state, dataItem.size);
          markerGroup.clear();
          template.render({
            model: dataItem,
            container: markerGroup.element,
            onRendered: that._deferredItems[i].resolve
          });
        }
      };
      item.renderMarker(states.normal);
      that._createHint(dataItem, itemGroup);
      if (dataItem.id !== undefined) {
        that._markersId[dataItem.id] = i;
      }
      return item;
    });
  },
  getTemplatesGroups: function () {
    return this._templatesGroups || [];
  },
  getTemplatesDef: function () {
    return this._deferredItems || [];
  },
  _getItemData: function () {
    let items = this._data || [];
    const options = this._options || {};
    // For maps in dashboards
    if (options.inverted) {
      items = items.slice().reverse();
    }
    return items.filter(i => i.visible);
  },
  _finalUpdate: function (options) {
    this._adjustBackgroundSettings(options);
    this._setBoundingRect(options.margin);
  },
  // The name is chosen to be opposite for `draw`
  erase: function () {
    const that = this;
    const insideLegendGroup = that._insideLegendGroup;
    insideLegendGroup && insideLegendGroup.dispose();
    that._insideLegendGroup = that._markersGroup = that._x1 = that._x2 = that._y2 = that._y2 = null;
    return that;
  },
  _locateElements: function (locationOptions) {
    this._moveInInitialValues();
    this._locateRowsColumns(locationOptions);
  },
  _moveInInitialValues: function () {
    const that = this;
    that._title.hasText() && that._title.move([0, 0]);
    that._legendGroup && that._legendGroup.move(0, 0);
    that._background && that._background.attr({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
  },
  applySelected: function (id) {
    applyMarkerState(id, this._markersId, this._items, 'selection');
    return this;
  },
  applyHover: function (id) {
    applyMarkerState(id, this._markersId, this._items, 'hover');
    return this;
  },
  resetItem: function (id) {
    applyMarkerState(id, this._markersId, this._items, 'normal');
    return this;
  },
  _createLabel: function (data, group) {
    const labelFormatObject = this._getCustomizeObject(data);
    const options = this._options;
    const align = getAlign(options.itemTextPosition);
    const text = options.customizeText.call(labelFormatObject, labelFormatObject);
    const fontStyle = _isDefined(data.textOpacity) ? {
      color: options.font.color,
      opacity: data.textOpacity
    } : {};
    return this._renderer.text(text, 0, 0).css((0, _utils.patchFontOptions)(fontStyle)).attr({
      align: align,
      class: options.cssClass
    }).append(group);
  },
  _createHint: function (data, group) {
    const labelFormatObject = this._getCustomizeObject(data);
    const text = this._options.customizeHint.call(labelFormatObject, labelFormatObject);
    if (_isDefined(text) && text !== '') {
      group.setTitle(text);
    }
  },
  _createBackground: function () {
    const that = this;
    const isInside = that._options.position === INSIDE;
    const color = that._options.backgroundColor;
    const fill = color || (isInside ? that._options.containerBackgroundColor : NONE);
    if (that._options.border.visible || (isInside || color) && color !== NONE) {
      that._background = that._renderer.rect(0, 0, 0, 0).attr({
        fill: fill,
        class: that._backgroundClass
      }).append(that._insideLegendGroup);
    }
  },
  _locateRowsColumns: function (options) {
    const that = this;
    let iteration = 0;
    const layoutOptions = that._getItemsLayoutOptions();
    const countItems = that._items.length;
    let lines;
    do {
      lines = [];
      that._createLines(lines, layoutOptions);
      that._alignLines(lines, layoutOptions);
      iteration++;
    } while (checkLinesSize(lines, layoutOptions, countItems, options.margin) && iteration < countItems);
    that._applyItemPosition(lines, layoutOptions);
  },
  _createLines: function (lines, layoutOptions) {
    this._items.forEach((item, i) => {
      const tableLine = getLines(lines, layoutOptions, i);
      const labelBox = {
        width: item.labelBBox.width,
        height: item.labelBBox.height,
        element: item.label,
        bBox: item.labelBBox,
        pos: getPos(layoutOptions),
        itemIndex: i
      };
      const markerBox = {
        width: item.markerBBox.width,
        height: item.markerBBox.height,
        element: item.marker,
        pos: {
          horizontal: CENTER,
          vertical: CENTER
        },
        bBox: {
          width: item.markerBBox.width,
          height: item.markerBBox.height,
          x: item.markerBBox.x,
          y: item.markerBBox.y
        },
        itemIndex: i
      };
      let firstItem;
      let secondItem;
      const offsetDirection = layoutOptions.markerOffset ? 'altOffset' : 'offset';
      if (layoutOptions.inverseLabelPosition) {
        firstItem = labelBox;
        secondItem = markerBox;
      } else {
        firstItem = markerBox;
        secondItem = labelBox;
      }
      firstItem[offsetDirection] = layoutOptions.labelOffset;
      tableLine.secondLine.push(firstItem);
      tableLine.firstLine.push(secondItem);
    });
  },
  _alignLines: function (lines, layoutOptions) {
    let i;
    let measure = layoutOptions.altMeasure;
    lines.forEach(line => setMaxInLine(line, measure));
    measure = layoutOptions.measure;
    if (layoutOptions.itemsAlignment) {
      if (layoutOptions.markerOffset) {
        for (i = 0; i < lines.length;) {
          transpose([lines[i++], lines[i++]]).forEach(processLine);
        }
      }
    } else {
      transpose(lines).forEach(processLine);
    }
    function processLine(line) {
      setMaxInLine(line, measure);
    }
  },
  _applyItemPosition: function (lines, layoutOptions) {
    const that = this;
    const position = {
      x: 0,
      y: 0
    };
    const maxLineLength = getMaxLineLength(lines, layoutOptions);
    lines.forEach(line => {
      const firstItem = line[0];
      const altOffset = firstItem.altOffset || layoutOptions.altSpacing;
      position[layoutOptions.direction] = getInitPositionForDirection(line, layoutOptions, maxLineLength);
      line.forEach(item => {
        const offset = item.offset || layoutOptions.spacing;
        const wrap = new _layout_element.WrapperLayoutElement(item.element, item.bBox);
        const itemBBoxOptions = {
          x: position.x,
          y: position.y,
          width: item.width,
          height: item.height
        };
        const itemBBox = new _layout_element.WrapperLayoutElement(null, itemBBoxOptions);
        const itemLegend = that._items[item.itemIndex];
        wrap.position({
          of: itemBBox,
          my: item.pos,
          at: item.pos
        });
        itemLegend.bBoxes.push(itemBBox);
        position[layoutOptions.direction] += item[layoutOptions.measure] + offset;
      });
      position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + altOffset;
    });
    this._items.forEach(item => {
      const itemBBox = calculateBBoxLabelAndMarker(item.bBoxes[0].getLayoutOptions(), item.bBoxes[1].getLayoutOptions());
      const horizontal = that._options.columnItemSpacing / 2;
      const vertical = that._options.rowItemSpacing / 2;
      item.tracker.left = itemBBox.left - horizontal;
      item.tracker.right = itemBBox.right + horizontal;
      item.tracker.top = itemBBox.top - vertical;
      item.tracker.bottom = itemBBox.bottom + vertical;
    });
  },
  _getItemsLayoutOptions: function () {
    const that = this;
    const options = that._options;
    const orientation = options.orientation;
    const layoutOptions = {
      itemsAlignment: options.itemsAlignment,
      orientation: options.orientation
    };
    const width = that._size.width - (that._background ? 2 * options.paddingLeftRight : 0);
    const height = that._size.height - (that._background ? 2 * options.paddingTopBottom : 0);
    if (orientation === HORIZONTAL) {
      layoutOptions.length = width;
      layoutOptions.spacing = options.columnItemSpacing;
      layoutOptions.direction = 'x';
      layoutOptions.measure = WIDTH;
      layoutOptions.altMeasure = HEIGHT;
      layoutOptions.altDirection = 'y';
      layoutOptions.altSpacing = options.rowItemSpacing;
      layoutOptions.countItem = options.columnCount;
      layoutOptions.altCountItem = options.rowCount;
      layoutOptions.marginTextLabel = 4;
      layoutOptions.labelOffset = 7;
      if (options.itemTextPosition === BOTTOM || options.itemTextPosition === TOP) {
        layoutOptions.labelOffset = 4;
        layoutOptions.markerOffset = true;
      }
    } else {
      layoutOptions.length = height;
      layoutOptions.spacing = options.rowItemSpacing;
      layoutOptions.direction = 'y';
      layoutOptions.measure = HEIGHT;
      layoutOptions.altMeasure = WIDTH;
      layoutOptions.altDirection = 'x';
      layoutOptions.altSpacing = options.columnItemSpacing;
      layoutOptions.countItem = options.rowCount;
      layoutOptions.altCountItem = options.columnCount;
      layoutOptions.marginTextLabel = 7;
      layoutOptions.labelOffset = 4;
      if (options.itemTextPosition === RIGHT || options.itemTextPosition === LEFT) {
        layoutOptions.labelOffset = 7;
        layoutOptions.markerOffset = true;
      }
    }
    if (!layoutOptions.countItem) {
      if (layoutOptions.altCountItem) {
        layoutOptions.countItem = _ceil(that._items.length / layoutOptions.altCountItem);
      } else {
        layoutOptions.countItem = that._items.length;
      }
    }
    if (options.itemTextPosition === TOP || options.itemTextPosition === LEFT) {
      layoutOptions.inverseLabelPosition = true;
    }
    layoutOptions.itemTextPosition = options.itemTextPosition;
    layoutOptions.altCountItem = layoutOptions.altCountItem || _ceil(that._items.length / layoutOptions.countItem);
    return layoutOptions;
  },
  _adjustBackgroundSettings: function (locationOptions) {
    if (!this._background) return;
    const border = locationOptions.border;
    const legendBox = this._calculateTotalBox();
    const backgroundSettings = {
      x: _round(legendBox.x - locationOptions.paddingLeftRight),
      y: _round(legendBox.y - locationOptions.paddingTopBottom),
      width: _round(legendBox.width) + 2 * locationOptions.paddingLeftRight,
      height: _round(legendBox.height),
      opacity: locationOptions.backgroundOpacity
    };
    if (border.visible && border.width && border.color && border.color !== NONE) {
      backgroundSettings['stroke-width'] = border.width;
      backgroundSettings.stroke = border.color;
      backgroundSettings['stroke-opacity'] = border.opacity;
      backgroundSettings.dashStyle = border.dashStyle;
      backgroundSettings.rx = border.cornerRadius || 0;
      backgroundSettings.ry = border.cornerRadius || 0;
    }
    this._background.attr(backgroundSettings);
  },
  _setBoundingRect: function (margin) {
    if (!this._insideLegendGroup) {
      return;
    }
    const box = this._calculateTotalBox();
    box.height += margin.top + margin.bottom;
    box.widthWithoutMargins = box.width;
    box.width += margin.left + margin.right;
    box.x -= margin.left;
    box.y -= margin.top;
    this._boundingRect = box;
  },
  _calculateTotalBox: function () {
    const markerBox = this._markersGroup.getBBox();
    const titleBox = this._title.getCorrectedLayoutOptions();
    const box = this._insideLegendGroup.getBBox();
    const verticalPadding = this._background ? 2 * this._options.paddingTopBottom : 0;
    box.height = markerBox.height + titleBox.height + verticalPadding;
    titleBox.width > box.width && (box.width = titleBox.width);
    return box;
  },
  getActionCallback: function (point) {
    const that = this;
    if (that._options.visible) {
      return function (act) {
        that[act](point.index);
      };
    } else {
      return _common.noop;
    }
  },
  getLayoutOptions: function () {
    const options = this._options;
    const boundingRect = this._insideLegendGroup ? this._boundingRect : {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    if (options) {
      boundingRect.verticalAlignment = options.verticalAlignment;
      boundingRect.horizontalAlignment = options.horizontalAlignment;
      if (options.orientation === HORIZONTAL) {
        boundingRect.cutLayoutSide = options.verticalAlignment;
        boundingRect.cutSide = 'vertical';
      } else {
        if (options.horizontalAlignment === CENTER) {
          boundingRect.cutLayoutSide = options.verticalAlignment;
          boundingRect.cutSide = 'vertical';
        } else {
          boundingRect.cutLayoutSide = options.horizontalAlignment;
          boundingRect.cutSide = 'horizontal';
        }
      }
      boundingRect.position = {
        horizontal: options.horizontalAlignment,
        vertical: options.verticalAlignment
      };
      return boundingRect;
    }
    return null;
  },
  shift: function (x, y) {
    const that = this;
    let box = {};
    if (that._insideLegendGroup) {
      that._insideLegendGroup.attr({
        translateX: x - that._boundingRect.x,
        translateY: y - that._boundingRect.y
      });
    }
    that._title && that._shiftTitle(that._boundingRect.widthWithoutMargins);
    that._markersGroup && that._shiftMarkers();
    if (that._insideLegendGroup) box = that._legendGroup.getBBox();
    that._x1 = box.x;
    that._y1 = box.y;
    that._x2 = box.x + box.width;
    that._y2 = box.y + box.height;
    return that;
  },
  _shiftTitle: function (boxWidth) {
    const that = this;
    const title = that._title;
    const titleBox = title.getCorrectedLayoutOptions();
    if (!titleBox || !title.hasText()) {
      return;
    }
    const width = boxWidth - (that._background ? 2 * that._options.paddingLeftRight : 0);
    const titleOptions = title.getOptions();
    let titleY = titleBox.y + titleOptions.margin.top;
    let titleX = 0;
    if (titleOptions.verticalAlignment === BOTTOM && that._markersGroup) {
      titleY += that._markersGroup.getBBox().height;
    }
    if (titleOptions.horizontalAlignment === RIGHT) {
      titleX = width - titleBox.width;
    } else if (titleOptions.horizontalAlignment === CENTER) {
      titleX = (width - titleBox.width) / 2;
    }
    title.shift(titleX, titleY);
  },
  _shiftMarkers: function () {
    const titleBox = this._title.getLayoutOptions();
    const markerBox = this._markersGroup.getBBox();
    const titleOptions = this._title.getOptions() || {};
    let center = 0;
    let y = 0;
    if (titleBox.width > markerBox.width && this._options.horizontalAlignment === CENTER) {
      center = titleBox.width / 2 - markerBox.width / 2;
    }
    if (titleOptions.verticalAlignment === TOP) {
      y = titleBox.height;
    }
    if (center !== 0 || y !== 0) {
      this._markersGroup.attr({
        translateX: center,
        translateY: y
      });
      this._items.forEach(item => {
        item.tracker.left += center;
        item.tracker.right += center;
        item.tracker.top += y;
        item.tracker.bottom += y;
      });
    }
  },
  getPosition: function () {
    return this._options.position;
  },
  coordsIn: function (x, y) {
    return x >= this._x1 && x <= this._x2 && y >= this._y1 && y <= this._y2;
  },
  getItemByCoord: function (x, y) {
    const items = this._items;
    const legendGroup = this._insideLegendGroup;
    x = x - legendGroup.attr('translateX');
    y = y - legendGroup.attr('translateY');
    for (let i = 0; i < items.length; i++) {
      if (inRect(items[i].tracker, x, y)) {
        return items[i].tracker;
      }
    }
    return null;
  },
  dispose: function () {
    const that = this;
    that._title && that._title.dispose();
    that._legendGroup = that._insideLegendGroup = that._title = that._renderer = that._options = that._data = that._items = null;
    return that;
  },
  // BaseWidget_layout_implementation
  layoutOptions: function () {
    if (!this.isVisible()) {
      return null;
    }
    const pos = this.getLayoutOptions();
    return {
      horizontalAlignment: this._options.horizontalAlignment,
      verticalAlignment: this._options.verticalAlignment,
      side: pos.cutSide,
      priority: 1,
      position: this.getPosition()
    };
  },
  measure: function (size) {
    if (this._updated || !this._insideLegendGroup) {
      this.draw(size[0], size[1]);
      this._updated = false;
    } else {
      this._items.forEach(item => {
        item.bBoxes = [];
      });
      this._updateElementsPosition(size[0], size[1]);
    }
    const rect = this.getLayoutOptions();
    return [rect.width, rect.height];
  },
  move: function (rect) {
    this.shift(rect[0], rect[1]);
  },
  freeSpace: function () {
    this._options._incidentOccurred('W2104');
    this.erase();
  }
  // BaseWidget_layout_implementation
});
const plugin = exports.plugin = {
  name: 'legend',
  init: function () {
    const that = this;
    const group = this._renderer.g().attr({
      class: this._rootClassPrefix + '-legend'
    }).enableLinks().append(that._renderer.root);
    that._legend = new Legend({
      renderer: that._renderer,
      group: group,
      widget: this,
      itemGroupClass: this._rootClassPrefix + '-item',
      titleGroupClass: this._rootClassPrefix + '-title',
      textField: 'text',
      getFormatObject: function (data) {
        return {
          item: data.item,
          text: data.text
        };
      }
    });
    that._layout.add(that._legend);
  },
  extenders: {
    _applyTilesAppearance: function () {
      const that = this;
      this._items.forEach(function (item) {
        that._applyLegendItemStyle(item.id, item.getState());
      });
    },
    _buildNodes: function () {
      this._createLegendItems();
    }
  },
  members: {
    _applyLegendItemStyle: function (id, state) {
      const legend = this._legend;
      switch (state) {
        case 'hover':
          legend.applyHover(id);
          break;
        case 'selection':
          legend.applySelected(id);
          break;
        default:
          legend.resetItem(id);
          break;
      }
    },
    _createLegendItems: function () {
      if (this._legend.update(this._getLegendData(), this._getOption('legend'), this._themeManager.theme('legend').title)) {
        this._requestChange(['LAYOUT']);
      }
    }
  },
  dispose: function () {
    this._legend.dispose();
  },
  customize: function (constructor) {
    constructor.prototype._proxyData.push(function (x, y) {
      if (this._legend.coordsIn(x, y)) {
        const item = this._legend.getItemByCoord(x, y);
        if (item) {
          return {
            id: item.id,
            type: 'legend'
          };
        }
      }
    });
    constructor.addChange({
      code: 'LEGEND',
      handler: function () {
        this._createLegendItems();
      },
      isThemeDependent: true,
      option: 'legend',
      isOptionChange: true
    });
  }
};

/***/ }),

/***/ 8587:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.correctValueType = correctValueType;
exports.getParser = void 0;
var _common = __webpack_require__(20576);
var _date_serialization = _interopRequireDefault(__webpack_require__(69434));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const parsers = {
  string: function (val) {
    return (0, _type.isDefined)(val) ? '' + val : val;
  },
  numeric: function (val) {
    if (!(0, _type.isDefined)(val)) {
      return val;
    }
    let parsedVal = Number(val);
    if (isNaN(parsedVal)) {
      parsedVal = undefined;
    }
    return parsedVal;
  },
  datetime: function (val) {
    if (!(0, _type.isDefined)(val)) {
      return val;
    }
    let parsedVal;
    const numVal = Number(val);
    if (!isNaN(numVal)) {
      parsedVal = new Date(numVal);
    } else {
      parsedVal = _date_serialization.default.deserializeDate(val);
    }
    if (isNaN(Number(parsedVal))) {
      parsedVal = undefined;
    }
    return parsedVal;
  }
};
function correctValueType(type) {
  return type === 'numeric' || type === 'datetime' || type === 'string' ? type : '';
}
const getParser = function (valueType) {
  return parsers[correctValueType(valueType)] || _common.noop;
};
exports.getParser = getParser;

/***/ }),

/***/ 88997:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Tracker = Tracker;
var _index = __webpack_require__(39611);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _click = __webpack_require__(95429);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const downPointerEventName = _pointer.default.down;
const movePointerEventName = _pointer.default.move;
function Tracker(parameters) {
  this._initHandlers(parameters);
}
Tracker.prototype = {
  constructor: Tracker,
  _initHandlers: function (parameters) {
    const document = _dom_adapter.default.getDocument();
    parameters.getCoords = function (e) {
      // TODO: Looks like "eventData" just returns e.pageX, e.pageY. Investigate and use just e.pageX, e.pageY is possible. Don't forget about touch.
      const data = (0, _index.eventData)(e);
      const offset = parameters.widget._renderer.getRootOffset();
      return [data.x - offset.left, data.y - offset.top];
    };
    parameters.root.on(_click.name, clickHandler);
    parameters.root.on(downPointerEventName, downHandler);
    _events_engine.default.on(document, downPointerEventName, downHandler);
    _events_engine.default.on(document, movePointerEventName, moveHandler);
    this._disposeHandlers = function () {
      parameters.root.off(_click.name, clickHandler);
      parameters.root.off(downPointerEventName, downHandler);
      _events_engine.default.off(document, downPointerEventName, downHandler);
      _events_engine.default.off(document, movePointerEventName, moveHandler);
    };
    function clickHandler(e) {
      processClick(e, parameters);
    }

    // Previously "stopPropagation" was called from the "downHandler" - so event triggered on "root" is not then triggered on "document".
    // Unfortunately it occurred (during T396917) that on touch devices calling "stopPropagation" prevents the following "dxclick" event.
    // Generally I think it would be better to use only (dxpointerdown, dxpointermove, dxpointerup) events (of course click is then implemented manually).
    // But for now removing "stopPropagation" will suffice - it can be implemented faster and with less changes, there are no known drawbacks in it.
    // We use "stopPropagation" to prevent unexpected scrolling or zooming when widget has some own scrolling behavior and is located inside another widget
    // (like dxScrollable) with its own scrolling behavior - dxTreeMap does not have own scrolling behavior.
    let isRootDown = false;
    function downHandler(e) {
      if (isRootDown) {
        isRootDown = false;
      } else {
        if (parameters.getData(e) !== undefined) {
          isRootDown = true;
        }
        moveHandler(e);
      }
    }
    function moveHandler(e) {
      processHover(e, parameters);
      parameters.widget._getOption('tooltip').enabled && processTooltip(e, parameters);
    }
  },
  dispose: function () {
    this._disposeHandlers();
  }
};
function processClick(e, params) {
  const id = params.getData(e);
  if (id >= 0) {
    params.click({
      node: params.getNode(id),
      coords: params.getCoords(e),
      event: e
    });
  }
}
function processHover(e, params) {
  const id = params.getData(e);
  if (id >= 0) {
    params.getNode(id).setHover();
  } else {
    params.widget.clearHover();
  }
}
function processTooltip(e, params) {
  const id = params.getData(e, true);
  let coords;
  if (id >= 0) {
    coords = (0, _index.eventData)(e);
    params.getNode(id).showTooltip([coords.x, coords.y]);
  } else {
    params.widget.hideTooltip();
  }
}

/***/ }),

/***/ 77129:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugins = exports.createAnnotations = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
var _tooltip = __webpack_require__(14371);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _plaque = __webpack_require__(64509);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _drag = __webpack_require__(23174);
var _index = __webpack_require__(39611);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const getDocument = _dom_adapter.default.getDocument;
const EVENT_NS = 'annotations';
const DOT_EVENT_NS = '.' + EVENT_NS;
const POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
const POINTER_UP_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.up, EVENT_NS);
const DRAG_START_EVENT_NAME = _drag.start + DOT_EVENT_NS;
const DRAG_EVENT_NAME = _drag.move + DOT_EVENT_NS;
const DRAG_END_EVENT_NAME = _drag.end + DOT_EVENT_NS;
function coreAnnotation(options, contentTemplate) {
  return {
    draw: function (widget, group) {
      const annotationGroup = widget._renderer.g().append(group).css((0, _utils.patchFontOptions)(options.font));
      if (this.plaque) {
        this.plaque.clear();
      }
      this.plaque = new _plaque.Plaque((0, _extend.extend)(true, {}, options, {
        cornerRadius: (options.border || {}).cornerRadius
      }), widget, annotationGroup, contentTemplate, widget._isAnnotationBounded(options));
      this.plaque.draw(widget._getAnnotationCoords(this));
      if (options.allowDragging) {
        annotationGroup.on(DRAG_START_EVENT_NAME, {
          immediate: true
        }, e => {
          this._dragOffsetX = this.plaque.x - e.pageX;
          this._dragOffsetY = this.plaque.y - e.pageY;
        }).on(DRAG_EVENT_NAME, e => {
          this.plaque.move(e.pageX + this._dragOffsetX, e.pageY + this._dragOffsetY);
        }).on(DRAG_END_EVENT_NAME, e => {
          this.offsetX = (this.offsetX || 0) + e.offset.x;
          this.offsetY = (this.offsetY || 0) + e.offset.y;
        });
      }
    },
    hitTest(x, y) {
      return this.plaque.hitTest(x, y);
    },
    showTooltip(tooltip, _ref) {
      let {
        x,
        y
      } = _ref;
      const that = this;
      const options = that.options;
      if (tooltip.annotation !== that) {
        tooltip.setTemplate(options.tooltipTemplate);
        const callback = result => {
          result && (tooltip.annotation = that);
        };
        callback(tooltip.show(options, {
          x,
          y
        }, {
          target: options
        }, options.customizeTooltip, callback));
      } else {
        if (!tooltip.isCursorOnTooltip(x, y)) {
          tooltip.move(x, y);
        }
      }
    }
  };
}
function getTemplateFunction(options, widget) {
  let template;
  if (options.type === 'text') {
    template = function (item, groupElement) {
      const text = widget._renderer.text(item.text).attr({
        'class': item.cssClass
      }).append({
        element: groupElement
      });
      if (item.width > 0 || item.height > 0) {
        text.setMaxSize(item.width, item.height, {
          wordWrap: item.wordWrap,
          textOverflow: item.textOverflow
        });
      }
    };
  } else if (options.type === 'image') {
    template = function (item, groupElement) {
      const {
        width,
        height,
        url,
        location
      } = item.image || {};
      const {
        width: outerWidth,
        height: outerHeight
      } = item;
      const imageWidth = outerWidth > 0 ? Math.min(width, outerWidth) : width;
      const imageHeight = outerHeight > 0 ? Math.min(height, outerHeight) : height;
      widget._renderer.image(0, 0, imageWidth, imageHeight, url, location || 'center').append({
        element: groupElement
      });
    };
  } else if (options.type === 'custom') {
    template = options.template;
  }
  return template;
}
function getImageObject(image) {
  return typeof image === 'string' ? {
    url: image
  } : image;
}
let createAnnotations = function (widget, items) {
  let commonAnnotationSettings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let customizeAnnotation = arguments.length > 3 ? arguments[3] : undefined;
  let pullOptions = arguments.length > 4 ? arguments[4] : undefined;
  const commonImageOptions = getImageObject(commonAnnotationSettings.image);
  return items.reduce((arr, item) => {
    const currentImageOptions = getImageObject(item.image);
    const customizedItem = (0, _type.isFunction)(customizeAnnotation) ? customizeAnnotation(item) : {};
    if (customizedItem) {
      customizedItem.image = getImageObject(customizedItem.image); // T881143
    }
    const options = (0, _extend.extend)(true, {}, commonAnnotationSettings, item, {
      image: commonImageOptions
    }, {
      image: currentImageOptions
    }, customizedItem);
    const templateFunction = getTemplateFunction(options, widget);
    const annotation = templateFunction && (0, _extend.extend)(true, pullOptions(options), coreAnnotation(options, widget._getTemplate(templateFunction)));
    annotation && arr.push(annotation);
    return arr;
  }, []);
};
exports.createAnnotations = createAnnotations;
const chartPlugin = {
  name: 'annotations_chart',
  init() {},
  dispose() {},
  members: {
    _getAnnotationCoords(annotation) {
      var _axis, _axis2;
      const coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY
      };
      const argCoordName = this._options.silent('rotated') ? 'y' : 'x';
      const valCoordName = this._options.silent('rotated') ? 'x' : 'y';
      const argAxis = this.getArgumentAxis();
      const argument = argAxis.validateUnit(annotation.argument);
      let axis = this.getValueAxis(annotation.axis);
      let series;
      let pane = (_axis = axis) === null || _axis === void 0 ? void 0 : _axis.pane;
      if (annotation.series) {
        var _series;
        series = this.series.filter(s => s.name === annotation.series)[0];
        axis = (_series = series) === null || _series === void 0 ? void 0 : _series.getValueAxis();
        (0, _type.isDefined)(axis) && (pane = axis.pane);
      }
      if ((0, _type.isDefined)(argument)) {
        if (series) {
          const center = series.getPointCenterByArg(argument);
          center && (coords[argCoordName] = center[argCoordName]);
        } else {
          coords[argCoordName] = argAxis.getTranslator().translate(argument);
        }
        !(0, _type.isDefined)(pane) && (pane = argAxis.pane);
      }
      const value = (_axis2 = axis) === null || _axis2 === void 0 ? void 0 : _axis2.validateUnit(annotation.value);
      if ((0, _type.isDefined)(value)) {
        var _axis3;
        coords[valCoordName] = (_axis3 = axis) === null || _axis3 === void 0 ? void 0 : _axis3.getTranslator().translate(value);
        !(0, _type.isDefined)(pane) && (0, _type.isDefined)(axis) && (pane = axis.pane);
      }
      coords.canvas = this._getCanvasForPane(pane);
      if ((0, _type.isDefined)(coords[argCoordName]) && !(0, _type.isDefined)(value)) {
        var _series2;
        if (!(0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[valCoordName] = argAxis.getAxisPosition();
        } else if ((0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[valCoordName] = this._argumentAxes.filter(a => a.pane === axis.pane)[0].getAxisPosition();
        } else if ((_series2 = series) !== null && _series2 !== void 0 && _series2.checkSeriesViewportCoord(argAxis, coords[argCoordName])) {
          coords[valCoordName] = series.getSeriesPairCoord(coords[argCoordName], true);
        }
      }
      if (!(0, _type.isDefined)(argument) && (0, _type.isDefined)(coords[valCoordName])) {
        if ((0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[argCoordName] = axis.getAxisPosition();
        } else if ((0, _type.isDefined)(series)) {
          if (series.checkSeriesViewportCoord(axis, coords[valCoordName])) {
            coords[argCoordName] = series.getSeriesPairCoord(coords[valCoordName], false);
          }
        }
      }
      return coords;
    },
    _annotationsPointerEventHandler(event) {
      if (this._disposed) {
        return;
      }
      const originalEvent = event.originalEvent || {};
      const touch = originalEvent.touches && originalEvent.touches[0] || {};
      const rootOffset = this._renderer.getRootOffset();
      const coords = {
        x: touch.pageX || originalEvent.pageX || event.pageX,
        y: touch.pageY || originalEvent.pageY || event.pageY
      };
      const annotation = this._annotations.items.filter(a => a.hitTest(coords.x - rootOffset.left, coords.y - rootOffset.top))[0];
      if (!annotation || !annotation.options.tooltipEnabled) {
        this._annotations.hideTooltip();
        return;
      }
      this._clear();
      if (annotation.options.allowDragging && event.type === _pointer.default.down) {
        this._annotations._hideToolTipForDrag = true;
      }
      if (!this._annotations._hideToolTipForDrag) {
        annotation.showTooltip(this._annotations.tooltip, coords);
        event.stopPropagation();
      }
    },
    _isAnnotationBounded(options) {
      return (0, _type.isDefined)(options.value) || (0, _type.isDefined)(options.argument);
    },
    _pullOptions(options) {
      return {
        type: options.type,
        name: options.name,
        x: options.x,
        y: options.y,
        value: options.value,
        argument: options.argument,
        axis: options.axis,
        series: options.series,
        options: options,
        offsetX: options.offsetX,
        offsetY: options.offsetY
      };
    },
    _forceAnnotationRender() {
      this._change(['FORCE_RENDER']);
    },
    _clear() {
      this.hideTooltip();
      this.clearHover();
    }
  }
};
const polarChartPlugin = {
  name: 'annotations_polar_chart',
  init() {},
  dispose() {},
  members: {
    _getAnnotationCoords(annotation) {
      const coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY,
        canvas: this._calcCanvas()
      };
      const argAxis = this.getArgumentAxis();
      let argument = argAxis.validateUnit(annotation.argument);
      const value = this.getValueAxis().validateUnit(annotation.value);
      const radius = annotation.radius;
      const angle = annotation.angle;
      let pointCoords;
      let series;
      if (annotation.series) {
        series = this.series.filter(s => s.name === annotation.series)[0];
      }
      (0, _extend.extend)(true, coords, this.getXYFromPolar(angle, radius, argument, value));
      if ((0, _type.isDefined)(series)) {
        if ((0, _type.isDefined)(coords.angle) && !(0, _type.isDefined)(value) && !(0, _type.isDefined)(radius)) {
          if (!(0, _type.isDefined)(argument)) {
            argument = argAxis.getTranslator().from(isFinite(angle) ? this.getActualAngle(angle) : coords.angle);
          }
          pointCoords = series.getSeriesPairCoord({
            argument,
            angle: -coords.angle
          }, true);
        } else if ((0, _type.isDefined)(coords.radius) && !(0, _type.isDefined)(argument) && !(0, _type.isDefined)(angle)) {
          pointCoords = series.getSeriesPairCoord({
            radius: coords.radius
          }, false);
        }
        if ((0, _type.isDefined)(pointCoords)) {
          coords.x = pointCoords.x;
          coords.y = pointCoords.y;
        }
      }
      if (annotation.series && !(0, _type.isDefined)(pointCoords)) {
        coords.x = coords.y = undefined;
      }
      return coords;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _isAnnotationBounded: chartPlugin.members._isAnnotationBounded,
    _pullOptions(options) {
      const polarOptions = (0, _extend.extend)({}, {
        radius: options.radius,
        angle: options.angle
      }, chartPlugin.members._pullOptions(options));
      delete polarOptions.axis;
      return polarOptions;
    },
    _forceAnnotationRender: chartPlugin.members._forceAnnotationRender,
    _clear: chartPlugin.members._clear
  }
};
const vectorMapPlugin = {
  name: 'annotations_vector_map',
  init() {},
  dispose() {
    this._annotations._offTracker();
    this._annotations._offTracker = null;
  },
  members: {
    _getAnnotationCoords(annotation) {
      const coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY
      };
      coords.canvas = this._projection.getCanvas();
      if (annotation.coordinates) {
        const data = this._projection.toScreenPoint(annotation.coordinates);
        coords.x = data[0];
        coords.y = data[1];
      }
      return coords;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _isAnnotationBounded(options) {
      return (0, _type.isDefined)(options.coordinates);
    },
    _pullOptions(options) {
      const vectorMapOptions = (0, _extend.extend)({}, {
        coordinates: options.coordinates
      }, chartPlugin.members._pullOptions(options));
      delete vectorMapOptions.axis;
      delete vectorMapOptions.series;
      delete vectorMapOptions.argument;
      delete vectorMapOptions.value;
      return vectorMapOptions;
    },
    _forceAnnotationRender() {
      this._change(['EXTRA_ELEMENTS']);
    },
    _getAnnotationStyles() {
      return {
        'text-anchor': 'start'
      };
    },
    _clear() {}
  },
  extenders: {
    _prepareExtraElements() {
      const that = this;
      const renderElements = () => {
        that._renderExtraElements();
      };
      that._annotations._offTracker = that._tracker.on({
        'move': renderElements,
        'zoom': renderElements,
        'end': renderElements
      });
    }
  }
};
const pieChartPlugin = {
  name: 'annotations_pie_chart',
  init() {},
  dispose() {},
  members: {
    _getAnnotationCoords(annotation) {
      let series;
      const coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY,
        canvas: this._canvas
      };
      if (annotation.argument) {
        if (annotation.series) {
          series = this.getSeriesByName(annotation.series);
        } else {
          series = this.series[0];
        }
        const argument = series.getPointsByArg(annotation.argument)[0];
        const {
          x,
          y
        } = argument.getAnnotationCoords(annotation.location);
        coords.x = x;
        coords.y = y;
      }
      return coords;
    },
    _isAnnotationBounded(options) {
      return options.argument;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _pullOptions(options) {
      const pieChartOptions = (0, _extend.extend)({}, {
        location: options.location
      }, chartPlugin.members._pullOptions(options));
      delete pieChartOptions.axis;
      return pieChartOptions;
    },
    _clear: chartPlugin.members._clear,
    _forceAnnotationRender: chartPlugin.members._forceAnnotationRender
  }
};
const corePlugin = {
  name: 'annotations_core',
  init() {
    this._annotations = {
      items: [],
      _hideToolTipForDrag: false,
      tooltip: new _tooltip.Tooltip({
        cssClass: `${this._rootClassPrefix}-annotation-tooltip`,
        eventTrigger: this._eventTrigger,
        widgetRoot: this.element(),
        widget: this
      }),
      hideTooltip() {
        this.tooltip.annotation = null;
        this.tooltip.hide();
      },
      clearItems() {
        this.items.forEach(i => i.plaque.clear());
        this.items = [];
      }
    };
    this._annotations.tooltip.setRendererOptions(this._getRendererOptions());
  },
  dispose() {
    this._annotationsGroup.linkRemove().linkOff();
    _events_engine.default.off(getDocument(), DOT_EVENT_NS);
    this._annotationsGroup.off(DOT_EVENT_NS);
    this._annotations.tooltip && this._annotations.tooltip.dispose();
  },
  extenders: {
    _createHtmlStructure() {
      this._annotationsGroup = this._renderer.g().attr({
        'class': `${this._rootClassPrefix}-annotations`
      }).css(this._getAnnotationStyles()).linkOn(this._renderer.root, 'annotations').linkAppend();
      _events_engine.default.on(getDocument(), POINTER_ACTION, e => {
        if (this._disposed) {
          return;
        }
        if (!this._annotations.tooltip.isCursorOnTooltip(e.pageX, e.pageY)) {
          this._annotations.hideTooltip();
        }
      });
      _events_engine.default.on(getDocument(), POINTER_UP_EVENT_NAME, event => {
        this._annotations._hideToolTipForDrag = false;
        this._annotationsPointerEventHandler(event);
      });
      this._annotationsGroup.on(POINTER_ACTION, this._annotationsPointerEventHandler.bind(this));
    },
    _renderExtraElements() {
      this._annotationsGroup.clear();
      this._annotations.items.forEach(item => item.draw(this, this._annotationsGroup));
    },
    _stopCurrentHandling() {
      this._annotations.hideTooltip();
    }
  },
  members: {
    _buildAnnotations() {
      this._annotations.clearItems();
      const items = this._getOption('annotations', true);
      if (!(items !== null && items !== void 0 && items.length)) {
        return;
      }
      this._annotations.items = createAnnotations(this, items, this._getOption('commonAnnotationSettings'), this._getOption('customizeAnnotation', true), this._pullOptions);
    },
    _setAnnotationTooltipOptions() {
      const tooltipOptions = (0, _extend.extend)({}, this._getOption('tooltip'));
      tooltipOptions.contentTemplate = tooltipOptions.customizeTooltip = undefined;
      this._annotations.tooltip.update(tooltipOptions);
    },
    _getAnnotationCoords() {
      return {};
    },
    _pullOptions() {
      return {};
    },
    _getAnnotationStyles() {
      return {};
    }
  },
  customize(constructor) {
    constructor.addChange({
      code: 'ANNOTATIONITEMS',
      handler() {
        this._requestChange(['ANNOTATIONS']);
      },
      isOptionChange: true,
      option: 'annotations'
    });
    constructor.addChange({
      code: 'ANNOTATIONSSETTINGS',
      handler() {
        this._requestChange(['ANNOTATIONS']);
      },
      isOptionChange: true,
      option: 'commonAnnotationSettings'
    });
    constructor.addChange({
      code: 'ANNOTATIONS',
      handler() {
        this._buildAnnotations();
        this._setAnnotationTooltipOptions();
        this._forceAnnotationRender();
      },
      isThemeDependent: true,
      isOptionChange: true
    });
  },
  fontFields: ['commonAnnotationSettings.font']
};
const plugins = exports.plugins = {
  core: corePlugin,
  chart: chartPlugin,
  polarChart: polarChartPlugin,
  vectorMap: vectorMapPlugin,
  pieChart: pieChartPlugin
};

/***/ }),

/***/ 43637:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.BaseThemeManager = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _palette = __webpack_require__(23696);
var _utils = __webpack_require__(19157);
var _themes = __webpack_require__(86231);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _getTheme = _themes.getTheme;
const _addCacheItem = _themes.addCacheItem;
const _removeCacheItem = _themes.removeCacheItem;
const _extend = _extend2.extend;
const _each = _iterator.each;
function getThemePart(theme, path) {
  let _theme = theme;
  path && _each(path.split('.'), function (_, pathItem) {
    return _theme = _theme[pathItem];
  });
  return _theme;
}
const BaseThemeManager = exports.BaseThemeManager = _class.default.inherit({
  // TODO: test hack
  ctor: function (options) {
    this._themeSection = options.themeSection;
    this._fontFields = options.fontFields || [];
    _addCacheItem(this);
  },
  dispose: function () {
    const that = this;
    _removeCacheItem(that);
    that._callback = that._theme = that._font = null;
    return that;
  },
  // TODO: Move it to constructor when charts theme managers's constructor is removed
  setCallback: function (callback) {
    this._callback = callback;
    return this;
  },
  setTheme: function (theme, rtl) {
    this._current = theme;
    this._rtl = rtl;
    return this.refresh();
  },
  // Officially we do not support objects as "theme" option value - we should stop doing it in code
  refresh: function () {
    const that = this;
    const current = that._current || {};
    let theme = _getTheme(current.name || current);
    that._themeName = theme.name;
    that._defaultPalette = theme.defaultPalette;
    that._font = _extend({}, theme.font, current.font);
    that._themeSection && _each(that._themeSection.split('.'), function (_, path) {
      theme = _extend(true, {}, theme[path]);
    });
    that._theme = _extend(true, {}, theme, (0, _type.isString)(current) ? {} : current);
    that._initializeTheme();
    if ((0, _utils.parseScalar)(that._rtl, that._theme.rtlEnabled)) {
      _extend(true, that._theme, that._theme._rtl);
    }
    that._callback();
    return that;
  },
  theme: function (path) {
    return getThemePart(this._theme, path);
  },
  themeName: function () {
    return this._themeName;
  },
  // TODO: May be we need some single method for all palettes?

  createPalette: function (palette, options) {
    return (0, _palette.createPalette)(palette, options, this._defaultPalette);
  },
  createDiscretePalette: function (palette, count) {
    return (0, _palette.getDiscretePalette)(palette, count, this._defaultPalette);
  },
  createGradientPalette: function (palette) {
    return (0, _palette.getGradientPalette)(palette, this._defaultPalette);
  },
  getAccentColor: function (palette) {
    return (0, _palette.getAccentColor)(palette, this._defaultPalette);
  },
  _initializeTheme: function () {
    const that = this;
    _each(that._fontFields || [], function (_, path) {
      that._initializeFont(getThemePart(that._theme, path));
    });
  },
  _initializeFont: function (font) {
    _extend(font, this._font, _extend({}, font));
  }
});

/***/ }),

/***/ 98469:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.createEventTrigger = createEventTrigger;
exports.createIncidentOccurred = void 0;
exports.createResizeHandler = createResizeHandler;
var _version = __webpack_require__(36739);
var _string = __webpack_require__(68752);
var _errors_warnings = _interopRequireDefault(__webpack_require__(80726));
var _iterator = __webpack_require__(95479);
var _resize_callbacks = _interopRequireDefault(__webpack_require__(55814));
var _resize_observer = _interopRequireDefault(__webpack_require__(91784));
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERROR_MESSAGES = _errors_warnings.default.ERROR_MESSAGES;
function createEventTrigger(eventsMap, callbackGetter) {
  let triggers = {};
  (0, _iterator.each)(eventsMap, function (name, info) {
    if (info.name) {
      createEvent(name);
    }
  });
  let changes;
  triggerEvent.change = function (name) {
    const eventInfo = eventsMap[name];
    if (eventInfo) {
      (changes = changes || {})[name] = eventInfo;
    }
    return !!eventInfo;
  };
  triggerEvent.applyChanges = function () {
    if (changes) {
      (0, _iterator.each)(changes, function (name, eventInfo) {
        createEvent(eventInfo.newName || name);
      });
      changes = null;
    }
  };
  triggerEvent.dispose = function () {
    eventsMap = callbackGetter = triggers = null;
  };
  return triggerEvent;
  function createEvent(name) {
    const eventInfo = eventsMap[name];
    triggers[eventInfo.name] = callbackGetter(name, eventInfo.actionSettings);
  }
  function triggerEvent(name, arg, complete) {
    triggers[name](arg);
    complete && complete();
  }
}
let createIncidentOccurred = function (widgetName, eventTrigger) {
  return function incidentOccurred(id, args) {
    eventTrigger('incidentOccurred', {
      target: {
        id: id,
        type: id[0] === 'E' ? 'error' : 'warning',
        args: args,
        text: _string.format.apply(null, [ERROR_MESSAGES[id]].concat(args || [])),
        widget: widgetName,
        version: _version.version
      }
    });
  };
};
exports.createIncidentOccurred = createIncidentOccurred;
function getResizeManager(resizeCallback) {
  return (observe, unsubscribe) => {
    const {
      handler,
      dispose
    } = createDeferredHandler(resizeCallback, unsubscribe);
    observe(handler);
    return dispose;
  };
}
function createDeferredHandler(callback, unsubscribe) {
  let timeout;
  const handler = function () {
    clearTimeout(timeout);
    timeout = setTimeout(callback, 100);
  };
  return {
    handler,
    dispose() {
      clearTimeout(timeout);
      unsubscribe(handler);
    }
  };
}
function createResizeHandler(contentElement, redrawOnResize, resize) {
  let disposeHandler;
  const resizeManager = getResizeManager(resize);
  if ((0, _utils.normalizeEnum)(redrawOnResize) === 'windowonly') {
    disposeHandler = resizeManager(handler => _resize_callbacks.default.add(handler), handler => _resize_callbacks.default.remove(handler));
  } else if (redrawOnResize === true) {
    disposeHandler = resizeManager(handler => _resize_observer.default.observe(contentElement, handler), () => _resize_observer.default.unobserve(contentElement));
  }
  return disposeHandler;
}

/***/ }),

/***/ 56672:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugins = void 0;
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
const pieChartPlugin = {
  name: 'center_template_pie_chart',
  init: _common.noop,
  dispose: function () {
    this._centerTemplateGroup.linkOff().dispose();
  },
  extenders: {
    _createHtmlStructure() {
      const patchedFontOptions = (0, _utils.patchFontOptions)(this._themeManager._font);
      this._centerTemplateGroup = this._renderer.g().attr({
        class: 'dxc-hole-template'
      }).linkOn(this._renderer.root, 'center-template').css(patchedFontOptions).linkAppend();
    },
    _renderExtraElements() {
      this._requestChange(['CENTER_TEMPLATE']);
    }
  },
  members: {
    _renderCenterTemplate() {
      const template = this.option('centerTemplate');
      const centerTemplateGroup = this._centerTemplateGroup.clear();
      if (!template) {
        return;
      }
      centerTemplateGroup.attr({
        visibility: 'hidden'
      });
      const center = this._getCenter();
      this._getTemplate(template).render({
        model: this,
        container: centerTemplateGroup.element,
        onRendered: () => {
          const group = centerTemplateGroup;
          const bBox = group.getBBox();
          const bBoxCenterX = bBox.x + bBox.width / 2;
          const bBoxCenterY = bBox.y + bBox.height / 2;
          group.move(center.x - bBoxCenterX, center.y - bBoxCenterY);
          group.attr({
            visibility: 'visible'
          });
        }
      });
    }
  },
  customize(constructor) {
    constructor.addChange({
      code: 'CENTER_TEMPLATE',
      handler: function () {
        this._renderCenterTemplate();
      },
      option: 'centerTemplate'
    });
  }
};
const gaugePlugin = {
  name: 'center_template_gauge',
  init: _common.noop,
  dispose: pieChartPlugin.dispose,
  extenders: {
    _initCore() {
      this._createCenterTemplateGroup();
    },
    _renderContent() {
      const patchedFontOptions = (0, _utils.patchFontOptions)(this._themeManager._font);
      this._centerTemplateGroup.css(patchedFontOptions);
      this._requestChange(['CENTER_TEMPLATE']);
    },
    _updateExtraElements() {
      this._requestChange(['CENTER_TEMPLATE']);
    }
  },
  members: {
    _renderCenterTemplate: pieChartPlugin.members._renderCenterTemplate,
    _createCenterTemplateGroup() {
      this._centerTemplateGroup = this._renderer.g().attr({
        class: 'dxg-hole-template'
      }).linkOn(this._renderer.root, 'center-template').linkAppend();
    }
  },
  customize: pieChartPlugin.customize
};
const plugins = exports.plugins = {
  pieChart: pieChartPlugin,
  gauge: gaugePlugin
};

/***/ }),

/***/ 1539:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _common = __webpack_require__(20576);
var _data_helper = _interopRequireDefault(__webpack_require__(53305));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const postCtor = _data_helper.default.postCtor;
let name;
const members = {
  _dataSourceLoadErrorHandler: function () {
    this._dataSourceChangedHandler();
  },
  _dataSourceOptions: function () {
    return {
      paginate: false
    };
  },
  _updateDataSource: function () {
    this._refreshDataSource();
    if (!this.option('dataSource')) {
      this._dataSourceChangedHandler();
    }
  },
  _dataIsLoaded: function () {
    return !this._dataSource || this._dataSource.isLoaded();
  },
  _dataSourceItems: function () {
    return this._dataSource && this._dataSource.items();
  }
};
for (name in _data_helper.default) {
  if (name === 'postCtor') {
    continue;
  }
  members[name] = _data_helper.default[name];
}
const plugin = exports.plugin = {
  name: 'data_source',
  init: function () {
    postCtor.call(this);
  },
  dispose: _common.noop,
  members: members
};

/***/ }),

/***/ 80726:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _error = _interopRequireDefault(__webpack_require__(95640));
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  /**
  * @name ErrorsUIWidgets.E2001
  */
  E2001: 'Invalid data source',
  /**
  * @name ErrorsUIWidgets.E2002
  */
  E2002: 'Axis type and data type are incompatible',
  /**
  * @name ErrorsUIWidgets.E2003
  */
  E2003: 'The "{0}" data source field contains data of unsupported type',
  /**
  * @name ErrorsUIWidgets.E2004
  */
  E2004: 'The "{0}" data source field is inconsistent',
  /**
  * @name ErrorsUIWidgets.E2005
  */
  E2005: 'The value field "{0}" is absent in the data source or all its values are negative',
  /**
  * @name ErrorsUIWidgets.E2006
  */
  E2006: 'A cycle is detected in provided data',
  /**
  * @name ErrorsUIWidgets.E2007
  */
  E2007: 'The value field "{0}" is absent in the data source',
  /**
  * @name ErrorsUIWidgets.E2008
  */
  E2008: 'The value field "{0}" must be a string',
  /**
  * @name ErrorsUIWidgets.E2009
  */
  E2009: 'The value field "{0}" must be a positive numeric value',
  /**
  * @name ErrorsUIWidgets.E2101
  */
  E2101: 'Unknown series type: {0}',
  /**
  * @name ErrorsUIWidgets.E2102
  */
  E2102: 'Ambiguity occurred between two value axes with the same name',
  /**
  * @name ErrorsUIWidgets.E2103
  */
  E2103: 'The "{0}" option is given an invalid value. Assign a function instead',
  /**
  * @name ErrorsUIWidgets.E2104
  */
  E2104: 'Invalid logarithm base',
  /**
  * @name ErrorsUIWidgets.E2105
  */
  E2105: 'Invalid value of a "{0}"',
  /**
  * @name ErrorsUIWidgets.E2202
  */
  E2202: 'Invalid {0} scale value',
  /**
  * @name ErrorsUIWidgets.E2203
  */
  E2203: 'The range you are trying to set is invalid',
  /**
  * @name ErrorsUIWidgets.W2002
  */
  W2002: 'The {0} series cannot be drawn because the {1} data field is missing',
  /**
  * @name ErrorsUIWidgets.W2003
  */
  W2003: 'Tick interval is too small',
  /**
  * @name ErrorsUIWidgets.W2101
  */
  W2101: 'The "{0}" pane does not exist; the last pane is used by default',
  /**
  * @name ErrorsUIWidgets.W2102
  */
  W2102: 'A value axis with the "{0}" name was created automatically',
  /**
  * @name ErrorsUIWidgets.W2103
  */
  W2103: 'The chart title was hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2104
  */
  W2104: 'The legend was hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2105
  */
  W2105: 'The title of the "{0}" axis was hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2106
  */
  W2106: 'The labels of the "{0}" axis were hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2107
  */
  W2107: 'The export menu was hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2108
  */
  W2108: 'The browser does not support exporting images to {0} format.',
  /**
  * @name ErrorsUIWidgets.W2301
  */
  W2301: 'Invalid value range'
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82454:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.getMarkup = exports.exportWidgets = exports.exportFromMarkup = exports.combineMarkups = exports.ExportMenu = void 0;
var _extend = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var _utils = __webpack_require__(19157);
var _svg = __webpack_require__(19155);
var _exporter = __webpack_require__(78292);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _type = __webpack_require__(35922);
var _themes = __webpack_require__(86231);
var _hover = __webpack_require__(24028);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _console = __webpack_require__(30869);
var _size = __webpack_require__(58664);
var _renderer = __webpack_require__(56453);
var _renderer2 = _interopRequireDefault(__webpack_require__(68374));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const pointerActions = [_pointer.default.down, _pointer.default.move].join(' ');
const BUTTON_SIZE = 35;
const ICON_COORDS = [[9, 12, 26, 12, 26, 14, 9, 14], [9, 17, 26, 17, 26, 19, 9, 19], [9, 22, 26, 22, 26, 24, 9, 24]];
const LIST_PADDING_TOP = 4;
const LIST_WIDTH = 120;
const VERTICAL_TEXT_MARGIN = 8;
const HORIZONTAL_TEXT_MARGIN = 15;
const MENU_ITEM_HEIGHT = 30;
const LIST_STROKE_WIDTH = 1;
const MARGIN = 10;
const SHADOW_OFFSET = 2;
const SHADOW_BLUR = 3;
const DEFAULT_EXPORT_FORMAT = 'PNG';
const ALLOWED_IMAGE_FORMATS = [DEFAULT_EXPORT_FORMAT, 'JPEG', 'GIF'];
const ALLOWED_EXTRA_FORMATS = ['PDF', 'SVG'];
const EXPORT_CSS_CLASS = 'dx-export-menu';
const A4WidthCm = '21cm';
const EXPORT_DATA_KEY = 'export-element-type';
const FORMAT_DATA_KEY = 'export-element-format';
const GET_COLOR_REGEX = /data-backgroundcolor="([^"]*)"/;
function getRendererWrapper(width, height, backgroundColor) {
  const rendererContainer = (0, _renderer2.default)('<div>').get(0);
  const renderer = new _renderer.Renderer({
    container: rendererContainer
  });
  renderer.resize(width, height);
  renderer.root.element.setAttribute('data-backgroundcolor', backgroundColor);
  return {
    createGroup() {
      return renderer.g();
    },
    getRootContent() {
      return renderer.root.element.cloneNode(true);
    },
    dispose() {
      renderer.dispose();
      rendererContainer.remove();
    }
  };
}
function getValidFormats() {
  const imageFormats = _exporter.image.testFormats(ALLOWED_IMAGE_FORMATS);
  return {
    unsupported: imageFormats.unsupported,
    supported: imageFormats.supported.concat(ALLOWED_EXTRA_FORMATS)
  };
}
function validateFormat(format, incidentOccurred, validFormats) {
  validFormats = validFormats || getValidFormats();
  format = String(format).toUpperCase();
  if (validFormats.supported.indexOf(format) !== -1) {
    return format;
  }
  if (validFormats.unsupported.indexOf(format) !== -1) {
    incidentOccurred && incidentOccurred('W2108', [format]);
  }
}
function getCreatorFunc(format) {
  if (format === 'SVG') {
    return _exporter.svg.getData;
  } else if (format === 'PDF') {
    return _exporter.pdf.getData;
  } else {
    return _exporter.image.getData;
  }
}
function print(imageSrc, options) {
  const document = (0, _window.getWindow)().document;
  const iFrame = document.createElement('iframe');
  iFrame.onload = setPrint(imageSrc, options);
  iFrame.style.position = 'fixed';
  iFrame.style.width = '0';
  iFrame.style.height = '0';
  iFrame.style.right = '0';
  iFrame.style.bottom = '0';
  document.body.appendChild(iFrame);
}
function calculatePrintPageWidth(iFrameBody) {
  iFrameBody.style.width = A4WidthCm;
  const width = (0, _size.getWidth)(iFrameBody);
  iFrameBody.style.width = '';
  return width;
}
function setPrint(imageSrc, options) {
  return function () {
    let window = this.contentWindow;
    const img = window.document.createElement('img');
    window.document.body.appendChild(img);
    const widthRatio = calculatePrintPageWidth(window.document.body) / options.width;
    if (widthRatio < 1) {
      window.document.body.style.transform = `scale(${widthRatio})`;
      window.document.body.style['transform-origin'] = '0 0';
    }
    const removeFrame = () => {
      this.parentElement.removeChild(this);
    };
    img.addEventListener('load', () => {
      window.focus();
      window.print();
    });
    img.addEventListener('error', removeFrame);
    window.addEventListener('afterprint', () => {
      // T933486
      setTimeout(removeFrame, 0); // timeout needed for FF
    });
    img.src = imageSrc;
  };
}
function getItemAttributes(options, type, itemIndex) {
  const x = BUTTON_SIZE - LIST_WIDTH;
  const y = BUTTON_SIZE + LIST_PADDING_TOP + LIST_STROKE_WIDTH + itemIndex * MENU_ITEM_HEIGHT;
  const attr = {
    rect: {
      width: LIST_WIDTH - LIST_STROKE_WIDTH * 2,
      height: MENU_ITEM_HEIGHT,
      x: x + LIST_STROKE_WIDTH,
      y: y
    },
    text: {
      x: x + (options.rtl ? LIST_WIDTH - HORIZONTAL_TEXT_MARGIN : HORIZONTAL_TEXT_MARGIN),
      y: y + MENU_ITEM_HEIGHT - VERTICAL_TEXT_MARGIN
    }
  };
  if (type === 'printing') {
    attr.separator = {
      stroke: options.button.default.borderColor,
      'stroke-width': LIST_STROKE_WIDTH,
      cursor: 'pointer',
      sharp: 'v',
      d: 'M ' + x + ' ' + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH) + ' ' + 'L ' + (x + LIST_WIDTH) + ' ' + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH)
    };
  }
  return attr;
}
function createMenuItem(renderer, options, settings) {
  const itemData = {};
  const type = settings.type;
  const format = settings.format;
  const attr = getItemAttributes(options, type, settings.itemIndex);
  const fontStyle = (0, _utils.patchFontOptions)(options.font);
  fontStyle['pointer-events'] = 'none';
  const menuItem = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-list-item'
  });
  itemData[EXPORT_DATA_KEY] = type;
  if (format) {
    itemData[FORMAT_DATA_KEY] = format;
  }
  const rect = renderer.rect();
  rect.attr(attr.rect).css({
    cursor: 'pointer',
    'pointer-events': 'all'
  }).data(itemData);
  rect.on(_hover.start + '.export', () => rect.attr({
    fill: options.button.hover.backgroundColor
  })).on(_hover.end + '.export', () => rect.attr({
    fill: null
  }));
  rect.append(menuItem);
  const text = renderer.text(settings.text).css(fontStyle).attr(attr.text).append(menuItem);
  if (type === 'printing') {
    renderer.path(null, 'line').attr(attr.separator).append(menuItem);
  }
  return {
    g: menuItem,
    rect: rect,
    resetState: () => rect.attr({
      fill: null
    }),
    fixPosition: () => {
      const textBBox = text.getBBox();
      text.move(attr.text.x - textBBox.x - (options.rtl ? textBBox.width : 0));
    }
  };
}
function createMenuItems(renderer, options) {
  let items = [];
  if (options.printingEnabled) {
    items.push(createMenuItem(renderer, options, {
      type: 'printing',
      text: _message.default.format('vizExport-printingButtonText'),
      itemIndex: items.length
    }));
  }
  items = options.formats.reduce((r, format) => {
    r.push(createMenuItem(renderer, options, {
      type: 'exporting',
      text: _message.default.getFormatter('vizExport-exportButtonText')(format),
      format: format,
      itemIndex: r.length
    }));
    return r;
  }, items);
  return items;
}
function getBackgroundColorFromMarkup(markup) {
  const parsedMarkup = GET_COLOR_REGEX.exec(markup);
  return parsedMarkup === null || parsedMarkup === void 0 ? void 0 : parsedMarkup[1];
}
const exportFromMarkup = function (markup, options) {
  options.format = validateFormat(options.format) || DEFAULT_EXPORT_FORMAT;
  options.fileName = options.fileName || 'file';
  options.exportingAction = options.onExporting;
  options.exportedAction = options.onExported;
  options.fileSavingAction = options.onFileSaving;
  options.margin = (0, _type.isDefined)(options.margin) ? options.margin : MARGIN;
  options.backgroundColor = (0, _type.isDefined)(options.backgroundColor) ? options.backgroundColor : getBackgroundColorFromMarkup(markup) || (0, _themes.getTheme)().backgroundColor;
  (0, _exporter.export)(markup, options, getCreatorFunc(options.format));
};
exports.exportFromMarkup = exportFromMarkup;
const getMarkup = widgets => combineMarkups(widgets).root.outerHTML;
exports.getMarkup = getMarkup;
const exportWidgets = function (widgets, options) {
  options = options || {};
  const markupInfo = combineMarkups(widgets, {
    gridLayout: options.gridLayout,
    verticalAlignment: options.verticalAlignment,
    horizontalAlignment: options.horizontalAlignment
  });
  options.width = markupInfo.width;
  options.height = markupInfo.height;
  exportFromMarkup(markupInfo.root, options);
};
exports.exportWidgets = exportWidgets;
let combineMarkups = function (widgets) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!Array.isArray(widgets)) {
    widgets = [[widgets]];
  } else if (!Array.isArray(widgets[0])) {
    widgets = widgets.map(item => [item]);
  }
  const compactView = !options.gridLayout;
  const exportItems = widgets.reduce((r, row, rowIndex) => {
    const rowInfo = row.reduce((r, item, colIndex) => {
      const size = item.getSize();
      const backgroundColor = item.option('backgroundColor') || (0, _themes.getTheme)(item.option('theme')).backgroundColor;
      const node = item.element().find('svg').get(0).cloneNode(true);
      backgroundColor && r.backgroundColors.indexOf(backgroundColor) === -1 && r.backgroundColors.push(backgroundColor);
      r.hOffset = r.width;
      r.width += size.width;
      r.height = Math.max(r.height, size.height);
      r.itemWidth = Math.max(r.itemWidth, size.width);
      r.items.push({
        node,
        width: size.width,
        height: size.height,
        c: colIndex,
        r: rowIndex,
        hOffset: r.hOffset
      });
      return r;
    }, {
      items: [],
      height: 0,
      itemWidth: 0,
      hOffset: 0,
      width: 0,
      backgroundColors: r.backgroundColors
    });
    r.rowOffsets.push(r.totalHeight);
    r.rowHeights.push(rowInfo.height);
    r.totalHeight += rowInfo.height;
    r.items = r.items.concat(rowInfo.items);
    r.itemWidth = Math.max(r.itemWidth, rowInfo.itemWidth);
    r.maxItemLen = Math.max(r.maxItemLen, rowInfo.items.length);
    r.totalWidth = compactView ? Math.max(r.totalWidth, rowInfo.width) : r.maxItemLen * r.itemWidth;
    return r;
  }, {
    items: [],
    rowOffsets: [],
    rowHeights: [],
    itemWidth: 0,
    totalHeight: 0,
    maxItemLen: 0,
    totalWidth: 0,
    backgroundColors: []
  });
  const backgroundColor = `${exportItems.backgroundColors.length === 1 ? exportItems.backgroundColors[0] : ''}`;
  const {
    totalWidth,
    totalHeight
  } = exportItems;
  const rootElement = wrapItemsToElement(totalWidth, totalHeight, backgroundColor, {
    options,
    exportItems,
    compactView
  });
  return {
    root: rootElement,
    width: totalWidth,
    height: totalHeight
  };
};
exports.combineMarkups = combineMarkups;
function wrapItemsToElement(width, height, backgroundColor, _ref) {
  let {
    exportItems,
    options,
    compactView
  } = _ref;
  const rendererWrapper = getRendererWrapper(width, height, backgroundColor);
  const getVOffset = item => {
    const align = options.verticalAlignment;
    const dy = exportItems.rowHeights[item.r] - item.height;
    return exportItems.rowOffsets[item.r] + (align === 'bottom' ? dy : align === 'center' ? dy / 2 : 0);
  };
  const getHOffset = item => {
    if (compactView) {
      return item.hOffset;
    }
    const align = options.horizontalAlignment;
    const colWidth = exportItems.itemWidth;
    const dx = colWidth - item.width;
    return item.c * colWidth + (align === 'right' ? dx : align === 'center' ? dx / 2 : 0);
  };
  exportItems.items.forEach(item => {
    const container = rendererWrapper.createGroup();
    container.attr({
      translateX: getHOffset(item),
      translateY: getVOffset(item)
    });
    container.element.appendChild(item.node);
    container.append();
  });
  const result = rendererWrapper.getRootContent();
  rendererWrapper.dispose();
  return result;
}
let ExportMenu = function (params) {
  const renderer = this._renderer = params.renderer;
  this._incidentOccurred = params.incidentOccurred;
  this._exportTo = params.exportTo;
  this._print = params.print;
  this._shadow = renderer.shadowFilter('-50%', '-50%', '200%', '200%', SHADOW_OFFSET, 6, SHADOW_BLUR);
  this._shadow.attr({
    opacity: 0.8
  });
  this._group = renderer.g().attr({
    'class': EXPORT_CSS_CLASS,
    [_svg.HIDDEN_FOR_EXPORT]: true
  }).linkOn(renderer.root, {
    name: 'export-menu',
    after: 'peripheral'
  });
  this._buttonGroup = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-button'
  }).append(this._group);
  this._listGroup = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-list'
  }).append(this._group);
  this._overlay = renderer.rect(-LIST_WIDTH + BUTTON_SIZE, BUTTON_SIZE + LIST_PADDING_TOP, LIST_WIDTH, 0);
  this._overlay.attr({
    'stroke-width': LIST_STROKE_WIDTH,
    cursor: 'pointer',
    rx: 4,
    ry: 4,
    filter: this._shadow.id
  });
  this._overlay.data({
    'export-element-type': 'list'
  });
  this.validFormats = getValidFormats();
  this._subscribeEvents();
};
exports.ExportMenu = ExportMenu;
(0, _extend.extend)(ExportMenu.prototype, {
  getLayoutOptions() {
    if (this._hiddenDueToLayout) {
      return {
        width: 0,
        height: 0,
        cutSide: 'vertical',
        cutLayoutSide: 'top'
      };
    }
    const bBox = this._buttonGroup.getBBox();
    bBox.cutSide = 'vertical';
    bBox.cutLayoutSide = 'top';
    bBox.height += MARGIN;
    bBox.position = {
      vertical: 'top',
      horizontal: 'right'
    };
    bBox.verticalAlignment = 'top';
    bBox.horizontalAlignment = 'right';
    return bBox;
  },
  shift(_, y) {
    this._group.attr({
      translateY: this._group.attr('translateY') + y
    });
  },
  draw(width, height, canvas) {
    this._group.move(width - BUTTON_SIZE - SHADOW_OFFSET - SHADOW_BLUR + canvas.left, Math.floor(height / 2 - BUTTON_SIZE / 2));
    const layoutOptions = this.getLayoutOptions();
    if (layoutOptions.width > width || layoutOptions.height > height) {
      this.freeSpace();
    }
    return this;
  },
  show() {
    this._group.linkAppend();
  },
  hide() {
    this._group.linkRemove();
  },
  setOptions(options) {
    this._options = options;
    if (options.formats) {
      options.formats = options.formats.reduce((r, format) => {
        format = validateFormat(format, this._incidentOccurred, this.validFormats);
        format && r.push(format);
        return r;
      }, []);
    } else {
      options.formats = this.validFormats.supported.slice();
    }
    options.printingEnabled = options.printingEnabled === undefined ? true : options.printingEnabled;
    if (options.enabled && (options.formats.length || options.printingEnabled)) {
      this.show();
      this._updateButton();
      this._updateList();
      this._hideList();
    } else {
      this.hide();
    }
  },
  dispose() {
    this._unsubscribeEvents();
    this._group.linkRemove().linkOff();
    this._group.dispose();
    this._shadow.dispose();
  },
  // BaseWidget_layout_implementation
  layoutOptions() {
    return this._options.enabled && {
      horizontalAlignment: 'right',
      verticalAlignment: 'top',
      weak: true
    };
  },
  measure() {
    this._fillSpace();
    const margin = this._options.button.margin;
    return [BUTTON_SIZE + margin.left + margin.right, BUTTON_SIZE + margin.top + margin.bottom];
  },
  move(rect) {
    const margin = this._options.button.margin;
    this._group.attr({
      translateX: Math.round(rect[0]) + margin.left,
      translateY: Math.round(rect[1]) + margin.top
    });
  },
  _fillSpace() {
    this._hiddenDueToLayout = false;
    this.show();
  },
  freeSpace() {
    this._incidentOccurred('W2107');
    this._hiddenDueToLayout = true;
    this.hide();
  },
  // BaseWidget_layout_implementation

  _hideList() {
    this._listGroup.remove();
    this._listShown = false;
    this._setButtonState('default');
    this._menuItems.forEach(item => item.resetState());
  },
  _showList() {
    this._listGroup.append(this._group);
    this._listShown = true;
    this._menuItems.forEach(item => item.fixPosition());
  },
  _setButtonState(state) {
    const style = this._options.button[state];
    this._button.attr({
      stroke: style.borderColor,
      fill: style.backgroundColor
    });
    this._icon.attr({
      fill: style.color
    });
  },
  _subscribeEvents() {
    this._renderer.root.on(_pointer.default.up + '.export', e => {
      const elementType = e.target[EXPORT_DATA_KEY];
      if (!elementType) {
        if (this._button) {
          this._hideList();
        }
        return;
      }
      if (elementType === 'button') {
        if (this._listShown) {
          this._setButtonState('default');
          this._hideList();
        } else {
          this._setButtonState('focus');
          this._showList();
        }
      } else if (elementType === 'printing') {
        this._print();
        this._hideList();
      } else if (elementType === 'exporting') {
        this._exportTo(e.target[FORMAT_DATA_KEY]);
        this._hideList();
      }
    });
    this._listGroup.on(pointerActions, e => e.stopPropagation());
    this._buttonGroup.on(_pointer.default.enter, () => this._setButtonState('hover'));
    this._buttonGroup.on(_pointer.default.leave, () => this._setButtonState(this._listShown ? 'focus' : 'default'));
    this._buttonGroup.on(_pointer.default.down + '.export', () => this._setButtonState('active'));
  },
  _unsubscribeEvents() {
    this._renderer.root.off('.export');
    this._listGroup.off();
    this._buttonGroup.off();
  },
  _updateButton() {
    const renderer = this._renderer;
    const options = this._options;
    const exportData = {
      'export-element-type': 'button'
    };
    if (!this._button) {
      this._button = renderer.rect(0, 0, BUTTON_SIZE, BUTTON_SIZE).append(this._buttonGroup);
      this._button.attr({
        rx: 4,
        ry: 4,
        fill: options.button.default.backgroundColor,
        stroke: options.button.default.borderColor,
        'stroke-width': 1,
        cursor: 'pointer'
      });
      this._button.data(exportData);
      this._icon = renderer.path(ICON_COORDS).append(this._buttonGroup);
      this._icon.attr({
        fill: options.button.default.color,
        cursor: 'pointer'
      });
      this._icon.data(exportData);
      this._buttonGroup.setTitle(_message.default.format('vizExport-titleMenuText'));
    }
  },
  _updateList() {
    const options = this._options;
    const buttonDefault = options.button.default;
    const listGroup = this._listGroup;
    const items = createMenuItems(this._renderer, options);
    this._shadow.attr({
      color: options.shadowColor
    });
    this._overlay.attr({
      height: items.length * MENU_ITEM_HEIGHT + LIST_STROKE_WIDTH * 2,
      fill: buttonDefault.backgroundColor,
      stroke: buttonDefault.borderColor
    });
    listGroup.clear();
    this._overlay.append(listGroup);
    items.forEach(item => item.g.append(listGroup));
    this._menuItems = items;
  }
});

// BaseWidget.js
function getExportOptions(widget, exportOptions, fileName, format) {
  if (format || exportOptions.format) {
    format = validateFormat(format || exportOptions.format, widget._incidentOccurred);
  }
  const {
    width,
    height
  } = widget.getSize();
  return {
    format: format || DEFAULT_EXPORT_FORMAT,
    fileName: fileName || exportOptions.fileName || 'file',
    backgroundColor: exportOptions.backgroundColor,
    width,
    height,
    margin: exportOptions.margin,
    svgToCanvas: exportOptions.svgToCanvas,
    exportingAction: widget._createActionByOption('onExporting', {
      excludeValidators: ['disabled']
    }),
    exportedAction: widget._createActionByOption('onExported', {
      excludeValidators: ['disabled']
    }),
    fileSavingAction: widget._createActionByOption('onFileSaving', {
      excludeValidators: ['disabled']
    })
  };
}
const plugin = exports.plugin = {
  name: 'export',
  init() {
    this._exportMenu = new ExportMenu({
      renderer: this._renderer,
      incidentOccurred: this._incidentOccurred,
      print: () => this.print(),
      exportTo: format => this.exportTo(undefined, format)
    });
    this._layout.add(this._exportMenu);
  },
  dispose() {
    this._exportMenu.dispose();
  },
  members: {
    _getExportMenuOptions() {
      return (0, _extend.extend)({}, this._getOption('export'), {
        rtl: this._getOption('rtlEnabled', true)
      });
    },
    _disablePointerEvents() {
      const pointerEventsValue = this._renderer.root.attr('pointer-events');
      this._renderer.root.attr({
        'pointer-events': 'none'
      });
      return pointerEventsValue;
    },
    exportTo(fileName, format) {
      const menu = this._exportMenu;
      const options = getExportOptions(this, this._getOption('export') || {}, fileName, format);
      menu && menu.hide();
      const pointerEventsValue = this._disablePointerEvents();
      const promise = (0, _exporter.export)(this._renderer.root.element, options, getCreatorFunc(options.format)).fail(_console.logger.error).always(() => {
        this._renderer.root.attr({
          'pointer-events': pointerEventsValue
        });
      });
      menu && menu.show();
      return promise;
    },
    print() {
      const menu = this._exportMenu;
      const options = getExportOptions(this, this._getOption('export') || {});
      options.exportingAction = null;
      options.exportedAction = null;
      options.margin = 0;
      options.format = 'PNG';
      options.useBase64 = true;
      options.fileSavingAction = eventArgs => {
        print(`data:image/png;base64,${eventArgs.data}`, {
          width: options.width,
          __test: options.__test
        });
        eventArgs.cancel = true;
      };
      const pointerEventsValue = this._disablePointerEvents();
      menu && menu.hide();
      const promise = (0, _exporter.export)(this._renderer.root.element, options, getCreatorFunc(options.format)).fail(_console.logger.error).always(() => {
        this._renderer.root.attr({
          'pointer-events': pointerEventsValue
        });
      });
      menu && menu.show();
      return promise;
    }
  },
  customize(constructor) {
    const proto = constructor.prototype;
    constructor.addChange({
      code: 'EXPORT',
      handler() {
        this._exportMenu.setOptions(this._getExportMenuOptions());
        this._change(['LAYOUT']);
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'export'
    });

    // TODO: Event options change processing either should be done by the eventTrigger or shouldn't be done at all
    proto._optionChangesMap.onExporting = 'EXPORT';
    proto._optionChangesMap.onExported = 'EXPORT';
    proto._optionChangesMap.onFileSaving = 'EXPORT';
  },
  fontFields: ['export.font']
};

/***/ }),

/***/ 3603:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.changes = changes;
exports.expand = expand;
exports.replaceInherit = void 0;
var _extend2 = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var _common = __webpack_require__(20576);
const isServerSide = !(0, _window.hasWindow)();
function Flags() {
  this.reset();
}
Flags.prototype = {
  constructor: Flags,
  add: function (codes) {
    let i;
    const ii = codes.length;
    const flags = this._flags;
    for (i = 0; i < ii; ++i) {
      flags[codes[i]] = 1;
    }
  },
  has: function (code) {
    return this._flags[code] > 0;
  },
  count: function () {
    return Object.keys(this._flags).length;
  },
  reset: function () {
    this._flags = {};
  }
};
function combineMaps(baseMap, thisMap) {
  return baseMap !== thisMap ? (0, _extend2.extend)({}, baseMap, thisMap) : (0, _extend2.extend)({}, baseMap);
}
function combineLists(baseList, thisList) {
  return baseList !== thisList ? baseList.concat(thisList) : baseList.slice();
}
function buildTotalChanges(proto) {
  proto._totalChangesOrder = proto._optionChangesOrder.concat(proto._layoutChangesOrder, proto._customChangesOrder);
}
function addChange(settings) {
  const proto = this.prototype;
  const code = settings.code;
  proto['_change_' + code] = settings.handler;
  if (settings.isThemeDependent) {
    proto._themeDependentChanges.push(code);
  }
  if (settings.option) {
    proto._optionChangesMap[settings.option] = code;
  }
  (settings.isOptionChange ? proto._optionChangesOrder : proto._customChangesOrder).push(code);
  buildTotalChanges(proto);
}
function createChainExecutor() {
  const executeChain = function () {
    let i;
    const ii = executeChain._chain.length;
    let result;
    for (i = 0; i < ii; ++i) {
      result = executeChain._chain[i].apply(this, arguments);
    }
    return result;
  };
  executeChain._chain = [];
  executeChain.add = function (item) {
    executeChain._chain.push(item);
  };
  executeChain.copy = function (executor) {
    executeChain._chain = executor._chain.slice();
  };
  return executeChain;
}
function expand(target, name, expander) {
  let current = target[name];
  if (!current) {
    current = expander;
  } else {
    if (!current.add) {
      current = createChainExecutor();
      current.add(target[name]);
      current.add(expander);
    } else {
      if (Object.prototype.hasOwnProperty.call(target, name) === false) {
        current = createChainExecutor();
        current.copy(target[name]);
      }
      current.add(expander);
    }
  }
  target[name] = current;
}
function addPlugin(plugin) {
  const proto = this.prototype;
  proto._plugins.push(plugin);
  plugin.fontFields && proto._fontFields.push.apply(proto._fontFields, plugin.fontFields);
  if (plugin.members) {
    (0, _extend2.extend)(this.prototype, plugin.members);
  }
  if (plugin.customize) {
    plugin.customize(this);
  }
  if (plugin.extenders) {
    Object.keys(plugin.extenders).forEach(function (key) {
      const func = plugin.extenders[key];
      expand(proto, key, func);
    }, this);
  }
}
const replaceInherit = exports.replaceInherit = isServerSide ? function (widget) {
  const _inherit = widget.inherit;
  widget.inherit = function () {
    const result = _inherit.apply(this, arguments);
    const proto = result.prototype;
    ['_plugins', '_eventsMap', '_initialChanges', '_themeDependentChanges', '_optionChangesMap', '_optionChangesOrder', '_layoutChangesOrder', '_customChangesOrder', '_totalChangesOrder'].forEach(function (key) {
      proto[key] = {};
    });
    result.addPlugin = _common.noop;
    return result;
  };
  widget.addChange = _common.noop;
  widget.addPlugin = _common.noop;
} : function (widget) {
  const _inherit = widget.inherit;
  widget.inherit = function () {
    let proto = this.prototype;
    const plugins = proto._plugins;
    const fontFields = proto._fontFields;
    const eventsMap = proto._eventsMap;
    const initialChanges = proto._initialChanges;
    const themeDependentChanges = proto._themeDependentChanges;
    const optionChangesMap = proto._optionChangesMap;
    const partialOptionChangesMap = proto._partialOptionChangesMap;
    const partialOptionChangesPath = proto._partialOptionChangesPath;
    const optionChangesOrder = proto._optionChangesOrder;
    const layoutChangesOrder = proto._layoutChangesOrder;
    const customChangesOrder = proto._customChangesOrder;
    const result = _inherit.apply(this, arguments);
    proto = result.prototype;
    proto._plugins = combineLists(plugins, proto._plugins);
    proto._fontFields = combineLists(fontFields, proto._fontFields);
    proto._eventsMap = combineMaps(eventsMap, proto._eventsMap);
    proto._initialChanges = combineLists(initialChanges, proto._initialChanges);
    proto._themeDependentChanges = combineLists(themeDependentChanges, proto._themeDependentChanges);
    proto._optionChangesMap = combineMaps(optionChangesMap, proto._optionChangesMap);
    proto._partialOptionChangesMap = combineMaps(partialOptionChangesMap, proto._partialOptionChangesMap);
    proto._partialOptionChangesPath = combineMaps(partialOptionChangesPath, proto._partialOptionChangesPath);
    proto._optionChangesOrder = combineLists(optionChangesOrder, proto._optionChangesOrder);
    proto._layoutChangesOrder = combineLists(layoutChangesOrder, proto._layoutChangesOrder);
    proto._customChangesOrder = combineLists(customChangesOrder, proto._customChangesOrder);
    buildTotalChanges(proto);
    result.addPlugin = addPlugin;
    return result;
  };
  widget.prototype._plugins = [];
  widget.prototype._fontFields = [];
  widget.addChange = addChange;
  widget.addPlugin = addPlugin;
};
function changes() {
  return new Flags();
}

/***/ }),

/***/ 94551:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
const _min = Math.min;
const _max = Math.max;
const _round = Math.round;
const ALIGN_START = 0;
const ALIGN_MIDDLE = 1;
const ALIGN_END = 2;
const horizontalAlignmentMap = {
  left: ALIGN_START,
  center: ALIGN_MIDDLE,
  right: ALIGN_END
};
const verticalAlignmentMap = {
  top: ALIGN_START,
  center: ALIGN_MIDDLE,
  bottom: ALIGN_END
};
const sideMap = {
  horizontal: 0,
  vertical: 1
};
const slicersMap = {};
const BBOX_CEIL_CORRECTION = 2;
slicersMap[ALIGN_START] = function (a, b, size) {
  return [a, _min(b, a + size)];
};
slicersMap[ALIGN_MIDDLE] = function (a, b, size) {
  return [_max(a, (a + b - size) / 2), _min(b, (a + b + size) / 2)];
};
slicersMap[ALIGN_END] = function (a, b, size) {
  return [_max(a, b - size), b];
};
function pickValue(value, map, defaultValue) {
  const val = (0, _utils.normalizeEnum)(value);
  return val in map ? map[val] : defaultValue;
}
function normalizeLayoutOptions(options) {
  const side = pickValue(options.side, sideMap, 1);
  const alignment = [pickValue(options.horizontalAlignment, horizontalAlignmentMap, ALIGN_MIDDLE), pickValue(options.verticalAlignment, verticalAlignmentMap, ALIGN_START)];
  return {
    side: side,
    primary: bringToEdge(alignment[side]),
    secondary: alignment[1 - side],
    weak: options.weak,
    priority: options.priority || 0,
    header: options.header,
    position: options.position
  };
}
function bringToEdge(primary) {
  return primary < 2 ? 0 : 2;
}
function getConjugateSide(side) {
  return 1 - side;
}
function getSlice(alignment, a, b, size) {
  return slicersMap[alignment](a, b, size);
}
function getShrink(alignment, size) {
  return (alignment > 0 ? -1 : +1) * size;
}
function processForward(item, rect, minSize) {
  const side = item.side;
  const size = item.element.measure([rect[2] - rect[0], rect[3] - rect[1]]);
  const minSide = item.position === 'indside' ? 0 : minSize[side];
  const isValid = size[side] < rect[2 + side] - rect[side] - minSide;
  if (isValid) {
    if (item.position !== 'inside') {
      rect[item.primary + side] += getShrink(item.primary, size[side]);
    }
    item.size = size;
  }
  return isValid;
}
function processRectBackward(item, rect, alignmentRect) {
  const primarySide = item.side;
  const secondarySide = getConjugateSide(primarySide);
  const itemRect = [];
  const secondary = getSlice(item.secondary, alignmentRect[secondarySide], alignmentRect[2 + secondarySide], item.size[secondarySide]);
  itemRect[primarySide] = _round(itemRect[2 + primarySide] = rect[item.primary + primarySide] + (item.position === 'inside' ? getShrink(item.primary, item.size[primarySide]) : 0));
  itemRect[item.primary + primarySide] = _round(rect[item.primary + primarySide] - getShrink(item.primary, item.size[primarySide]));
  if (item.position !== 'inside') {
    rect[item.primary + primarySide] = itemRect[item.primary + primarySide];
  }
  itemRect[secondarySide] = _round(secondary[0]);
  itemRect[2 + secondarySide] = _round(secondary[1]);
  return itemRect;
}
function processBackward(item, rect, alignmentRect, fitRect, size, targetRect) {
  const itemRect = processRectBackward(item, rect, alignmentRect);
  const itemFitRect = processRectBackward(item, fitRect, fitRect);
  if (size[item.side] > 0) {
    size[item.side] -= item.size[item.side];
    targetRect[item.primary + item.side] = itemRect[item.primary + item.side];
    item.element.freeSpace();
  } else {
    item.element.move(itemRect, itemFitRect);
  }
}
function Layout() {
  this._targets = [];
}
Layout.prototype = {
  constructor: Layout,
  dispose: function () {
    this._targets = null;
  },
  add: function (target) {
    this._targets.push(target);
  },
  // Note on possible improvement.
  // "createTargets" part depends on options of a target while the following cycle depends on container size - those areas do not intersect.
  // When any of options are changed targets have to be recreated and cycle has to be executed. But when container size is changed there is no
  // need to recreate targets - only cycle has to be executed.
  forward: function (targetRect, minSize) {
    const rect = targetRect.slice();
    const targets = createTargets(this._targets);
    let i;
    const ii = targets.length;
    const cache = [];
    for (i = 0; i < ii; ++i) {
      if (processForward(targets[i], rect, minSize)) {
        cache.push(targets[i]);
      } else {
        targets[i].element.freeSpace();
      }
    }
    this._cache = cache.reverse();
    return rect;
  },
  backward: function (targetRect, alignmentRect) {
    let size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
    let backwardRect = targetRect.slice();
    const fitRect = targetRect.slice();
    const targets = this._cache;
    let targetSide = 0;
    let target;
    let i;
    const ii = targets.length;
    for (i = 0; i < ii; ++i) {
      target = targets[i];
      if (target.side !== targetSide) {
        backwardRect = targetRect.slice();
      }
      processBackward(target, backwardRect, alignmentRect, fitRect, size, targetRect);
      targetSide = target.side;
    }
    return size;
  }
};
function createTargets(targets) {
  let i;
  const ii = targets.length;
  let collection = [];
  let layout;
  for (i = 0; i < ii; ++i) {
    layout = targets[i].layoutOptions();
    if (layout) {
      layout = normalizeLayoutOptions(layout);
      layout.element = targets[i];
      collection.push(layout);
    }
  }
  collection.sort(function (a, b) {
    return b.side - a.side || a.priority - b.priority;
  });
  collection = processWeakItems(collection);
  return collection;
}
function processWeakItems(collection) {
  const weakItem = collection.filter(function (item) {
    return item.weak === true;
  })[0];
  let headerItem;
  if (weakItem) {
    headerItem = collection.filter(function (item) {
      return weakItem.primary === item.primary && item.side === weakItem.side && item !== weakItem;
    })[0];
  }
  if (weakItem && headerItem) {
    return [makeHeader(headerItem, weakItem)].concat(collection.filter(function (item) {
      return !(item === headerItem || item === weakItem);
    }));
  }
  return collection;
}
function processBackwardHeaderRect(element, rect) {
  const rectCopy = rect.slice();
  const itemRect = processRectBackward(element, rectCopy, rectCopy);
  itemRect[element.side] = rect[element.side];
  itemRect[2 + element.side] = rect[2 + element.side];
  return itemRect;
}
function makeHeader(header, weakElement) {
  const side = header.side;
  const primary = header.primary;
  const secondary = header.secondary;
  return {
    side: side,
    primary: primary,
    secondary: secondary,
    priority: 0,
    element: {
      measure: function (targetSize) {
        const result = targetSize.slice();
        const weakSize = weakElement.element.measure(targetSize.slice());
        targetSize[primary] -= weakSize[primary];
        const headerSize = header.element.measure(targetSize.slice());
        result[side] = weakSize[side] = headerSize[side] = Math.max(headerSize[side], weakSize[side]);
        weakElement.size = weakSize;
        header.size = headerSize;
        return result;
      },
      move: function (rect, fitRect) {
        if (fitRect[2] - fitRect[0] < header.size[0] + weakElement.size[0] - BBOX_CEIL_CORRECTION) {
          this.freeSpace();
          return;
        }
        const weakRect = processBackwardHeaderRect(weakElement, fitRect);
        fitRect[2 + weakElement.primary] = weakRect[weakElement.primary];
        const headerFitReact = processBackwardHeaderRect(header, fitRect);
        if (fitRect[2 + weakElement.primary] < rect[2 + weakElement.primary] && header.size[header.primary] > rect[2 + header.primary] - rect[header.primary]) {
          rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];
        }
        let headerRect = processBackwardHeaderRect(header, rect);
        if (headerRect[2 + weakElement.primary] > fitRect[2 + weakElement.primary]) {
          rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];
          headerRect = processBackwardHeaderRect(header, rect);
        }
        weakElement.element.move(weakRect);
        header.element.move(headerRect, headerFitReact);
      },
      freeSpace: function () {
        header.element.freeSpace();
        weakElement.element.freeSpace();
      }
    }
  };
}
var _default = exports["default"] = Layout;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 73711:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.LayoutElement = LayoutElement;
exports.WrapperLayoutElement = WrapperLayoutElement;
var _common = __webpack_require__(20576);
var _object = __webpack_require__(48013);
const _round = Math.round;
const defaultOffset = {
  horizontal: 0,
  vertical: 0
};
const alignFactors = {
  center: 0.5,
  right: 1,
  bottom: 1,
  left: 0,
  top: 0
};
function LayoutElement(options) {
  this._options = options;
}
LayoutElement.prototype = {
  constructor: LayoutElement,
  position: function (options) {
    const that = this;
    const ofBBox = options.of.getLayoutOptions();
    const myBBox = that.getLayoutOptions();
    const at = options.at;
    const my = options.my;
    const offset = options.offset || defaultOffset;
    const shiftX = -alignFactors[my.horizontal] * myBBox.width + ofBBox.x + alignFactors[at.horizontal] * ofBBox.width + parseInt(offset.horizontal);
    const shiftY = -alignFactors[my.vertical] * myBBox.height + ofBBox.y + alignFactors[at.vertical] * ofBBox.height + parseInt(offset.vertical);
    that.shift(_round(shiftX), _round(shiftY));
  },
  getLayoutOptions: _common.noop
};
function WrapperLayoutElement(renderElement, bBox) {
  this._renderElement = renderElement;
  this._cacheBBox = bBox;
}
const wrapperLayoutElementPrototype = WrapperLayoutElement.prototype = (0, _object.clone)(LayoutElement.prototype);
wrapperLayoutElementPrototype.constructor = WrapperLayoutElement;
wrapperLayoutElementPrototype.getLayoutOptions = function () {
  return this._cacheBBox || this._renderElement.getBBox();
};
wrapperLayoutElementPrototype.shift = function (shiftX, shiftY) {
  const bBox = this.getLayoutOptions();
  this._renderElement.move(_round(shiftX - bBox.x), _round(shiftY - bBox.y));
};

/***/ }),

/***/ 64758:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.LoadingIndicator = void 0;
var _utils = __webpack_require__(19157);
const STATE_HIDDEN = 0;
const STATE_SHOWN = 1;
const ANIMATION_EASING = 'linear';
const ANIMATION_DURATION = 400;
const LOADING_INDICATOR_READY = 'loadingIndicatorReady';
let LoadingIndicator = function (parameters) {
  const that = this;
  const renderer = parameters.renderer;
  that._group = renderer.g().attr({
    'class': 'dx-loading-indicator'
  }).linkOn(renderer.root, {
    name: 'loading-indicator',
    after: 'peripheral'
  });
  that._rect = renderer.rect().attr({
    opacity: 0
  }).append(that._group);
  that._text = renderer.text().attr({
    align: 'center'
  }).append(that._group);
  that._createStates(parameters.eventTrigger, that._group, renderer.root, parameters.notify);
};
exports.LoadingIndicator = LoadingIndicator;
LoadingIndicator.prototype = {
  constructor: LoadingIndicator,
  _createStates: function (eventTrigger, group, root, notify) {
    const that = this;
    that._states = [{
      opacity: 0,
      start: function () {
        notify(false);
      },
      complete: function () {
        group.linkRemove();
        root.css({
          'pointer-events': ''
        });
        eventTrigger(LOADING_INDICATOR_READY);
      }
    }, {
      opacity: 0.85,
      start: function () {
        group.linkAppend();
        root.css({
          'pointer-events': 'none'
        });
        notify(true);
      },
      complete: function () {
        eventTrigger(LOADING_INDICATOR_READY);
      }
    }];
    that._state = STATE_HIDDEN;
  },
  setSize: function (size) {
    const width = size.width;
    const height = size.height;
    this._rect.attr({
      width: width,
      height: height
    });
    this._text.attr({
      x: width / 2,
      y: height / 2
    });
  },
  setOptions: function (options) {
    this._rect.attr({
      fill: options.backgroundColor
    });
    this._text.css((0, _utils.patchFontOptions)(options.font)).attr({
      text: options.text,
      'class': options.cssClass
    });
    this[options.show ? 'show' : 'hide']();
  },
  dispose: function () {
    const that = this;
    that._group.linkRemove().linkOff();
    that._group = that._rect = that._text = that._states = null;
  },
  _transit: function (stateId) {
    const that = this;
    let state;
    if (that._state !== stateId) {
      that._state = stateId;
      that._isHiding = false;
      state = that._states[stateId];
      that._rect.stopAnimation().animate({
        opacity: state.opacity
      }, {
        complete: state.complete,
        easing: ANIMATION_EASING,
        duration: ANIMATION_DURATION,
        unstoppable: true // T261694
      });
      that._noHiding = true;
      state.start();
      that._noHiding = false;
    }
  },
  show: function () {
    this._transit(STATE_SHOWN);
  },
  hide: function () {
    this._transit(STATE_HIDDEN);
  },
  scheduleHiding: function () {
    if (!this._noHiding) {
      this._isHiding = true;
    }
  },
  fulfillHiding: function () {
    if (this._isHiding) {
      this.hide();
    }
  }
};
const plugin = exports.plugin = {
  name: 'loading_indicator',
  init: function () {
    const that = this;
    // "exports" is used for testing purposes.
    that._loadingIndicator = new LoadingIndicator({
      eventTrigger: that._eventTrigger,
      renderer: that._renderer,
      notify: notify
    });
    that._scheduleLoadingIndicatorHiding();
    function notify(state) {
      // This flag is used to suppress redundant `_optionChanged` notifications caused by the mechanism that synchronizes the `loadingIndicator.show` option and the loading indicator visibility
      that._skipLoadingIndicatorOptions = true;
      that.option('loadingIndicator', {
        show: state
      });
      that._skipLoadingIndicatorOptions = false;
      if (state) {
        that._stopCurrentHandling();
      }
    }
  },
  dispose: function () {
    this._loadingIndicator.dispose();
    this._loadingIndicator = null;
  },
  members: {
    _scheduleLoadingIndicatorHiding: function () {
      this._loadingIndicator.scheduleHiding();
    },
    _fulfillLoadingIndicatorHiding: function () {
      this._loadingIndicator.fulfillHiding();
    },
    showLoadingIndicator: function () {
      this._loadingIndicator.show();
    },
    hideLoadingIndicator: function () {
      this._loadingIndicator.hide();
    },
    _onBeginUpdate: function () {
      if (!this._optionChangedLocker) {
        this._scheduleLoadingIndicatorHiding();
      }
    }
  },
  extenders: {
    _dataSourceLoadingChangedHandler(isLoading) {
      if (isLoading && (this._options.silent('loadingIndicator') || {}).enabled) {
        this._loadingIndicator.show();
      }
    },
    _setContentSize() {
      this._loadingIndicator.setSize(this._canvas);
    },
    endUpdate() {
      if (this._initialized && this._dataIsReady()) {
        this._fulfillLoadingIndicatorHiding();
      }
    }
  },
  customize: function (constructor) {
    const proto = constructor.prototype;

    // Of course this looks dirty - but cleaning it is another task. For now it has been just extracted from BaseWidget with minimal changes.
    if (proto._dataSourceChangedHandler) {
      const _dataSourceChangedHandler = proto._dataSourceChangedHandler;
      proto._dataSourceChangedHandler = function () {
        this._scheduleLoadingIndicatorHiding();
        _dataSourceChangedHandler.apply(this, arguments);
      };
    }
    constructor.addChange({
      code: 'LOADING_INDICATOR',
      handler: function () {
        if (!this._skipLoadingIndicatorOptions) {
          this._loadingIndicator.setOptions(this._getOption('loadingIndicator'));
        }
        this._scheduleLoadingIndicatorHiding();
      },
      isThemeDependent: true,
      option: 'loadingIndicator',
      isOptionChange: true
    });
    proto._eventsMap.onLoadingIndicatorReady = {
      name: 'loadingIndicatorReady'
    };
    const _drawn = proto._drawn;
    proto._drawn = function () {
      _drawn.apply(this, arguments);
      if (this._dataIsReady()) {
        this._fulfillLoadingIndicatorHiding();
      }
    };
  },
  fontFields: ['loadingIndicator.font']
};

/***/ }),

/***/ 64509:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Plaque = void 0;
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
const _excluded = ["x", "y", "canvas", "offsetX", "offsetY", "offset"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }
const math = Math;
const round = math.round;
const max = math.max;
const min = math.min;
const sin = math.sin;
const cos = math.cos;
const asin = math.asin;
const PI = math.PI;
const buildPath = function () {
  for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
    points[_key] = arguments[_key];
  }
  return points.join('');
};
function getArc(cornerRadius, xDirection, yDirection) {
  return `a ${cornerRadius} ${cornerRadius} 0 0 1 ${xDirection * cornerRadius} ${yDirection * cornerRadius}`;
}
function getAbsoluteArc(cornerRadius, x, y) {
  return `A ${cornerRadius} ${cornerRadius} 0 0 1 ${x} ${y}`;
}
function rotateX(x, y, angle, x0, y0) {
  return (x - x0) * round(cos(angle)) + (y - y0) * round(sin(angle)) + x0;
}
function rotateY(x, y, angle, x0, y0) {
  return -(x - x0) * round(sin(angle)) + (y - y0) * round(cos(angle)) + y0;
}
function rotateSize(options, angle) {
  if (angle % 90 === 0 && angle % 180 !== 0) {
    return {
      width: options.height,
      height: options.width
    };
  }
  return options;
}
function getCloudAngle(_ref, x, y, anchorX, anchorY) {
  let {
    width,
    height
  } = _ref;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  const xr = Math.ceil(x + halfWidth);
  const xl = Math.floor(x - halfWidth);
  const yt = Math.floor(y - halfHeight);
  const yb = Math.ceil(y + halfHeight);

  // 1 | 2 | 3
  // 8 | 0 | 4
  // 7 | 6 | 5
  if (anchorX < xl && anchorY < yt ||
  // 1
  anchorX >= xl && anchorX <= xr && anchorY < yt // 2
  ) {
    return 270;
  }
  if (anchorX > xr && anchorY > yb ||
  // 5
  anchorX >= xl && anchorX <= xr && anchorY > yb // 6
  ) {
    return 90;
  } else if (anchorX < xl && anchorY > yb ||
  // 7
  anchorX < xl && anchorY >= yt && anchorY <= yb // 8
  ) {
    return 180;
  }
  return 0; // 0, 3, 4
}
function getCloudPoints(_ref2, x, y, anchorX, anchorY, _ref3, bounded) {
  let {
    width,
    height
  } = _ref2;
  let {
    arrowWidth,
    cornerRadius = 0
  } = _ref3;
  const halfArrowWidth = arrowWidth / 2;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  const xr = Math.ceil(x + halfWidth);
  const xl = Math.floor(x - halfWidth);
  const yt = Math.floor(y - halfHeight);
  const yb = Math.ceil(y + halfHeight);
  const leftTopCorner = [xl, yt];
  const rightTopCorner = [xr, yt];
  const rightBottomCorner = [xr, yb];
  const leftBottomCorner = [xl, yb];
  const arrowX = anchorX <= xl ? xl : xr <= anchorX ? xr : anchorX;
  const arrowY = anchorY <= yt ? yt : yb <= anchorY ? yb : anchorY;
  const arrowBaseBottom = min(arrowY + halfArrowWidth, yb);
  const arrowBaseTop = max(arrowY - halfArrowWidth, yt);
  const arrowBaseLeft = max(arrowX - halfArrowWidth, xl);
  cornerRadius = Math.min(width / 2, height / 2, cornerRadius);
  let points;
  leftTopCorner[1] += cornerRadius;
  rightTopCorner[0] -= cornerRadius;
  rightBottomCorner[1] -= cornerRadius;
  leftBottomCorner[0] += cornerRadius;
  // 1 | 2 | 3
  // 8 | 0 | 4
  // 7 | 6 | 5
  if (!bounded || xl <= anchorX && anchorX <= xr && yt <= anchorY && anchorY <= yb) {
    // 0
    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), 'L', rightTopCorner, getArc(cornerRadius, 1, 1), 'L', rightBottomCorner, getArc(cornerRadius, -1, 1), 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  } else if (anchorX > xr && anchorY < yt) {
    // 3
    const arrowAngle = arrowWidth / cornerRadius || 0;
    const angle = PI / 4 + arrowAngle / 2;
    const endAngle = PI / 4 - arrowAngle / 2;
    const arrowEndPointX = rightTopCorner[0] + cos(endAngle) * cornerRadius;
    const arrowEndPointY = rightTopCorner[1] + (1 - sin(endAngle)) * cornerRadius;
    let arrowArc = buildPath('L', rightTopCorner, getArc(cornerRadius, cos(angle), 1 - sin(angle)), 'L', [anchorX, anchorY, arrowEndPointX, arrowEndPointY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius));
    if (Math.abs(angle) > PI / 2) {
      arrowArc = buildPath('L', [arrowBaseLeft, yt, anchorX, anchorY, xr, arrowBaseBottom]);
    }
    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), arrowArc, 'L', rightBottomCorner, getArc(cornerRadius, -1, 1), 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  } else if (anchorX > xr && anchorY >= yt && anchorY <= yb) {
    // 4
    let arrowArc;
    if (arrowBaseTop >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {
      arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', [xr, arrowBaseTop, anchorX, anchorY, xr, arrowBaseBottom], 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {
      const arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;
      const angle = arrowWidthRest / cornerRadius;
      const arrowBaseTopX = rightTopCorner[0] + cos(angle) * cornerRadius;
      const arrowBaseTopY = rightTopCorner[1] + (1 - sin(angle)) * cornerRadius;
      arrowArc = buildPath(getArc(cornerRadius, cos(angle), 1 - sin(angle)), 'L', [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, xr, arrowBaseBottom], 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom < rightTopCorner[1] + cornerRadius) {
      const arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;
      const arrowAngle = arrowWidthRest / cornerRadius;
      const angle = arrowAngle;
      const arrowBaseTopX = rightTopCorner[0] + cos(angle) * cornerRadius;
      const arrowBaseTopY = rightTopCorner[1] + (1 - sin(angle)) * cornerRadius;
      const bottomAngle = Math.sin((rightTopCorner[1] + cornerRadius - arrowBaseBottom) / cornerRadius);
      const arrowBaseBottomX = rightTopCorner[0] + cornerRadius * cos(bottomAngle);
      const arrowBaseBottomY = rightTopCorner[1] + cornerRadius * (1 - sin(bottomAngle));
      arrowArc = buildPath(getArc(cornerRadius, cos(angle), 1 - sin(angle)), 'L', [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius), 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop <= rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightBottomCorner[1]) {
      const topAngle = asin((rightTopCorner[1] + cornerRadius - arrowBaseTop) / cornerRadius);
      const arrowBaseTopX = rightTopCorner[0] + cornerRadius * cos(topAngle);
      const arrowBaseTopY = rightTopCorner[1] + cornerRadius * (1 - sin(topAngle));
      const bottomAngle = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
      const arrowBaseBottomX = rightBottomCorner[0] + cornerRadius * (cos(bottomAngle) - 1);
      const arrowBaseBottomY = rightBottomCorner[1] + cornerRadius * sin(bottomAngle);
      arrowArc = buildPath(getArc(cornerRadius, cos(topAngle), 1 - sin(topAngle)), 'L', [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    } else if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseTop <= rightBottomCorner[1] && arrowBaseBottom > rightBottomCorner[1]) {
      const bottomAngle = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
      const arrowBaseBottomX = rightBottomCorner[0] + cornerRadius * (cos(bottomAngle) - 1);
      const arrowBaseBottomY = rightBottomCorner[1] + cornerRadius * sin(bottomAngle);
      arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', [xr, arrowBaseTop, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    } else if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseBottom > rightBottomCorner[1]) {
      const bottomAngle = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
      const arrowBaseBottomX = rightBottomCorner[0] + cornerRadius * (cos(bottomAngle) - 1);
      const arrowBaseBottomY = rightBottomCorner[1] + cornerRadius * sin(bottomAngle);
      const topAngle = asin((arrowBaseTop - rightBottomCorner[1]) / cornerRadius);
      const arrowBaseTopX = rightBottomCorner[0] + cornerRadius * (cos(topAngle) - 1);
      const arrowBaseTopY = rightBottomCorner[1] + cornerRadius * sin(topAngle);
      arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', rightBottomCorner, getArc(cornerRadius, cos(topAngle) - 1, sin(topAngle)), 'L', [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    }
    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), 'L', rightTopCorner, arrowArc, 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  }
  return buildPath('M', points, 'Z');
}
class Plaque {
  constructor(options, widget, root, contentTemplate) {
    let bounded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    let measureContent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : (_, g) => g.getBBox();
    let moveContentGroup = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : (_, g, x, y) => g.move(x, y);
    this.widget = widget;
    this.options = options;
    this.root = root;
    this.contentTemplate = contentTemplate;
    this.bonded = bounded;
    this.measureContent = measureContent;
    this.moveContentGroup = moveContentGroup;
  }
  draw(_ref4) {
    let {
        x: anchorX,
        y: anchorY,
        canvas = {},
        offsetX,
        offsetY,
        offset = 0
      } = _ref4,
      restProps = _objectWithoutPropertiesLoose(_ref4, _excluded);
    const options = this.options;
    let {
      x,
      y
    } = options;
    const bounds = {
      xl: canvas.left,
      xr: canvas.width - canvas.right,
      width: canvas.width - canvas.right - canvas.left,
      yt: canvas.top,
      yb: canvas.height - canvas.bottom,
      height: canvas.height - canvas.bottom - canvas.top
    };
    if (!((0, _type.isDefined)(anchorX) && (0, _type.isDefined)(anchorY)) && !((0, _type.isDefined)(x) && (0, _type.isDefined)(y))) {
      return false;
    }
    if ((0, _type.isDefined)(anchorX) && (anchorX < bounds.xl || bounds.xr < anchorX || anchorY < bounds.yt || bounds.yb < anchorY)) {
      return false;
    }
    if (!this._root) {
      this._draw();
    }
    const shadowSettings = (0, _extend.extend)({
      x: '-50%',
      y: '-50%',
      width: '200%',
      height: '200%'
    }, options.shadow);
    const contentWidth = options.width > 0 ? options.width : null;
    const contentHeight = options.height > 0 ? options.height : null;
    const onRender = () => {
      var _this$_root;
      const bBox = this._contentBBox = this.measureContent(this.widget, this._contentGroup);
      const size = this._size = {
        width: max(contentWidth, bBox.width) + options.paddingLeftRight * 2,
        height: max(contentHeight, bBox.height) + options.paddingTopBottom * 2,
        offset
      };
      const xOff = shadowSettings.offsetX;
      const yOff = shadowSettings.offsetY;
      const blur = shadowSettings.blur * 2 + 1;
      const lm = max(blur - xOff, 0); // left margin
      const rm = max(blur + xOff, 0); // right margin
      const tm = max(blur - yOff, 0); // top margin
      const bm = max(blur + yOff, 0); // bottom margin

      this.margins = {
        lm,
        rm,
        tm,
        bm
      };
      if (!(0, _type.isDefined)(x)) {
        if ((0, _type.isDefined)(offsetX)) {
          x = anchorX + offsetX;
        } else {
          if (bounds.width < size.width) {
            x = round(bounds.xl + bounds.width / 2);
          } else {
            x = min(max(anchorX, Math.ceil(bounds.xl + size.width / 2 + lm)), Math.floor(bounds.xr - size.width / 2 - rm));
          }
        }
      } else {
        x += offsetX || 0;
        if (!(0, _type.isDefined)(anchorX)) {
          anchorX = x;
        }
      }
      if (!(0, _type.isDefined)(y)) {
        if ((0, _type.isDefined)(offsetY)) {
          y = anchorY + offsetY;
        } else {
          const y_top = anchorY - options.arrowLength - size.height / 2 - offset;
          const y_bottom = anchorY + options.arrowLength + size.height / 2 + offset;
          if (bounds.height < size.height + options.arrowLength) {
            y = round(bounds.yt + size.height / 2);
          } else if (y_top - size.height / 2 - tm < bounds.yt) {
            if (y_bottom + size.height / 2 + bm < bounds.yb) {
              y = y_bottom;
              anchorY += offset;
            } else {
              y = round(bounds.yt + size.height / 2);
            }
          } else {
            y = y_top;
            anchorY -= offset;
          }
        }
      } else {
        y += offsetY || 0;
        if (!(0, _type.isDefined)(anchorY)) {
          anchorY = y + size.height / 2;
        }
      }
      this.anchorX = anchorX;
      this.anchorY = anchorY;
      this.move(x, y);
      (_this$_root = this._root) === null || _this$_root === void 0 || _this$_root.append(this.root);
    };
    if (this.contentTemplate.render) {
      this.contentTemplate.render({
        model: options,
        container: this._contentGroup.element,
        onRendered: onRender
      });
    } else {
      return this.contentTemplate(_extends({
        group: this._contentGroup,
        onRender
      }, restProps));
    }
    return true;
  }
  _draw() {
    const renderer = this.widget._renderer;
    const options = this.options;
    const shadowSettings = (0, _extend.extend)({
      x: '-50%',
      y: '-50%',
      width: '200%',
      height: '200%'
    }, options.shadow);
    const shadow = this._shadow = renderer.shadowFilter().attr(shadowSettings);
    const cloudSettings = {
      opacity: options.opacity,
      'stroke-width': 0,
      fill: options.color
    };
    const borderOptions = options.border || {};
    if (borderOptions.visible) {
      (0, _extend.extend)(cloudSettings, {
        'stroke-width': borderOptions.width,
        stroke: borderOptions.color,
        'stroke-opacity': borderOptions.opacity,
        dashStyle: borderOptions.dashStyle
      });
    }
    const group = this._root = renderer.g().append(this.root);
    if (options.type) {
      group.attr({
        class: `dxc-${options.type}-annotation`
      });
    }
    const cloudGroup = renderer.g().attr({
      filter: shadow.id
    }).append(group);
    this._cloud = renderer.path([], 'area').attr(cloudSettings).sharp().append(cloudGroup);
    this._contentGroup = renderer.g().append(group);
  }
  getBBox() {
    const size = this._size || {};
    const margins = this.margins || {};
    const rotationAngle = getCloudAngle(size, this.x, this.y, this.anchorX, this.anchorY);
    return {
      x: Math.floor(this.x - size.width / 2 - margins.lm),
      y: Math.floor(this.y - size.height / 2 - margins.tm - (rotationAngle === 270 ? this.options.arrowLength : 0)),
      width: size.width + margins.lm + margins.rm,
      height: size.height + margins.tm + margins.bm + (rotationAngle === 90 || rotationAngle === 270 ? this.options.arrowLength : 0)
    };
  }
  clear() {
    if (this._root) {
      this._root.remove();
      this._shadow.remove();
      this._root = null;
    }
    return this;
  }
  customizeCloud(attr) {
    if (this._cloud) {
      this._cloud.attr(attr);
    }
  }
  moveRoot(x, y) {
    if (this._root) {
      this._root.move(x, y);
    }
  }
  move(x, y) {
    x = round(x);
    y = round(y);
    this.x = x;
    this.y = y;
    const rotationAngle = getCloudAngle(this._size, x, y, this.anchorX, this.anchorY);
    const radRotationAngle = rotationAngle * PI / 180;
    this._cloud.attr({
      d: getCloudPoints(rotateSize(this._size, rotationAngle), x, y, rotateX(this.anchorX, this.anchorY, radRotationAngle, x, y), rotateY(this.anchorX, this.anchorY, radRotationAngle, x, y), this.options, this.bonded)
    }).rotate(rotationAngle, x, y);
    this.moveContentGroup(this.widget, this._contentGroup, x - this._contentBBox.x - this._contentBBox.width / 2, y - this._contentBBox.y - this._contentBBox.height / 2);
  }
  hitTest(x, y) {
    const {
      width,
      height
    } = this._size || {};
    return Math.abs(x - this.x) <= width / 2 && Math.abs(y - this.y) <= height / 2;
  }
}
exports.Plaque = Plaque;

/***/ }),

/***/ 91577:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.AnimationController = AnimationController;
exports.easingFunctions = exports.animationSvgStep = void 0;
var _frame = __webpack_require__(90057);
const noop = function () {};
const easingFunctions = exports.easingFunctions = {
  easeOutCubic: function (pos, start, end) {
    return pos === 1 ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start;
  },
  linear: function (pos, start, end) {
    return pos === 1 ? end : pos * (end - start) + +start;
  }
};
const animationSvgStep = exports.animationSvgStep = {
  segments: function (elem, params, progress, easing, currentParams) {
    const from = params.from;
    const to = params.to;
    let curSeg;
    let seg;
    let i;
    let j;
    const segments = [];
    for (i = 0; i < from.length; i++) {
      curSeg = from[i];
      seg = [curSeg[0]];
      if (curSeg.length > 1) {
        for (j = 1; j < curSeg.length; j++) {
          seg.push(easing(progress, curSeg[j], to[i][j]));
        }
      }
      segments.push(seg);
    }
    currentParams.segments = params.end && progress === 1 ? params.end : segments;
    elem.attr({
      segments: segments
    });
  },
  arc: function (elem, params, progress, easing) {
    const from = params.from;
    const to = params.to;
    const current = {};
    for (const i in from) {
      current[i] = easing(progress, from[i], to[i]);
    }
    elem.attr(current);
  },
  transform: function (elem, params, progress, easing, currentParams) {
    const from = params.from;
    const to = params.to;
    const current = {};
    for (const i in from) {
      current[i] = currentParams[i] = easing(progress, from[i], to[i]);
    }
    elem.attr(current);
  },
  base: function (elem, params, progress, easing, currentParams, attributeName) {
    const obj = {};
    obj[attributeName] = currentParams[attributeName] = easing(progress, params.from, params.to);
    elem.attr(obj);
  },
  _: noop,
  complete: function (element, currentSettings) {
    element.attr(currentSettings);
  }
};
function step(now) {
  const that = this;
  const animateStep = that._animateStep;
  let attrName;
  that._progress = that._calcProgress(now);
  for (attrName in that.params) {
    const anim = animateStep[attrName] || animateStep.base;
    anim(that.element, that.params[attrName], that._progress, that._easing, that._currentParams, attrName);
  }
  that.options.step && that.options.step(that._easing(that._progress, 0, 1), that._progress);
  if (that._progress === 1) return that.stop();
  return true;
}
function delayTick(now) {
  if (now - this._startTime >= this.delay) {
    this.tick = step;
  }
  return true;
}
function start(now) {
  this._startTime = now;
  this.tick = this.delay ? delayTick : step;
  return true;
}
function Animation(element, params, options) {
  const that = this;
  that._progress = 0;
  that.element = element;
  that.params = params;
  that.options = options;
  that.duration = options.partitionDuration ? options.duration * options.partitionDuration : options.duration;
  that.delay = options.delay && options.duration * options.delay || 0;
  that._animateStep = options.animateStep || animationSvgStep;
  that._easing = easingFunctions[options.easing] || easingFunctions['easeOutCubic'];
  that._currentParams = {};
  that.tick = start;
}
Animation.prototype = {
  _calcProgress: function (now) {
    return Math.min(1, (now - this.delay - this._startTime) / this.duration);
  },
  stop: function (disableComplete) {
    const that = this;
    const options = that.options;
    const animateStep = that._animateStep;
    that.stop = that.tick = noop;
    animateStep.complete && animateStep.complete(that.element, that._currentParams);
    options.complete && !disableComplete && options.complete();
  }
};
function AnimationController(element) {
  const that = this;
  that._animationCount = 0;
  that._timerId = null;
  that._animations = {};
  that.element = element;
}
AnimationController.prototype = {
  _loop: function () {
    const that = this;
    const animations = that._animations;
    let activeAnimation = 0;
    const now = new Date().getTime();
    let an;
    const endAnimation = that._endAnimation;
    for (an in animations) {
      if (!animations[an].tick(now)) {
        delete animations[an];
      }
      activeAnimation++;
    }
    if (activeAnimation === 0) {
      that.stop();
      that._endAnimationTimer = endAnimation && setTimeout(function () {
        if (that._animationCount === 0) {
          endAnimation();
          that._endAnimation = null;
        }
      });
      return;
    }
    that._timerId = _frame.requestAnimationFrame.call(null, function () {
      that._loop();
    }, that.element);
  },
  addAnimation: function (animation) {
    const that = this;
    that._animations[that._animationCount++] = animation;
    clearTimeout(that._endAnimationTimer);
    if (!that._timerId) {
      clearTimeout(that._startDelay);
      that._startDelay = setTimeout(function () {
        that._timerId = 1;
        that._loop();
      }, 0);
    }
  },
  animateElement: function (elem, params, options) {
    if (elem && params && options) {
      elem.animation && elem.animation.stop();
      this.addAnimation(elem.animation = new Animation(elem, params, options));
    }
  },
  onEndAnimation: function (endAnimation) {
    this._animationCount ? this._endAnimation = endAnimation : endAnimation();
  },
  dispose: function () {
    this.stop();
    this.element = null;
  },
  stop: function () {
    const that = this;
    that._animations = {};
    that._animationCount = 0;
    (0, _frame.cancelAnimationFrame)(that._timerId);
    clearTimeout(that._startDelay);
    clearTimeout(that._endAnimationTimer);
    that._timerId = null;
  },
  lock: function () {
    let an;
    const animations = this._animations;
    let unstoppable; // T261694
    let hasUnstoppableInAnimations;
    for (an in animations) {
      unstoppable = animations[an].options.unstoppable;
      hasUnstoppableInAnimations = hasUnstoppableInAnimations || unstoppable;
      if (!unstoppable) {
        animations[an].stop(true);
        delete animations[an];
      }
    }
    !hasUnstoppableInAnimations && this.stop();
  }
};

/***/ }),

/***/ 56453:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.RectSvgElement = exports.PathSvgElement = exports.ArcSvgElement = void 0;
exports.Renderer = Renderer;
exports.TextSvgElement = exports.SvgElement = void 0;
exports.getFuncIri = getFuncIri;
exports.processHatchingAttrs = processHatchingAttrs;
exports.refreshPaths = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _svg = __webpack_require__(19155);
var _animation = __webpack_require__(91577);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = (0, _window.getWindow)();
const {
  max,
  round
} = Math;
const SHARPING_CORRECTION = 0.5;
const ARC_COORD_PREC = 5;
const LIGHTENING_HASH = '@filter::lightening';
const pxAddingExceptions = {
  'column-count': true,
  'fill-opacity': true,
  'flex-grow': true,
  'flex-shrink': true,
  'font-weight': true,
  'line-height': true,
  'opacity': true,
  'order': true,
  'orphans': true,
  'widows': true,
  'z-index': true,
  'zoom': true
};
const KEY_TEXT = 'text';
const KEY_STROKE = 'stroke';
const KEY_STROKE_WIDTH = 'stroke-width';
const KEY_STROKE_OPACITY = 'stroke-opacity';
const KEY_FONT_SIZE = 'font-size';
const KEY_FONT_STYLE = 'font-style';
const KEY_FONT_WEIGHT = 'font-weight';
const KEY_TEXT_DECORATION = 'text-decoration';
const KEY_TEXTS_ALIGNMENT = 'textsAlignment';
const NONE = 'none';
const DEFAULT_FONT_SIZE = 12;
const ELLIPSIS = '...';
const objectCreate = function () {
  if (!Object.create) {
    return function (proto) {
      const F = function () {};
      F.prototype = proto;
      return new F();
    };
  } else {
    return function (proto) {
      return Object.create(proto);
    };
  }
}();
const DEFAULTS = {
  scaleX: 1,
  scaleY: 1,
  'pointer-events': null
};
const getBackup = (0, _call_once.default)(function () {
  const backupContainer = _dom_adapter.default.createElement('div');
  const backupCounter = 0;
  backupContainer.style.left = '-9999px';
  backupContainer.style.position = 'absolute';
  return {
    backupContainer: backupContainer,
    backupCounter: backupCounter
  };
});
function backupRoot(root) {
  if (getBackup().backupCounter === 0) {
    _dom_adapter.default.getBody().appendChild(getBackup().backupContainer);
  }
  ++getBackup().backupCounter;
  root.append({
    element: getBackup().backupContainer
  });
}
function restoreRoot(root, container) {
  root.append({
    element: container
  });
  --getBackup().backupCounter;
  if (getBackup().backupCounter === 0) {
    _dom_adapter.default.getBody().removeChild(getBackup().backupContainer);
  }
}
function isObjectArgument(value) {
  return value && typeof value !== 'string';
}
function createElement(tagName) {
  return _dom_adapter.default.createElementNS('http://www.w3.org/2000/svg', tagName);
}
function getFuncIri(id, pathModified) {
  return id !== null ? 'url(' + (pathModified ? window.location.href.split('#')[0] : '') + '#' + id + ')' : id;
}
function extend(target, source) {
  let key;
  for (key in source) {
    target[key] = source[key];
  }
  return target;
}
const preserveAspectRatioMap = {
  'full': NONE,
  'lefttop': 'xMinYMin',
  'leftcenter': 'xMinYMid',
  'leftbottom': 'xMinYMax',
  'centertop': 'xMidYMin',
  'center': 'xMidYMid',
  'centerbottom': 'xMidYMax',
  'righttop': 'xMaxYMin',
  'rightcenter': 'xMaxYMid',
  'rightbottom': 'xMaxYMax'
};
function processHatchingAttrs(element, attrs) {
  if (attrs.hatching && (0, _utils.normalizeEnum)(attrs.hatching.direction) !== 'none') {
    attrs = extend({}, attrs);
    attrs.fill = element._hatching = element.renderer.lockDefsElements({
      color: attrs.fill,
      hatching: attrs.hatching
    }, element._hatching, 'pattern');
    delete attrs.filter;
  } else if (element._hatching) {
    element.renderer.releaseDefsElements(element._hatching);
    element._hatching = null;
    delete attrs.filter;
  } else if (attrs.filter) {
    attrs = extend({}, attrs);
    attrs.filter = element._filter = element.renderer.lockDefsElements({}, element._filter, 'filter');
  } else if (element._filter) {
    element.renderer.releaseDefsElements(element._filter);
    element._filter = null;
  }
  delete attrs.hatching;
  return attrs;
}

//
// Build path segments
//

const buildArcPath = function (x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag) {
  return ['M', (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC), 'A', outerR.toFixed(ARC_COORD_PREC), outerR.toFixed(ARC_COORD_PREC), 0, longFlag, 0, (x + outerR * endAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * endAngleSin).toFixed(ARC_COORD_PREC), isCircle ? 'M' : 'L', (x + innerR * endAngleCos).toFixed(5), (y - innerR * endAngleSin).toFixed(ARC_COORD_PREC), 'A', innerR.toFixed(ARC_COORD_PREC), innerR.toFixed(ARC_COORD_PREC), 0, longFlag, 1, (x + innerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - innerR * startAngleSin).toFixed(ARC_COORD_PREC), 'Z'].join(' ');
};
function buildPathSegments(points, type) {
  let list = [['M', 0, 0]];
  switch (type) {
    case 'line':
      list = buildLineSegments(points);
      break;
    case 'area':
      list = buildLineSegments(points, true);
      break;
    case 'bezier':
      list = buildCurveSegments(points);
      break;
    case 'bezierarea':
      list = buildCurveSegments(points, true);
      break;
  }
  return list;
}
function buildLineSegments(points, close) {
  return buildSegments(points, buildSimpleLineSegment, close);
}
function buildCurveSegments(points, close) {
  return buildSegments(points, buildSimpleCurveSegment, close);
}
function buildSegments(points, buildSimpleSegment, close) {
  var _points$;
  let i;
  let ii;
  const list = [];
  if ((_points$ = points[0]) !== null && _points$ !== void 0 && _points$.length) {
    for (i = 0, ii = points.length; i < ii; ++i) {
      buildSimpleSegment(points[i], close, list);
    }
  } else {
    buildSimpleSegment(points, close, list);
  }
  return list;
}
function buildSimpleLineSegment(points, close, list) {
  let i = 0;
  const k0 = list.length;
  let k = k0;
  const ii = (points || []).length;
  if (ii) {
    // backward compatibility
    if (points[0].x !== undefined) {
      for (; i < ii;) {
        list[k++] = ['L', points[i].x, points[i++].y];
      }
    } else {
      for (; i < ii;) {
        list[k++] = ['L', points[i++], points[i++]];
      }
    }
    list[k0][0] = 'M';
  } else {
    list[k] = ['M', 0, 0];
  }
  close && list.push(['Z']);
  return list;
}
function buildSimpleCurveSegment(points, close, list) {
  let i;
  let k = list.length;
  const ii = (points || []).length;
  if (ii) {
    // backward compatibility
    if (points[0].x !== undefined) {
      list[k++] = ['M', points[0].x, points[0].y];
      for (i = 1; i < ii;) {
        list[k++] = ['C', points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y];
      }
    } else {
      list[k++] = ['M', points[0], points[1]];
      for (i = 2; i < ii;) {
        list[k++] = ['C', points[i++], points[i++], points[i++], points[i++], points[i++], points[i++]];
      }
    }
  } else {
    list[k] = ['M', 0, 0];
  }
  close && list.push(['Z']);
  return list;
}
function combinePathParam(segments) {
  const d = [];
  let k = 0;
  let i;
  const ii = segments.length;
  let segment;
  let j;
  let jj;
  for (i = 0; i < ii; ++i) {
    segment = segments[i];
    for (j = 0, jj = segment.length; j < jj; ++j) {
      d[k++] = segment[j];
    }
  }
  return d.join(' ');
}
function compensateSegments(oldSegments, newSegments, type) {
  const oldLength = oldSegments.length;
  const newLength = newSegments.length;
  let i;
  let originalNewSegments;
  const makeEqualSegments = type.indexOf('area') !== -1 ? makeEqualAreaSegments : makeEqualLineSegments;
  if (oldLength === 0) {
    for (i = 0; i < newLength; i++) {
      oldSegments.push(newSegments[i].slice(0));
    }
  } else if (oldLength < newLength) {
    makeEqualSegments(oldSegments, newSegments, type);
  } else if (oldLength > newLength) {
    originalNewSegments = newSegments.slice(0);
    makeEqualSegments(newSegments, oldSegments, type);
  }
  return originalNewSegments;
}
function prepareConstSegment(constSeg, type) {
  const x = constSeg[constSeg.length - 2];
  const y = constSeg[constSeg.length - 1];
  switch (type) {
    case 'line':
    case 'area':
      constSeg[0] = 'L';
      break;
    case 'bezier':
    case 'bezierarea':
      constSeg[0] = 'C';
      constSeg[1] = constSeg[3] = constSeg[5] = x;
      constSeg[2] = constSeg[4] = constSeg[6] = y;
      break;
  }
}
function makeEqualLineSegments(short, long, type) {
  const constSeg = short[short.length - 1].slice();
  let i = short.length;
  prepareConstSegment(constSeg, type);
  for (; i < long.length; i++) {
    short[i] = constSeg.slice(0);
  }
}
function makeEqualAreaSegments(short, long, type) {
  let i;
  let head;
  const shortLength = short.length;
  const longLength = long.length;
  let constsSeg1;
  let constsSeg2;
  if ((shortLength - 1) % 2 === 0 && (longLength - 1) % 2 === 0) {
    i = (shortLength - 1) / 2 - 1;
    head = short.slice(0, i + 1);
    constsSeg1 = head[head.length - 1].slice(0);
    constsSeg2 = short.slice(i + 1)[0].slice(0);
    prepareConstSegment(constsSeg1, type);
    prepareConstSegment(constsSeg2, type);
    for (let j = i; j < (longLength - 1) / 2 - 1; j++) {
      short.splice(j + 1, 0, constsSeg1);
      short.splice(j + 3, 0, constsSeg2);
    }
  }
}
function baseCss(that, styles) {
  const elemStyles = that._styles;
  let key;
  let value;
  styles = styles || {};
  for (key in styles) {
    value = styles[key];
    if ((0, _type.isDefined)(value)) {
      value += typeof value === 'number' && !pxAddingExceptions[key] ? 'px' : '';
      elemStyles[key] = value !== '' ? value : null;
    }
  }
  // NOTE: Seems that [].concat is not faster when there are only few entries in the `styles` (and in most cases there are few of them)
  for (key in elemStyles) {
    // The alternative is to *delete* entries in the previous cycle, but it is *delete*!
    value = elemStyles[key];
    if (value) {
      that.element.style[key] = value;
    } else if (value === null) {
      that.element.style[key] = '';
    }
  }
  return that;
}
function fixFuncIri(wrapper, attribute) {
  const element = wrapper.element;
  const id = wrapper.attr(attribute);
  if (id && id.indexOf('DevExpress') !== -1) {
    element.removeAttribute(attribute);
    element.setAttribute(attribute, getFuncIri(id, wrapper.renderer.pathModified));
  }
}
function baseAttr(that, attrs) {
  attrs = attrs || {};
  const settings = that._settings;
  const attributes = {};
  let key;
  let value;
  const elem = that.element;
  const renderer = that.renderer;
  const rtl = renderer.rtl;
  let hasTransformations;
  let recalculateDashStyle;
  let sw;
  let i;
  if (!isObjectArgument(attrs)) {
    if (attrs in settings) {
      return settings[attrs];
    }
    if (attrs in DEFAULTS) {
      return DEFAULTS[attrs];
    }
    return 0;
  }
  extend(attributes, attrs);
  for (key in attributes) {
    value = attributes[key];
    if (value === undefined) {
      continue;
    }
    settings[key] = value;
    if (key === 'align') {
      key = 'text-anchor';
      value = {
        left: rtl ? 'end' : 'start',
        center: 'middle',
        right: rtl ? 'start' : 'end'
      }[value] || null;
    } else if (key === 'dashStyle') {
      recalculateDashStyle = true;
      continue;
    } else if (key === KEY_STROKE_WIDTH) {
      recalculateDashStyle = true;
    } else if (value && (key === 'fill' || key === 'clip-path' || key === 'filter') && value.indexOf('DevExpress') === 0) {
      that._addFixIRICallback();
      value = getFuncIri(value, renderer.pathModified);
    } else if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y)|sharp|sharpDirection)$/i.test(key)) {
      hasTransformations = true;
      continue;
    } else if (/^(x|y|d)$/i.test(key)) {
      // TODO test it
      hasTransformations = true;
    }
    if (value === null) {
      elem.removeAttribute(key);
    } else {
      elem.setAttribute(key, value);
    }
  }
  if (recalculateDashStyle && 'dashStyle' in settings) {
    value = settings.dashStyle;
    sw = ('_originalSW' in that ? that._originalSW : settings[KEY_STROKE_WIDTH]) || 1;
    key = 'stroke-dasharray';
    value = value === null ? '' : (0, _utils.normalizeEnum)(value);
    if (value === '' || value === 'solid' || value === NONE) {
      that.element.removeAttribute(key);
    } else {
      value = value.replace(/longdash/g, '8,3,').replace(/dash/g, '4,3,').replace(/dot/g, '1,3,').replace(/,$/, '').split(',');
      i = value.length;
      while (i--) {
        value[i] = parseInt(value[i]) * sw;
      }
      that.element.setAttribute(key, value.join(','));
    }
  }
  if (hasTransformations) {
    that._applyTransformation();
  }
  return that;
}
function pathAttr(attrs) {
  const that = this;
  let segments;
  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);
    segments = attrs.segments;
    if ('points' in attrs) {
      segments = buildPathSegments(attrs.points, that.type);
      delete attrs.points;
    }
    if (segments) {
      attrs.d = combinePathParam(segments);
      that.segments = segments;
      delete attrs.segments;
    }
  }
  return baseAttr(that, attrs);
}
function arcAttr(attrs) {
  const settings = this._settings;
  let x;
  let y;
  let innerRadius;
  let outerRadius;
  let startAngle;
  let endAngle;
  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);
    if ('x' in attrs || 'y' in attrs || 'innerRadius' in attrs || 'outerRadius' in attrs || 'startAngle' in attrs || 'endAngle' in attrs) {
      settings.x = x = 'x' in attrs ? attrs.x : settings.x;
      delete attrs.x;
      settings.y = y = 'y' in attrs ? attrs.y : settings.y;
      delete attrs.y;
      settings.innerRadius = innerRadius = 'innerRadius' in attrs ? attrs.innerRadius : settings.innerRadius;
      delete attrs.innerRadius;
      settings.outerRadius = outerRadius = 'outerRadius' in attrs ? attrs.outerRadius : settings.outerRadius;
      delete attrs.outerRadius;
      settings.startAngle = startAngle = 'startAngle' in attrs ? attrs.startAngle : settings.startAngle;
      delete attrs.startAngle;
      settings.endAngle = endAngle = 'endAngle' in attrs ? attrs.endAngle : settings.endAngle;
      delete attrs.endAngle;
      attrs.d = buildArcPath.apply(null, (0, _utils.normalizeArcParams)(x, y, innerRadius, outerRadius, startAngle, endAngle));
    }
  }
  return baseAttr(this, attrs);
}
function rectAttr(attrs) {
  const that = this;
  let x;
  let y;
  let width;
  let height;
  let sw;
  let maxSW;
  let newSW;
  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);
    if (attrs.x !== undefined || attrs.y !== undefined || attrs.width !== undefined || attrs.height !== undefined || attrs[KEY_STROKE_WIDTH] !== undefined) {
      attrs.x !== undefined ? x = that._originalX = attrs.x : x = that._originalX || 0;
      attrs.y !== undefined ? y = that._originalY = attrs.y : y = that._originalY || 0;
      attrs.width !== undefined ? width = that._originalWidth = attrs.width : width = that._originalWidth || 0;
      attrs.height !== undefined ? height = that._originalHeight = attrs.height : height = that._originalHeight || 0;
      attrs[KEY_STROKE_WIDTH] !== undefined ? sw = that._originalSW = attrs[KEY_STROKE_WIDTH] : sw = that._originalSW;
      maxSW = ~~((width < height ? width : height) / 2);
      newSW = (sw || 0) < maxSW ? sw || 0 : maxSW;
      attrs.x = x + newSW / 2;
      attrs.y = y + newSW / 2;
      attrs.width = width - newSW;
      attrs.height = height - newSW;
      ((sw || 0) !== newSW || !(newSW === 0 && sw === undefined)) && (attrs[KEY_STROKE_WIDTH] = newSW);
    }
    if ('sharp' in attrs) {
      delete attrs.sharp;
    }
  }
  return baseAttr(that, attrs);
}
function textAttr(attrs) {
  const that = this;
  let isResetRequired;
  if (!isObjectArgument(attrs)) {
    return baseAttr(that, attrs);
  }
  attrs = extend({}, attrs);
  const settings = that._settings;
  const wasStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);
  if (attrs[KEY_TEXT] !== undefined) {
    settings[KEY_TEXT] = attrs[KEY_TEXT];
    delete attrs[KEY_TEXT];
    isResetRequired = true;
  }
  if (attrs[KEY_STROKE] !== undefined) {
    settings[KEY_STROKE] = attrs[KEY_STROKE];
    delete attrs[KEY_STROKE];
  }
  if (attrs[KEY_STROKE_WIDTH] !== undefined) {
    settings[KEY_STROKE_WIDTH] = attrs[KEY_STROKE_WIDTH];
    delete attrs[KEY_STROKE_WIDTH];
  }
  if (attrs[KEY_STROKE_OPACITY] !== undefined) {
    settings[KEY_STROKE_OPACITY] = attrs[KEY_STROKE_OPACITY];
    delete attrs[KEY_STROKE_OPACITY];
  }
  if (attrs[KEY_TEXTS_ALIGNMENT] !== undefined) {
    alignTextNodes(that, attrs[KEY_TEXTS_ALIGNMENT]);
    delete attrs[KEY_TEXTS_ALIGNMENT];
  }
  const isStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);
  baseAttr(that, attrs);
  isResetRequired = isResetRequired || isStroked !== wasStroked && settings[KEY_TEXT];
  if (isResetRequired) {
    createTextNodes(that, settings.text, isStroked);
    that._hasEllipsis = false;
  }
  if (isResetRequired || attrs['x'] !== undefined || attrs['y'] !== undefined) {
    locateTextNodes(that);
  }
  if (isStroked) {
    strokeTextNodes(that);
  }
  return that;
}
function textCss(styles) {
  styles = styles || {};
  baseCss(this, styles);
  if (KEY_FONT_SIZE in styles) {
    locateTextNodes(this);
  }
  return this;
}
function orderHtmlTree(list, line, node, parentStyle, parentClassName) {
  let style;
  let realStyle;
  let i;
  let ii;
  let nodes;
  if (node.wholeText !== undefined) {
    list.push({
      value: node.wholeText,
      style: parentStyle,
      className: parentClassName /* EXPERIMENTAL */,
      line: line,
      height: parentStyle[KEY_FONT_SIZE] || 0
    });
  } else if (node.tagName === 'BR') {
    ++line;
  } else if (_dom_adapter.default.isElementNode(node)) {
    extend(style = {}, parentStyle);
    switch (node.tagName) {
      case 'B':
      case 'STRONG':
        style[KEY_FONT_WEIGHT] = 'bold';
        break;
      case 'I':
      case 'EM':
        style[KEY_FONT_STYLE] = 'italic';
        break;
      case 'U':
        style[KEY_TEXT_DECORATION] = 'underline';
        break;
    }
    realStyle = node.style;
    realStyle.color && (style.fill = realStyle.color);
    realStyle.fontSize && (style[KEY_FONT_SIZE] = realStyle.fontSize);
    realStyle.fontStyle && (style[KEY_FONT_STYLE] = realStyle.fontStyle);
    realStyle.fontWeight && (style[KEY_FONT_WEIGHT] = realStyle.fontWeight);
    realStyle.textDecoration && (style[KEY_TEXT_DECORATION] = realStyle.textDecoration);
    for (i = 0, nodes = node.childNodes, ii = nodes.length; i < ii; ++i) {
      line = orderHtmlTree(list, line, nodes[i], style, node.className || parentClassName);
    }
  }
  return line;
}
function adjustLineHeights(items) {
  let i;
  let ii;
  let currentItem = items[0];
  let item;
  for (i = 1, ii = items.length; i < ii; ++i) {
    item = items[i];
    if (item.line === currentItem.line) {
      // T177039
      currentItem.height = maxLengthFontSize(currentItem.height, item.height);
      currentItem.inherits = currentItem.inherits || parseFloat(item.height) === 0;
      item.height = NaN;
    } else {
      currentItem = item;
    }
  }
}
function removeExtraAttrs(html) {
  const findTagAttrs = /(?:(<[a-z0-9]+\s*))([\s\S]*?)(>|\/>)/gi;
  const findStyleAndClassAttrs = /(style|class)\s*=\s*(["'])(?:(?!\2).)*\2\s?/gi;
  return html.replace(findTagAttrs, function (allTagAttrs, p1, p2, p3) {
    p2 = (p2 && p2.match(findStyleAndClassAttrs) || []).map(function (str) {
      return str;
    }).join(' ');
    return p1 + p2 + p3;
  });
}
function parseHTML(text) {
  const items = [];
  const div = _dom_adapter.default.createElement('div');
  div.innerHTML = text.replace(/\r/g, '').replace(/\n/g, '<br/>').replace(/style=/g, 'data-style=');
  div.querySelectorAll('[data-style]').forEach(element => {
    element.style = element.getAttribute('data-style');
    element.removeAttribute('data-style');
  });
  orderHtmlTree(items, 0, div, {}, '');
  adjustLineHeights(items);
  return items;
}
function parseMultiline(text) {
  const texts = text.replace(/\r/g, '').split(/\n/g);
  let i = 0;
  const items = [];
  for (; i < texts.length; i++) {
    items.push({
      value: texts[i].trim(),
      height: 0,
      line: i
    });
  }
  return items;
}
function createTspans(items, element, fieldName) {
  let i;
  let ii;
  let item;
  for (i = 0, ii = items.length; i < ii; ++i) {
    item = items[i];
    item[fieldName] = createElement('tspan');
    item[fieldName].appendChild(_dom_adapter.default.createTextNode(item.value));
    item.style && baseCss({
      element: item[fieldName],
      _styles: {}
    }, item.style);
    item.className && item[fieldName].setAttribute('class', item.className); // EXPERIMENTAL
    element.appendChild(item[fieldName]);
  }
}
function restoreText() {
  if (this._hasEllipsis) {
    this.attr({
      text: this._settings.text
    });
  }
}
function applyEllipsis(maxWidth) {
  const that = this;
  let lines;
  let hasEllipsis = false;
  let i;
  let ii;
  let lineParts;
  let j;
  let jj;
  let text;
  restoreText.call(that);
  const ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);
  const ellipsisWidth = ellipsis.getBBox().width;
  if (that._getElementBBox().width > maxWidth) {
    if (maxWidth - ellipsisWidth < 0) {
      maxWidth = 0;
    } else {
      maxWidth -= ellipsisWidth;
    }
    lines = prepareLines(that.element, that._texts, maxWidth);
    for (i = 0, ii = lines.length; i < ii; ++i) {
      lineParts = lines[i].parts;
      if (lines[i].commonLength === 1) {
        continue;
      }
      for (j = 0, jj = lineParts.length; j < jj; ++j) {
        text = lineParts[j];
        if ((0, _type.isDefined)(text.endIndex)) {
          setNewText(text, text.endIndex);
          hasEllipsis = true;
        } else if (text.startBox > maxWidth) {
          removeTextSpan(text);
        }
      }
    }
  }
  ellipsis.remove();
  that._hasEllipsis = hasEllipsis;
  return hasEllipsis;
}
function cloneAndRemoveAttrs(node) {
  let clone;
  if (node) {
    clone = node.cloneNode();
    clone.removeAttribute('y');
    clone.removeAttribute('x');
  }
  return clone || node;
}
function detachTitleElements(element) {
  const titleElements = _dom_adapter.default.querySelectorAll(element, 'title');
  for (let i = 0; i < titleElements.length; i++) {
    element.removeChild(titleElements[i]);
  }
  return titleElements;
}
function detachAndStoreTitleElements(element) {
  const titleElements = detachTitleElements(element);
  return () => {
    for (let i = 0; i < titleElements.length; i++) {
      element.appendChild(titleElements[i]);
    }
  };
}
function setMaxSize(maxWidth, maxHeight) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const that = this;
  let lines = [];
  let textChanged = false;
  let textIsEmpty = false;
  let ellipsisMaxWidth = maxWidth;
  restoreText.call(that);
  const restoreTitleElement = detachAndStoreTitleElements(this.element);
  const ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);
  const ellipsisWidth = ellipsis.getBBox().width;
  const {
    width,
    height
  } = that._getElementBBox();
  if ((width || height) && (width > maxWidth || maxHeight && height > maxHeight)) {
    if (maxWidth - ellipsisWidth < 0) {
      ellipsisMaxWidth = 0;
    } else {
      ellipsisMaxWidth -= ellipsisWidth;
    }
    lines = applyOverflowRules(that.element, that._texts, maxWidth, ellipsisMaxWidth, options);
    lines = setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, parseFloat(this._getLineHeight()));
    this._texts = lines.reduce((texts, line) => {
      return texts.concat(line.parts);
    }, []).filter(t => t.value !== '').map(t => {
      t.stroke && t.tspan.parentNode.appendChild(t.stroke);
      return t;
    }).map(t => {
      t.tspan.parentNode.appendChild(t.tspan);
      return t;
    });
    !this._texts.length && (this._texts = null);
    textChanged = true;
    if (this._texts) {
      locateTextNodes(this);
    } else {
      this.element.textContent = '';
      textIsEmpty = true;
    }
  }
  ellipsis.remove();
  that._hasEllipsis = textChanged;
  restoreTitleElement();
  return {
    rowCount: lines.length,
    textChanged,
    textIsEmpty
  };
}
function getIndexForEllipsis(text, maxWidth, startBox, endBox) {
  let k;
  let kk;
  if (startBox <= maxWidth && endBox > maxWidth) {
    for (k = 1, kk = text.value.length; k <= kk; ++k) {
      if (startBox + text.tspan.getSubStringLength(0, k) > maxWidth) {
        return k - 1;
      }
    }
  }
}
function getTextWidth(text) {
  return text.value.length ? text.tspan.getSubStringLength(0, text.value.length) : 0;
}
function prepareLines(element, texts, maxWidth) {
  let lines = [];
  let i;
  let ii;
  let text;
  let startBox;
  let endBox;
  if (texts) {
    for (i = 0, ii = texts.length; i < ii; ++i) {
      text = texts[i];
      if (!lines[text.line]) {
        text.startBox = startBox = 0;
        lines.push({
          commonLength: text.value.length,
          parts: [text]
        });
      } else {
        text.startBox = startBox;
        lines[text.line].parts.push(text);
        lines[text.line].commonLength += text.value.length;
      }
      endBox = startBox + text.tspan.getSubStringLength(0, text.value.length);
      text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);
      startBox = endBox;
    }
  } else {
    text = {
      value: element.textContent,
      tspan: element
    };
    text.startBox = startBox = 0;
    endBox = startBox + getTextWidth(text);
    text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);
    lines = [{
      commonLength: element.textContent.length,
      parts: [text]
    }];
  }
  return lines;
}
function getSpaceBreakIndex(text, maxWidth) {
  const initialIndices = text.startBox > 0 ? [0] : [];
  const spaceIndices = text.value.split('').reduce((indices, char, index) => {
    if (char === ' ') {
      indices.push(index);
    }
    return indices;
  }, initialIndices);
  let spaceIndex = 0;
  while (spaceIndices[spaceIndex + 1] !== undefined && text.startBox + text.tspan.getSubStringLength(0, spaceIndices[spaceIndex + 1]) < maxWidth) {
    spaceIndex++;
  }
  return spaceIndices[spaceIndex];
}
function getWordBreakIndex(text, maxWidth) {
  for (let i = 0; i < text.value.length - 1; i++) {
    if (text.startBox + text.tspan.getSubStringLength(0, i + 1) > maxWidth) {
      return i;
    }
  }
}
function getEllipsisString(ellipsisMaxWidth, _ref) {
  let {
    hideOverflowEllipsis
  } = _ref;
  return hideOverflowEllipsis && ellipsisMaxWidth === 0 ? '' : ELLIPSIS;
}
function setEllipsis(text, ellipsisMaxWidth, options) {
  const ellipsis = getEllipsisString(ellipsisMaxWidth, options);
  if (text.value.length && text.tspan.parentNode) {
    for (let i = text.value.length - 1; i >= 1; i--) {
      if (text.startBox + text.tspan.getSubStringLength(0, i) < ellipsisMaxWidth) {
        setNewText(text, i, ellipsis);
        break;
      } else if (i === 1) {
        setNewText(text, 0, ellipsis);
      }
    }
  }
}
function wordWrap(text, maxWidth, ellipsisMaxWidth, options, lastStepBreakIndex) {
  const wholeText = text.value;
  let breakIndex;
  if (options.wordWrap !== 'none') {
    breakIndex = options.wordWrap === 'normal' ? getSpaceBreakIndex(text, maxWidth) : getWordBreakIndex(text, maxWidth);
  }
  let restLines = [];
  let restText;
  if (isFinite(breakIndex) && !(lastStepBreakIndex === 0 && breakIndex === 0)) {
    setNewText(text, breakIndex, '');
    const newTextOffset = wholeText[breakIndex] === ' ' ? 1 : 0;
    const restString = wholeText.slice(breakIndex + newTextOffset);
    if (restString.length) {
      const restTspan = cloneAndRemoveAttrs(text.tspan);
      restTspan.textContent = restString;
      text.tspan.parentNode.appendChild(restTspan);
      restText = extend(extend({}, text), {
        value: restString,
        startBox: 0,
        height: 0,
        tspan: restTspan,
        stroke: cloneAndRemoveAttrs(text.stroke),
        endBox: restTspan.getSubStringLength(0, restString.length)
      });
      restText.stroke && (restText.stroke.textContent = restString);
      if (restText.endBox > maxWidth) {
        restLines = wordWrap(restText, maxWidth, ellipsisMaxWidth, options, breakIndex);
        if (!restLines.length) {
          return [];
        }
      }
    }
  }
  if (text.value.length) {
    if (options.textOverflow === 'ellipsis' && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {
      setEllipsis(text, ellipsisMaxWidth, options);
    }
    if (options.textOverflow === 'hide' && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {
      return [];
    }
  } else {
    text.tspan.parentNode.removeChild(text.tspan);
  }
  const parts = [];
  if (restText) {
    parts.push(restText);
  }
  return [{
    commonLength: wholeText.length,
    parts
  }].concat(restLines);
}
function calculateLineHeight(line, lineHeight) {
  return line.parts.reduce((height, text) => {
    return max(height, getItemLineHeight(text, lineHeight));
  }, 0);
}
function setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, lineHeight) {
  const textOverflow = options.textOverflow;
  if (!isFinite(maxHeight) || Number(maxHeight) === 0 || textOverflow === 'none') {
    return lines;
  }
  const result = lines.reduce((_ref2, l, index, arr) => {
    let [lines, commonHeight] = _ref2;
    const height = calculateLineHeight(l, lineHeight);
    commonHeight += height;
    if (commonHeight < maxHeight) {
      lines.push(l);
    } else {
      l.parts.forEach(item => {
        removeTextSpan(item);
      });
      if (textOverflow === 'ellipsis') {
        const prevLine = arr[index - 1];
        if (prevLine) {
          const text = prevLine.parts[prevLine.parts.length - 1];
          if (!text.hasEllipsis) {
            if (ellipsisMaxWidth === 0 || text.endBox < ellipsisMaxWidth) {
              setNewText(text, text.value.length, getEllipsisString(ellipsisMaxWidth, options));
            } else {
              setEllipsis(text, ellipsisMaxWidth, options);
            }
          }
        }
      }
    }
    return [lines, commonHeight];
  }, [[], 0]);
  if (textOverflow === 'hide' && result[1] > maxHeight) {
    result[0].forEach(l => {
      l.parts.forEach(item => {
        removeTextSpan(item);
      });
    });
    return [];
  }
  return result[0];
}
function applyOverflowRules(element, texts, maxWidth, ellipsisMaxWidth, options) {
  if (!texts) {
    const textValue = element.textContent;
    const text = {
      value: textValue,
      height: 0,
      line: 0
    };
    element.textContent = '';
    createTspans([text], element, 'tspan');
    texts = [text];
  }
  return texts.reduce((_ref3, text) => {
    let [lines, startBox, endBox, stop, lineNumber] = _ref3;
    const line = lines[lines.length - 1];
    if (stop) {
      return [lines, startBox, endBox, stop];
    }
    if (!line || text.line !== lineNumber) {
      text.startBox = startBox = 0;
      lines.push({
        commonLength: text.value.length,
        parts: [text]
      });
    } else {
      text.startBox = startBox;
      if (startBox > ellipsisMaxWidth && options.wordWrap === 'none' && options.textOverflow === 'ellipsis') {
        removeTextSpan(text);
        return [lines, startBox, endBox, stop, lineNumber];
      }
      line.parts.push(text);
      line.commonLength += text.value.length;
    }
    text.endBox = endBox = startBox + getTextWidth(text);
    startBox = endBox;
    if ((0, _type.isDefined)(maxWidth) && endBox > maxWidth) {
      const wordWrapLines = wordWrap(text, maxWidth, ellipsisMaxWidth, options);
      if (!wordWrapLines.length) {
        lines = [];
        stop = true;
      } else {
        lines = lines.concat(wordWrapLines.filter(l => l.parts.length > 0));
      }
    }
    return [lines, startBox, endBox, stop, text.line];
  }, [[], 0, 0, false, 0])[0];
}
function setNewText(text, index) {
  let insertString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ELLIPSIS;
  const newText = text.value.substr(0, index) + insertString;
  text.value = text.tspan.textContent = newText;
  text.stroke && (text.stroke.textContent = newText);
  if (insertString === ELLIPSIS) {
    text.hasEllipsis = true;
  }
}
function removeTextSpan(text) {
  text.tspan.parentNode && text.tspan.parentNode.removeChild(text.tspan);
  text.stroke && text.stroke.parentNode && text.stroke.parentNode.removeChild(text.stroke);
}
function createTextNodes(wrapper, text, isStroked) {
  let items;
  let parsedHtml;
  wrapper._texts = null;
  wrapper.clear();
  if (text === null) return;
  text = '' + text;
  if (!wrapper.renderer.encodeHtml && (/<[a-z][\s\S]*>/i.test(text) || text.indexOf('&') !== -1)) {
    parsedHtml = removeExtraAttrs(text);
    items = parseHTML(parsedHtml);
  } else if (/\n/g.test(text)) {
    items = parseMultiline(text);
  } else if (isStroked) {
    items = [{
      value: text.trim(),
      height: 0
    }];
  }
  if (items) {
    if (items.length) {
      // T227388
      wrapper._texts = items;
      if (isStroked) {
        createTspans(items, wrapper.element, KEY_STROKE);
      }
      createTspans(items, wrapper.element, 'tspan');
    }
  } else {
    wrapper.element.appendChild(_dom_adapter.default.createTextNode(text));
  }
}
function setTextNodeAttribute(item, name, value) {
  item.tspan.setAttribute(name, value);
  item.stroke && item.stroke.setAttribute(name, value);
}
function getItemLineHeight(item, defaultValue) {
  return item.inherits ? maxLengthFontSize(item.height, defaultValue) : item.height || defaultValue;
}
function locateTextNodes(wrapper) {
  if (!wrapper._texts) return;
  const items = wrapper._texts;
  const x = wrapper._settings.x;
  const lineHeight = wrapper._getLineHeight();
  let i;
  let ii;
  let item = items[0];
  setTextNodeAttribute(item, 'x', x);
  setTextNodeAttribute(item, 'y', wrapper._settings.y);
  for (i = 1, ii = items.length; i < ii; ++i) {
    item = items[i];
    if (parseFloat(item.height) >= 0) {
      setTextNodeAttribute(item, 'x', x);
      const height = getItemLineHeight(item, lineHeight);
      setTextNodeAttribute(item, 'dy', height); // T177039
    }
  }
}
function alignTextNodes(wrapper, alignment) {
  if (!wrapper._texts || alignment === 'center') {
    return;
  }
  const items = wrapper._texts;
  const direction = alignment === 'left' ? -1 : 1;
  const maxTextWidth = Math.max.apply(Math, items.map(t => {
    return getTextWidth(t);
  }));
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    const textWidth = getTextWidth(item);
    if (maxTextWidth !== 0 && maxTextWidth !== textWidth) {
      setTextNodeAttribute(item, 'dx', direction * round((maxTextWidth - textWidth) / 2 * 10) / 10);
    }
  }
}
function maxLengthFontSize(fontSize1, fontSize2) {
  const parsedHeight1 = parseFloat(fontSize1);
  const parsedHeight2 = parseFloat(fontSize2);
  const height1 = parsedHeight1 || DEFAULT_FONT_SIZE;
  const height2 = parsedHeight2 || DEFAULT_FONT_SIZE;
  return height1 > height2 ? !isNaN(parsedHeight1) ? fontSize1 : height1 : !isNaN(parsedHeight2) ? fontSize2 : height2;
}
function strokeTextNodes(wrapper) {
  if (!wrapper._texts) return;
  const items = wrapper._texts;
  const stroke = wrapper._settings[KEY_STROKE];
  const strokeWidth = wrapper._settings[KEY_STROKE_WIDTH];
  const strokeOpacity = wrapper._settings[KEY_STROKE_OPACITY] || 1;
  let tspan;
  let i;
  let ii;
  for (i = 0, ii = items.length; i < ii; ++i) {
    tspan = items[i].stroke;
    tspan.setAttribute(KEY_STROKE, stroke);
    tspan.setAttribute(KEY_STROKE_WIDTH, strokeWidth);
    tspan.setAttribute(KEY_STROKE_OPACITY, strokeOpacity);
    tspan.setAttribute('stroke-linejoin', 'round');
  }
}
function baseAnimate(that, params, options, complete) {
  options = options || {};
  let key;
  let value;
  const renderer = that.renderer;
  const settings = that._settings;
  const animationParams = {};
  const defaults = {
    translateX: 0,
    translateY: 0,
    scaleX: 1,
    scaleY: 1,
    rotate: 0,
    rotateX: 0,
    rotateY: 0
  };
  if (complete) {
    options.complete = complete;
  }
  if (renderer.animationEnabled()) {
    for (key in params) {
      value = params[key];
      if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {
        animationParams.transform = animationParams.transform || {
          from: {},
          to: {}
        };
        animationParams.transform.from[key] = key in settings ? Number(settings[key].toFixed(3)) : defaults[key]; // T338486
        animationParams.transform.to[key] = value;
      } else if (key === 'arc' || key === 'segments') {
        animationParams[key] = value;
      } else {
        animationParams[key] = {
          from: key in settings ? settings[key] : parseFloat(that.element.getAttribute(key) || 0),
          to: value
        };
      }
    }
    renderer.animateElement(that, animationParams, extend(extend({}, renderer._animation), options));
  } else {
    options.step && options.step.call(that, 1, 1);
    options.complete && options.complete.call(that);
    that.attr(params);
  }
  return that;
}
function pathAnimate(params, options, complete) {
  const that = this;
  const curSegments = that.segments || [];
  let newSegments;
  let endSegments;
  if (that.renderer.animationEnabled() && 'points' in params) {
    newSegments = buildPathSegments(params.points, that.type);
    endSegments = compensateSegments(curSegments, newSegments, that.type);
    params.segments = {
      from: curSegments,
      to: newSegments,
      end: endSegments
    };
    delete params.points;
  }
  return baseAnimate(that, params, options, complete);
}
function arcAnimate(params, options, complete) {
  const that = this;
  const settings = that._settings;
  const arcParams = {
    from: {},
    to: {}
  };
  if (that.renderer.animationEnabled() && ('x' in params || 'y' in params || 'innerRadius' in params || 'outerRadius' in params || 'startAngle' in params || 'endAngle' in params)) {
    arcParams.from.x = settings.x || 0;
    arcParams.from.y = settings.y || 0;
    arcParams.from.innerRadius = settings.innerRadius || 0;
    arcParams.from.outerRadius = settings.outerRadius || 0;
    arcParams.from.startAngle = settings.startAngle || 0;
    arcParams.from.endAngle = settings.endAngle || 0;
    arcParams.to.x = 'x' in params ? params.x : settings.x;
    delete params.x;
    arcParams.to.y = 'y' in params ? params.y : settings.y;
    delete params.y;
    arcParams.to.innerRadius = 'innerRadius' in params ? params.innerRadius : settings.innerRadius;
    delete params.innerRadius;
    arcParams.to.outerRadius = 'outerRadius' in params ? params.outerRadius : settings.outerRadius;
    delete params.outerRadius;
    arcParams.to.startAngle = 'startAngle' in params ? params.startAngle : settings.startAngle;
    delete params.startAngle;
    arcParams.to.endAngle = 'endAngle' in params ? params.endAngle : settings.endAngle;
    delete params.endAngle;
    params.arc = arcParams;
  }
  return baseAnimate(that, params, options, complete);
}
function buildLink(target, parameters) {
  const obj = {
    is: false,
    name: parameters.name || parameters,
    after: parameters.after
  };
  if (target) {
    obj.to = target;
  } else {
    obj.virtual = true;
  }
  return obj;
}

// SvgElement
let SvgElement = function (renderer, tagName, type) {
  const that = this;
  that.renderer = renderer;
  that.element = createElement(tagName);
  that._settings = {};
  that._styles = {};
  if (tagName === 'path') {
    that.type = type || 'line';
  }
};
exports.SvgElement = SvgElement;
function removeFuncIriCallback(callback) {
  fixFuncIriCallbacks.remove(callback);
}
SvgElement.prototype = {
  constructor: SvgElement,
  _getJQElement: function () {
    return this._$element || (this._$element = (0, _renderer.default)(this.element));
  },
  _addFixIRICallback: function () {
    const that = this;
    const fn = function () {
      fixFuncIri(that, 'fill');
      fixFuncIri(that, 'clip-path');
      fixFuncIri(that, 'filter');
    };
    that.element._fixFuncIri = fn;
    fn.renderer = that.renderer;
    fixFuncIriCallbacks.add(fn);
    that._addFixIRICallback = function () {};
  },
  _clearChildrenFuncIri: function () {
    const clearChildren = function (element) {
      let i;
      for (i = 0; i < element.childNodes.length; i++) {
        removeFuncIriCallback(element.childNodes[i]._fixFuncIri);
        clearChildren(element.childNodes[i]);
      }
    };
    clearChildren(this.element);
  },
  dispose: function () {
    removeFuncIriCallback(this.element._fixFuncIri);
    this._clearChildrenFuncIri();
    this._getJQElement().remove();
    return this;
  },
  append: function (parent) {
    (parent || this.renderer.root).element.appendChild(this.element);
    return this;
  },
  remove: function () {
    const element = this.element;
    element.parentNode && element.parentNode.removeChild(element);
    return this;
  },
  // NOTE: Though it is not actually required I think it would be better to explicitly declare usage of link mechanism
  enableLinks: function () {
    this._links = [];
    return this;
  },
  virtualLink: function (parameters) {
    linkItem({
      _link: buildLink(null, parameters)
    }, this);
    return this;
  },
  linkAfter: function (name) {
    this._linkAfter = name;
    return this;
  },
  linkOn: function (target, parameters) {
    this._link = buildLink(target, parameters);
    linkItem(this, target);
    return this;
  },
  linkOff: function () {
    unlinkItem(this);
    this._link = null;
    return this;
  },
  // It might be better to traverse list to start (not to end) as widget components more likely will be rendered in the same order as they were created
  linkAppend: function () {
    const link = this._link;
    const items = link.to._links;
    let i;
    let next;
    for (i = link.i + 1; (next = items[i]) && !next._link.is; ++i);
    this._insert(link.to, next);
    link.is = true;
    return this;
  },
  // The method exists only for being overridden in vml
  _insert: function (parent, next) {
    parent.element.insertBefore(this.element, next ? next.element : null);
  },
  linkRemove: function () {
    this.remove();
    this._link.is = false;
    return this;
  },
  clear: function () {
    this._clearChildrenFuncIri(); // T711457
    this._getJQElement().empty();
    return this;
  },
  toBackground: function () {
    const elem = this.element;
    const parent = elem.parentNode;
    parent && parent.insertBefore(elem, parent.firstChild);
    return this;
  },
  toForeground: function () {
    const elem = this.element;
    const parent = elem.parentNode;
    parent && parent.appendChild(elem);
    return this;
  },
  attr: function (attrs) {
    return baseAttr(this, attrs);
  },
  smartAttr: function (attrs) {
    return this.attr(processHatchingAttrs(this, attrs));
  },
  css: function (styles) {
    return baseCss(this, styles);
  },
  animate: function (params, options, complete) {
    return baseAnimate(this, params, options, complete);
  },
  sharp(pos, sharpDirection) {
    return this.attr({
      sharp: pos || true,
      sharpDirection
    });
  },
  _applyTransformation() {
    const tr = this._settings;
    let rotateX;
    let rotateY;
    const transformations = [];
    const sharpMode = tr.sharp;
    const trDirection = tr.sharpDirection || 1;
    const strokeOdd = tr[KEY_STROKE_WIDTH] % 2;
    const correctionX = strokeOdd && (sharpMode === 'h' || sharpMode === true) ? SHARPING_CORRECTION * trDirection : 0;
    const correctionY = strokeOdd && (sharpMode === 'v' || sharpMode === true) ? SHARPING_CORRECTION * trDirection : 0;
    transformations.push('translate(' + ((tr.translateX || 0) + correctionX) + ',' + ((tr.translateY || 0) + correctionY) + ')');
    if (tr.rotate) {
      if ('rotateX' in tr) {
        rotateX = tr.rotateX;
      } else {
        rotateX = tr.x;
      }
      if ('rotateY' in tr) {
        rotateY = tr.rotateY;
      } else {
        rotateY = tr.y;
      }
      transformations.push('rotate(' + tr.rotate + ',' + (rotateX || 0) + ',' + (rotateY || 0) + ')');
    }
    const scaleXDefined = (0, _type.isDefined)(tr.scaleX);
    const scaleYDefined = (0, _type.isDefined)(tr.scaleY);
    if (scaleXDefined || scaleYDefined) {
      transformations.push('scale(' + (scaleXDefined ? tr.scaleX : 1) + ',' + (scaleYDefined ? tr.scaleY : 1) + ')');
    }
    if (transformations.length) {
      this.element.setAttribute('transform', transformations.join(' '));
    }
  },
  move: function (x, y, animate, animOptions) {
    const obj = {};
    (0, _type.isDefined)(x) && (obj.translateX = x);
    (0, _type.isDefined)(y) && (obj.translateY = y);
    if (!animate) {
      this.attr(obj);
    } else {
      this.animate(obj, animOptions);
    }
    return this;
  },
  rotate: function (angle, x, y, animate, animOptions) {
    const obj = {
      rotate: angle || 0
    };
    (0, _type.isDefined)(x) && (obj.rotateX = x);
    (0, _type.isDefined)(y) && (obj.rotateY = y);
    if (!animate) {
      this.attr(obj);
    } else {
      this.animate(obj, animOptions);
    }
    return this;
  },
  _getElementBBox: function () {
    const elem = this.element;
    let bBox;
    try {
      bBox = elem.getBBox && elem.getBBox();
    } catch (e) {}
    return bBox || {
      x: 0,
      y: 0,
      width: elem.offsetWidth || 0,
      height: elem.offsetHeight || 0
    };
  },
  // TODO do we need to round results and consider rotation coordinates?
  getBBox: function () {
    const transformation = this._settings;
    let bBox = this._getElementBBox();
    if (transformation.rotate) {
      bBox = (0, _utils.rotateBBox)(bBox, [('rotateX' in transformation ? transformation.rotateX : transformation.x) || 0, ('rotateY' in transformation ? transformation.rotateY : transformation.y) || 0], -transformation.rotate); // Angle is transformed from svg to right-handed cartesian space
    } else {
      bBox = (0, _utils.normalizeBBox)(bBox);
    }
    return bBox;
  },
  markup: function () {
    return (0, _svg.getSvgMarkup)(this.element);
  },
  getOffset: function () {
    return this._getJQElement().offset();
  },
  stopAnimation: function (disableComplete) {
    const animation = this.animation;
    animation && animation.stop(disableComplete);
    return this;
  },
  setTitle: function (text) {
    const titleElem = createElement('title');
    titleElem.textContent = text || '';
    this.element.appendChild(titleElem);
  },
  removeTitle() {
    detachTitleElements(this.element);
  },
  data: function (obj, val) {
    const elem = this.element;
    let key;
    if (val !== undefined) {
      elem[obj] = val;
    } else {
      for (key in obj) {
        elem[key] = obj[key];
      }
    }
    return this;
  },
  on: function () {
    const args = [this._getJQElement()];
    args.push.apply(args, arguments);
    _events_engine.default.on.apply(_events_engine.default, args);
    return this;
  },
  off: function () {
    const args = [this._getJQElement()];
    args.push.apply(args, arguments);
    _events_engine.default.off.apply(_events_engine.default, args);
    return this;
  },
  trigger: function () {
    const args = [this._getJQElement()];
    args.push.apply(args, arguments);
    _events_engine.default.trigger.apply(_events_engine.default, args);
    return this;
  }
};
// SvgElement

// PathSvgElement
let PathSvgElement = function (renderer, type) {
  SvgElement.call(this, renderer, 'path', type);
};
exports.PathSvgElement = PathSvgElement;
PathSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(PathSvgElement.prototype, {
  constructor: PathSvgElement,
  attr: pathAttr,
  animate: pathAnimate
});
// PathSvgElement

// ArcSvgElement
let ArcSvgElement = function (renderer) {
  SvgElement.call(this, renderer, 'path', 'arc');
};
exports.ArcSvgElement = ArcSvgElement;
ArcSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(ArcSvgElement.prototype, {
  constructor: ArcSvgElement,
  attr: arcAttr,
  animate: arcAnimate
});
// ArcSvgElement

// RectSvgElement
let RectSvgElement = function (renderer) {
  SvgElement.call(this, renderer, 'rect');
};
exports.RectSvgElement = RectSvgElement;
RectSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(RectSvgElement.prototype, {
  constructor: RectSvgElement,
  attr: rectAttr
});
// RectSvgElement

// TextSvgElement
let TextSvgElement = function (renderer) {
  SvgElement.call(this, renderer, 'text');
  this.css({
    'white-space': 'pre'
  });
};
exports.TextSvgElement = TextSvgElement;
TextSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(TextSvgElement.prototype, {
  constructor: TextSvgElement,
  attr: textAttr,
  css: textCss,
  applyEllipsis,
  setMaxSize,
  restoreText,
  _getLineHeight() {
    return !isNaN(parseFloat(this._styles[KEY_FONT_SIZE])) ? this._styles[KEY_FONT_SIZE] : DEFAULT_FONT_SIZE;
  }
});
// TextSvgElement

function updateIndexes(items, k) {
  let i;
  let item;
  for (i = k; item = items[i]; ++i) {
    item._link.i = i;
  }
}
function linkItem(target, container) {
  const items = container._links;
  const key = target._link.after = target._link.after || container._linkAfter;
  let i;
  let item;
  if (key) {
    for (i = 0; (item = items[i]) && item._link.name !== key; ++i);
    if (item) {
      for (++i; (item = items[i]) && item._link.after === key; ++i);
    }
  } else {
    i = items.length;
  }
  items.splice(i, 0, target);
  updateIndexes(items, i);
}
function unlinkItem(target) {
  let i;
  const items = target._link.to._links;
  for (i = 0; items[i] !== target; ++i);
  items.splice(i, 1);
  updateIndexes(items, i);
}
function Renderer(options) {
  const that = this;
  that.root = that._createElement('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    version: '1.1',
    // Backward compatibility
    fill: NONE,
    stroke: NONE,
    'stroke-width': 0
  }).attr({
    'class': options.cssClass
  }).css({
    'line-height': 'normal',
    // T179515
    '-moz-user-select': NONE,
    '-webkit-user-select': NONE,
    '-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0)',
    display: 'block',
    overflow: 'hidden'
  });
  that._init();
  that.pathModified = !!options.pathModified;
  that._$container = (0, _renderer.default)(options.container);
  that.root.append({
    element: options.container
  });
  that._locker = 0;
  that._backed = false;
}
Renderer.prototype = {
  constructor: Renderer,
  _init: function () {
    const that = this;
    that._defs = that._createElement('defs').append(that.root);
    that._animationController = new _animation.AnimationController(that.root.element);
    that._animation = {
      enabled: true,
      duration: 1000,
      easing: 'easeOutCubic'
    };
  },
  setOptions: function (options) {
    const that = this;
    that.rtl = !!options.rtl;
    that.encodeHtml = !!options.encodeHtml;
    that.updateAnimationOptions(options.animation || {});
    that.root.attr({
      direction: that.rtl ? 'rtl' : 'ltr'
    });
    return that;
  },
  _createElement: function (tagName, attr, type) {
    const elem = new SvgElement(this, tagName, type);
    attr && elem.attr(attr);
    return elem;
  },
  lock: function () {
    const that = this;
    if (that._locker === 0) {
      that._backed = !that._$container.is(':visible');
      if (that._backed) {
        backupRoot(that.root);
      }
    }
    ++that._locker;
    return that;
  },
  unlock: function () {
    const that = this;
    --that._locker;
    if (that._locker === 0) {
      if (that._backed) {
        restoreRoot(that.root, that._$container[0]);
      }
      that._backed = false;
    }
    return that;
  },
  resize: function (width, height) {
    if (width >= 0 && height >= 0) {
      this.root.attr({
        width: width,
        height: height
      });
    }
    return this;
  },
  dispose: function () {
    const that = this;
    let key;
    that.root.dispose();
    that._defs.dispose();
    that._animationController.dispose();
    fixFuncIriCallbacks.removeByRenderer(that);
    for (key in that) {
      that[key] = null;
    }
    return that;
  },
  animationEnabled: function () {
    return !!this._animation.enabled;
  },
  updateAnimationOptions: function (newOptions) {
    extend(this._animation, newOptions);
    return this;
  },
  stopAllAnimations: function (lock) {
    this._animationController[lock ? 'lock' : 'stop']();
    return this;
  },
  animateElement: function (element, params, options) {
    this._animationController.animateElement(element, params, options);
    return this;
  },
  svg: function () {
    return this.root.markup();
  },
  getRootOffset: function () {
    return this.root.getOffset();
  },
  onEndAnimation: function (endAnimation) {
    this._animationController.onEndAnimation(endAnimation);
  },
  rect: function (x, y, width, height) {
    const elem = new RectSvgElement(this);
    return elem.attr({
      x: x || 0,
      y: y || 0,
      width: width || 0,
      height: height || 0
    });
  },
  simpleRect: function () {
    return this._createElement('rect');
  },
  circle: function (x, y, r) {
    return this._createElement('circle', {
      cx: x || 0,
      cy: y || 0,
      r: r || 0
    });
  },
  g: function () {
    return this._createElement('g');
  },
  image: function (x, y, w, h, href, location) {
    const image = this._createElement('image', {
      x: x || 0,
      y: y || 0,
      width: w || 0,
      height: h || 0,
      preserveAspectRatio: preserveAspectRatioMap[(0, _utils.normalizeEnum)(location)] || NONE
    });
    image.element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href || '');
    return image;
  },
  // to combine different d attributes use helper methods
  path: function (points, type) {
    const elem = new PathSvgElement(this, type);
    return elem.attr({
      points: points || []
    });
  },
  // TODO check B232257
  // TODO animate end angle special case
  arc: function (x, y, innerRadius, outerRadius, startAngle, endAngle) {
    const elem = new ArcSvgElement(this);
    return elem.attr({
      x: x || 0,
      y: y || 0,
      innerRadius: innerRadius || 0,
      outerRadius: outerRadius || 0,
      startAngle: startAngle || 0,
      endAngle: endAngle || 0
    });
  },
  text: function (text, x, y) {
    const elem = new TextSvgElement(this);
    return elem.attr({
      text: text,
      x: x || 0,
      y: y || 0
    });
  },
  linearGradient: function (stops) {
    let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _utils.getNextDefsSvgId)();
    let rotationAngle = arguments.length > 2 ? arguments[2] : undefined;
    const gradient = this._createElement('linearGradient', {
      id,
      gradientTransform: `rotate(${rotationAngle || 0})`
    }).append(this._defs);
    gradient.id = id;
    this._createGradientStops(stops, gradient);
    return gradient;
  },
  radialGradient: function (stops, id) {
    const gradient = this._createElement('radialGradient', {
      id
    }).append(this._defs);
    this._createGradientStops(stops, gradient);
    return gradient;
  },
  _createGradientStops: function (stops, group) {
    stops.forEach(stop => {
      this._createElement('stop', {
        offset: stop.offset,
        'stop-color': stop['stop-color'] ?? stop.color,
        'stop-opacity': stop.opacity
      }).append(group);
    });
  },
  // appended automatically
  pattern: function (color, hatching, _id) {
    hatching = hatching || {};
    const that = this;
    const step = hatching.step || 6;
    const stepTo2 = step / 2;
    const stepBy15 = step * 1.5;
    const id = _id || (0, _utils.getNextDefsSvgId)();
    const d = (0, _utils.normalizeEnum)(hatching.direction) === 'right' ? 'M ' + stepTo2 + ' ' + -stepTo2 + ' L ' + -stepTo2 + ' ' + stepTo2 + ' M 0 ' + step + ' L ' + step + ' 0 M ' + stepBy15 + ' ' + stepTo2 + ' L ' + stepTo2 + ' ' + stepBy15 : 'M 0 0 L ' + step + ' ' + step + ' M ' + -stepTo2 + ' ' + stepTo2 + ' L ' + stepTo2 + ' ' + stepBy15 + ' M ' + stepTo2 + ' ' + -stepTo2 + ' L ' + stepBy15 + ' ' + stepTo2;
    const pattern = that._createElement('pattern', {
      id: id,
      width: step,
      height: step,
      patternUnits: 'userSpaceOnUse'
    }).append(that._defs);
    pattern.id = id;
    const rect = that.rect(0, 0, step, step).attr({
      fill: color,
      opacity: hatching.opacity
    }).append(pattern);
    const path = new PathSvgElement(this).attr({
      d: d,
      'stroke-width': hatching.width || 1,
      stroke: color
    }).append(pattern);
    return pattern;
  },
  customPattern: function (id, template, width, height) {
    const option = {
      id,
      width,
      height,
      patternContentUnits: 'userSpaceOnUse',
      patternUnits: this._getPatternUnits(width, height)
    };
    const pattern = this._createElement('pattern', option).append(this._defs);
    template.render({
      container: pattern.element
    });
    return pattern;
  },
  _getPatternUnits: function (width, height) {
    if (Number(width) && Number(height)) {
      return 'userSpaceOnUse';
    }
  },
  _getPointsWithYOffset: function (points, offset) {
    return points.map(function (point, index) {
      if (index % 2 !== 0) {
        return point + offset;
      }
      return point;
    });
  },
  // appended automatically
  clipShape: function (method, methodArgs) {
    const that = this;
    const id = (0, _utils.getNextDefsSvgId)();
    let clipPath = that._createElement('clipPath', {
      id: id
    }).append(that._defs);
    const shape = method.apply(that, methodArgs).append(clipPath);
    shape.id = id;
    shape.remove = function () {
      throw 'Not implemented';
    };
    shape.dispose = function () {
      clipPath.dispose();
      clipPath = null;
      return this;
    };
    return shape;
  },
  // appended automatically
  clipRect(x, y, width, height) {
    return this.clipShape(this.rect, arguments);
  },
  // appended automatically
  clipCircle(x, y, radius) {
    return this.clipShape(this.circle, arguments);
  },
  // appended automatically
  shadowFilter: function (x, y, width, height, offsetX, offsetY, blur, color, opacity) {
    const that = this;
    const id = (0, _utils.getNextDefsSvgId)();
    const filter = that._createElement('filter', {
      id: id,
      x: x || 0,
      y: y || 0,
      width: width || 0,
      height: height || 0
    }).append(that._defs);
    const gaussianBlur = that._createElement('feGaussianBlur', {
      'in': 'SourceGraphic',
      'result': 'gaussianBlurResult',
      'stdDeviation': blur || 0
    }).append(filter);
    const offset = that._createElement('feOffset', {
      'in': 'gaussianBlurResult',
      'result': 'offsetResult',
      'dx': offsetX || 0,
      'dy': offsetY || 0
    }).append(filter);
    const flood = that._createElement('feFlood', {
      'result': 'floodResult',
      'flood-color': color || '',
      'flood-opacity': opacity
    }).append(filter);
    const composite = that._createElement('feComposite', {
      'in': 'floodResult',
      'in2': 'offsetResult',
      'operator': 'in',
      'result': 'compositeResult'
    }).append(filter);
    const finalComposite = that._createElement('feComposite', {
      'in': 'SourceGraphic',
      'in2': 'compositeResult',
      'operator': 'over'
    }).append(filter);
    filter.id = id;
    filter.gaussianBlur = gaussianBlur;
    filter.offset = offset;
    filter.flood = flood;
    filter.composite = composite;
    filter.finalComposite = finalComposite;
    filter.attr = function (attrs) {
      const that = this;
      const filterAttrs = {};
      const offsetAttrs = {};
      const floodAttrs = {};
      'x' in attrs && (filterAttrs.x = attrs.x);
      'y' in attrs && (filterAttrs.y = attrs.y);
      'width' in attrs && (filterAttrs.width = attrs.width);
      'height' in attrs && (filterAttrs.height = attrs.height);
      baseAttr(that, filterAttrs);
      'blur' in attrs && that.gaussianBlur.attr({
        'stdDeviation': attrs.blur
      });
      'offsetX' in attrs && (offsetAttrs.dx = attrs.offsetX);
      'offsetY' in attrs && (offsetAttrs.dy = attrs.offsetY);
      that.offset.attr(offsetAttrs);
      'color' in attrs && (floodAttrs['flood-color'] = attrs.color);
      'opacity' in attrs && (floodAttrs['flood-opacity'] = attrs.opacity);
      that.flood.attr(floodAttrs);
      return that;
    };
    return filter;
  },
  brightFilter: function (type, slope) {
    const that = this;
    const id = (0, _utils.getNextDefsSvgId)();
    const filter = that._createElement('filter', {
      id: id
    }).append(that._defs);
    const componentTransferElement = that._createElement('feComponentTransfer').append(filter);
    const attrs = {
      type: type,
      slope: slope
    };
    filter.id = id;
    that._createElement('feFuncR', attrs).append(componentTransferElement);
    that._createElement('feFuncG', attrs).append(componentTransferElement);
    that._createElement('feFuncB', attrs).append(componentTransferElement);
    return filter;
  },
  getGrayScaleFilter: function () {
    if (this._grayScaleFilter) {
      return this._grayScaleFilter;
    }
    const that = this;
    const id = (0, _utils.getNextDefsSvgId)();
    const filter = that._createElement('filter', {
      id: id
    }).append(that._defs);
    that._createElement('feColorMatrix').attr({
      type: 'matrix',
      values: '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 0.6 0'
    }).append(filter);
    filter.id = id;
    that._grayScaleFilter = filter;
    return filter;
  },
  lightenFilter: function (id) {
    const coef = 1.3;
    const filter = this._createElement('filter', {
      id
    }).append(this._defs);
    this._createElement('feColorMatrix', {
      type: 'matrix',
      values: `${coef} 0 0 0 0 0 ${coef} 0 0 0 0 0 ${coef} 0 0 0 0 0 1 0`
    }).append(filter);
    filter.id = id;
    return filter;
  },
  initDefsElements: function () {
    const storage = this._defsElementsStorage = this._defsElementsStorage || {
      byHash: {},
      baseId: (0, _utils.getNextDefsSvgId)()
    };
    const byHash = storage.byHash;
    let name;
    for (name in byHash) {
      byHash[name].pattern.dispose();
    }
    storage.byHash = {};
    storage.refToHash = {};
    storage.nextId = 0;
  },
  drawPattern: function (_ref4, storageId, nextId) {
    let {
      color,
      hatching
    } = _ref4;
    return this.pattern(color, hatching, `${storageId}-hatching-${nextId++}`);
  },
  drawFilter: function (_, storageId, nextId) {
    return this.lightenFilter(`${storageId}-lightening-${nextId++}`);
  },
  lockDefsElements: function (attrs, ref, type) {
    const storage = this._defsElementsStorage;
    let storageItem;
    const hash = type === 'pattern' ? getHatchingHash(attrs) : LIGHTENING_HASH;
    const method = type === 'pattern' ? this.drawPattern : this.drawFilter;
    let pattern;
    if (storage.refToHash[ref] !== hash) {
      if (ref) {
        this.releaseDefsElements(ref);
      }
      storageItem = storage.byHash[hash];
      if (!storageItem) {
        pattern = method.call(this, attrs, storage.baseId, storage.nextId++);
        storageItem = storage.byHash[hash] = {
          pattern: pattern,
          count: 0
        };
        storage.refToHash[pattern.id] = hash;
      }
      ++storageItem.count;
      ref = storageItem.pattern.id;
    }
    return ref;
  },
  releaseDefsElements: function (ref) {
    const storage = this._defsElementsStorage;
    const hash = storage.refToHash[ref];
    const storageItem = storage.byHash[hash];
    if (storageItem && --storageItem.count === 0) {
      storageItem.pattern.dispose();
      delete storage.byHash[hash];
      delete storage.refToHash[ref];
    }
  }
};
function getHatchingHash(_ref5) {
  let {
    color,
    hatching
  } = _ref5;
  return '@' + color + '::' + hatching.step + ':' + hatching.width + ':' + hatching.opacity + ':' + hatching.direction;
}

// paths modifier
const fixFuncIriCallbacks = function () {
  let callbacks = [];
  return {
    add: function (fn) {
      callbacks.push(fn);
    },
    remove: function (fn) {
      callbacks = callbacks.filter(function (el) {
        return el !== fn;
      });
    },
    removeByRenderer: function (renderer) {
      callbacks = callbacks.filter(function (el) {
        return el.renderer !== renderer;
      });
    },
    fire: function () {
      callbacks.forEach(function (fn) {
        fn();
      });
    }
  };
}();
const refreshPaths = function () {
  fixFuncIriCallbacks.fire();
};
exports.refreshPaths = refreshPaths;

/***/ }),

/***/ 1939:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.SeriesFamily = SeriesFamily;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _math = __webpack_require__(60810);
var _common = __webpack_require__(20576);
var _utils = __webpack_require__(19157);
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  round,
  abs,
  pow,
  sqrt
} = Math;
const _min = Math.min;
const DEFAULT_BAR_GROUP_PADDING = 0.3;
function validateBarPadding(barPadding) {
  return barPadding < 0 || barPadding > 1 ? undefined : barPadding;
}
function validateBarGroupPadding(barGroupPadding) {
  return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding;
}
function isStackExist(series, arg) {
  return series.some(function (s) {
    return !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function (point) {
      return point.hasValue();
    });
  });
}
function correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {
  series.forEach(function (series) {
    const stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);
    const points = series.getPointsByArg(arg, true);
    const barPadding = validateBarPadding(series.getOptions().barPadding);
    const barWidth = series.getOptions().barWidth;
    let offset = getOffset(stackIndex, parameters);
    let width = parameters.width;
    let extraParameters;
    if (stackIndex === -1) {
      return;
    }
    if ((0, _type.isDefined)(barPadding) || (0, _type.isDefined)(barWidth)) {
      extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);
      width = extraParameters.width;
      if (!series.getBarOverlapGroup()) {
        offset = getOffset(stackIndex, extraParameters);
      }
    }
    correctPointCoordinates(points, width, offset);
  });
}
function getStackName(series) {
  return series.getStackName() || series.getBarOverlapGroup();
}
function adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {
  var _series$, _series$2;
  const commonStacks = [];
  const allArguments = [];
  const seriesInStacks = {};
  const barGroupWidth = options.barGroupWidth;
  const argumentAxis = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.getArgumentAxis();
  let interval;
  if ((_series$2 = series[0]) !== null && _series$2 !== void 0 && _series$2.useAggregation()) {
    var _series$3;
    const isDateArgAxis = ((_series$3 = series[0]) === null || _series$3 === void 0 ? void 0 : _series$3.argumentType) === 'datetime';
    let tickInterval = argumentAxis.getTickInterval();
    let aggregationInterval = argumentAxis.getAggregationInterval();
    tickInterval = isDateArgAxis ? _date.default.dateToMilliseconds(tickInterval) : tickInterval;
    aggregationInterval = isDateArgAxis ? _date.default.dateToMilliseconds(aggregationInterval) : aggregationInterval;
    interval = aggregationInterval < tickInterval ? aggregationInterval : tickInterval;
  }
  interval = argumentAxis === null || argumentAxis === void 0 ? void 0 : argumentAxis.getTranslator().getInterval(interval);
  const barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));
  series.forEach(function (s, i) {
    const stackName = getStackName(s) || i.toString();
    let argument;
    for (argument in s.pointsByArgument) {
      if (allArguments.indexOf(argument.valueOf()) === -1) {
        allArguments.push(argument.valueOf());
      }
    }
    if (commonStacks.indexOf(stackName) === -1) {
      commonStacks.push(stackName);
      seriesInStacks[stackName] = [];
    }
    seriesInStacks[stackName].push(s);
  });
  allArguments.forEach(function (arg) {
    const currentStacks = commonStacks.reduce((stacks, stack) => {
      if (isStackExist(seriesInStacks[stack], arg)) {
        stacks.push(stack);
      }
      return stacks;
    }, []);
    const parameters = calculateParams(barsArea, currentStacks.length);
    commonStacks.forEach(stack => {
      correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback);
    });
  });
}
function calculateParams(barsArea, count, percentWidth, fixedBarWidth) {
  let spacing;
  let width;
  if (fixedBarWidth) {
    width = _min(fixedBarWidth, barsArea / count);
    spacing = count > 1 ? round((barsArea - round(width) * count) / (count - 1)) : 0;
  } else if ((0, _type.isDefined)(percentWidth)) {
    width = barsArea * percentWidth / count;
    spacing = count > 1 ? round((barsArea - barsArea * percentWidth) / (count - 1)) : 0;
  } else {
    spacing = round(barsArea / count * 0.2);
    width = (barsArea - spacing * (count - 1)) / count;
  }
  return {
    width: width > 1 ? round(width) : 1,
    spacing: spacing,
    middleIndex: count / 2,
    rawWidth: width
  };
}
function getOffset(stackIndex, parameters) {
  const width = parameters.rawWidth < 1 ? parameters.rawWidth : parameters.width;
  return (stackIndex - parameters.middleIndex + 0.5) * width - (parameters.middleIndex - stackIndex - 0.5) * parameters.spacing;
}
function correctPointCoordinates(points, width, offset) {
  (0, _iterator.each)(points, function (_, point) {
    point.correctCoordinates({
      width: width,
      offset: offset
    });
  });
}
function getValueType(value) {
  return value >= 0 ? 'positive' : 'negative';
}
function getVisibleSeries(that) {
  return that.series.filter(function (s) {
    return s.isVisible();
  });
}
function getAbsStackSumByArg(stackKeepers, stackName, argument) {
  const positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;
  const negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;
  return positiveStackValue + negativeStackValue;
}
function getStackSumByArg(stackKeepers, stackName, argument) {
  const positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;
  const negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;
  return positiveStackValue + negativeStackValue;
}
function getSeriesStackIndexCallback(inverted) {
  if (!inverted) {
    return function (index) {
      return index;
    };
  } else {
    return function (index, stackCount) {
      return stackCount - index - 1;
    };
  }
}
function isInverted(series) {
  return series[0] && series[0].getArgumentAxis().getTranslator().isInverted();
}
function adjustBarSeriesDimensions() {
  const series = getVisibleSeries(this);
  adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)));
}
function getFirstValueSign(series) {
  const points = series.getPoints();
  let value;
  for (let i = 0; i < points.length; i++) {
    const point = points[i];
    value = point.initialValue && point.initialValue.valueOf();
    if (abs(value) > 0) {
      break;
    }
  }
  return (0, _math.sign)(value);
}
function adjustStackedSeriesValues() {
  const that = this;
  const negativesAsZeroes = that._options.negativesAsZeroes;
  const series = getVisibleSeries(that);
  const stackKeepers = {
    positive: {},
    negative: {}
  };
  const holesStack = {
    left: {},
    right: {}
  };
  const lastSeriesInPositiveStack = {};
  const lastSeriesInNegativeStack = {};
  series.forEach(function (singleSeries) {
    const stackName = getStackName(singleSeries);
    let hole = false;
    const stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;
    singleSeries._prevSeries = stack[stackName];
    stack[stackName] = singleSeries;
    singleSeries.holes = (0, _extend.extend)(true, {}, holesStack);
    singleSeries.getPoints().forEach(function (point, index, points) {
      let value = point.initialValue && point.initialValue.valueOf();
      let argument = point.argument.valueOf();
      let stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;
      const isNotBarSeries = singleSeries.type !== 'bar';
      if (negativesAsZeroes && value < 0) {
        stacks = stackKeepers.positive;
        value = 0;
        point.resetValue();
      }
      stacks[stackName] = stacks[stackName] || {};
      const currentStack = stacks[stackName];
      if (currentStack[argument]) {
        if (isNotBarSeries) point.correctValue(currentStack[argument]);
        currentStack[argument] += value;
      } else {
        currentStack[argument] = value;
        if (isNotBarSeries) point.resetCorrection();
      }
      if (!point.hasValue()) {
        const prevPoint = points[index - 1];
        if (!hole && prevPoint && prevPoint.hasValue()) {
          argument = prevPoint.argument.valueOf();
          prevPoint._skipSetRightHole = true;
          holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0));
        }
        hole = true;
      } else if (hole) {
        hole = false;
        holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));
        point._skipSetLeftHole = true;
      }
    });
  });
  series.forEach(function (singleSeries) {
    const holes = singleSeries.holes;
    singleSeries.getPoints().forEach(function (point) {
      const argument = point.argument.valueOf();
      point.resetHoles();
      !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, 'left');
      !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, 'right');
      point._skipSetLeftHole = null;
      point._skipSetRightHole = null;
    });
  });
  that._stackKeepers = stackKeepers;
  series.forEach(function (singleSeries) {
    singleSeries.getPoints().forEach(function (point) {
      const argument = point.argument.valueOf();
      const stackName = getStackName(singleSeries);
      const absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);
      const total = getStackSumByArg(stackKeepers, stackName, argument);
      point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument]);
    });
  });
}
function updateStackedSeriesValues() {
  const that = this;
  const series = getVisibleSeries(that);
  const stack = that._stackKeepers;
  const stackKeepers = {
    positive: {},
    negative: {}
  };
  (0, _iterator.each)(series, function (_, singleSeries) {
    const minBarSize = singleSeries.getOptions().minBarSize;
    const valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
    const minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
    const stackName = singleSeries.getStackName();
    (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
      if (!point.hasValue()) {
        return;
      }
      let value = point.initialValue && point.initialValue.valueOf();
      const argument = point.argument.valueOf();
      if (that.fullStacked) {
        value = value / getAbsStackSumByArg(stack, stackName, argument) || 0;
      }
      const updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);
      const valueType = getValueType(updateValue);
      const currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
      if (currentStack[argument]) {
        point.minValue = currentStack[argument];
        currentStack[argument] += updateValue;
      } else {
        currentStack[argument] = updateValue;
      }
      point.value = currentStack[argument];
    });
  });
  if (that.fullStacked) {
    updateFullStackedSeriesValues(series, stackKeepers);
  }
}
function updateFullStackedSeriesValues(series, stackKeepers) {
  (0, _iterator.each)(series, function (_, singleSeries) {
    const stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default';
    (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
      const stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());
      if (stackSum !== 0) {
        point.value = point.value / stackSum;
        if ((0, _type.isNumeric)(point.minValue)) {
          point.minValue = point.minValue / stackSum;
        }
      }
    });
  });
}
function updateRangeSeriesValues() {
  const that = this;
  const series = getVisibleSeries(that);
  (0, _iterator.each)(series, function (_, singleSeries) {
    const minBarSize = singleSeries.getOptions().minBarSize;
    const valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
    const minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
    if (minShownBusinessValue) {
      (0, _iterator.each)(singleSeries.getPoints(), function (_, point) {
        if (!point.hasValue()) {
          return;
        }
        if (point.value.valueOf() - point.minValue.valueOf() < minShownBusinessValue) {
          point.value = valueAxisTranslator.toValue(point.value.valueOf() + minShownBusinessValue / 2);
          point.minValue = valueAxisTranslator.toValue(point.minValue.valueOf() - minShownBusinessValue / 2);
        }
      });
    }
  });
}
function updateBarSeriesValues() {
  (0, _iterator.each)(this.series, function (_, singleSeries) {
    const minBarSize = singleSeries.getOptions().minBarSize;
    const valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
    const minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
    if (minShownBusinessValue) {
      (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
        if (point.hasValue()) {
          point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue);
        }
      });
    }
  });
}
function adjustCandlestickSeriesDimensions() {
  const series = getVisibleSeries(this);
  adjustBarSeriesDimensionsCore(series, {
    barGroupPadding: 0.3
  }, getSeriesStackIndexCallback(isInverted(series)));
}
function adjustBubbleSeriesDimensions() {
  const series = getVisibleSeries(this);
  if (!series.length) {
    return;
  }
  const options = this._options;
  const visibleAreaX = series[0].getArgumentAxis().getVisibleArea();
  const visibleAreaY = series[0].getValueAxis().getVisibleArea();
  const min = _min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);
  const minBubbleArea = pow(options.minBubbleSize, 2);
  const maxBubbleArea = pow(min * options.maxBubbleSize, 2);
  const equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;
  let minPointSize = Infinity;
  let maxPointSize = -Infinity;
  let pointSize;
  let bubbleArea;
  let sizeProportion;
  (0, _iterator.each)(series, function (_, seriesItem) {
    (0, _iterator.each)(seriesItem.getPoints(), function (_, point) {
      maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;
      minPointSize = minPointSize < point.size ? minPointSize : point.size;
    });
  });
  const sizeDispersion = maxPointSize - minPointSize;
  const areaDispersion = abs(maxBubbleArea - minBubbleArea);
  (0, _iterator.each)(series, function (_, seriesItem) {
    (0, _iterator.each)(seriesItem.getPoints(), function (_, point) {
      if (maxPointSize === minPointSize) {
        pointSize = round(equalBubbleSize);
      } else {
        sizeProportion = abs(point.size - minPointSize) / sizeDispersion;
        bubbleArea = areaDispersion * sizeProportion + minBubbleArea;
        pointSize = round(sqrt(bubbleArea));
      }
      point.correctCoordinates(pointSize);
    });
  });
}
function SeriesFamily(options) {
  const that = this;
  that.type = (0, _utils.normalizeEnum)(options.type);
  that.pane = options.pane;
  that.series = [];
  that.updateOptions(options);
  switch (that.type) {
    case 'bar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.updateSeriesValues = updateBarSeriesValues;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;
    case 'rangebar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.updateSeriesValues = updateRangeSeriesValues;
      break;
    case 'fullstackedbar':
      that.fullStacked = true;
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      that.updateSeriesValues = updateStackedSeriesValues;
      break;
    case 'stackedbar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      that.updateSeriesValues = updateStackedSeriesValues;
      break;
    case 'fullstackedarea':
    case 'fullstackedline':
    case 'fullstackedspline':
    case 'fullstackedsplinearea':
      that.fullStacked = true;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;
    case 'stackedarea':
    case 'stackedsplinearea':
    case 'stackedline':
    case 'stackedspline':
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;
    case 'candlestick':
    case 'stock':
      that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;
      break;
    case 'bubble':
      that.adjustSeriesDimensions = adjustBubbleSeriesDimensions;
      break;
  }
}
SeriesFamily.prototype = {
  constructor: SeriesFamily,
  adjustSeriesDimensions: _common.noop,
  adjustSeriesValues: _common.noop,
  updateSeriesValues: _common.noop,
  updateOptions: function (options) {
    this._options = options;
  },
  dispose: function () {
    this.series = null;
  },
  add: function (series) {
    const type = this.type;
    this.series = (0, _utils.map)(series, singleSeries => singleSeries.type === type ? singleSeries : null);
  }
};

/***/ }),

/***/ 17384:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.Title = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _layout_element = __webpack_require__(73711);
const _Number = Number;
const parseHorizontalAlignment = (0, _utils.enumParser)(['left', 'center', 'right']);
const parseVerticalAlignment = (0, _utils.enumParser)(['top', 'bottom']);
const DEFAULT_MARGIN = 10;
function hasText(text) {
  return !!(text && String(text).length > 0);
}
function processTitleLength(elem, text, width, options, placeholderSize) {
  if (elem.attr({
    text
  }).setMaxSize(width, placeholderSize, options).textChanged) {
    elem.setTitle(text);
  }
}
function pickMarginValue(value) {
  return value >= 0 ? _Number(value) : DEFAULT_MARGIN;
}
function validateMargin(margin) {
  let result;
  if (margin >= 0) {
    result = {
      left: _Number(margin),
      top: _Number(margin),
      right: _Number(margin),
      bottom: _Number(margin)
    };
  } else {
    margin = margin || {};
    result = {
      left: pickMarginValue(margin.left),
      top: pickMarginValue(margin.top),
      right: pickMarginValue(margin.right),
      bottom: pickMarginValue(margin.bottom)
    };
  }
  return result;
}
function checkRect(rect, boundingRect) {
  return rect[2] - rect[0] < boundingRect.width || rect[3] - rect[1] < boundingRect.height;
}
let Title = function (params) {
  this._params = params;
  this._group = params.renderer.g().attr({
    'class': params.cssClass
  }).linkOn(params.root || params.renderer.root, 'title');
  this._hasText = false;
};

// There is no normal inheritance from LayoutElement because it is actually a container of methods rather than a class.
exports.Title = Title;
(0, _extend.extend)(Title.prototype, _layout_element.LayoutElement.prototype, {
  dispose: function () {
    const that = this;
    that._group.linkRemove();
    that._group.linkOff();
    if (that._titleElement) {
      that._clipRect.dispose();
      that._titleElement = that._subtitleElement = that._clipRect = null;
    }
    that._params = that._group = that._options = null;
  },
  _updateOptions: function (options) {
    this._options = options;
    this._options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, 'center');
    this._options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, 'top');
    this._options.margin = validateMargin(options.margin);
  },
  _updateStructure: function () {
    const that = this;
    const renderer = that._params.renderer;
    const group = that._group;
    const options = that._options;
    const align = options.horizontalAlignment;

    // Looks like the following "laziness" is only to avoid unnecessary DOM content creation -
    // for example when widget is created without "title" option.
    if (!that._titleElement) {
      that._titleElement = renderer.text().append(group);
      that._subtitleElement = renderer.text();
      that._clipRect = renderer.clipRect();
      group.attr({
        'clip-path': that._clipRect.id
      });
    }
    that._titleElement.attr({
      align,
      'class': options.cssClass
    });
    that._subtitleElement.attr({
      align,
      'class': options.subtitle.cssClass
    });
    group.linkAppend();
    hasText(options.subtitle.text) ? that._subtitleElement.append(group) : that._subtitleElement.remove();
  },
  _updateTexts: function () {
    const that = this;
    const options = that._options;
    const subtitleOptions = options.subtitle;
    const titleElement = that._titleElement;
    const subtitleElement = that._subtitleElement;
    const testText = 'A';
    let titleBox;
    titleElement.attr({
      text: testText,
      y: 0
    }).css((0, _utils.patchFontOptions)(options.font));
    titleBox = titleElement.getBBox(); // for multiline text
    that._baseLineCorrection = titleBox.height + titleBox.y;
    titleElement.attr({
      text: options.text
    });
    titleBox = titleElement.getBBox();
    const y = -titleBox.y;
    titleElement.attr({
      y: y
    });
    if (hasText(subtitleOptions.text)) {
      subtitleElement.attr({
        text: subtitleOptions.text,
        y: 0
      }).css((0, _utils.patchFontOptions)(subtitleOptions.font));
    }
  },
  _shiftSubtitle() {
    const that = this;
    const titleBox = that._titleElement.getBBox();
    const element = that._subtitleElement;
    const offset = that._options.subtitle.offset;
    element.move(0, titleBox.y + titleBox.height - element.getBBox().y - offset);
  },
  _updateBoundingRectAlignment: function () {
    const boundingRect = this._boundingRect;
    const options = this._options;
    boundingRect.verticalAlignment = options.verticalAlignment;
    boundingRect.horizontalAlignment = options.horizontalAlignment;
    boundingRect.cutLayoutSide = options.verticalAlignment;
    boundingRect.cutSide = 'vertical';
    boundingRect.position = {
      horizontal: options.horizontalAlignment,
      vertical: options.verticalAlignment
    };
  },
  hasText: function () {
    return this._hasText;
  },
  update: function (themeOptions, userOptions) {
    const that = this;
    const options = (0, _extend.extend)(true, {}, themeOptions, processTitleOptions(userOptions));
    const _hasText = hasText(options.text);
    const isLayoutChanged = _hasText || _hasText !== that._hasText;
    that._baseLineCorrection = 0;
    that._updateOptions(options);
    that._boundingRect = {};
    if (_hasText) {
      that._updateStructure();
      that._updateTexts();
    } else {
      that._group.linkRemove();
    }
    that._updateBoundingRect();
    that._updateBoundingRectAlignment();
    that._hasText = _hasText;
    return isLayoutChanged;
  },
  draw: function (width, height) {
    const that = this;
    if (that._hasText) {
      that._group.linkAppend();
      that._correctTitleLength(width);
      if (that._group.getBBox().height > height) {
        this.freeSpace();
      }
    }
    return that;
  },
  _correctTitleLength: function (width) {
    const that = this;
    const options = that._options;
    const margin = options.margin;
    const maxWidth = width - margin.left - margin.right;
    let placeholderSize = options.placeholderSize;
    processTitleLength(that._titleElement, options.text, maxWidth, options, placeholderSize);
    if (that._subtitleElement) {
      if (_Number(placeholderSize) > 0) {
        placeholderSize -= that._titleElement.getBBox().height;
      }
      processTitleLength(that._subtitleElement, options.subtitle.text, maxWidth, options.subtitle, placeholderSize);
      that._shiftSubtitle();
    }
    that._updateBoundingRect();
    const {
      x,
      y,
      height
    } = this.getCorrectedLayoutOptions();
    this._clipRect.attr({
      x,
      y,
      width,
      height
    });
  },
  getLayoutOptions: function () {
    return this._boundingRect || null;
  },
  shift: function (x, y) {
    const that = this;
    const box = that.getLayoutOptions();
    that._group.move(x - box.x, y - box.y);
    return that;
  },
  _updateBoundingRect: function () {
    const that = this;
    const options = that._options;
    const margin = options.margin;
    const boundingRect = that._boundingRect;
    const box = that._hasText ? that._group.getBBox() : {
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      isEmpty: true
    };
    if (!box.isEmpty) {
      box.height += margin.top + margin.bottom - that._baseLineCorrection;
      box.width += margin.left + margin.right;
      box.x -= margin.left;
      box.y += that._baseLineCorrection - margin.top;
    }
    if (options.placeholderSize > 0) {
      box.height = options.placeholderSize;
    }
    boundingRect.height = box.height;
    boundingRect.width = box.width;
    boundingRect.x = box.x;
    boundingRect.y = box.y;
  },
  getCorrectedLayoutOptions() {
    const srcBox = this.getLayoutOptions();
    const correction = this._baseLineCorrection;
    return (0, _extend.extend)({}, srcBox, {
      y: srcBox.y - correction,
      height: srcBox.height + correction
    });
  },
  // BaseWidget_layout_implementation
  layoutOptions: function () {
    if (!this._hasText) {
      return null;
    }
    return {
      horizontalAlignment: this._boundingRect.horizontalAlignment,
      verticalAlignment: this._boundingRect.verticalAlignment,
      priority: 0
    };
  },
  measure: function (size) {
    this.draw(size[0], size[1]);
    return [this._boundingRect.width, this._boundingRect.height];
  },
  move: function (rect, fitRect) {
    const boundingRect = this._boundingRect;
    if (checkRect(rect, boundingRect)) {
      this.shift(fitRect[0], fitRect[1]);
    } else {
      this.shift(Math.round(rect[0]), Math.round(rect[1]));
    }
  },
  freeSpace: function () {
    const that = this;
    that._params.incidentOccurred('W2103');
    that._group.linkRemove();
    that._boundingRect.width = that._boundingRect.height = 0;
  },
  getOptions: function () {
    return this._options;
  },
  changeLink: function (root) {
    this._group.linkRemove();
    this._group.linkOn(root, 'title');
  }
  // BaseWidget_layout_implementation
});
function processTitleOptions(options) {
  const newOptions = (0, _type.isString)(options) ? {
    text: options
  } : options || {};
  newOptions.subtitle = (0, _type.isString)(newOptions.subtitle) ? {
    text: newOptions.subtitle
  } : newOptions.subtitle || {};
  return newOptions;
}
const plugin = exports.plugin = {
  name: 'title',
  init: function () {
    const that = this;
    // "exports" is used for testing purposes.
    that._title = new Title({
      renderer: that._renderer,
      cssClass: that._rootClassPrefix + '-title',
      incidentOccurred: that._incidentOccurred
    });
    that._layout.add(that._title);
  },
  dispose: function () {
    this._title.dispose();
    this._title = null;
  },
  customize: function (constructor) {
    constructor.addChange({
      code: 'TITLE',
      handler: function () {
        if (this._title.update(this._themeManager.theme('title'), this.option('title'))) {
          this._change(['LAYOUT']);
        }
      },
      isThemeDependent: true,
      option: 'title',
      isOptionChange: true
    });
  },
  fontFields: ['title.font', 'title.subtitle.font']
};

/***/ }),

/***/ 14371:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.Tooltip = void 0;
var _size = __webpack_require__(58664);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _dom = __webpack_require__(3532);
var _inflector = __webpack_require__(78008);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _renderer2 = __webpack_require__(56453);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _plaque = __webpack_require__(64509);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const format = _format_helper.default.format;
const mathCeil = Math.ceil;
const mathMax = Math.max;
const mathMin = Math.min;
const window = (0, _window.getWindow)();
const DEFAULT_HTML_GROUP_WIDTH = 3000;
function hideElement($element) {
  $element.css({
    left: '-9999px'
  }).detach();
}
function getSpecialFormatOptions(options, specialFormat) {
  let result = options;
  switch (specialFormat) {
    case 'argument':
      result = {
        format: options.argumentFormat
      };
      break;
    case 'percent':
      result = {
        format: {
          type: 'percent',
          precision: options.format && options.format.percentPrecision
        }
      };
      break;
  }
  return result;
}
function createTextHtml() {
  return (0, _renderer.default)('<div>').css({
    position: 'relative',
    display: 'inline-block',
    padding: 0,
    margin: 0,
    border: '0px solid transparent'
  });
}
function removeElements(elements) {
  elements.forEach(el => el.remove());
}
let Tooltip = function (params) {
  const that = this;
  that._eventTrigger = params.eventTrigger;
  that._widgetRoot = params.widgetRoot;
  that._widget = params.widget;
  that._textHtmlContainers = []; // T1015148

  that._wrapper = (0, _renderer.default)('<div>').css({
    position: 'absolute',
    overflow: 'hidden',
    'pointerEvents': 'none'
  }) // T265557, T447623
  .addClass(params.cssClass);
  const renderer = that._renderer = new _renderer2.Renderer({
    pathModified: params.pathModified,
    container: that._wrapper[0]
  });
  const root = renderer.root;
  root.attr({
    'pointer-events': 'none'
  });

  // svg text
  that._text = renderer.text(undefined, 0, 0);

  // html text
  that._textGroupHtml = (0, _renderer.default)('<div>').css({
    position: 'absolute',
    padding: 0,
    margin: 0,
    border: '0px solid transparent'
  }).appendTo(that._wrapper);
  that._textHtml = createTextHtml().appendTo(that._textGroupHtml);
};
exports.Tooltip = Tooltip;
Tooltip.prototype = {
  constructor: Tooltip,
  dispose: function () {
    this._wrapper.remove();
    this._renderer.dispose();
    this._options = this._widgetRoot = null;
  },
  _getContainer: function () {
    const options = this._options;
    let container = (0, _renderer.default)(this._widgetRoot).closest(options.container);
    if (container.length === 0) {
      container = (0, _renderer.default)(options.container);
    }
    return (container.length ? container : (0, _renderer.default)('body')).get(0);
  },
  setTemplate(contentTemplate) {
    const that = this;
    that._template = contentTemplate ? that._widget._getTemplate(contentTemplate) : null;
  },
  setOptions: function (options) {
    options = options || {};
    const that = this;
    that._options = options;
    that._textFontStyles = (0, _utils.patchFontOptions)(options.font);
    that._textFontStyles.color = that._textFontStyles.fill;
    that._wrapper.css({
      'zIndex': options.zIndex
    });
    that._customizeTooltip = options.customizeTooltip;
    const textGroupHtml = that._textGroupHtml;
    if (this.plaque) {
      this.plaque.clear();
    }
    this.setTemplate(options.contentTemplate);
    const pointerEvents = options.interactive ? 'auto' : 'none';
    if (options.interactive) {
      this._renderer.root.css({
        '-moz-user-select': 'auto',
        '-webkit-user-select': 'auto'
      });
    }
    const drawTooltip = _ref => {
      let {
        group,
        onRender,
        eventData,
        isMoving,
        templateCallback = () => {}
      } = _ref;
      const state = that._state;
      if (!isMoving) {
        const template = that._template;
        const useTemplate = template && !state.formatObject.skipTemplate;
        if (state.html || useTemplate) {
          textGroupHtml.css({
            color: state.textColor,
            width: DEFAULT_HTML_GROUP_WIDTH,
            'pointerEvents': pointerEvents
          });
          if (useTemplate) {
            const htmlContainers = that._textHtmlContainers;
            const containerToTemplateRender = createTextHtml().appendTo(that._textGroupHtml);
            htmlContainers.push(containerToTemplateRender);
            template.render({
              model: state.formatObject,
              container: containerToTemplateRender,
              onRendered: () => {
                removeElements(htmlContainers.splice(0, htmlContainers.length - 1));
                that._textHtml = (0, _dom.replaceWith)(that._textHtml, containerToTemplateRender);
                state.html = that._textHtml.html();
                if ((0, _size.getWidth)(that._textHtml) === 0 && (0, _size.getHeight)(that._textHtml) === 0) {
                  this.plaque.clear();
                  templateCallback(false);
                  return;
                }
                onRender();
                that._riseEvents(eventData);
                that._moveWrapper();
                that.plaque.customizeCloud({
                  fill: state.color,
                  stroke: state.borderColor,
                  'pointer-events': pointerEvents
                });
                templateCallback(true);
                that._textHtmlContainers = [];
              }
            });
            return;
          } else {
            that._text.attr({
              text: ''
            });
            that._textHtml.html(state.html);
          }
        } else {
          that._text.css({
            fill: state.textColor
          }).attr({
            text: state.text,
            class: options.cssClass,
            'pointer-events': pointerEvents
          }).append(group.attr({
            align: options.textAlignment
          }));
        }
        that._riseEvents(eventData);
        that.plaque.customizeCloud({
          fill: state.color,
          stroke: state.borderColor,
          'pointer-events': pointerEvents
        });
      }
      onRender();
      that._moveWrapper();
      return true;
    };
    this.plaque = new _plaque.Plaque({
      opacity: that._options.opacity,
      color: that._options.color,
      border: that._options.border,
      paddingLeftRight: that._options.paddingLeftRight,
      paddingTopBottom: that._options.paddingTopBottom,
      arrowLength: that._options.arrowLength,
      arrowWidth: 20,
      shadow: that._options.shadow,
      cornerRadius: that._options.cornerRadius
    }, that, that._renderer.root, drawTooltip, true, (tooltip, g) => {
      const state = tooltip._state;
      if (state.html) {
        let bBox = window.getComputedStyle(that._textHtml.get(0));
        bBox = {
          x: 0,
          y: 0,
          width: mathCeil(parseFloat(bBox.width)),
          height: mathCeil(parseFloat(bBox.height))
        };
        return bBox;
      }
      return g.getBBox();
    }, (tooltip, g, x, y) => {
      const state = tooltip._state;
      if (state.html) {
        that._textGroupHtml.css({
          left: x,
          top: y
        });
      } else {
        g.move(x, y);
      }
    });
    return that;
  },
  _riseEvents: function (eventData) {
    // trigger event
    // The *onTooltipHidden* is triggered outside the *hide* method because of the cases when *show* is called to determine if tooltip will be visible or not (when target is changed) -
    // *hide* can neither be called before that *show* - because if tooltip is determined to hide it requires some timeout before actually hiding
    // nor after that *show* - because it is either too early to hide (because of timeout) or wrong (because tooltip has already been shown for new target)
    // It is only inside the *show* where it is known weather *onTooltipHidden* is required or not
    // This functionality can be simplified when we get rid of timeouts for tooltip
    const that = this;
    that._eventData && that._eventTrigger('tooltipHidden', that._eventData);
    that._eventData = eventData;
    that._eventTrigger('tooltipShown', that._eventData);
  },
  setRendererOptions: function (options) {
    this._renderer.setOptions(options);
    this._textGroupHtml.css({
      direction: options.rtl ? 'rtl' : 'ltr'
    });
    return this;
  },
  update: function (options) {
    const that = this;
    that.setOptions(options);

    // The following is because after update (on widget refresh) tooltip must be hidden
    hideElement(that._wrapper);

    // text area
    const normalizedCSS = {};
    for (const name in that._textFontStyles) {
      normalizedCSS[(0, _inflector.camelize)(name)] = that._textFontStyles[name];
    }
    that._textGroupHtml.css(normalizedCSS);
    that._text.css(that._textFontStyles);
    that._eventData = null;
    return that;
  },
  _prepare: function (formatObject, state) {
    let customizeTooltip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._customizeTooltip;
    const options = this._options;
    let customize = {};
    if ((0, _type.isFunction)(customizeTooltip)) {
      customize = customizeTooltip.call(formatObject, formatObject);
      customize = (0, _type.isPlainObject)(customize) ? customize : {};
      if ('text' in customize) {
        state.text = (0, _type.isDefined)(customize.text) ? String(customize.text) : '';
      }
      if ('html' in customize) {
        state.html = (0, _type.isDefined)(customize.html) ? String(customize.html) : '';
      }
    }
    if (!('text' in state) && !('html' in state)) {
      state.text = formatObject.valueText || formatObject.description || '';
    }
    state.color = customize.color || options.color;
    state.borderColor = customize.borderColor || (options.border || {}).color;
    state.textColor = customize.fontColor || (this._textFontStyles || {}).color;
    return !!state.text || !!state.html || !!this._template;
  },
  show: function (formatObject, params, eventData, customizeTooltip, templateCallback) {
    const that = this;
    if (that._options.forceEvents) {
      // for Blazor charts
      eventData.x = params.x;
      eventData.y = params.y - params.offset;
      that._riseEvents(eventData);
      return true;
    }
    const state = {
      formatObject,
      eventData,
      templateCallback
    };
    if (!that._prepare(formatObject, state, customizeTooltip)) {
      return false;
    }
    that._state = state;
    that._wrapper.appendTo(that._getContainer());
    that._clear();
    const parameters = (0, _extend.extend)({}, that._options, {
      canvas: that._getCanvas()
    }, state, {
      x: params.x,
      y: params.y,
      offset: params.offset
    });
    return this.plaque.clear().draw(parameters);
  },
  isCursorOnTooltip: function (x, y) {
    if (this._options.interactive) {
      const box = this.plaque.getBBox();
      return x > box.x && x < box.x + box.width && y > box.y && y < box.y + box.height;
    }
    return false;
  },
  hide: function (isPointerOut) {
    const that = this;
    hideElement(that._wrapper);
    // trigger event
    if (that._eventData) {
      that._eventTrigger('tooltipHidden', that._options.forceEvents ? (0, _extend.extend)({
        isPointerOut
      }, that._eventData) : that._eventData);
      that._clear();
      that._eventData = null;
    }
  },
  _clear() {
    this._textHtml.empty();
  },
  move: function (x, y, offset) {
    this.plaque.draw({
      x,
      y,
      offset,
      canvas: this._getCanvas(),
      isMoving: true
    });
  },
  _moveWrapper: function () {
    const that = this;
    const plaqueBBox = this.plaque.getBBox();
    that._renderer.resize(plaqueBBox.width, plaqueBBox.height);

    // move wrapper
    const offset = that._wrapper.css({
      left: 0,
      top: 0
    }).offset();
    const left = plaqueBBox.x;
    const top = plaqueBBox.y;
    that._wrapper.css({
      left: left - offset.left,
      top: top - offset.top
    });
    this.plaque.moveRoot(-left, -top);
    if (this._state.html) {
      that._textHtml.css({
        left: -left,
        top: -top
      });
      that._textGroupHtml.css({
        width: mathCeil((0, _size.getWidth)(that._textHtml))
      });
    }
  },
  formatValue: function (value, _specialFormat) {
    const options = _specialFormat ? getSpecialFormatOptions(this._options, _specialFormat) : this._options;
    return format(value, options.format);
  },
  getOptions() {
    return this._options;
  },
  getLocation: function () {
    return (0, _utils.normalizeEnum)(this._options.location);
  },
  isEnabled: function () {
    return !!this._options.enabled || !!this._options.forceEvents; // for Blazor charts
  },
  isShared: function () {
    return !!this._options.shared;
  },
  _getCanvas: function () {
    const container = this._getContainer();
    const containerBox = container.getBoundingClientRect();
    const html = _dom_adapter.default.getDocumentElement();
    const document = _dom_adapter.default.getDocument();
    let left = window.pageXOffset || html.scrollLeft || 0;
    let top = window.pageYOffset || html.scrollTop || 0;
    const box = {
      left: left,
      top: top,
      width: mathMax(html.clientWidth, document.body.clientWidth) + left,
      height: mathMax(document.body.scrollHeight, html.scrollHeight, document.body.offsetHeight, html.offsetHeight, document.body.clientHeight, html.clientHeight),
      right: 0,
      bottom: 0
    };
    if (container !== _dom_adapter.default.getBody()) {
      left = mathMax(box.left, box.left + containerBox.left);
      top = mathMax(box.top, box.top + containerBox.top);
      box.width = mathMin(containerBox.width, box.width) + left + box.left;
      box.height = mathMin(containerBox.height, box.height) + top + box.top;
      box.left = left;
      box.top = top;
    }
    return box;
  }
};
const plugin = exports.plugin = {
  name: 'tooltip',
  init: function () {
    this._initTooltip();
  },
  dispose: function () {
    this._disposeTooltip();
  },
  members: {
    // The method exists only to be overridden in sparklines.
    _initTooltip: function () {
      // "exports" is used for testing purposes.
      this._tooltip = new Tooltip({
        cssClass: this._rootClassPrefix + '-tooltip',
        eventTrigger: this._eventTrigger,
        pathModified: this.option('pathModified'),
        widgetRoot: this.element(),
        widget: this
      });
    },
    // The method exists only to be overridden in sparklines.
    _disposeTooltip: function () {
      this._tooltip.dispose();
      this._tooltip = null;
    },
    // The method exists only to be overridden in sparklines.
    _setTooltipRendererOptions: function () {
      this._tooltip.setRendererOptions(this._getRendererOptions());
    },
    // The method exists only to be overridden in sparklines and gauges.
    _setTooltipOptions: function () {
      this._tooltip.update(this._getOption('tooltip'));
    }
  },
  extenders: {
    _stopCurrentHandling() {
      this._tooltip && this._tooltip.hide();
    }
  },
  customize: function (constructor) {
    const proto = constructor.prototype;
    proto._eventsMap.onTooltipShown = {
      name: 'tooltipShown'
    };
    proto._eventsMap.onTooltipHidden = {
      name: 'tooltipHidden'
    };
    constructor.addChange({
      code: 'TOOLTIP_RENDERER',
      handler: function () {
        this._setTooltipRendererOptions();
      },
      isThemeDependent: true,
      isOptionChange: true
    });
    constructor.addChange({
      code: 'TOOLTIP',
      handler: function () {
        this._setTooltipOptions();
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'tooltip'
    });
  },
  fontFields: ['tooltip.font']
};

/***/ }),

/***/ 19157:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.PANE_PADDING = void 0;
exports.adjustVisualRange = adjustVisualRange;
exports.convertAngleToRendererSpace = void 0;
exports.convertPolarToXY = convertPolarToXY;
exports.convertVisualRangeObject = convertVisualRangeObject;
exports.enumParser = exports.degreesToRadians = exports.decreaseGaps = exports.convertXYToPolar = void 0;
exports.extractColor = extractColor;
exports.getAddFunction = getAddFunction;
exports.getLog = exports.getDistance = exports.getDecimalOrder = exports.getCosAndSin = exports.getCategoriesInfo = exports.getAppropriateFormat = exports.getAdjustedLog10 = void 0;
exports.getLogExt = getLogExt;
exports.getVerticallyShiftedAngularCoords = exports.getPower = exports.getNextDefsSvgId = void 0;
exports.getVizRangeObject = getVizRangeObject;
exports.isRelativeHeightPane = isRelativeHeightPane;
exports.map = map;
exports.mergeMarginOptions = mergeMarginOptions;
exports.normalizeAngle = void 0;
exports.normalizeArcParams = normalizeArcParams;
exports.normalizeBBox = normalizeBBox;
exports.normalizeEnum = normalizeEnum;
exports.normalizePanesHeight = normalizePanesHeight;
exports.patchFontOptions = exports.parseScalar = void 0;
exports.pointInCanvas = pointInCanvas;
exports.raiseTo = exports.processSeriesTemplate = void 0;
exports.raiseToExt = raiseToExt;
exports.rangesAreEqual = rangesAreEqual;
exports.rotateBBox = rotateBBox;
exports.roundValue = void 0;
exports.setCanvasValues = setCanvasValues;
exports.unique = void 0;
exports.updatePanesCanvases = updatePanesCanvases;
exports.valueOf = valueOf;
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _math = __webpack_require__(60810);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _color = _interopRequireDefault(__webpack_require__(52752));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  PI,
  LN10,
  abs,
  log,
  floor,
  ceil,
  pow,
  sqrt,
  atan2
} = Math;
const _min = Math.min;
const _max = Math.max;
const _cos = Math.cos;
const _sin = Math.sin;
const _round = Math.round;
const dateToMilliseconds = _date.default.dateToMilliseconds;
const MAX_PIXEL_COUNT = 1E10;
const PI_DIV_180 = PI / 180;
const _isNaN = isNaN;
const _Number = Number;
const _NaN = NaN;
let numDefsSvgElements = 1;
const PANE_PADDING = exports.PANE_PADDING = 10;
const getLog = function (value, base) {
  if (!value) {
    return _NaN;
  }
  return log(value) / log(base);
};
exports.getLog = getLog;
const getAdjustedLog10 = function (value) {
  return (0, _math.adjust)(getLog(value, 10));
};
exports.getAdjustedLog10 = getAdjustedLog10;
const raiseTo = function (power, base) {
  return pow(base, power);
};

//  Translates angle to [0, 360)
//  Expects number, no validation
exports.raiseTo = raiseTo;
const normalizeAngle = function (angle) {
  return (angle % 360 + 360) % 360;
};

//  Maps angle in trigonometric space to angle in 'renderer' space
//  Expects numbers, no validation
exports.normalizeAngle = normalizeAngle;
const convertAngleToRendererSpace = function (angle) {
  return 90 - angle;
};

//  Maps angle in degrees to angle in radians
//  Expects number, no validation
exports.convertAngleToRendererSpace = convertAngleToRendererSpace;
const degreesToRadians = function (value) {
  return PI * value / 180;
};

//  Calculates sin and cos for <angle> in degrees
//  Expects number, no validation
exports.degreesToRadians = degreesToRadians;
const getCosAndSin = function (angle) {
  const angleInRadians = degreesToRadians(angle);
  return {
    cos: _cos(angleInRadians),
    sin: _sin(angleInRadians)
  };
};

//  Because Math.log(1000) / Math.LN10 < 3 though it is exactly 3
//  Same happens for 1E6, 1E9, 1E12, 1E13, 1E15, ...
exports.getCosAndSin = getCosAndSin;
const DECIMAL_ORDER_THRESHOLD = 1E-14;
//    ____________________
//   /       2          2
// \/ (y2-y1)  + (x2-x1)
const getDistance = function (x1, y1, x2, y2) {
  const diffX = x2 - x1;
  const diffY = y2 - y1;
  return sqrt(diffY * diffY + diffX * diffX);
};
exports.getDistance = getDistance;
const getDecimalOrder = function (number) {
  let n = abs(number);
  let cn;
  if (!_isNaN(n)) {
    if (n > 0) {
      n = log(n) / LN10;
      cn = ceil(n);
      return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n);
    }
    return 0;
  }
  return _NaN;
};
exports.getDecimalOrder = getDecimalOrder;
const getAppropriateFormat = function (start, end, count) {
  const order = _max(getDecimalOrder(start), getDecimalOrder(end));
  let precision = -getDecimalOrder(abs(end - start) / count);
  let format;
  if (!_isNaN(order) && !_isNaN(precision)) {
    if (abs(order) <= 4) {
      format = 'fixedPoint';
      precision < 0 && (precision = 0);
      precision > 4 && (precision = 4);
    } else {
      format = 'exponential';
      precision += order - 1;
      precision > 3 && (precision = 3);
    }
    return {
      type: format,
      precision: precision
    };
  }
  return null;
};
exports.getAppropriateFormat = getAppropriateFormat;
const roundValue = function (value, precision) {
  if (precision > 20) {
    precision = 20;
  }
  if ((0, _type.isNumeric)(value)) {
    if ((0, _type.isExponential)(value)) {
      return _Number(value.toExponential(precision));
    } else {
      return _Number(value.toFixed(precision));
    }
  }
};
exports.roundValue = roundValue;
const getPower = function (value) {
  return value.toExponential().split('e')[1];
};
exports.getPower = getPower;
function map(array, callback) {
  let i = 0;
  const len = array.length;
  const result = [];
  let value;
  while (i < len) {
    value = callback(array[i], i);
    if (value !== null) {
      result.push(value);
    }
    i++;
  }
  return result;
}
function selectByKeys(object, keys) {
  return map(keys, key => object[key] ? object[key] : null);
}
function decreaseFields(object, keys, eachDecrease, decrease) {
  let dec = decrease;
  (0, _iterator.each)(keys, (_, key) => {
    if (object[key]) {
      object[key] -= eachDecrease;
      dec -= eachDecrease;
    }
  });
  return dec;
}
function normalizeEnum(value) {
  return String(value).toLowerCase();
}
function setCanvasValues(canvas) {
  if (canvas) {
    canvas.originalTop = canvas.top;
    canvas.originalBottom = canvas.bottom;
    canvas.originalLeft = canvas.left;
    canvas.originalRight = canvas.right;
  }
  return canvas;
}
function normalizeBBoxField(value) {
  return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0;
}
function normalizeBBox(bBox) {
  const xl = normalizeBBoxField(floor(bBox.x));
  const yt = normalizeBBoxField(floor(bBox.y));
  const xr = normalizeBBoxField(ceil(bBox.width + bBox.x));
  const yb = normalizeBBoxField(ceil(bBox.height + bBox.y));
  const result = {
    x: xl,
    y: yt,
    width: xr - xl,
    height: yb - yt
  };
  result.isEmpty = !result.x && !result.y && !result.width && !result.height;
  return result;
}

// Angle is expected to be from right-handed cartesian (not svg) space - positive is counterclockwise
function rotateBBox(bBox, center, angle) {
  const cos = _Number(_cos(angle * PI_DIV_180).toFixed(3));
  const sin = _Number(_sin(angle * PI_DIV_180).toFixed(3));
  const w2 = bBox.width / 2;
  const h2 = bBox.height / 2;
  const centerX = bBox.x + w2;
  const centerY = bBox.y + h2;
  const w2_ = abs(w2 * cos) + abs(h2 * sin);
  const h2_ = abs(w2 * sin) + abs(h2 * cos);
  // Note that the following slightly differs from theoretical formula:
  // x' = x * cos - y * sin, y' = x * sin + y * cos
  // That is because in svg y goes down (not up) - so sign of sin is reverted
  // x' = x * cos + y * sin, y' = -x * sin + y * cos
  const centerX_ = center[0] + (centerX - center[0]) * cos + (centerY - center[1]) * sin;
  const centerY_ = center[1] - (centerX - center[0]) * sin + (centerY - center[1]) * cos;
  return normalizeBBox({
    x: centerX_ - w2_,
    y: centerY_ - h2_,
    width: 2 * w2_,
    height: 2 * h2_
  });
}
const decreaseGaps = function (object, keys, decrease) {
  let arrayGaps;
  do {
    arrayGaps = selectByKeys(object, keys);
    arrayGaps.push(ceil(decrease / arrayGaps.length));
    decrease = decreaseFields(object, keys, _min.apply(null, arrayGaps), decrease);
  } while (decrease > 0 && arrayGaps.length > 1);
  return decrease;
};
exports.decreaseGaps = decreaseGaps;
const parseScalar = function (value, defaultValue) {
  return value !== undefined ? value : defaultValue;
};
exports.parseScalar = parseScalar;
const enumParser = function (values) {
  const stored = {};
  let i;
  let ii;
  for (i = 0, ii = values.length; i < ii; ++i) {
    stored[normalizeEnum(values[i])] = 1;
  }
  return function (value, defaultValue) {
    const _value = normalizeEnum(value);
    return stored[_value] ? _value : defaultValue;
  };
};
exports.enumParser = enumParser;
const patchFontOptions = function (options) {
  const fontOptions = {};
  (0, _iterator.each)(options || {}, function (key, value) {
    if (/^(cursor)$/i.test(key)) {
      // TODO check other properties, add tests
    } else if (key === 'opacity') {
      value = null;
    } else if (key === 'color') {
      key = 'fill';
      if ('opacity' in options) {
        const color = new _color.default(value);
        value = `rgba(${color.r},${color.g},${color.b},${options.opacity})`;
      }
    } else {
      key = 'font-' + key;
    }
    fontOptions[key] = value;
  });
  return fontOptions;
};
exports.patchFontOptions = patchFontOptions;
function convertPolarToXY(centerCoords, startAngle, angle, radius) {
  const shiftAngle = 90;
  const normalizedRadius = radius > 0 ? radius : 0;
  angle = (0, _type.isDefined)(angle) ? angle + startAngle - shiftAngle : 0;
  const cosSin = getCosAndSin(angle);
  return {
    x: _round(centerCoords.x + normalizedRadius * cosSin.cos),
    y: _round(centerCoords.y + normalizedRadius * cosSin.sin)
  };
}
const convertXYToPolar = function (centerCoords, x, y) {
  const radius = getDistance(centerCoords.x, centerCoords.y, x, y);
  const angle = atan2(y - centerCoords.y, x - centerCoords.x);
  return {
    phi: _round(normalizeAngle(angle * 180 / PI)),
    r: _round(radius)
  };
};
exports.convertXYToPolar = convertXYToPolar;
const processSeriesTemplate = function (seriesTemplate, items) {
  const customizeSeries = (0, _type.isFunction)(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : _common.noop;
  const nameField = seriesTemplate.nameField;
  const generatedSeries = {};
  const seriesOrder = [];
  let series;
  let i = 0;
  let length;
  let data;
  items = items || [];
  for (length = items.length; i < length; i++) {
    data = items[i];
    if (nameField in data) {
      series = generatedSeries[data[nameField]];
      if (!series) {
        series = generatedSeries[data[nameField]] = {
          name: data[nameField],
          nameFieldValue: data[nameField]
        };
        seriesOrder.push(series.name);
      }
    }
  }
  return map(seriesOrder, function (orderedName) {
    const group = generatedSeries[orderedName];
    return (0, _extend.extend)(group, customizeSeries.call(null, group.name));
  });
};
exports.processSeriesTemplate = processSeriesTemplate;
const getCategoriesInfo = function (categories, startValue, endValue) {
  if (categories.length === 0) {
    return {
      categories: []
    };
  }
  startValue = (0, _type.isDefined)(startValue) ? startValue : categories[0];
  endValue = (0, _type.isDefined)(endValue) ? endValue : categories[categories.length - 1];
  const categoriesValue = map(categories, category => category === null || category === void 0 ? void 0 : category.valueOf());
  let indexStartValue = categoriesValue.indexOf(startValue.valueOf());
  let indexEndValue = categoriesValue.indexOf(endValue.valueOf());
  let swapBuf;
  let inverted = false;
  indexStartValue < 0 && (indexStartValue = 0);
  indexEndValue < 0 && (indexEndValue = categories.length - 1);
  if (indexEndValue < indexStartValue) {
    swapBuf = indexEndValue;
    indexEndValue = indexStartValue;
    indexStartValue = swapBuf;
    inverted = true;
  }
  const visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);
  const lastIdx = visibleCategories.length - 1;
  return {
    categories: visibleCategories,
    start: visibleCategories[inverted ? lastIdx : 0],
    end: visibleCategories[inverted ? 0 : lastIdx],
    inverted: inverted
  };
};
exports.getCategoriesInfo = getCategoriesInfo;
function isRelativeHeightPane(pane) {
  return !(pane.unit % 2);
}
function normalizePanesHeight(panes) {
  panes.forEach(pane => {
    const height = pane.height;
    let unit = 0;
    let parsedHeight = parseFloat(height) || undefined;
    if ((0, _type.isString)(height) && height.indexOf('px') > -1 || (0, _type.isNumeric)(height) && height > 1) {
      parsedHeight = _round(parsedHeight);
      unit = 1;
    }
    if (!unit && parsedHeight) {
      if ((0, _type.isString)(height) && height.indexOf('%') > -1) {
        parsedHeight = parsedHeight / 100;
        unit = 2;
      } else if (parsedHeight < 0) {
        parsedHeight = parsedHeight < -1 ? 1 : abs(parsedHeight);
      }
    }
    pane.height = parsedHeight;
    pane.unit = unit;
  });
  const relativeHeightPanes = panes.filter(isRelativeHeightPane);
  const weightSum = relativeHeightPanes.reduce((prev, next) => prev + (next.height || 0), 0);
  const weightHeightCount = relativeHeightPanes.length;
  const emptyHeightPanes = relativeHeightPanes.filter(pane => !pane.height);
  const emptyHeightCount = emptyHeightPanes.length;
  if (weightSum < 1 && emptyHeightCount) {
    emptyHeightPanes.forEach(pane => pane.height = (1 - weightSum) / emptyHeightCount);
  } else if (weightSum > 1 || weightSum < 1 && !emptyHeightCount || weightSum === 1 && emptyHeightCount) {
    if (emptyHeightCount) {
      const weightForEmpty = weightSum / weightHeightCount;
      const emptyWeightSum = emptyHeightCount * weightForEmpty;
      relativeHeightPanes.filter(pane => pane.height).forEach(pane => pane.height *= (weightSum - emptyWeightSum) / weightSum);
      emptyHeightPanes.forEach(pane => pane.height = weightForEmpty);
    }
    relativeHeightPanes.forEach(pane => pane.height *= 1 / weightSum);
  }
}
function updatePanesCanvases(panes, canvas, rotated) {
  let distributedSpace = 0;
  const padding = PANE_PADDING;
  const paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom;
  const totalCustomSpace = panes.reduce((prev, cur) => prev + (!isRelativeHeightPane(cur) ? cur.height : 0), 0);
  const usefulSpace = paneSpace - padding * (panes.length - 1) - totalCustomSpace;
  const startName = rotated ? 'left' : 'top';
  const endName = rotated ? 'right' : 'bottom';
  panes.forEach(pane => {
    const calcLength = !isRelativeHeightPane(pane) ? pane.height : _round(pane.height * usefulSpace);
    pane.canvas = pane.canvas || {};
    (0, _extend.extend)(pane.canvas, canvas);
    pane.canvas[startName] = canvas[startName] + distributedSpace;
    pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);
    distributedSpace = distributedSpace + calcLength + padding;
    setCanvasValues(pane.canvas);
  });
}
const unique = function (array) {
  const values = {};
  return map(array, function (item) {
    const result = !values[item] ? item : null;
    values[item] = true;
    return result;
  });
};
exports.unique = unique;
const getVerticallyShiftedAngularCoords = function (bBox, dy, center) {
  // TODO: Use center instead of left top corner - that is more correct and allows to get rid of "isPositive"
  //   horizontalOffset1 = bBox.x + bBox.width / 2 - center.x
  //   horizontalOffset2 = bBox.y + bBox.height / 2 - center.y
  //   verticalOffset2 = newCoord.y + bBox.height / 2 - center.y
  const isPositive = bBox.x + bBox.width / 2 >= center.x;
  const horizontalOffset1 = (isPositive ? bBox.x : bBox.x + bBox.width) - center.x;
  const verticalOffset1 = bBox.y - center.y;
  const verticalOffset2 = verticalOffset1 + dy;
  const horizontalOffset2 = _round(sqrt(horizontalOffset1 * horizontalOffset1 + verticalOffset1 * verticalOffset1 - verticalOffset2 * verticalOffset2));
  const dx = (isPositive ? +horizontalOffset2 : -horizontalOffset2) || horizontalOffset1;
  return {
    x: center.x + (isPositive ? dx : dx - bBox.width),
    y: bBox.y + dy
  };
};
exports.getVerticallyShiftedAngularCoords = getVerticallyShiftedAngularCoords;
function mergeMarginOptions(opt1, opt2) {
  return {
    checkInterval: opt1.checkInterval || opt2.checkInterval,
    size: _max(opt1.size || 0, opt2.size || 0),
    percentStick: opt1.percentStick || opt2.percentStick,
    sizePointNormalState: _max(opt1.sizePointNormalState || 0, opt2.sizePointNormalState || 0)
  };
}
function getVizRangeObject(value) {
  if (Array.isArray(value)) {
    return {
      startValue: value[0],
      endValue: value[1]
    };
  } else {
    return value || {};
  }
}
function normalizeArcParams(x, y, innerRadius, outerRadius, startAngle, endAngle) {
  let isCircle;
  let noArc = true;
  const angleDiff = roundValue(endAngle, 3) - roundValue(startAngle, 3);
  if (angleDiff) {
    if (abs(angleDiff) % 360 === 0) {
      startAngle = 0;
      endAngle = 360;
      isCircle = true;
      endAngle -= 0.01;
    }
    if (startAngle > 360) {
      startAngle = startAngle % 360;
    }
    if (endAngle > 360) {
      endAngle = endAngle % 360;
    }
    if (startAngle > endAngle) {
      startAngle -= 360;
    }
    noArc = false;
  }
  startAngle *= PI_DIV_180;
  endAngle *= PI_DIV_180;
  return [x, y, Math.min(outerRadius, innerRadius), Math.max(outerRadius, innerRadius), Math.cos(startAngle), Math.sin(startAngle), Math.cos(endAngle), Math.sin(endAngle), isCircle, floor(abs(endAngle - startAngle) / PI) % 2 ? '1' : '0', noArc];
}
function convertVisualRangeObject(visualRange, convertToVisualRange) {
  if (convertToVisualRange) {
    return visualRange;
  }
  return [visualRange.startValue, visualRange.endValue];
}
function getAddFunction(range, correctZeroLevel) {
  // T170398
  if (range.dataType === 'datetime') {
    return function (rangeValue, marginValue) {
      let sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return new Date(rangeValue.getTime() + sign * marginValue);
    };
  }
  if (range.axisType === 'logarithmic') {
    return function (rangeValue, marginValue) {
      let sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      const log = getLogExt(rangeValue, range.base) + sign * marginValue;
      return raiseToExt(log, range.base);
    };
  }
  return function (rangeValue, marginValue) {
    let sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    const newValue = rangeValue + sign * marginValue;
    return correctZeroLevel && newValue * rangeValue <= 0 ? 0 : newValue;
  };
}
function adjustVisualRange(options, visualRange, wholeRange, dataRange) {
  const minDefined = (0, _type.isDefined)(visualRange.startValue);
  const maxDefined = (0, _type.isDefined)(visualRange.endValue);
  const nonDiscrete = options.axisType !== 'discrete';
  dataRange = dataRange || wholeRange;
  const add = getAddFunction(options, false);
  let min = minDefined ? visualRange.startValue : dataRange.min;
  let max = maxDefined ? visualRange.endValue : dataRange.max;
  let rangeLength = visualRange.length;
  const categories = dataRange.categories;
  if (nonDiscrete && !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {
    return {
      startValue: min,
      endValue: max
    };
  }
  if ((0, _type.isDefined)(rangeLength)) {
    if (nonDiscrete) {
      if (options.dataType === 'datetime' && !(0, _type.isNumeric)(rangeLength)) {
        rangeLength = dateToMilliseconds(rangeLength);
      }
      if (maxDefined && !minDefined || !maxDefined && !minDefined) {
        (0, _type.isDefined)(wholeRange.max) && (max = max > wholeRange.max ? wholeRange.max : max);
        min = add(max, rangeLength, -1);
      } else if (minDefined && !maxDefined) {
        (0, _type.isDefined)(wholeRange.min) && (min = min < wholeRange.min ? wholeRange.min : min);
        max = add(min, rangeLength);
      }
    } else {
      rangeLength = parseInt(rangeLength);
      if (!isNaN(rangeLength) && isFinite(rangeLength)) {
        rangeLength--;
        if (!maxDefined && !minDefined) {
          max = categories[categories.length - 1];
          min = categories[categories.length - 1 - rangeLength];
        } else if (minDefined && !maxDefined) {
          const categoriesInfo = getCategoriesInfo(categories, min, undefined);
          max = categoriesInfo.categories[rangeLength];
        } else if (!minDefined && maxDefined) {
          const categoriesInfo = getCategoriesInfo(categories, undefined, max);
          min = categoriesInfo.categories[categoriesInfo.categories.length - 1 - rangeLength];
        }
      }
    }
  }
  if (nonDiscrete) {
    if ((0, _type.isDefined)(wholeRange.max) && max > wholeRange.max) {
      max = wholeRange.max;
    }
    if ((0, _type.isDefined)(wholeRange.min) && min < wholeRange.min) {
      min = wholeRange.min;
    }
  }
  return {
    startValue: min,
    endValue: max
  };
}
function getLogExt(value, base) {
  let allowNegatives = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let linearThreshold = arguments.length > 3 ? arguments[3] : undefined;
  if (!allowNegatives) {
    return getLog(value, base);
  }
  if (value === 0) {
    return 0;
  }
  const transformValue = getLog(abs(value), base) - (linearThreshold - 1);
  if (transformValue < 0) {
    return 0;
  }
  return (0, _math.adjust)((0, _math.sign)(value) * transformValue, Number(pow(base, linearThreshold - 1).toFixed(abs(linearThreshold))));
}
function raiseToExt(value, base) {
  let allowNegatives = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let linearThreshold = arguments.length > 3 ? arguments[3] : undefined;
  if (!allowNegatives) {
    return raiseTo(value, base);
  }
  if (value === 0) {
    return 0;
  }
  const transformValue = raiseTo(abs(value) + (linearThreshold - 1), base);
  if (transformValue < 0) {
    return 0;
  }
  return (0, _math.adjust)((0, _math.sign)(value) * transformValue, Number(pow(base, linearThreshold).toFixed(abs(linearThreshold))));
}
function rangesAreEqual(range, rangeFromOptions) {
  if (Array.isArray(rangeFromOptions)) {
    return range.length === rangeFromOptions.length && range.every((item, i) => valueOf(item) === valueOf(rangeFromOptions[i]));
  } else {
    return valueOf(range.startValue) === valueOf(rangeFromOptions.startValue) && valueOf(range.endValue) === valueOf(rangeFromOptions.endValue);
  }
}
function valueOf(value) {
  return value && value.valueOf();
}
function pointInCanvas(canvas, x, y) {
  return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom;
}
const getNextDefsSvgId = () => {
  return `DevExpress_${numDefsSvgElements++}`;
};
exports.getNextDefsSvgId = getNextDefsSvgId;
function extractColor(color, isBase) {
  if ((0, _type.isString)(color) || !color) {
    return color;
  } else if (isBase) {
    return color.base;
  } else {
    return color.fillId || color.base;
  }
}

/***/ }),

/***/ 5259:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _export = __webpack_require__(82454);
Object.keys(_export).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _export[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _export[key];
    }
  });
});

/***/ }),

/***/ 30187:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _funnel = _interopRequireDefault(__webpack_require__(44697));
var _label = __webpack_require__(47250);
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _legend = __webpack_require__(16342);
var _tracker = __webpack_require__(76686);
var _tooltip = __webpack_require__(32037);
var _loading_indicator = __webpack_require__(64758);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
_funnel.default.addPlugin(_label.plugin);
_funnel.default.addPlugin(_export.plugin);
_funnel.default.addPlugin(_title.plugin);
_funnel.default.addPlugin(_legend.plugin);
_funnel.default.addPlugin(_tracker.plugin);
_funnel.default.addPlugin(_tooltip.plugin);
_funnel.default.addPlugin(_loading_indicator.plugin);
var _default = exports["default"] = _funnel.default;
/**
 * @name dxFunnelItem
 * @publicName Item
 */
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 44697:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tiling = __webpack_require__(68074);
var _tiling2 = _interopRequireDefault(__webpack_require__(89482));
var _tiling3 = _interopRequireDefault(__webpack_require__(2356));
var _common = __webpack_require__(20576);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _item = _interopRequireDefault(__webpack_require__(65700));
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NODES_CREATE_CHANGE = 'NODES_CREATE';
(0, _tiling.addAlgorithm)('dynamicslope', _tiling2.default, true);
(0, _tiling.addAlgorithm)('dynamicheight', _tiling3.default);
function invertFigure(figure) {
  return figure.map(function (coord, index) {
    return index % 2 ? 1 - coord : coord;
  });
}
function getLegendItemState(itemState) {
  return {
    fill: itemState.fill,
    hatching: itemState.hatching
  };
}
const dxFunnel = _m_base_widget.default.inherit({
  _rootClass: 'dxf-funnel',
  _rootClassPrefix: 'dxf',
  _proxyData: [],
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    neckWidth: NODES_CREATE_CHANGE,
    neckHeight: NODES_CREATE_CHANGE,
    inverted: NODES_CREATE_CHANGE,
    algorithm: NODES_CREATE_CHANGE,
    item: NODES_CREATE_CHANGE,
    valueField: NODES_CREATE_CHANGE,
    argumentField: NODES_CREATE_CHANGE,
    colorField: NODES_CREATE_CHANGE,
    palette: NODES_CREATE_CHANGE,
    paletteExtensionMode: NODES_CREATE_CHANGE,
    sortData: NODES_CREATE_CHANGE
  },
  _themeDependentChanges: [NODES_CREATE_CHANGE],
  _getDefaultSize: function () {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'funnel',
  _fontFields: ['legend.title.font', 'legend.title.subtitle.font', 'legend.font'],
  _optionChangesOrder: ['DATA_SOURCE'],
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function () {
    this._group = this._renderer.g().append(this._renderer.root);
    this._items = [];
  },
  _eventsMap: {
    onHoverChanged: {
      name: 'hoverChanged'
    },
    onSelectionChanged: {
      name: 'selectionChanged'
    }
  },
  _disposeCore: _common.noop,
  _applySize: function (rect) {
    this._rect = rect.slice();
    this._change(['TILING']);
    return this._rect;
  },
  _getAlignmentRect: function () {
    return this._rect;
  },
  _change_TILING: function () {
    const that = this;
    const items = that._items;
    const rect = that._rect;
    const convertCoord = function (coord, index) {
      const offset = index % 2;
      return rect[0 + offset] + (rect[2 + offset] - rect[0 + offset]) * coord;
    };
    this._group.clear();
    items.forEach(function (item, index) {
      const coords = item.figure.map(convertCoord);
      const element = that._renderer.path([], 'area').attr({
        points: coords
      }).append(that._group);
      item.coords = coords;
      item.element = element;
    });
    this._requestChange(['TILES']);
  },
  _customChangesOrder: [NODES_CREATE_CHANGE, 'LAYOUT', 'TILING', 'TILES', 'DRAWN'],
  _dataSourceChangedHandler: function () {
    this._requestChange([NODES_CREATE_CHANGE]);
  },
  _change_DRAWN: function () {
    this._drawn();
  },
  _change_DATA_SOURCE: function () {
    this._change(['DRAWN']);
    this._updateDataSource();
  },
  _change_NODES_CREATE: function () {
    this._buildNodes();
  },
  _change_TILES: function () {
    this._applyTilesAppearance();
  },
  _suspend: function () {
    if (!this._applyingChanges) {
      this._suspendChanges();
    }
  },
  _resume: function () {
    if (!this._applyingChanges) {
      this._resumeChanges();
    }
  },
  _applyTilesAppearance: function () {
    this._items.forEach(function (item) {
      const state = item.getState();
      item.element.smartAttr(item.states[state]);
    });
  },
  _hitTestTargets: function (x, y) {
    const that = this;
    let data;
    this._proxyData.some(function (callback) {
      data = callback.call(that, x, y);
      if (data) {
        return true;
      }
    });
    return data;
  },
  clearHover: function () {
    this._suspend();
    this._items.forEach(function (item) {
      item.isHovered() && item.hover(false);
    });
    this._resume();
  },
  clearSelection: function () {
    this._suspend();
    this._items.forEach(function (item) {
      item.isSelected() && item.select(false);
    });
    this._resume();
  },
  _getData: function () {
    const that = this;
    const data = that._dataSourceItems() || [];
    const valueField = that._getOption('valueField', true);
    const argumentField = that._getOption('argumentField', true);
    const colorField = that._getOption('colorField', true);
    const processedData = data.reduce(function (d, item) {
      const value = Number(item[valueField]);
      if (value >= 0) {
        d[0].push({
          value: value,
          color: item[colorField],
          argument: item[argumentField],
          dataItem: item
        });
        d[1] += value;
      }
      return d;
    }, [[], 0]);
    const items = processedData[0];
    if (data.length > 0 && items.length === 0) {
      that._incidentOccurred('E2005', valueField);
    }
    if (!processedData[1]) {
      return [];
    }
    if (that._getOption('sortData', true)) {
      items.sort(function (a, b) {
        return b.value - a.value;
      });
    }
    return items;
  },
  _buildNodes: function () {
    const that = this;
    const data = that._getData();
    const algorithm = (0, _tiling.getAlgorithm)(that._getOption('algorithm', true));
    const percents = algorithm.normalizeValues(data);
    const itemOptions = that._getOption('item');
    const figures = algorithm.getFigures(percents, that._getOption('neckWidth', true), that._getOption('neckHeight', true));
    const palette = that._themeManager.createPalette(that._getOption('palette', true), {
      useHighlight: true,
      extensionMode: that._getOption('paletteExtensionMode', true),
      count: figures.length
    });
    that._items = figures.map(function (figure, index) {
      const curData = data[index];
      const node = new _item.default(that, {
        figure: figure,
        data: curData,
        percent: percents[index],
        id: index,
        color: curData.color || palette.getNextColor(),
        itemOptions: itemOptions
      });
      return node;
    });
    if (that._getOption('inverted', true)) {
      that._items.forEach(function (item) {
        item.figure = invertFigure(item.figure);
      });
    }
    that._renderer.initDefsElements();
    that._change(['TILING', 'DRAWN']);
  },
  _showTooltip: _common.noop,
  hideTooltip: _common.noop,
  getAllItems: function () {
    return this._items.slice();
  },
  _getLegendData() {
    return this._items.map(item => {
      const states = item.states;
      return {
        id: item.id,
        visible: true,
        text: item.argument,
        item: item,
        states: {
          normal: getLegendItemState(states.normal),
          hover: getLegendItemState(states.hover),
          selection: getLegendItemState(states.selection)
        }
      };
    });
  },
  _getMinSize: function () {
    const adaptiveLayout = this._getOption('adaptiveLayout');
    return [adaptiveLayout.width, adaptiveLayout.height];
  }
});
(0, _component_registrator.default)('dxFunnel', dxFunnel);
var _default = exports["default"] = dxFunnel; // PLUGINS_SECTION
dxFunnel.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 65700:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
const states = ['normal', 'hover', 'selection', 'selection'];
function parseStyles(color, style, baseStyle) {
  const border = style.border;
  const baseBorder = baseStyle.border;
  const borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  const borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  return {
    fill: color,
    hatching: style.hatching,
    stroke: border.color || baseBorder.color,
    'stroke-width': borderVisible ? borderWidth : 0
  };
}
function Item(widget, options) {
  const that = this;
  const data = options.data;
  that.code = 0;
  that.widget = widget;
  that.figure = options.figure;
  that.argument = data.argument;
  that.value = data.value;
  that.data = data.dataItem;
  that.percent = options.percent;
  that.id = options.id;
  that.color = options.color;
  that.states = {
    normal: parseStyles(options.color, options.itemOptions, options.itemOptions),
    hover: parseStyles(options.color, options.itemOptions.hoverStyle, options.itemOptions),
    selection: parseStyles(options.color, options.itemOptions.selectionStyle, options.itemOptions)
  };
}
Item.prototype = {
  getState: function () {
    return states[this.code];
  },
  getNormalStyle: function () {
    return this.states.normal;
  },
  setHover: function () {
    this.hover(true);
  },
  hover: function (state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }
    this.widget._suspend();
    state && this.widget.clearHover();
    this.setState(1, state);
    this.widget._eventTrigger('hoverChanged', {
      item: this
    });
    this.widget._resume();
  },
  setState: function (code, state) {
    if (state) {
      this.code |= code;
    } else {
      this.code &= ~code;
    }
    this.widget._applyTilesAppearance();
  },
  select: function (state) {
    const mode = this.widget._getOption('selectionMode', true);
    if (mode === 'none' || state === this.isSelected()) {
      return;
    }
    this.widget._suspend();
    if (state && mode !== 'multiple') {
      this.widget.clearSelection();
    }
    this.setState(2, state);
    this.widget._eventTrigger('selectionChanged', {
      item: this
    });
    this.widget._resume();
  },
  showTooltip: function (coords) {
    this.widget._showTooltip(this.id, coords);
  },
  getColor: function () {
    return this.color;
  },
  isHovered: function () {
    return !!(this.code & 1);
  },
  isSelected: function () {
    return !!(this.code & 2);
  }
};
var _default = exports["default"] = Item;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 47250:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _label = __webpack_require__(28318);
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
var _common = __webpack_require__(20576);
const OUTSIDE_POSITION = 'outside';
const INSIDE_POSITION = 'inside';
const OUTSIDE_LABEL_INDENT = 5;
const COLUMNS_LABEL_INDENT = 20;
const CONNECTOR_INDENT = 4;
const PREVENT_EMPTY_PIXEL_OFFSET = 1;
function getLabelIndent(pos) {
  pos = (0, _utils.normalizeEnum)(pos);
  if (pos === OUTSIDE_POSITION) {
    return OUTSIDE_LABEL_INDENT;
  } else if (pos === INSIDE_POSITION) {
    return 0;
  }
  return COLUMNS_LABEL_INDENT;
}
function isOutsidePosition(pos) {
  pos = (0, _utils.normalizeEnum)(pos);
  return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION;
}
function correctYForInverted(y, bBox, inverted) {
  return inverted ? y - bBox.height : y;
}
function getOutsideRightLabelPosition(coords, bBox, options, inverted) {
  return {
    x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,
    y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
  };
}
function getOutsideLeftLabelPosition(coords, bBox, options, inverted) {
  return {
    x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,
    y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)
  };
}
function getInsideLabelPosition(coords, bBox, options) {
  const width = coords[2] - coords[0];
  const height = coords[7] - coords[1];
  return {
    x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,
    y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2
  };
}
function getColumnLabelRightPosition(labelRect, rect, textAlignment) {
  return function (coords, bBox, options, inverted) {
    return {
      x: textAlignment === 'left' ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,
      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
    };
  };
}
function getColumnLabelLeftPosition(labelRect, rect, textAlignment) {
  return function (coords, bBox, options, inverted) {
    return {
      x: textAlignment === 'left' ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,
      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
    };
  };
}
function getConnectorStrategy(options, inverted) {
  const isLeftPos = options.horizontalAlignment === 'left';
  const connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;
  const verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;
  function getFigureCenter(figure) {
    return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection];
  }
  return {
    isLabelInside: function () {
      return !isOutsidePosition(options.position);
    },
    getFigureCenter: getFigureCenter,
    prepareLabelPoints: function (bBox) {
      const x = bBox.x + connectorIndent;
      const y = bBox.y;
      const x1 = x + bBox.width;
      return [...Array(bBox.height + 1)].map((_, i) => [x, y + i]).concat([...Array(bBox.height + 1)].map((_, i) => [x1, y + i]));
    },
    isHorizontal: function () {
      return true;
    },
    findFigurePoint: function (figure) {
      return getFigureCenter(figure);
    },
    adjustPoints: function (points) {
      return points.map(Math.round);
    }
  };
}
function getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {
  const opt = labelOptions || {};
  const labelFont = (0, _extend.extend)({}, opt.font) || {};
  const labelBorder = opt.border || {};
  const labelConnector = opt.connector || {};
  const backgroundAttr = {
    fill: opt.backgroundColor || defaultColor,
    'stroke-width': labelBorder.visible ? labelBorder.width || 0 : 0,
    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : 'none',
    dashStyle: labelBorder.dashStyle
  };
  const connectorAttr = {
    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : 'none',
    'stroke-width': labelConnector.visible ? labelConnector.width || 0 : 0,
    opacity: labelConnector.opacity
  };
  labelFont.color = opt.backgroundColor === 'none' && (0, _utils.normalizeEnum)(labelFont.color) === '#ffffff' && opt.position !== 'inside' ? defaultColor : labelFont.color;
  return {
    format: opt.format,
    textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : 'center'),
    customizeText: opt.customizeText,
    attributes: {
      font: labelFont
    },
    visible: labelFont.size !== 0 ? opt.visible : false,
    showForZeroValues: opt.showForZeroValues,
    horizontalOffset: opt.horizontalOffset,
    verticalOffset: opt.verticalOffset,
    background: backgroundAttr,
    connector: connectorAttr,
    wordWrap: labelOptions.wordWrap,
    textOverflow: labelOptions.textOverflow
  };
}
function correctLabelPosition(pos, bBox, rect) {
  if (pos.x < rect[0]) {
    pos.x = rect[0];
  }
  if (pos.x + bBox.width > rect[2]) {
    pos.x = rect[2] - bBox.width;
  }
  if (pos.y < rect[1]) {
    pos.y = rect[1];
  }
  if (pos.y + bBox.height > rect[3]) {
    pos.y = rect[3] - bBox.height;
  }
  return pos;
}
function removeEmptySpace(labels, requiredSpace, startPoint) {
  labels.reduce((requiredSpace, label, index, labels) => {
    const prevLabel = labels[index + 1];
    if (requiredSpace > 0) {
      const bBox = label.getBoundingRect();
      const point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;
      const emptySpace = bBox.y - point;
      const shift = Math.min(emptySpace, requiredSpace);
      labels.slice(0, index + 1).forEach(label => {
        const bBox = label.getBoundingRect();
        label.shift(bBox.x, bBox.y - shift);
      });
      requiredSpace -= shift;
    }
    return requiredSpace;
  }, requiredSpace);
}
const plugin = exports.plugin = {
  name: 'lables',
  init: _common.noop,
  dispose: _common.noop,
  extenders: {
    _initCore: function () {
      this._labelsGroup = this._renderer.g().attr({
        class: this._rootClassPrefix + '-labels'
      }).append(this._renderer.root);
      this._labels = [];
    },
    _applySize: function () {
      const options = this._getOption('label');
      const adaptiveLayout = this._getOption('adaptiveLayout');
      const rect = this._rect;
      let labelWidth = 0;
      const width = rect[2] - rect[0];
      this._labelRect = rect.slice();
      if (!this._labels.length || !isOutsidePosition(options.position)) {
        if ((0, _utils.normalizeEnum)(this._getOption('resolveLabelOverlapping', true) !== 'none')) {
          this._labels.forEach(l => !l.isVisible() && l.draw(true));
        }
        return;
      }
      const groupWidth = this._labels.map(function (label) {
        label.resetEllipsis();
        return label.getBoundingRect().width;
      }).reduce(function (max, width) {
        return Math.max(max, width);
      }, 0);
      labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);
      if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {
        this._labels.forEach(function (label) {
          label.draw(false);
        });
        return;
      } else {
        if (width - labelWidth < adaptiveLayout.width) {
          labelWidth = width - adaptiveLayout.width;
          labelWidth = labelWidth > 0 ? labelWidth : 0;
        }
        this._labels.forEach(function (label) {
          label.draw(true);
        });
      }
      if (options.horizontalAlignment === 'left') {
        rect[0] += labelWidth;
      } else {
        rect[2] -= labelWidth;
      }
    },
    _buildNodes: function () {
      this._createLabels();
    },
    _change_TILING: function () {
      const that = this;
      const options = that._getOption('label');
      let getCoords = getInsideLabelPosition;
      const inverted = that._getOption('inverted', true);
      let textAlignment;
      if (isOutsidePosition(options.position)) {
        if ((0, _utils.normalizeEnum)(options.position) === OUTSIDE_POSITION) {
          getCoords = options.horizontalAlignment === 'left' ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition;
        } else {
          textAlignment = this._defaultLabelTextAlignment();
          getCoords = options.horizontalAlignment === 'left' ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment);
        }
      }
      that._labels.forEach(function (label, index) {
        const item = that._items[index];
        const borderWidth = item.getNormalStyle()['stroke-width'];
        const halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;
        const coords = halfBorderWidth ? item.coords.map(function (coord, index) {
          if (index === 1 || index === 3) {
            return coord - halfBorderWidth;
          } else if (index === 2) {
            return coord - borderWidth;
          } else if (index === 0) {
            return coord + borderWidth;
          }
          return coord;
        }) : item.coords;
        if (!options.showForZeroValues && item.value === 0) {
          label.draw(false);
          return;
        }
        if (isOutsidePosition(options.position)) {
          that._correctLabelWidth(label, item.coords, options);
        }
        const bBox = label.getBoundingRect();
        const pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);
        label.setFigureToDrawConnector(coords);
        label.shift(pos.x, pos.y);
      });
      that._resolveLabelOverlapping();
    }
  },
  members: {
    _resolveLabelOverlapping() {
      const that = this;
      const resolveLabelOverlapping = (0, _utils.normalizeEnum)(that._getOption('resolveLabelOverlapping', true));
      const labels = this._getOption('inverted', true) ? that._labels.slice().reverse() : that._labels;
      if (resolveLabelOverlapping === 'hide') {
        labels.reduce((height, label) => {
          if (label.getBoundingRect().y < height) {
            label.hide();
          } else {
            height = label.getBoundingRect().y + label.getBoundingRect().height;
          }
          return height;
        }, 0);
      } else if (resolveLabelOverlapping === 'shift') {
        const maxHeight = this._labelRect[3];
        labels.filter(label => label.isVisible()).reduce((_ref, label, index, labels) => {
          let [height, emptySpace] = _ref;
          const bBox = label.getBoundingRect();
          let y = bBox.y;
          if (bBox.y < height) {
            label.shift(bBox.x, height);
            y = height;
          }
          if (y - height > 0) {
            emptySpace += y - height;
          }
          if (y + bBox.height > maxHeight) {
            if (emptySpace && emptySpace > y + bBox.height - maxHeight) {
              removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);
              emptySpace -= y + bBox.height - maxHeight;
              label.shift(bBox.x, y - (y + bBox.height - maxHeight));
              height = y - (y + bBox.height - maxHeight) + bBox.height;
            } else {
              label.hide();
            }
          } else {
            height = y + bBox.height;
          }
          return [height, emptySpace];
        }, [this._labelRect[1], 0]);
      }
    },
    _defaultLabelTextAlignment: function () {
      return this._getOption('rtlEnabled', true) ? 'right' : 'left';
    },
    _correctLabelWidth: function (label, item, options) {
      const isLeftPos = options.horizontalAlignment === 'left';
      const minX = isLeftPos ? this._labelRect[0] : item[2];
      const maxX = isLeftPos ? item[0] : this._labelRect[2];
      const maxWidth = maxX - minX;
      if (label.getBoundingRect().width > maxWidth) {
        label.fit(maxWidth);
      }
    },
    _createLabels: function () {
      const that = this;
      const labelOptions = that._getOption('label');
      const connectorStrategy = getConnectorStrategy(labelOptions, that._getOption('inverted', true));
      this._labelsGroup.clear();
      if (!labelOptions.visible) {
        return;
      }
      this._labels = that._items.map(function (item) {
        const label = new _label.Label({
          renderer: that._renderer,
          labelsGroup: that._labelsGroup,
          strategy: connectorStrategy
        });
        label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));
        label.setData({
          item: item,
          value: item.value,
          percent: item.percent
        });
        label.draw(true);
        return label;
      });
      if (this._labels.length && isOutsidePosition(labelOptions.position)) {
        this._requestChange(['LAYOUT']);
      }
    }
  },
  customize: function (constructor) {
    constructor.prototype._proxyData.push(function (x, y) {
      const that = this;
      let data;
      that._labels.forEach(function (label, index) {
        const rect = label.getBoundingRect();
        if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
          const pos = isOutsidePosition(that._getOption('label').position) ? 'outside' : 'inside';
          data = {
            id: index,
            type: pos + '-label'
          };
          return true;
        }
      });
      return data;
    });
    ['label', 'resolveLabelOverlapping'].forEach(optionName => {
      constructor.addChange({
        code: optionName.toUpperCase(),
        handler: function () {
          this._createLabels();
          this._requestChange(['LAYOUT']);
        },
        isThemeDependent: true,
        isOptionChange: true,
        option: optionName
      });
    });
  },
  fontFields: ['label.font']
};

/***/ }),

/***/ 89482:
/***/ (function(module, exports) {



exports["default"] = void 0;
const CENTER = 0.5;
var _default = exports["default"] = {
  getFigures: function (data) {
    const height = 1 / data.length;
    return data.map(function (value, index, array) {
      const nextValue = array[index + 1] ? array[index + 1] : array[index];
      return [CENTER - value / 2, height * index, CENTER + value / 2, height * index, CENTER + nextValue / 2, height * (index + 1), CENTER - nextValue / 2, height * (index + 1)];
    });
  },
  normalizeValues: function (items) {
    const max = items.reduce(function (max, item) {
      return Math.max(item.value, max);
    }, items[0] && items[0].value || 0);
    return items.map(function (item) {
      return item.value / max;
    });
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 68074:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addAlgorithm = addAlgorithm;
exports.getAlgorithm = getAlgorithm;
var _utils = __webpack_require__(19157);
const algorithms = {};
let defaultAlgorithm;
function getAlgorithm(name) {
  return algorithms[(0, _utils.normalizeEnum)(name)] || defaultAlgorithm;
}
function addAlgorithm(name, callback, setDefault) {
  algorithms[name] = callback;
  if (setDefault) {
    defaultAlgorithm = algorithms[name];
  }
}

/***/ }),

/***/ 2356:
/***/ (function(module, exports) {



exports["default"] = void 0;
const CENTER = 0.5;
const LEFTCORNER = 0;
const RIGHTCORNER = 1;
var _default = exports["default"] = {
  getFigures: function (data, neckWidth, neckHeight) {
    let height = 0;
    let y = 0;
    let x = 0;
    let offsetX = 0;
    const halfNeckWidth = neckWidth / 2;
    const offsetFromCorner = CENTER - halfNeckWidth;
    const funnelHeight = 1 - neckHeight;
    const neckLeftCorner = CENTER - halfNeckWidth;
    const neckRightCorner = CENTER + halfNeckWidth;
    return data.map(function (value) {
      x = offsetX;
      y = height;
      height += value;
      offsetX = offsetFromCorner * height / funnelHeight;
      if (y <= funnelHeight && height <= funnelHeight) {
        return [x, y, RIGHTCORNER - x, y, RIGHTCORNER - offsetX, height, LEFTCORNER + offsetX, height];
      } else if (y <= funnelHeight && height > funnelHeight) {
        return [x, y, RIGHTCORNER - x, y, neckRightCorner, funnelHeight, neckRightCorner, height, neckLeftCorner, height, neckLeftCorner, funnelHeight];
      } else {
        return [neckLeftCorner, y, neckRightCorner, y, neckRightCorner, height, neckLeftCorner, height];
      }
    });
  },
  normalizeValues: function (items) {
    const sum = items.reduce(function (sum, item) {
      return sum + item.value;
    }, 0);
    return items.map(function (item) {
      return item.value / sum;
    });
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 32037:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _common = __webpack_require__(20576);
var _tooltip = __webpack_require__(14371);
function getCoords(coords, figureCoords, renderer) {
  const offset = renderer.getRootOffset();
  return coords || figureCoords && [(figureCoords[0] + figureCoords[2]) / 2 + offset.left, (figureCoords[1] + figureCoords[5]) / 2 + offset.top] || [-1000, -1000];
}
const plugin = exports.plugin = {
  name: 'funnel-tooltip',
  init: _common.noop,
  dispose: _common.noop,
  extenders: {
    _buildNodes: function () {
      this.hideTooltip();
    },
    _change_TILING: function () {
      if (this._tooltipIndex >= 0) {
        this._moveTooltip(this._items[this._tooltipIndex]);
      }
    }
  },
  members: {
    hideTooltip: function () {
      if (this._tooltipIndex >= 0) {
        this._tooltipIndex = -1;
        this._tooltip.hide();
      }
    },
    _moveTooltip: function (item, coords) {
      const xy = getCoords(coords, item.coords, this._renderer);
      this._tooltip.move(xy[0], xy[1], 0);
    },
    _showTooltip: function (index, coords) {
      const that = this;
      const tooltip = that._tooltip;
      const item = that._items[index];
      if (that._tooltipIndex === index) {
        that._moveTooltip(item, coords);
        return;
      }
      const callback = result => {
        if (result === undefined) {
          return;
        }
        if (!result) {
          tooltip.hide();
        }
        that._tooltipIndex = result ? index : -1;
      };
      const xy = getCoords(coords, item.coords, this._renderer);
      callback(tooltip.show({
        value: item.value,
        valueText: tooltip.formatValue(item.value),
        percentText: tooltip.formatValue(item.percent, 'percent'),
        percent: item.percent,
        item: item
      }, {
        x: xy[0],
        y: xy[1],
        offset: 0
      }, {
        item: item
      }, undefined, callback));
    }
  },
  customize: function (constructor) {
    constructor.addPlugin(_tooltip.plugin);
  }
};

/***/ }),

/***/ 76686:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _funnel = _interopRequireDefault(__webpack_require__(44697));
var _tracker = __webpack_require__(88997);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DATA_KEY_BASE = '__funnel_data_';
let dataKeyModifier = 0;
const proto = _funnel.default.prototype;
proto._eventsMap.onItemClick = {
  name: 'itemClick'
};
proto._eventsMap.onLegendClick = {
  name: 'legendClick'
};
const getDataKey = function () {
  return DATA_KEY_BASE + dataKeyModifier++;
};
const plugin = exports.plugin = {
  name: 'tracker',
  init: function () {
    const that = this;
    const dataKey = getDataKey();
    const getProxyData = function (e) {
      const rootOffset = that._renderer.getRootOffset();
      const x = Math.floor(e.pageX - rootOffset.left);
      const y = Math.floor(e.pageY - rootOffset.top);
      return that._hitTestTargets(x, y);
    };
    that._tracker = new _tracker.Tracker({
      widget: that,
      root: that._renderer.root,
      getData: function (e, tooltipData) {
        const target = e.target;
        const data = target[dataKey];
        if ((0, _type.isDefined)(data)) {
          return data;
        }
        const proxyData = getProxyData(e);
        if (tooltipData && proxyData && proxyData.type !== 'inside-label') {
          return;
        }
        return proxyData && proxyData.id;
      },
      getNode: function (index) {
        return that._items[index];
      },
      click: function (e) {
        const proxyData = getProxyData(e.event);
        const dataType = proxyData && proxyData.type;
        const event = dataType === 'legend' ? 'legendClick' : 'itemClick';
        that._eventTrigger(event, {
          item: e.node,
          event: e.event
        });
      }
    });
    this._dataKey = dataKey;
  },
  dispose: function () {
    this._tracker.dispose();
  },
  extenders: {
    _change_TILING: function () {
      const dataKey = this._dataKey;
      this._items.forEach(function (item, index) {
        item.element.data(dataKey, index);
      });
    }
  }
};

/***/ }),

/***/ 44898:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.dxBarGauge = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _object = __webpack_require__(48013);
var _common = __webpack_require__(20576);
var _m_base_chart = __webpack_require__(14107);
var _extend2 = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _base_gauge = __webpack_require__(18029);
var _circular_gauge = _interopRequireDefault(__webpack_require__(51576));
var _legend = __webpack_require__(16342);
var _center_template = __webpack_require__(56672);
var _math = __webpack_require__(60810);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const PI_DIV_180 = Math.PI / 180;
const _abs = Math.abs;
const _round = Math.round;
const _floor = Math.floor;
const _min = Math.min;
const _max = Math.max;
const _getSampleText = _base_gauge.getSampleText;
const _formatValue = _base_gauge.formatValue;
const _compareArrays = _base_gauge.compareArrays;
const _isArray = Array.isArray;
const _convertAngleToRendererSpace = _utils.convertAngleToRendererSpace;
const _getCosAndSin = _utils.getCosAndSin;
const _patchFontOptions = _utils.patchFontOptions;
const _Number = Number;
const _isFinite = isFinite;
const _noop = _common.noop;
const _extend = _extend2.extend;
const ARC_COORD_PREC = 5;
const OPTION_VALUES = 'values';
let BarWrapper;
const dxBarGauge = exports.dxBarGauge = _base_gauge.BaseGauge.inherit({
  _rootClass: 'dxbg-bar-gauge',
  _themeSection: 'barGauge',
  _fontFields: ['label.font', 'legend.font', 'legend.title.font', 'legend.title.subtitle.font'],
  _initCore: function () {
    const that = this;
    that.callBase.apply(that, arguments);
    that._barsGroup = that._renderer.g().attr({
      'class': 'dxbg-bars'
    }).linkOn(that._renderer.root, 'bars');
    that._values = [];
    that._context = {
      renderer: that._renderer,
      translator: that._translator,
      tracker: that._tracker,
      group: that._barsGroup
    };
    that._animateStep = function (pos) {
      const bars = that._bars;
      let i;
      let ii;
      for (i = 0, ii = bars.length; i < ii; ++i) {
        bars[i].animate(pos);
      }
    };
    that._animateComplete = function () {
      that._bars.forEach(bar => bar.endAnimation());
      that._checkOverlap();
    };
  },
  _disposeCore: function () {
    const that = this;
    that._barsGroup.linkOff();
    that._barsGroup = that._values = that._context = that._animateStep = that._animateComplete = null;
    that.callBase.apply(that, arguments);
  },
  _setupDomainCore: function () {
    const that = this;
    let startValue = that.option('startValue');
    let endValue = that.option('endValue');
    _isFinite(startValue) || (startValue = 0);
    _isFinite(endValue) || (endValue = 100);
    that._translator.setDomain(startValue, endValue);
    that._baseValue = that._translator.adjust(that.option('baseValue'));
    _isFinite(that._baseValue) || (that._baseValue = startValue < endValue ? startValue : endValue);
  },
  _getDefaultSize: function () {
    return {
      width: 300,
      height: 300
    };
  },
  _setupCodomain: _circular_gauge.default.prototype._setupCodomain,
  _getApproximateScreenRange: function () {
    const that = this;
    const sides = that._area.sides;
    const width = that._canvas.width / (sides.right - sides.left);
    const height = that._canvas.height / (sides.down - sides.up);
    const r = width < height ? width : height;
    return -that._translator.getCodomainRange() * r * PI_DIV_180;
  },
  _setupAnimationSettings: function () {
    const that = this;
    that.callBase.apply(that, arguments);
    if (that._animationSettings) {
      that._animationSettings.step = that._animateStep;
      that._animationSettings.complete = that._animateComplete;
    }
  },
  _cleanContent: function () {
    const that = this;
    that._barsGroup.linkRemove();
    that._animationSettings && that._barsGroup.stopAnimation();
    that._barsGroup.clear();
  },
  _renderContent: function () {
    const that = this;
    let labelOptions = that.option('label');
    const context = that._context;
    that._barsGroup.linkAppend();
    context.textEnabled = labelOptions === undefined || labelOptions && (!('visible' in labelOptions) || labelOptions.visible);
    if (context.textEnabled) {
      var _labelOptions, _labelOptions2;
      context.fontStyles = _patchFontOptions(_extend({}, that._themeManager.theme().label.font, (_labelOptions = labelOptions) === null || _labelOptions === void 0 ? void 0 : _labelOptions.font, {
        color: ((_labelOptions2 = labelOptions) === null || _labelOptions2 === void 0 || (_labelOptions2 = _labelOptions2.font) === null || _labelOptions2 === void 0 ? void 0 : _labelOptions2.color) || null
      }));
      labelOptions = _extend(true, {}, that._themeManager.theme().label, labelOptions);
      context.formatOptions = {
        format: labelOptions.format !== undefined ? labelOptions.format : that._defaultFormatOptions,
        customizeText: labelOptions.customizeText
      };
      context.textOptions = {
        align: 'center'
      };
      that._textIndent = labelOptions.indent > 0 ? _Number(labelOptions.indent) : 0;
      context.lineWidth = labelOptions.connectorWidth > 0 ? _Number(labelOptions.connectorWidth) : 0;
      context.lineColor = labelOptions.connectorColor || null;
      const text = that._renderer.text(_getSampleText(that._translator, context.formatOptions), 0, 0).attr(context.textOptions).css(context.fontStyles).append(that._barsGroup);
      const bBox = text.getBBox();
      text.remove();
      context.textY = bBox.y;
      context.textWidth = bBox.width;
      context.textHeight = bBox.height;
    }
    _circular_gauge.default.prototype._applyMainLayout.call(that);
    that._renderBars();
  },
  _measureMainElements: function () {
    const result = {
      maxRadius: this._area.radius
    };
    if (this._context.textEnabled) {
      result.horizontalMargin = this._context.textWidth;
      result.verticalMargin = this._context.textHeight;
      result.inverseHorizontalMargin = this._context.textWidth / 2;
      result.inverseVerticalMargin = this._context.textHeight / 2;
    }
    return result;
  },
  _renderBars: function () {
    const that = this;
    const options = _extend({}, that._themeManager.theme(), that.option());
    let radius;
    const area = that._area;
    const relativeInnerRadius = options.relativeInnerRadius > 0 && options.relativeInnerRadius < 1 ? _Number(options.relativeInnerRadius) : 0.1;
    radius = area.radius;
    if (that._context.textEnabled) {
      //  B253614
      that._textIndent = _round(_min(that._textIndent, radius / 2));
      radius -= that._textIndent;
    }
    that._outerRadius = _floor(radius);
    that._innerRadius = _floor(radius * relativeInnerRadius);
    that._barSpacing = options.barSpacing > 0 ? _Number(options.barSpacing) : 0;
    _extend(that._context, {
      backgroundColor: options.backgroundColor,
      x: area.x,
      y: area.y,
      startAngle: area.startCoord,
      endAngle: area.endCoord,
      baseAngle: that._translator.translate(that._baseValue)
    });
    that._arrangeBars();
  },
  _arrangeBars: function () {
    const that = this;
    let radius = that._outerRadius - that._innerRadius;
    const context = that._context;
    let i;
    const count = that._bars.length;
    that._beginValueChanging();
    context.barSize = count > 0 ? _max((radius - (count - 1) * that._barSpacing) / count, 1) : 0;
    const spacing = count > 1 ? _max(_min((radius - count * context.barSize) / (count - 1), that._barSpacing), 0) : 0;
    const _count = _min(_floor((radius + spacing) / context.barSize), count);
    that._setBarsCount(count);
    radius = that._outerRadius;
    context.textRadius = radius;
    context.textIndent = that._textIndent;
    that._palette.reset();
    const unitOffset = context.barSize + spacing;
    const colors = that._palette.generateColors(_count);
    for (i = 0; i < _count; ++i, radius -= unitOffset) {
      that._bars[i].arrange({
        radius: radius,
        color: colors[i]
      });
    }
    for (let i = _count; i < count; i++) {
      that._bars[i].hide();
    }
    if (that._animationSettings && !that._noAnimation) {
      that._animateBars();
    } else {
      that._updateBars();
    }
    that._endValueChanging();
  },
  _setBarsCount: function () {
    const that = this;
    if (that._bars.length > 0) {
      if (that._dummyBackground) {
        that._dummyBackground.dispose();
        that._dummyBackground = null;
      }
    } else {
      if (!that._dummyBackground) {
        that._dummyBackground = that._renderer.arc().attr({
          'stroke-linejoin': 'round'
        });
      }
      that._dummyBackground.attr({
        //  Because of vizMocks
        x: that._context.x,
        y: that._context.y,
        outerRadius: that._outerRadius,
        innerRadius: that._innerRadius,
        startAngle: that._context.endAngle,
        endAngle: that._context.startAngle,
        fill: that._context.backgroundColor
      }).append(that._barsGroup);
    }
  },
  _getCenter: function () {
    return {
      x: this._context.x,
      y: this._context.y
    };
  },
  _updateBars: function () {
    this._bars.forEach(bar => bar.applyValue());
    this._checkOverlap();
  },
  _checkOverlap: function () {
    const that = this;
    const overlapStrategy = (0, _utils.normalizeEnum)(that._getOption('resolveLabelOverlapping', true));
    function shiftFunction(box, length) {
      return (0, _utils.getVerticallyShiftedAngularCoords)(box, -length, that._context);
    }
    if (overlapStrategy === 'none') {
      return;
    }
    if (overlapStrategy === 'shift') {
      const newBars = that._dividePoints();
      _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(newBars.left, that._canvas, false, false, shiftFunction);
      _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(newBars.right, that._canvas, false, false, shiftFunction);
      that._clearLabelsCrossTitle();
      that._drawConnector();
    } else {
      that._clearOverlappingLabels();
    }
  },
  _drawConnector() {
    const that = this;
    const bars = that._bars;
    const {
      connectorWidth
    } = that._getOption('label');
    bars.forEach(bar => {
      if (!bar._isLabelShifted) {
        return;
      }
      const x = bar._bar.attr('x');
      const y = bar._bar.attr('y');
      const innerRadius = bar._bar.attr('innerRadius');
      const outerRadius = bar._bar.attr('outerRadius');
      const startAngle = bar._bar.attr('startAngle');
      const endAngle = bar._bar.attr('endAngle');
      const coordStart = getStartCoordsArc.apply(null, (0, _utils.normalizeArcParams)(x, y, innerRadius, outerRadius, startAngle, endAngle));
      const {
        cos,
        sin
      } = _getCosAndSin(bar._angle);
      const xStart = coordStart.x - sin * connectorWidth / 2 - cos;
      const yStart = coordStart.y - cos * connectorWidth / 2 + sin;
      const box = bar._text.getBBox();
      const lastCoords = bar._text._lastCoords;
      const indentFromLabel = that._context.textWidth / 2;
      const originalXLabelCoord = box.x + box.width / 2 + lastCoords.x;
      const originalPoints = [xStart, yStart, originalXLabelCoord, box.y + lastCoords.y];
      if (bar._angle > 90) {
        originalPoints[2] += indentFromLabel;
      } else {
        originalPoints[2] -= indentFromLabel;
      }
      if (bar._angle <= 180 && bar._angle > 0) {
        originalPoints[3] += box.height;
      }
      if (connectorWidth % 2) {
        const xDeviation = -sin / 2;
        const yDeviation = -cos / 2;
        if (bar._angle > 180) {
          originalPoints[0] -= xDeviation;
          originalPoints[1] -= yDeviation;
        } else if (bar._angle > 0 && bar._angle <= 90) {
          originalPoints[0] += xDeviation;
          originalPoints[1] += yDeviation;
        }
      }
      const points = originalPoints.map(coordinate => (0, _math.roundFloatPart)(coordinate, 4));
      bar._line.attr({
        points
      });
      bar._line.rotate(0);
      bar._isLabelShifted = false;
    });
  },
  _dividePoints() {
    const that = this;
    const bars = that._bars;
    return bars.reduce(function (stackBars, bar) {
      const angle = (0, _utils.normalizeAngle)(bar._angle);
      const isRightSide = angle <= 90 || angle >= 270;
      bar._text._lastCoords = {
        x: 0,
        y: 0
      };
      const barToExtend = isRightSide ? stackBars.right : stackBars.left;
      barToExtend.push({
        series: {
          isStackedSeries: () => false,
          isFullStackedSeries: () => false
        },
        getLabels: () => [{
          isVisible: () => true,
          getBoundingRect: () => {
            const {
              height,
              width,
              x,
              y
            } = bar._text.getBBox();
            const lastCoords = bar._text._lastCoords;
            return {
              x: x + lastCoords.x,
              y: y + lastCoords.y,
              width,
              height
            };
          },
          shift: (x, y) => {
            const box = bar._text.getBBox();
            bar._text._lastCoords = {
              x: x - box.x,
              y: y - box.y
            };
            bar._text.attr({
              translateX: x - box.x,
              translateY: y - box.y
            });
            bar._isLabelShifted = true;
          },
          draw: () => bar.hideLabel(),
          getData: () => {
            return {
              value: bar.getValue()
            };
          },
          hideInsideLabel: () => false
        }]
      });
      return stackBars;
    }, {
      left: [],
      right: []
    });
  },
  _clearOverlappingLabels() {
    const that = this;
    const bars = that._bars;
    let currentIndex = 0;
    let nextIndex = 1;
    const sortedBars = bars.concat().sort((a, b) => a.getValue() - b.getValue());
    while (currentIndex < sortedBars.length && nextIndex < sortedBars.length) {
      const current = sortedBars[currentIndex];
      const next = sortedBars[nextIndex];
      if (current.checkIntersect(next)) {
        next.hideLabel();
        nextIndex++;
      } else {
        currentIndex = nextIndex;
        nextIndex = currentIndex + 1;
      }
    }
  },
  _clearLabelsCrossTitle() {
    const that = this;
    const bars = that._bars;
    const titleCoords = that._title.getLayoutOptions() || {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    };
    const minY = titleCoords.y + titleCoords.height;
    bars.forEach(bar => {
      const box = bar._text.getBBox();
      const lastCoords = bar._text._lastCoords;
      if (minY > box.y + lastCoords.y) {
        bar.hideLabel();
      }
    });
  },
  _animateBars: function () {
    const that = this;
    let i;
    const ii = that._bars.length;
    if (ii > 0) {
      for (i = 0; i < ii; ++i) {
        that._bars[i].beginAnimation();
      }
      that._barsGroup.animate({
        _: 0
      }, that._animationSettings);
    }
  },
  _buildNodes() {
    const that = this;
    const options = that._options.silent();
    that._palette = that._themeManager.createPalette(options.palette, {
      useHighlight: true,
      extensionMode: options.paletteExtensionMode
    });
    that._palette.reset();
    that._bars = that._bars || [];
    that._animationSettings && that._barsGroup.stopAnimation();
    const barValues = that._values.filter(_isFinite);
    const count = barValues.length;
    if (that._bars.length > count) {
      const ii = that._bars.length;
      for (let i = count; i < ii; ++i) {
        that._bars[i].dispose();
      }
      that._bars.splice(count, ii - count);
    } else if (that._bars.length < count) {
      for (let i = that._bars.length; i < count; ++i) {
        that._bars.push(new BarWrapper(i, that._context));
      }
    }
    that._bars.forEach((bar, index) => {
      bar.update({
        color: that._palette.getNextColor(count),
        value: barValues[index]
      });
    });
  },
  _updateValues: function (values) {
    const that = this;
    const list = _isArray(values) && values || _isFinite(values) && [values] || [];
    let i;
    const ii = list.length;
    let value;
    that._values.length = ii;
    for (i = 0; i < ii; ++i) {
      value = list[i];
      that._values[i] = _Number(_isFinite(value) ? value : that._values[i]);
    }
    if (!that._resizing) {
      if (!_compareArrays(that._values, that.option(OPTION_VALUES))) {
        that.option(OPTION_VALUES, that._values.slice());
      }
    }
    this._change(['NODES']);
  },
  values: function (arg) {
    if (arg !== undefined) {
      this._updateValues(arg);
      return this;
    } else {
      return this._values.slice(0);
    }
  },
  _optionChangesMap: {
    backgroundColor: 'MOSTLY_TOTAL',
    relativeInnerRadius: 'MOSTLY_TOTAL',
    barSpacing: 'MOSTLY_TOTAL',
    label: 'MOSTLY_TOTAL',
    resolveLabelOverlapping: 'MOSTLY_TOTAL',
    palette: 'MOSTLY_TOTAL',
    paletteExtensionMode: 'MOSTLY_TOTAL',
    values: 'VALUES'
  },
  _change_VALUES: function () {
    this._updateValues(this.option(OPTION_VALUES));
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory),
  _optionChangesOrder: ['VALUES', 'NODES'],
  _initialChanges: ['VALUES'],
  _change_NODES() {
    this._buildNodes();
  },
  _change_MOSTLY_TOTAL: function () {
    this._change(['NODES']);
    this.callBase();
  },
  _proxyData: [],
  _getLegendData() {
    const that = this;
    const formatOptions = {};
    const options = that._options.silent();
    const labelFormatOptions = (options.label || {}).format;
    const legendFormatOptions = (options.legend || {}).itemTextFormat;
    if (legendFormatOptions) {
      formatOptions.format = legendFormatOptions;
    } else {
      formatOptions.format = labelFormatOptions || that._defaultFormatOptions;
    }
    return (this._bars || []).map(b => {
      return {
        id: b.index,
        item: {
          value: b.getValue(),
          color: b.getColor(),
          index: b.index
        },
        text: _formatValue(b.getValue(), formatOptions),
        visible: true,
        states: {
          normal: {
            fill: b.getColor()
          }
        }
      };
    });
  }
});
BarWrapper = function (index, context) {
  const that = this;
  that._context = context;
  that._tracker = context.renderer.arc().attr({
    'stroke-linejoin': 'round'
  });
  that.index = index;
};
_extend(BarWrapper.prototype, {
  dispose: function () {
    const that = this;
    that._background.dispose();
    that._bar.dispose();
    if (that._context.textEnabled) {
      that._line.dispose();
      that._text.dispose();
    }
    that._context.tracker.detach(that._tracker);
    that._context = that._settings = that._background = that._bar = that._line = that._text = that._tracker = null;
    return that;
  },
  arrange: function (options) {
    const that = this;
    const context = that._context;
    this._visible = true;
    context.tracker.attach(that._tracker, that, {
      index: that.index
    });
    that._background = context.renderer.arc().attr({
      'stroke-linejoin': 'round',
      fill: context.backgroundColor
    }).append(context.group);
    that._settings = that._settings || {
      x: context.x,
      y: context.y,
      startAngle: context.baseAngle,
      endAngle: context.baseAngle
    };
    that._bar = context.renderer.arc().attr(_extend({
      'stroke-linejoin': 'round'
    }, that._settings)).append(context.group);
    if (context.textEnabled) {
      that._line = context.renderer.path([], 'line').attr({
        'stroke-width': context.lineWidth
      }).append(context.group);
      that._text = context.renderer.text().css(context.fontStyles).attr(context.textOptions).append(context.group);
    }
    that._angle = isFinite(that._angle) ? that._angle : context.baseAngle;
    that._settings.outerRadius = options.radius;
    that._settings.innerRadius = options.radius - context.barSize;
    that._settings.x = context.x;
    that._settings.y = context.y;
    that._background.attr(_extend({}, that._settings, {
      startAngle: context.endAngle,
      endAngle: context.startAngle,
      fill: that._context.backgroundColor
    }));
    that._bar.attr({
      x: context.x,
      y: context.y,
      outerRadius: that._settings.outerRadius,
      innerRadius: that._settings.innerRadius,
      fill: that._color
    });
    that._tracker.attr(that._settings);
    if (context.textEnabled) {
      that._line.attr({
        points: [context.x, context.y - that._settings.innerRadius, context.x, context.y - context.textRadius - context.textIndent],
        stroke: context.lineColor || that._color
      }).sharp();
      that._text.css({
        fill: context.fontStyles.fill || that._color
      });
    }
    return that;
  },
  getTooltipParameters: function () {
    const that = this;
    const cosSin = _getCosAndSin((that._angle + that._context.baseAngle) / 2);
    return {
      x: _round(that._context.x + (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.cos),
      y: _round(that._context.y - (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.sin),
      offset: 0,
      color: that._color,
      value: that._value
    };
  },
  setAngle: function (angle) {
    const that = this;
    const context = that._context;
    const settings = that._settings;
    let cosSin;
    that._angle = angle;
    setAngles(settings, context.baseAngle, angle);
    that._bar.attr(settings);
    that._tracker.attr(settings);
    if (context.textEnabled) {
      cosSin = _getCosAndSin(angle);
      const indent = context.textIndent;
      const radius = context.textRadius + indent;
      let x = context.x + radius * cosSin.cos;
      let y = context.y - radius * cosSin.sin;
      const halfWidth = context.textWidth * 0.5;
      const textHeight = context.textHeight;
      const textY = context.textY;
      if (_abs(x - context.x) > indent) {
        x += x < context.x ? -halfWidth : halfWidth;
      }
      if (_abs(y - context.y) <= indent) {
        y -= textY + textHeight * 0.5;
      } else {
        y -= y < context.y ? textY + textHeight : textY;
      }
      const text = _formatValue(that._value, context.formatOptions, {
        index: that.index
      });
      const visibility = text === '' ? 'hidden' : null;
      that._text.attr({
        text: text,
        x: x,
        y: y,
        visibility: visibility
      });
      that._line.attr({
        visibility: visibility
      });
      that._line.rotate(_convertAngleToRendererSpace(angle), context.x, context.y);
    }
    return that;
  },
  hideLabel: function () {
    this._text.attr({
      visibility: 'hidden'
    });
    this._line.attr({
      visibility: 'hidden'
    });
  },
  checkIntersect: function (anotherBar) {
    const coords = this.calculateLabelCoords();
    const anotherCoords = anotherBar.calculateLabelCoords();
    if (!coords || !anotherCoords) {
      return false;
    }
    const width = Math.max(0, Math.min(coords.bottomRight.x, anotherCoords.bottomRight.x) - Math.max(coords.topLeft.x, anotherCoords.topLeft.x));
    const height = Math.max(0, Math.min(coords.bottomRight.y, anotherCoords.bottomRight.y) - Math.max(coords.topLeft.y, anotherCoords.topLeft.y));
    return width * height !== 0;
  },
  calculateLabelCoords: function () {
    if (!this._text) {
      return;
    }
    const box = this._text.getBBox();
    return {
      topLeft: {
        x: box.x,
        y: box.y
      },
      bottomRight: {
        x: box.x + box.width,
        y: box.y + box.height
      }
    };
  },
  _processValue: function (value) {
    return this._context.translator.translate(this._context.translator.adjust(value));
  },
  applyValue() {
    if (!this._visible) {
      return this;
    }
    return this.setAngle(this._processValue(this.getValue()));
  },
  update(_ref) {
    let {
      color,
      value
    } = _ref;
    this._color = color;
    this._value = value;
  },
  hide() {
    this._visible = false;
  },
  getColor() {
    return this._color;
  },
  getValue() {
    return this._value;
  },
  beginAnimation: function () {
    if (!this._visible) {
      return this;
    }
    const that = this;
    const angle = this._processValue(this.getValue());
    if (!compareFloats(that._angle, angle)) {
      that._start = that._angle;
      that._delta = angle - that._angle;
      that._tracker.attr({
        visibility: 'hidden'
      });
      if (that._context.textEnabled) {
        that._line.attr({
          visibility: 'hidden'
        });
        that._text.attr({
          visibility: 'hidden'
        });
      }
    } else {
      that.animate = _noop;
      that.setAngle(that._angle);
    }
  },
  animate: function (pos) {
    if (!this._visible) {
      return this;
    }
    const that = this;
    that._angle = that._start + that._delta * pos;
    setAngles(that._settings, that._context.baseAngle, that._angle);
    that._bar.attr(that._settings);
  },
  endAnimation: function () {
    const that = this;
    if (that._delta !== undefined) {
      if (compareFloats(that._angle, that._start + that._delta)) {
        that._tracker.attr({
          visibility: null
        });
        that.setAngle(that._angle);
      }
    } else {
      delete that.animate;
    }
    delete that._start;
    delete that._delta;
  }
});
function setAngles(target, angle1, angle2) {
  target.startAngle = angle1 < angle2 ? angle1 : angle2;
  target.endAngle = angle1 < angle2 ? angle2 : angle1;
}
function compareFloats(value1, value2) {
  return _abs(value1 - value2) < 0.0001;
}
function getStartCoordsArc(x, y, innerR, outerR, startAngleCos, startAngleSin) {
  return {
    x: (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC),
    y: (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC)
  };
}
(0, _component_registrator.default)('dxBarGauge', dxBarGauge);
dxBarGauge.addPlugin(_legend.plugin);
dxBarGauge.addPlugin(_center_template.plugins.gauge);

/***/ }),

/***/ 18029:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.BaseGauge = void 0;
exports.compareArrays = compareArrays;
exports.getSampleText = exports.formatValue = void 0;
var _utils = __webpack_require__(19157);
var _extend2 = __webpack_require__(13306);
var _translator1d = __webpack_require__(17953);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _theme_manager = _interopRequireDefault(__webpack_require__(41802));
var _tracker = _interopRequireDefault(__webpack_require__(57298));
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _tooltip = __webpack_require__(14371);
var _loading_indicator = __webpack_require__(64758);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _Number = Number;
const _extend = _extend2.extend;
const _format = _format_helper.default.format;
const BaseGauge = exports.BaseGauge = _m_base_widget.default.inherit({
  _rootClassPrefix: 'dxg',
  _themeSection: 'gauge',
  _createThemeManager: function () {
    return new _theme_manager.default.ThemeManager(this._getThemeManagerOptions());
  },
  _initCore: function () {
    const that = this;
    const root = that._renderer.root;
    that._valueChangingLocker = 0;
    that._translator = that._factory.createTranslator();
    that._tracker = that._factory.createTracker({
      renderer: that._renderer,
      container: root
    });
    that._setTrackerCallbacks();
  },
  _beginValueChanging: function () {
    this._resetIsReady();
    this._onBeginUpdate();
    ++this._valueChangingLocker;
  },
  _endValueChanging: function () {
    if (--this._valueChangingLocker === 0) {
      this._drawn();
    }
  },
  _setTrackerCallbacks: function () {
    const that = this;
    const renderer = that._renderer;
    const tooltip = that._tooltip;
    that._tracker.setCallbacks({
      'tooltip-show': function (target, info, callback) {
        const tooltipParameters = target.getTooltipParameters();
        const offset = renderer.getRootOffset();
        const formatObject = _extend({
          value: tooltipParameters.value,
          valueText: tooltip.formatValue(tooltipParameters.value),
          color: tooltipParameters.color
        }, info);
        return tooltip.show(formatObject, {
          x: tooltipParameters.x + offset.left,
          y: tooltipParameters.y + offset.top,
          offset: tooltipParameters.offset
        }, {
          target: info
        }, undefined, callback);
      },
      'tooltip-hide': function () {
        return tooltip.hide();
      }
    });
  },
  _dispose: function () {
    this._cleanCore();
    this.callBase.apply(this, arguments);
  },
  _disposeCore: function () {
    const that = this;
    that._themeManager.dispose();
    that._tracker.dispose();
    that._translator = that._tracker = null;
  },
  _cleanCore: function () {
    const that = this;
    that._tracker.deactivate();
    that._cleanContent();
  },
  _renderCore: function () {
    const that = this;
    if (!that._isValidDomain) return;
    that._renderContent();
    that._renderGraphicObjects();
    that._tracker.setTooltipState(that._tooltip.isEnabled());
    that._tracker.activate();
    that._noAnimation = false;
  },
  _applyChanges: function () {
    this.callBase.apply(this, arguments);
    this._resizing = this._noAnimation = false;
  },
  _setContentSize: function () {
    const that = this;
    that._resizing = that._noAnimation = that._changes.count() === 2;
    that.callBase.apply(that, arguments);
  },
  _applySize: function (rect) {
    const that = this;
    that._innerRect = {
      left: rect[0],
      top: rect[1],
      right: rect[2],
      bottom: rect[3]
    };
    // If loading indicator is shown it is got hidden at the end of "_renderCore" - during "_drawn". Then "loadingIndicator" option is changed.
    // It causes another "_setContentSize" execution (inside of the first one). Layout backwards during inner "_setContentSize" and clears its cache and
    // then backwards again during outer "_setContentSize" when "_cache" is null - so it fails.
    // The following code dirtily preserves layout cache for the outer backward.
    // The appropriate solution is to remove heavy rendering from "_applySize" - it should be done later during some other change processing.
    // It would be even better to somehow defer any inside option changes - so they all are applied after all changes are processed.
    const layoutCache = that._layout._cache;
    that._cleanCore();
    that._renderCore();
    that._layout._cache = that._layout._cache || layoutCache;
    return [rect[0], that._innerRect.top, rect[2], that._innerRect.bottom];
  },
  _initialChanges: ['DOMAIN'],
  _themeDependentChanges: ['DOMAIN'],
  _optionChangesMap: {
    subtitle: 'MOSTLY_TOTAL',
    indicator: 'MOSTLY_TOTAL',
    geometry: 'MOSTLY_TOTAL',
    animation: 'MOSTLY_TOTAL',
    startValue: 'DOMAIN',
    endValue: 'DOMAIN'
  },
  _optionChangesOrder: ['DOMAIN', 'MOSTLY_TOTAL'],
  _change_DOMAIN: function () {
    this._setupDomain();
  },
  _change_MOSTLY_TOTAL: function () {
    this._applyMostlyTotalChange();
  },
  _updateExtraElements: _common.noop,
  _setupDomain: function () {
    const that = this;
    that._setupDomainCore();
    // T130599
    that._isValidDomain = isFinite(1 / (that._translator.getDomain()[1] - that._translator.getDomain()[0]));
    if (!that._isValidDomain) {
      that._incidentOccurred('W2301');
    }
    that._change(['MOSTLY_TOTAL']);
  },
  _applyMostlyTotalChange: function () {
    const that = this;
    that._setupCodomain();
    that._setupAnimationSettings();
    that._setupDefaultFormat();
    that._change(['LAYOUT']);
  },
  _setupAnimationSettings: function () {
    const that = this;
    let option = that.option('animation');
    that._animationSettings = null;
    if (option === undefined || option) {
      option = _extend({
        enabled: true,
        duration: 1000,
        easing: 'easeOutCubic'
      }, option);
      if (option.enabled && option.duration > 0) {
        that._animationSettings = {
          duration: _Number(option.duration),
          easing: option.easing
        };
      }
    }
    //  It is better to place it here than to create separate function for one line of code
    that._containerBackgroundColor = that.option('containerBackgroundColor') || that._themeManager.theme().containerBackgroundColor;
  },
  _setupDefaultFormat: function () {
    const domain = this._translator.getDomain();
    this._defaultFormatOptions = (0, _utils.getAppropriateFormat)(domain[0], domain[1], this._getApproximateScreenRange());
  },
  _setupDomainCore: null,
  _calculateSize: null,
  _cleanContent: null,
  _renderContent: null,
  _setupCodomain: null,
  _getApproximateScreenRange: null,
  _factory: {
    createTranslator: function () {
      return new _translator1d.Translator1D();
    },
    createTracker: function (parameters) {
      return new _tracker.default(parameters);
    }
  }
});

//  TODO: find a better place for it
const formatValue = function (value, options, extra) {
  if (Object.is(value, -0)) {
    value = 0;
  }
  options = options || {};
  const text = _format(value, options.format);
  let formatObject;
  if (typeof options.customizeText === 'function') {
    formatObject = _extend({
      value: value,
      valueText: text
    }, extra);
    return String(options.customizeText.call(formatObject, formatObject));
  }
  return text;
};

//  TODO: find a better place for it
exports.formatValue = formatValue;
const getSampleText = function (translator, options) {
  const text1 = formatValue(translator.getDomainStart(), options);
  const text2 = formatValue(translator.getDomainEnd(), options);
  return text1.length >= text2.length ? text1 : text2;
};
exports.getSampleText = getSampleText;
function compareArrays(array1, array2) {
  return array1 && array2 && array1.length === array2.length && compareArraysElements(array1, array2);
}
function compareArraysElements(array1, array2) {
  let i;
  const ii = array1.length;
  let array1ValueIsNaN;
  let array2ValueIsNaN;
  for (i = 0; i < ii; ++i) {
    array1ValueIsNaN = array1[i] !== array1[i];
    array2ValueIsNaN = array2[i] !== array2[i];
    if (array1ValueIsNaN && array2ValueIsNaN) {
      continue;
    }
    if (array1[i] !== array2[i]) return false;
  }
  return true;
}

// PLUGINS_SECTION
BaseGauge.addPlugin(_export.plugin);
BaseGauge.addPlugin(_title.plugin);
BaseGauge.addPlugin(_tooltip.plugin);
BaseGauge.addPlugin(_loading_indicator.plugin);

// These are gauges specifics on using tooltip - they require refactoring.
const _setTooltipOptions = BaseGauge.prototype._setTooltipOptions;
BaseGauge.prototype._setTooltipOptions = function () {
  _setTooltipOptions.apply(this, arguments);
  this._tracker && this._tracker.setTooltipState(this._tooltip.isEnabled());
};

/***/ }),

/***/ 3446:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.BaseTextCloudMarker = exports.BaseRangeBar = exports.BaseIndicator = exports.BaseElement = void 0;
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _base_gauge = __webpack_require__(18029);
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
var _class = _interopRequireDefault(__webpack_require__(38377));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _isFinite = isFinite;
const _Number = Number;
const _round = Math.round;
const _formatValue = _base_gauge.formatValue;
const _getSampleText = _base_gauge.getSampleText;
const BaseElement = exports.BaseElement = _class.default.inherit({
  ctor: function (parameters) {
    const that = this;
    (0, _iterator.each)(parameters, function (name, value) {
      that['_' + name] = value;
    });
    that._init();
  },
  dispose: function () {
    const that = this;
    that._dispose();
    (0, _iterator.each)(that, function (name) {
      that[name] = null;
    });
    return that;
  },
  getOffset: function () {
    return _Number(this._options.offset) || 0;
  }
});
const BaseIndicator = exports.BaseIndicator = BaseElement.inherit({
  _init: function () {
    const that = this;
    that._rootElement = that._createRoot().linkOn(that._owner, {
      name: 'value-indicator',
      after: 'core'
    });
    that._trackerElement = that._createTracker();
  },
  _dispose: function () {
    this._rootElement.linkOff();
  },
  _setupAnimation: function () {
    const that = this;
    if (that._options.animation) {
      that._animation = {
        step: function (pos) {
          that._actualValue = that._animation.start + that._animation.delta * pos;
          that._actualPosition = that._translator.translate(that._actualValue);
          that._move();
        },
        duration: that._options.animation.duration > 0 ? _Number(that._options.animation.duration) : 0,
        easing: that._options.animation.easing
      };
    }
  },
  _runAnimation: function (value) {
    const that = this;
    const animation = that._animation;
    animation.start = that._actualValue;
    animation.delta = value - that._actualValue;
    that._rootElement.animate({
      _: 0
    }, {
      step: animation.step,
      duration: animation.duration,
      easing: animation.easing
    });
  },
  _createRoot: function () {
    return this._renderer.g().attr({
      'class': this._className
    });
  },
  _createTracker: function () {
    return this._renderer.path([], 'area');
  },
  _getTrackerSettings: _common.noop,
  clean: function () {
    const that = this;
    that._animation && that._rootElement.stopAnimation();
    that._rootElement.linkRemove().clear();
    that._clear();
    that._tracker.detach(that._trackerElement);
    that._options = that.enabled = that._animation = null;
    return that;
  },
  render: function (options) {
    const that = this;
    that.type = options.type;
    that._options = options;
    that._actualValue = that._currentValue = that._translator.adjust(that._options.currentValue);
    that.enabled = that._isEnabled();
    if (that.enabled) {
      that._setupAnimation();
      that._rootElement.attr({
        fill: (0, _utils.extractColor)(that._options.color)
      }).linkAppend();
      that._tracker.attach(that._trackerElement, that, that._trackerInfo);
    }
    return that;
  },
  resize: function (layout) {
    const that = this;
    that._rootElement.clear();
    that._clear();
    that.visible = that._isVisible(layout);
    if (that.visible) {
      (0, _extend.extend)(that._options, layout);
      that._actualPosition = that._translator.translate(that._actualValue);
      that._render();
      that._trackerElement.attr(that._getTrackerSettings());
      that._move();
    }
    return that;
  },
  value: function (arg, _noAnimation) {
    const that = this;
    let val;
    const rootElement = this._rootElement;
    let visibility = null;
    if (arg === undefined) {
      return that._currentValue;
    }
    if (arg === null) {
      visibility = 'hidden';
      that._currentValue = arg;
    } else {
      val = that._translator.adjust(arg);
      if (that._currentValue !== val && _isFinite(val)) {
        that._currentValue = val;
        if (that.visible) {
          if (that._animation && !_noAnimation) {
            that._runAnimation(val);
          } else {
            that._actualValue = val;
            that._actualPosition = that._translator.translate(val);
            that._move();
          }
        }
      }
    }
    rootElement.attr({
      visibility: visibility
    });
    return that;
  },
  _isEnabled: null,
  _isVisible: null,
  _render: null,
  _clear: null,
  _move: null
});

// The following is from baseMarker.js

const COEFFICIENTS_MAP = {};
COEFFICIENTS_MAP['right-bottom'] = COEFFICIENTS_MAP['rb'] = [0, -1, -1, 0, 0, 1, 1, 0];
COEFFICIENTS_MAP['bottom-right'] = COEFFICIENTS_MAP['br'] = [-1, 0, 0, -1, 1, 0, 0, 1];
COEFFICIENTS_MAP['left-bottom'] = COEFFICIENTS_MAP['lb'] = [0, -1, 1, 0, 0, 1, -1, 0];
COEFFICIENTS_MAP['bottom-left'] = COEFFICIENTS_MAP['bl'] = [1, 0, 0, -1, -1, 0, 0, 1];
COEFFICIENTS_MAP['left-top'] = COEFFICIENTS_MAP['lt'] = [0, 1, 1, 0, 0, -1, -1, 0];
COEFFICIENTS_MAP['top-left'] = COEFFICIENTS_MAP['tl'] = [1, 0, 0, 1, -1, 0, 0, -1];
COEFFICIENTS_MAP['right-top'] = COEFFICIENTS_MAP['rt'] = [0, 1, -1, 0, 0, -1, 1, 0];
COEFFICIENTS_MAP['top-right'] = COEFFICIENTS_MAP['tr'] = [-1, 0, 0, 1, 1, 0, 0, -1];
function getTextCloudInfo(options) {
  let x = options.x;
  let y = options.y;
  const type = COEFFICIENTS_MAP[options.type];
  const cloudWidth = options.cloudWidth;
  const cloudHeight = options.cloudHeight;
  let tailWidth;
  let tailHeight;
  const cx = x;
  const cy = y;
  tailWidth = tailHeight = options.tailLength;
  if (type[0] & 1) {
    tailHeight = Math.min(tailHeight, cloudHeight / 3);
  } else {
    tailWidth = Math.min(tailWidth, cloudWidth / 3);
  }
  return {
    cx: _round(cx + type[0] * tailWidth + (type[0] + type[2]) * cloudWidth / 2),
    cy: _round(cy + type[1] * tailHeight + (type[1] + type[3]) * cloudHeight / 2),
    points: [_round(x), _round(y), _round(x += type[0] * (cloudWidth + tailWidth)), _round(y += type[1] * (cloudHeight + tailHeight)), _round(x += type[2] * cloudWidth), _round(y += type[3] * cloudHeight), _round(x += type[4] * cloudWidth), _round(y += type[5] * cloudHeight), _round(x += type[6] * (cloudWidth - tailWidth)), _round(y += type[7] * (cloudHeight - tailHeight))]
  };
}
const BaseTextCloudMarker = exports.BaseTextCloudMarker = BaseIndicator.inherit({
  _move: function () {
    const that = this;
    const options = that._options;
    const textCloudOptions = that._getTextCloudOptions();
    const text = _formatValue(that._actualValue, options.text);
    that._text.attr({
      text: text
    });
    const bBox = that._text.getBBox();
    const x = textCloudOptions.x;
    const y = textCloudOptions.y;
    const cloudWidth = (bBox.width || text.length * that._textUnitWidth) + 2 * options.horizontalOffset;
    const cloudHeight = (bBox.height || that._textHeight) + 2 * options.verticalOffset;
    const info = getTextCloudInfo({
      x,
      y,
      cloudWidth,
      cloudHeight,
      tailLength: options.arrowLength,
      type: that._correctCloudType(textCloudOptions.type, {
        x,
        y
      }, {
        width: cloudWidth,
        height: cloudHeight
      })
    });
    that._text.attr({
      x: info.cx,
      y: info.cy + that._textVerticalOffset
    });
    that._cloud.attr({
      points: info.points
    });
    that._trackerElement && that._trackerElement.attr({
      points: info.points
    });
  },
  _measureText: function () {
    const that = this;
    let root;
    let text;
    let bBox;
    let sampleText;
    if (!that._textVerticalOffset) {
      root = that._createRoot().append(that._owner);
      sampleText = _getSampleText(that._translator, that._options.text);
      text = that._renderer.text(sampleText, 0, 0).attr({
        align: 'center'
      }).css((0, _utils.patchFontOptions)(that._options.text.font)).append(root);
      bBox = text.getBBox();
      root.remove();
      that._textVerticalOffset = -bBox.y - bBox.height / 2;
      that._textWidth = bBox.width;
      that._textHeight = bBox.height;
      that._textUnitWidth = that._textWidth / sampleText.length;
      that._textFullWidth = that._textWidth + 2 * that._options.horizontalOffset;
      that._textFullHeight = that._textHeight + 2 * that._options.verticalOffset;
    }
  },
  _render: function () {
    const that = this;
    that._measureText();
    that._cloud = that._cloud || that._renderer.path([], 'area').append(that._rootElement);
    that._text = that._text || that._renderer.text().append(that._rootElement);
    that._text.attr({
      align: 'center'
    }).css((0, _utils.patchFontOptions)(that._options.text.font));
  },
  _clear: function () {
    delete this._cloud;
    delete this._text;
  },
  getTooltipParameters: function () {
    const position = this._getTextCloudOptions();
    return {
      x: position.x,
      y: position.y,
      value: this._currentValue,
      color: this._options.color
    };
  },
  _correctCloudType(type) {
    return type;
  }
});

// The following is from baseRangeBar.js

const BaseRangeBar = exports.BaseRangeBar = BaseIndicator.inherit({
  _measureText: function () {
    const that = this;
    let root;
    let text;
    let bBox;
    that._hasText = that._isTextVisible();
    if (that._hasText && !that._textVerticalOffset) {
      root = that._createRoot().append(that._owner);
      text = that._renderer.text(_getSampleText(that._translator, that._options.text), 0, 0).attr({
        'class': 'dxg-text',
        align: 'center'
      }).css((0, _utils.patchFontOptions)(that._options.text.font)).append(root);
      bBox = text.getBBox();
      root.remove();
      that._textVerticalOffset = -bBox.y - bBox.height / 2;
      that._textWidth = bBox.width;
      that._textHeight = bBox.height;
    }
  },
  _move: function () {
    const that = this;
    that._updateBarItemsPositions();
    if (that._hasText) {
      that._text.attr({
        text: _formatValue(that._actualValue, that._options.text)
      });
      that._updateTextPosition();
      that._updateLinePosition();
    }
  },
  _updateBarItems: function () {
    const that = this;
    const options = that._options;
    let spaceColor;
    const translator = that._translator;
    that._setBarSides();
    that._startPosition = translator.translate(translator.getDomainStart());
    that._endPosition = translator.translate(translator.getDomainEnd());
    that._basePosition = translator.translate(options.baseValue);
    that._space = that._getSpace();
    const backgroundColor = options.backgroundColor || 'none';
    if (backgroundColor !== 'none' && that._space > 0) {
      spaceColor = options.containerBackgroundColor || 'none';
    } else {
      that._space = 0;
      spaceColor = 'none';
    }
    that._backItem1.attr({
      fill: backgroundColor
    });
    that._backItem2.attr({
      fill: backgroundColor
    });
    that._spaceItem1.attr({
      fill: spaceColor
    });
    that._spaceItem2.attr({
      fill: spaceColor
    });
  },
  _getSpace: function () {
    return 0;
  },
  _updateTextItems: function () {
    const that = this;
    if (that._hasText) {
      that._line = that._line || that._renderer.path([], 'line').attr({
        'class': 'dxg-main-bar',
        'stroke-linecap': 'square'
      }).append(that._rootElement);
      that._text = that._text || that._renderer.text('', 0, 0).attr({
        'class': 'dxg-text'
      }).append(that._rootElement);
      that._text.attr({
        align: that._getTextAlign()
      }).css(that._getFontOptions());
      that._setTextItemsSides();
    } else {
      if (that._line) {
        that._line.remove();
        delete that._line;
      }
      if (that._text) {
        that._text.remove();
        delete that._text;
      }
    }
  },
  _isTextVisible: function () {
    return false;
  },
  _getTextAlign: function () {
    return 'center';
  },
  _getFontOptions: function () {
    const options = this._options;
    let font = options.text.font;
    if (!font || !font.color) {
      font = (0, _extend.extend)({}, font, {
        color: options.color
      });
    }
    return (0, _utils.patchFontOptions)(font);
  },
  _updateBarItemsPositions: function () {
    const that = this;
    const positions = that._getPositions();
    that._backItem1.attr(that._buildItemSettings(positions.start, positions.back1));
    that._backItem2.attr(that._buildItemSettings(positions.back2, positions.end));
    that._spaceItem1.attr(that._buildItemSettings(positions.back1, positions.main1));
    that._spaceItem2.attr(that._buildItemSettings(positions.main2, positions.back2));
    that._mainItem.attr(that._buildItemSettings(positions.main1, positions.main2));
    that._trackerElement && that._trackerElement.attr(that._buildItemSettings(positions.main1, positions.main2));
  },
  _render: function () {
    const that = this;
    that._measureText();
    if (!that._backItem1) {
      that._backItem1 = that._createBarItem();
      that._backItem1.attr({
        'class': 'dxg-back-bar'
      });
    }
    if (!that._backItem2) {
      that._backItem2 = that._createBarItem();
      that._backItem2.attr({
        'class': 'dxg-back-bar'
      });
    }
    if (!that._spaceItem1) {
      that._spaceItem1 = that._createBarItem();
      that._spaceItem1.attr({
        'class': 'dxg-space-bar'
      });
    }
    if (!that._spaceItem2) {
      that._spaceItem2 = that._createBarItem();
      that._spaceItem2.attr({
        'class': 'dxg-space-bar'
      });
    }
    if (!that._mainItem) {
      that._mainItem = that._createBarItem();
      that._mainItem.attr({
        'class': 'dxg-main-bar'
      });
    }
    that._updateBarItems();
    that._updateTextItems();
  },
  _clear: function () {
    const that = this;
    delete that._backItem1;
    delete that._backItem2;
    delete that._spaceItem1;
    delete that._spaceItem2;
    delete that._mainItem;
    delete that._hasText;
    delete that._line;
    delete that._text;
  },
  getTooltipParameters: function () {
    const position = this._getTooltipPosition();
    return {
      x: position.x,
      y: position.y,
      value: this._currentValue,
      color: this._options.color,
      offset: 0
    };
  }
});

/***/ }),

/***/ 84165:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _base_indicators = __webpack_require__(3446);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
const _Number = Number;
const _isArray = Array.isArray;
const _isFinite = isFinite;
const BaseRangeContainer = _base_indicators.BaseElement.inherit({
  _init: function () {
    this._root = this._renderer.g().attr({
      'class': 'dxg-range-container'
    }).linkOn(this._container, 'range-container');
  },
  _dispose: function () {
    this._root.linkOff();
  },
  clean: function () {
    this._root.linkRemove().clear();
    this._options = this.enabled = null;
    return this;
  },
  _getRanges: function () {
    const that = this;
    const options = that._options;
    const translator = that._translator;
    const totalStart = translator.getDomain()[0];
    const totalEnd = translator.getDomain()[1];
    const totalDelta = totalEnd - totalStart;
    const isValidSegment = totalDelta >= 0 ? isValidSegmentAsc : isValidSegmentDesc;
    const subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDesc;
    let list = [];
    let ranges = [];
    let backgroundRanges = [{
      start: totalStart,
      end: totalEnd
    }];
    const backgroundColor = (0, _utils.extractColor)(options.backgroundColor) || 'none';
    const width = options.width || {};
    const startWidth = _Number(width > 0 ? width : width.start);
    const endWidth = _Number(width > 0 ? width : width.end);
    const deltaWidth = endWidth - startWidth;
    if (options.ranges !== undefined && !_isArray(options.ranges)) {
      return null;
    }
    if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0)) {
      return null;
    }
    list = (_isArray(options.ranges) ? options.ranges : []).reduce((result, rangeOptions, i) => {
      rangeOptions = rangeOptions || {};
      const start = translator.adjust(rangeOptions.startValue);
      const end = translator.adjust(rangeOptions.endValue);
      if (_isFinite(start) && _isFinite(end) && isValidSegment(start, end, rangeOptions)) {
        result.push({
          start: start,
          end: end,
          color: (0, _utils.extractColor)(rangeOptions.color),
          classIndex: i
        });
      }
      return result;
    }, []);
    const palette = that._themeManager.createPalette(options.palette, {
      type: 'indicatingSet',
      extensionMode: options.paletteExtensionMode,
      keepLastColorInEnd: true,
      count: list.length
    });
    (0, _iterator.each)(list, function (_, item) {
      const paletteColor = palette.getNextColor();
      item.color = (0, _type.isString)(item.color) && item.color || paletteColor || 'none';
      item.className = 'dxg-range dxg-range-' + item.classIndex;
      delete item.classIndex;
    });
    (0, _iterator.each)(list, function (_, item) {
      let i;
      let ii;
      let sub;
      let subs;
      let range;
      const newRanges = [];
      const newBackgroundRanges = [];
      for (i = 0, ii = ranges.length; i < ii; ++i) {
        range = ranges[i];
        subs = subtractSegment(range.start, range.end, item.start, item.end);
        (sub = subs[0]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
        (sub = subs[1]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
      }
      newRanges.push(item);
      ranges = newRanges;
      for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {
        range = backgroundRanges[i];
        subs = subtractSegment(range.start, range.end, item.start, item.end);
        (sub = subs[0]) && newBackgroundRanges.push(sub);
        (sub = subs[1]) && newBackgroundRanges.push(sub);
      }
      backgroundRanges = newBackgroundRanges;
    });
    (0, _iterator.each)(backgroundRanges, function (_, range) {
      range.color = backgroundColor;
      range.className = 'dxg-range dxg-background-range';
      ranges.push(range);
    });
    (0, _iterator.each)(ranges, function (_, range) {
      range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;
      range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth;
    });
    return ranges;
  },
  render: function (options) {
    const that = this;
    that._options = options;
    that._processOptions();
    that._ranges = that._getRanges();
    if (that._ranges) {
      that.enabled = true;
      that._root.linkAppend();
    }
    return that;
  },
  resize: function (layout) {
    const that = this;
    that._root.clear();
    if (that._isVisible(layout)) {
      (0, _iterator.each)(that._ranges, function (_, range) {
        that._createRange(range, layout).attr({
          fill: range.color,
          'class': range.className
        }).append(that._root);
      });
    }
    return that;
  },
  _processOptions: null,
  _isVisible: null,
  _createRange: null,
  // S170193
  getColorForValue: function (value) {
    let color = null;
    (0, _iterator.each)(this._ranges, function (_, range) {
      if (range.start <= value && value <= range.end || range.start >= value && value >= range.end) {
        color = range.color;
        return false;
      }
    });
    return color;
  }
});
function subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {
  let result;
  if (otherStart > segmentStart && otherEnd < segmentEnd) {
    result = [{
      start: segmentStart,
      end: otherStart
    }, {
      start: otherEnd,
      end: segmentEnd
    }];
  } else if (otherStart >= segmentEnd || otherEnd <= segmentStart) {
    result = [{
      start: segmentStart,
      end: segmentEnd
    }];
  } else if (otherStart <= segmentStart && otherEnd >= segmentEnd) {
    result = [];
  } else if (otherStart > segmentStart) {
    result = [{
      start: segmentStart,
      end: otherStart
    }];
  } else if (otherEnd < segmentEnd) {
    result = [{
      start: otherEnd,
      end: segmentEnd
    }];
  }
  return result;
}
function subtractSegmentDesc(segmentStart, segmentEnd, otherStart, otherEnd) {
  let result;
  if (otherStart < segmentStart && otherEnd > segmentEnd) {
    result = [{
      start: segmentStart,
      end: otherStart
    }, {
      start: otherEnd,
      end: segmentEnd
    }];
  } else if (otherStart <= segmentEnd || otherEnd >= segmentStart) {
    result = [{
      start: segmentStart,
      end: segmentEnd
    }];
  } else if (otherStart >= segmentStart && otherEnd <= segmentEnd) {
    result = [];
  } else if (otherStart < segmentStart) {
    result = [{
      start: segmentStart,
      end: otherStart
    }];
  } else if (otherEnd > segmentEnd) {
    result = [{
      start: otherEnd,
      end: segmentEnd
    }];
  }
  return result;
}
function areEqualValues(start, end, _ref) {
  let {
    startValue,
    endValue
  } = _ref;
  return endValue === startValue && startValue === start && end === start;
}
function isValidSegmentAsc(start, end, options) {
  return end - start > 0 || areEqualValues(start, end, options);
}
function isValidSegmentDesc(start, end, options) {
  return start - end > 0 || areEqualValues(start, end, options);
}
var _default = exports["default"] = BaseRangeContainer;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 51576:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _object = __webpack_require__(48013);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _base_gauge = __webpack_require__(18029);
var _common = __webpack_require__(88917);
var _utils = __webpack_require__(19157);
var _center_template = __webpack_require__(56672);
var circularIndicators = _interopRequireWildcard(__webpack_require__(16030));
var _circular_range_container = _interopRequireDefault(__webpack_require__(27172));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _isFinite = isFinite;
const _normalizeAngle = _utils.normalizeAngle;
const _getCosAndSin = _utils.getCosAndSin;
const _abs = Math.abs;
const _max = Math.max;
const _min = Math.min;
const _round = Math.round;
const _each = _iterator.each;
const PI = Math.PI;
function getSides(startAngle, endAngle) {
  const startCosSin = _getCosAndSin(startAngle);
  const endCosSin = _getCosAndSin(endAngle);
  const startCos = startCosSin.cos;
  const startSin = startCosSin.sin;
  const endCos = endCosSin.cos;
  const endSin = endCosSin.sin;
  return {
    left: startSin <= 0 && endSin >= 0 || startSin <= 0 && endSin <= 0 && startCos <= endCos || startSin >= 0 && endSin >= 0 && startCos >= endCos ? -1 : _min(startCos, endCos, 0),
    right: startSin >= 0 && endSin <= 0 || startSin >= 0 && endSin >= 0 && startCos >= endCos || startSin <= 0 && endSin <= 0 && startCos <= endCos ? 1 : _max(startCos, endCos, 0),
    up: startCos <= 0 && endCos >= 0 || startCos <= 0 && endCos <= 0 && startSin >= endSin || startCos >= 0 && endCos >= 0 && startSin <= endSin ? -1 : -_max(startSin, endSin, 0),
    down: startCos >= 0 && endCos <= 0 || startCos >= 0 && endCos >= 0 && startSin <= endSin || startCos <= 0 && endCos <= 0 && startSin >= endSin ? 1 : -_min(startSin, endSin, 0)
  };
}
const dxCircularGauge = _common.dxGauge.inherit({
  _rootClass: 'dxg-circular-gauge',
  _factoryMethods: {
    rangeContainer: 'createCircularRangeContainer',
    indicator: 'createCircularIndicator'
  },
  _gridSpacingFactor: 17,
  _scaleTypes: {
    type: 'polarAxes',
    drawingType: 'circular'
  },
  _getThemeManagerOptions() {
    const options = this.callBase.apply(this, arguments);
    options.subTheme = '_circular';
    return options;
  },
  _updateScaleTickIndent: function (scaleOptions) {
    const indentFromTick = scaleOptions.label.indentFromTick;
    const length = scaleOptions.tick.visible ? scaleOptions.tick.length : 0;
    const textParams = this._scale.measureLabels((0, _extend.extend)({}, this._canvas));
    const scaleOrientation = scaleOptions.orientation;
    const tickCorrection = length;
    let indentFromAxis = indentFromTick;
    if (indentFromTick >= 0) {
      if (scaleOrientation === 'outside') {
        indentFromAxis += tickCorrection;
      } else if (scaleOrientation === 'center') {
        indentFromAxis += tickCorrection / 2;
      }
    } else {
      const labelCorrection = _max(textParams.width, textParams.height);
      indentFromAxis -= labelCorrection;
      if (scaleOrientation === 'inside') {
        indentFromAxis -= tickCorrection;
      } else if (scaleOrientation === 'center') {
        indentFromAxis -= tickCorrection / 2;
      }
    }
    scaleOptions.label.indentFromAxis = indentFromAxis;
    this._scale.updateOptions(scaleOptions);
  },
  _setupCodomain: function () {
    const that = this;
    const geometry = that.option('geometry') || {};
    let startAngle = geometry.startAngle;
    let endAngle = geometry.endAngle;
    let sides;
    startAngle = _isFinite(startAngle) ? _normalizeAngle(startAngle) : 225;
    endAngle = _isFinite(endAngle) ? _normalizeAngle(endAngle) : -45;
    if (_abs(startAngle - endAngle) < 1) {
      endAngle -= 360;
      sides = {
        left: -1,
        up: -1,
        right: 1,
        down: 1
      };
    } else {
      startAngle < endAngle && (endAngle -= 360);
      sides = getSides(startAngle, endAngle);
    }
    that._area = {
      x: 0,
      y: 0,
      radius: 100,
      startCoord: startAngle,
      endCoord: endAngle,
      sides: sides
    };
    that._translator.setCodomain(startAngle, endAngle);
  },
  _getCenter: function () {
    return this._getElementLayout();
  },
  _shiftScale: function (layout) {
    const scale = this._scale;
    const canvas = scale.getCanvas();
    canvas.width = canvas.height = layout.radius * 2;
    scale.draw(canvas);
    const centerCoords = scale.getCenter();
    scale.shift({
      right: layout.x - centerCoords.x,
      bottom: layout.y - centerCoords.y
    });
  },
  _getScaleLayoutValue: function () {
    return this._area.radius;
  },
  _getTicksOrientation: function (scaleOptions) {
    return scaleOptions.orientation;
  },
  _getTicksCoefficients: function (options) {
    const coefs = {
      inner: 0,
      outer: 1
    };
    if (options.orientation === 'inside') {
      coefs.inner = 1;
      coefs.outer = 0;
    } else if (options.orientation === 'center') {
      coefs.inner = coefs.outer = 0.5;
    }
    return coefs;
  },
  _correctScaleIndents: function (result, indentFromTick, textParams) {
    if (indentFromTick >= 0) {
      result.horizontalOffset = indentFromTick + textParams.width;
      result.verticalOffset = indentFromTick + textParams.height;
    } else {
      result.horizontalOffset = result.verticalOffset = 0;
      result.min -= -indentFromTick + _max(textParams.width, textParams.height);
    }
    result.inverseHorizontalOffset = textParams.width / 2;
    result.inverseVerticalOffset = textParams.height / 2;
  },
  _measureMainElements: function (elements, scaleMeasurement) {
    const that = this;
    const radius = that._area.radius;
    let maxRadius = 0;
    let minRadius = Infinity;
    let maxHorizontalOffset = 0;
    let maxVerticalOffset = 0;
    let maxInverseHorizontalOffset = 0;
    let maxInverseVerticalOffset = 0;
    const scale = that._scale;
    _each(elements.concat(scale), function (_, element) {
      const bounds = element.measure ? element.measure({
        radius: radius - element.getOffset()
      }) : scaleMeasurement;
      bounds.min > 0 && (minRadius = _min(minRadius, bounds.min));
      bounds.max > 0 && (maxRadius = _max(maxRadius, bounds.max));
      bounds.horizontalOffset > 0 && (maxHorizontalOffset = _max(maxHorizontalOffset, bounds.max + bounds.horizontalOffset));
      bounds.verticalOffset > 0 && (maxVerticalOffset = _max(maxVerticalOffset, bounds.max + bounds.verticalOffset));
      bounds.inverseHorizontalOffset > 0 && (maxInverseHorizontalOffset = _max(maxInverseHorizontalOffset, bounds.inverseHorizontalOffset));
      bounds.inverseVerticalOffset > 0 && (maxInverseVerticalOffset = _max(maxInverseVerticalOffset, bounds.inverseVerticalOffset));
    });
    maxHorizontalOffset = _max(maxHorizontalOffset - maxRadius, 0);
    maxVerticalOffset = _max(maxVerticalOffset - maxRadius, 0);
    return {
      minRadius: minRadius,
      maxRadius: maxRadius,
      horizontalMargin: maxHorizontalOffset,
      verticalMargin: maxVerticalOffset,
      inverseHorizontalMargin: maxInverseHorizontalOffset,
      inverseVerticalMargin: maxInverseVerticalOffset
    };
  },
  _applyMainLayout: function (elements, scaleMeasurement) {
    const measurements = this._measureMainElements(elements, scaleMeasurement);
    const area = this._area;
    const sides = area.sides;
    const margins = {
      left: (sides.left < -0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
      right: (sides.right > 0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
      top: (sides.up < -0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0,
      bottom: (sides.down > 0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0
    };
    const rect = selectRectByAspectRatio(this._innerRect, (sides.down - sides.up) / (sides.right - sides.left), margins);
    let radius = _min(getWidth(rect) / (sides.right - sides.left), getHeight(rect) / (sides.down - sides.up));
    radius = radius - measurements.maxRadius + area.radius;
    const x = rect.left - getWidth(rect) * sides.left / (sides.right - sides.left);
    const y = rect.top - getHeight(rect) * sides.up / (sides.down - sides.up);
    area.x = _round(x);
    area.y = _round(y);
    area.radius = radius;
    rect.left -= margins.left;
    rect.right += margins.right;
    rect.top -= margins.top;
    rect.bottom += margins.bottom;
    this._innerRect = rect;
  },
  _getElementLayout: function () {
    let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return {
      x: this._area.x,
      y: this._area.y,
      radius: _round(this._area.radius - offset)
    };
  },
  _getApproximateScreenRange: function () {
    const that = this;
    const area = that._area;
    let r = _min(that._canvas.width / (area.sides.right - area.sides.left), that._canvas.height / (area.sides.down - area.sides.up));
    r > area.totalRadius && (r = area.totalRadius);
    r = 0.8 * r;
    return -that._translator.getCodomainRange() * r * PI / 180;
  },
  _getDefaultSize: function () {
    return {
      width: 300,
      height: 300
    };
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory)
});
function getWidth(rect) {
  return rect.right - rect.left;
}
function getHeight(rect) {
  return rect.bottom - rect.top;
}
function selectRectByAspectRatio(srcRect, aspectRatio, margins) {
  const rect = (0, _extend.extend)({}, srcRect);
  let selfAspectRatio;
  let width = 0;
  let height = 0;
  margins = margins || {};
  if (aspectRatio > 0) {
    rect.left += margins.left || 0;
    rect.right -= margins.right || 0;
    rect.top += margins.top || 0;
    rect.bottom -= margins.bottom || 0;
    if (getWidth(rect) > 0 && getHeight(rect) > 0) {
      selfAspectRatio = getHeight(rect) / getWidth(rect);
      if (selfAspectRatio > 1) {
        aspectRatio < selfAspectRatio ? width = getWidth(rect) : height = getHeight(rect);
      } else {
        aspectRatio > selfAspectRatio ? height = getHeight(rect) : width = getWidth(rect);
      }
      width > 0 || (width = height / aspectRatio);
      height > 0 || (height = width * aspectRatio);
      width = (getWidth(rect) - width) / 2;
      height = (getHeight(rect) - height) / 2;
      rect.left += width;
      rect.right -= width;
      rect.top += height;
      rect.bottom -= height;
    } else {
      rect.left = rect.right = (rect.left + rect.right) / 2;
      rect.top = rect.bottom = (rect.top + rect.bottom) / 2;
    }
  }
  return rect;
}
const indicators = dxCircularGauge.prototype._factory.indicators = {};
dxCircularGauge.prototype._factory.createIndicator = (0, _common.createIndicatorCreator)(indicators);

/* eslint-disable import/namespace */
indicators._default = circularIndicators._default;
indicators['rectangleneedle'] = circularIndicators['rectangleneedle'];
indicators['triangleneedle'] = circularIndicators['triangleneedle'];
indicators['twocolorneedle'] = circularIndicators['twocolorneedle'];
indicators['trianglemarker'] = circularIndicators['trianglemarker'];
indicators['textcloud'] = circularIndicators['textcloud'];
indicators['rangebar'] = circularIndicators['rangebar'];
/* eslint-enable import/namespace */

dxCircularGauge.prototype._factory.RangeContainer = _circular_range_container.default;
(0, _component_registrator.default)('dxCircularGauge', dxCircularGauge);
dxCircularGauge.addPlugin(_center_template.plugins.gauge);
var _default = exports["default"] = dxCircularGauge;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 16030:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.twocolorneedle = exports.triangleneedle = exports.trianglemarker = exports.textcloud = exports.rectangleneedle = exports.rangebar = exports._default = void 0;
var _base_indicators = __webpack_require__(3446);
var _utils = __webpack_require__(19157);
const _Number = Number;
const _getCosAndSin = _utils.getCosAndSin;
const _convertAngleToRendererSpace = _utils.convertAngleToRendererSpace;
function correctRadius(layout, size) {
  if (layout && layout.radius - size <= 0) {
    layout.radius = size + 1;
  }
  return layout;
}
const SimpleIndicator = _base_indicators.BaseIndicator.inherit({
  _move: function () {
    const that = this;
    const options = that._options;
    const angle = _convertAngleToRendererSpace(that._actualPosition);
    that._rootElement.rotate(angle, options.x, options.y);
    that._trackerElement && that._trackerElement.rotate(angle, options.x, options.y);
  },
  _isEnabled: function () {
    return this._options.width > 0;
  },
  _isVisible: function (layout) {
    return layout.radius - _Number(this._options.indentFromCenter) > 0;
  },
  _getTrackerSettings: function () {
    const options = this._options;
    const radius = this._getRadius();
    const indentFromCenter = this._getIndentFromCenter();
    const x = options.x;
    const y = options.y - (radius + indentFromCenter) / 2;
    let width = options.width / 2;
    let length = (radius - indentFromCenter) / 2;
    width > 10 || (width = 10);
    length > 10 || (length = 10);
    return {
      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
    };
  },
  _render: function () {
    const that = this;
    that._renderPointer();
  },
  _clearPointer: function () {
    delete this._element;
  },
  _clear: function () {
    this._clearPointer();
  },
  _getIndentFromCenter: function (radius) {
    return Number(this._options.indentFromCenter) || 0;
  },
  _getRadius: function () {
    return 0;
  },
  measure: function (layout) {
    const result = {
      max: layout.radius
    };
    if (this._options.indentFromCenter < 0) {
      result.inverseHorizontalOffset = result.inverseVerticalOffset = -_Number(this._options.indentFromCenter);
    }
    return result;
  },
  getTooltipParameters: function () {
    const options = this._options;
    const cosSin = _getCosAndSin(this._actualPosition);
    const r = (this._getRadius() + this._getIndentFromCenter()) / 2;
    return {
      x: options.x + cosSin.cos * r,
      y: options.y - cosSin.sin * r,
      value: this._currentValue,
      color: options.color,
      offset: options.width / 2
    };
  }
});
const NeedleIndicator = SimpleIndicator.inherit({
  _isVisible: function (layout) {
    const indentFromCenter = this._adjustOffset(Number(this._options.indentFromCenter), layout.radius);
    const offset = this._adjustOffset(Number(this._options.offset), layout.radius);
    return layout.radius - indentFromCenter - offset > 0;
  },
  getOffset: function () {
    return 0;
  },
  _adjustOffset: function (value, radius) {
    const minRadius = Number(this._options.beginAdaptingAtRadius);
    const diff = radius / minRadius;
    if (diff < 1) {
      value = Math.floor(value * diff);
    }
    return value || 0;
  },
  _getIndentFromCenter: function (radius) {
    return this._adjustOffset(Number(this._options.indentFromCenter), this._options.radius);
  },
  _getRadius: function () {
    const options = this._options;
    return options.radius - this._adjustOffset(Number(options.offset), options.radius);
  },
  _renderSpindle: function () {
    const that = this;
    const options = that._options;
    const radius = options.radius;
    const spindleSize = this._adjustOffset(_Number(options.spindleSize) / 2, radius) * 2;
    let gapSize = this._adjustOffset(_Number(options.spindleGapSize) / 2, radius) * 2 || 0;
    if (gapSize > 0) {
      gapSize = gapSize <= spindleSize ? gapSize : spindleSize;
    }
    if (spindleSize > 0) {
      that._spindleOuter = that._spindleOuter || that._renderer.circle().append(that._rootElement);
      that._spindleInner = that._spindleInner || that._renderer.circle().append(that._rootElement);
      that._spindleOuter.attr({
        'class': 'dxg-spindle-border',
        cx: options.x,
        cy: options.y,
        r: spindleSize / 2
      });
      that._spindleInner.attr({
        'class': 'dxg-spindle-hole',
        cx: options.x,
        cy: options.y,
        r: gapSize / 2,
        fill: options.containerBackgroundColor
      });
    }
  },
  _render: function () {
    const that = this;
    that.callBase();
    that._renderSpindle();
  },
  _clear: function () {
    this.callBase();
    delete this._spindleOuter;
    delete this._spindleInner;
  }
});
const rectangleNeedle = exports.rectangleneedle = exports._default = NeedleIndicator.inherit({
  _renderPointer: function () {
    const that = this;
    const options = that._options;
    const y2 = options.y - this._getRadius();
    const y1 = options.y - this._getIndentFromCenter();
    const x1 = options.x - options.width / 2;
    const x2 = x1 + _Number(options.width);
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });
  }
});
const triangleNeedle = exports.triangleneedle = NeedleIndicator.inherit({
  _renderPointer: function () {
    const that = this;
    const options = that._options;
    const y2 = options.y - this._getRadius();
    const y1 = options.y - this._getIndentFromCenter();
    const x1 = options.x - options.width / 2;
    const x2 = options.x + options.width / 2;
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr({
      points: [x1, y1, options.x, y2, x2, y1]
    });
  }
});
const twoColorNeedle = exports.twocolorneedle = NeedleIndicator.inherit({
  _renderPointer: function () {
    const that = this;
    const options = that._options;
    const x1 = options.x - options.width / 2;
    const x2 = options.x + options.width / 2;
    const y4 = options.y - this._getRadius();
    const y1 = options.y - this._getIndentFromCenter();
    const fraction = _Number(options.secondFraction) || 0;
    let y2;
    let y3;
    //  B253863
    if (fraction >= 1) {
      y2 = y3 = y1;
    } else if (fraction <= 0) {
      y2 = y3 = y4;
    } else {
      y3 = y4 + (y1 - y4) * fraction;
      y2 = y3 + _Number(options.space);
    }
    that._firstElement = that._firstElement || that._renderer.path([], 'area').append(that._rootElement);
    that._spaceElement = that._spaceElement || that._renderer.path([], 'area').append(that._rootElement);
    that._secondElement = that._secondElement || that._renderer.path([], 'area').append(that._rootElement);
    that._firstElement.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });
    that._spaceElement.attr({
      points: [x1, y2, x1, y3, x2, y3, x2, y2],
      'class': 'dxg-hole',
      fill: options.containerBackgroundColor
    });
    that._secondElement.attr({
      points: [x1, y3, x1, y4, x2, y4, x2, y3],
      'class': 'dxg-part',
      fill: options.secondColor
    });
  },
  _clearPointer: function () {
    delete this._firstElement;
    delete this._secondElement;
    delete this._spaceElement;
  }
});

// The following is from circularMarker.js

const triangleMarker = exports.trianglemarker = SimpleIndicator.inherit({
  _isEnabled: function () {
    return this._options.length > 0 && this._options.width > 0;
  },
  _isVisible(layout) {
    return true;
  },
  resize(layout) {
    return this.callBase(correctRadius(layout, 0));
  },
  _render: function () {
    const that = this;
    const options = that._options;
    const x = options.x;
    const y1 = options.y - options.radius;
    const dx = options.width / 2 || 0;
    const y2 = y1 - _Number(options.length);
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    const settings = {
      points: [x, y1, x - dx, y2, x + dx, y2],
      stroke: 'none',
      'stroke-width': 0,
      'stroke-linecap': 'square'
    };
    if (options.space > 0) {
      settings['stroke-width'] = Math.min(options.space, options.width / 4) || 0;
      settings.stroke = settings['stroke-width'] > 0 ? options.containerBackgroundColor || 'none' : 'none';
    }
    that._element.attr(settings).sharp();
  },
  _clear: function () {
    delete this._element;
  },
  _getTrackerSettings: function () {
    const options = this._options;
    const x = options.x;
    const y = options.y - options.radius - options.length / 2;
    let width = options.width / 2;
    let length = options.length / 2;
    width > 10 || (width = 10);
    length > 10 || (length = 10);
    return {
      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
    };
  },
  measure: function (layout) {
    return {
      min: layout.radius,
      max: layout.radius + _Number(this._options.length)
    };
  },
  getTooltipParameters: function () {
    const options = this._options;
    const cosSin = _getCosAndSin(this._actualPosition);
    const r = options.radius + options.length / 2;
    const parameters = this.callBase();
    parameters.x = options.x + cosSin.cos * r;
    parameters.y = options.y - cosSin.sin * r;
    parameters.offset = options.length / 2;
    return parameters;
  }
});
const textCloud = exports.textcloud = _base_indicators.BaseTextCloudMarker.inherit({
  _isEnabled: function () {
    return true;
  },
  _isVisible(layout) {
    return true;
  },
  resize(layout) {
    return this.callBase(correctRadius(layout, 0));
  },
  _getTextCloudOptions: function () {
    const that = this;
    const cosSin = _getCosAndSin(that._actualPosition);
    const nAngle = (0, _utils.normalizeAngle)(that._actualPosition);
    return {
      x: that._options.x + cosSin.cos * that._options.radius,
      y: that._options.y - cosSin.sin * that._options.radius,
      type: nAngle > 270 ? 'left-top' : nAngle > 180 ? 'top-right' : nAngle > 90 ? 'right-bottom' : 'bottom-left'
    };
  },
  measure: function (layout) {
    const that = this;
    const arrowLength = _Number(that._options.arrowLength) || 0;
    that._measureText();
    const verticalOffset = that._textFullHeight + arrowLength;
    const horizontalOffset = that._textFullWidth + arrowLength;
    return {
      min: layout.radius,
      max: layout.radius,
      horizontalOffset: horizontalOffset,
      verticalOffset: verticalOffset,
      inverseHorizontalOffset: horizontalOffset,
      inverseVerticalOffset: verticalOffset
    };
  }
});

// The following is from circularRangeBar.js

const rangeBar = exports.rangebar = _base_indicators.BaseRangeBar.inherit({
  _isEnabled: function () {
    return this._options.size > 0;
  },
  _isVisible(layout) {
    return true;
  },
  resize(layout) {
    return this.callBase(correctRadius(layout, _Number(this._options.size)));
  },
  _createBarItem: function () {
    return this._renderer.arc().attr({
      'stroke-linejoin': 'round'
    }).append(this._rootElement);
  },
  _createTracker: function () {
    return this._renderer.arc().attr({
      'stroke-linejoin': 'round'
    });
  },
  _setBarSides: function () {
    const that = this;
    that._maxSide = that._options.radius;
    that._minSide = that._maxSide - _Number(that._options.size);
  },
  _getSpace: function () {
    const options = this._options;
    return options.space > 0 ? options.space * 180 / options.radius / Math.PI : 0;
  },
  _isTextVisible: function () {
    const options = this._options.text || {};
    return options.indent > 0;
  },
  _setTextItemsSides: function () {
    const that = this;
    const options = that._options;
    const indent = _Number(options.text.indent);
    that._lineFrom = options.y - options.radius;
    that._lineTo = that._lineFrom - indent;
    that._textRadius = options.radius + indent;
  },
  _getPositions: function () {
    const that = this;
    const basePosition = that._basePosition;
    const actualPosition = that._actualPosition;
    let mainPosition1;
    let mainPosition2;
    if (basePosition >= actualPosition) {
      mainPosition1 = basePosition;
      mainPosition2 = actualPosition;
    } else {
      mainPosition1 = actualPosition;
      mainPosition2 = basePosition;
    }
    return {
      start: that._startPosition,
      end: that._endPosition,
      main1: mainPosition1,
      main2: mainPosition2,
      back1: Math.min(mainPosition1 + that._space, that._startPosition),
      back2: Math.max(mainPosition2 - that._space, that._endPosition)
    };
  },
  _buildItemSettings: function (from, to) {
    const that = this;
    return {
      x: that._options.x,
      y: that._options.y,
      innerRadius: that._minSide,
      outerRadius: that._maxSide,
      startAngle: to,
      endAngle: from
    };
  },
  _updateTextPosition: function () {
    const that = this;
    const cosSin = _getCosAndSin(that._actualPosition);
    let x = that._options.x + that._textRadius * cosSin.cos;
    let y = that._options.y - that._textRadius * cosSin.sin;
    x += cosSin.cos * that._textWidth * 0.6;
    y -= cosSin.sin * that._textHeight * 0.6;
    that._text.attr({
      x: x,
      y: y + that._textVerticalOffset
    });
  },
  _updateLinePosition: function () {
    const that = this;
    const x = that._options.x;
    let x1;
    let x2;
    if (that._basePosition > that._actualPosition) {
      x1 = x - 2;
      x2 = x;
    } else if (that._basePosition < that._actualPosition) {
      x1 = x;
      x2 = x + 2;
    } else {
      x1 = x - 1;
      x2 = x + 1;
    }
    that._line.attr({
      points: [x1, that._lineFrom, x1, that._lineTo, x2, that._lineTo, x2, that._lineFrom]
    }).rotate(_convertAngleToRendererSpace(that._actualPosition), x, that._options.y).sharp();
  },
  _getTooltipPosition: function () {
    const that = this;
    const cosSin = _getCosAndSin((that._basePosition + that._actualPosition) / 2);
    const r = (that._minSide + that._maxSide) / 2;
    return {
      x: that._options.x + cosSin.cos * r,
      y: that._options.y - cosSin.sin * r
    };
  },
  measure: function (layout) {
    const that = this;
    const result = {
      min: layout.radius - _Number(that._options.size),
      max: layout.radius
    };
    that._measureText();
    if (that._hasText) {
      result.max += _Number(that._options.text.indent);
      result.horizontalOffset = that._textWidth;
      result.verticalOffset = that._textHeight;
    }
    return result;
  }
});

/* eslint-disable spellcheck/spell-checker */

/***/ }),

/***/ 27172:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _base_range_container = _interopRequireDefault(__webpack_require__(84165));
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _Number = Number;
const _max = Math.max;
const CircularRangeContainer = _base_range_container.default.inherit({
  _processOptions: function () {
    const that = this;
    that._inner = that._outer = 0;
    switch ((0, _utils.normalizeEnum)(that._options.orientation)) {
      case 'inside':
        that._inner = 1;
        break;
      case 'center':
        that._inner = that._outer = 0.5;
        break;
      default:
        that._outer = 1;
        break;
    }
  },
  _isVisible: function (layout) {
    let width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    return layout.radius - this._inner * width > 0;
  },
  _createRange: function (range, layout) {
    const that = this;
    const width = (range.startWidth + range.endWidth) / 2;
    return that._renderer.arc(layout.x, layout.y, layout.radius - that._inner * width, layout.radius + that._outer * width, that._translator.translate(range.end), that._translator.translate(range.start)).attr({
      'stroke-linejoin': 'round'
    });
  },
  measure: function (layout) {
    let width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    return {
      min: layout.radius - this._inner * width,
      max: layout.radius + this._outer * width
    };
  }
});
var _default = exports["default"] = CircularRangeContainer;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 88917:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.createIndicatorCreator = createIndicatorCreator;
exports.dxGauge = void 0;
var _base_gauge = __webpack_require__(18029);
var _type = __webpack_require__(35922);
var _extend2 = __webpack_require__(13306);
var _base_axis = __webpack_require__(41278);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
const _isArray = Array.isArray;
const _isFinite = isFinite;
const _Number = Number;
const _min = Math.min;
const _max = Math.max;
const _extend = _extend2.extend;
const SHIFT_ANGLE = 90;
const OPTION_VALUE = 'value';
const OPTION_SUBVALUES = 'subvalues';
const DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 5;
const DEFAULT_NUMBER_MULTIPLIERS = [1, 2, 5];
function processValue(value, fallbackValue) {
  if (value === null) {
    return value;
  }
  return _isFinite(value) ? _Number(value) : fallbackValue;
}
function parseArrayOfNumbers(arg) {
  return _isArray(arg) ? arg : (0, _type.isNumeric)(arg) ? [arg] : null;
}
const dxGauge = exports.dxGauge = _base_gauge.BaseGauge.inherit({
  _initCore: function () {
    const that = this;
    const renderer = that._renderer;
    that._setupValue(that.option(OPTION_VALUE));
    that.__subvalues = parseArrayOfNumbers(that.option(OPTION_SUBVALUES));
    that._setupSubvalues(that.__subvalues);
    selectMode(that);
    that.callBase.apply(that, arguments);
    that._rangeContainer = new that._factory.RangeContainer({
      renderer: renderer,
      container: renderer.root,
      translator: that._translator,
      themeManager: that._themeManager
    });
    that._initScale();
    that._subvalueIndicatorContainer = that._renderer.g().attr({
      class: 'dxg-subvalue-indicators'
    }).linkOn(that._renderer.root, 'valueIndicator').enableLinks();
  },
  _fontFields: ['scale.label.font', 'valueIndicators.rangebar.text.font', 'valueIndicators.textcloud.text.font', 'indicator.text.font'],
  _initScale: function () {
    const that = this;
    that._scaleGroup = that._renderer.g().attr({
      'class': 'dxg-scale'
    }).linkOn(that._renderer.root, 'scale');
    that._labelsAxesGroup = that._renderer.g().attr({
      'class': 'dxg-scale-elements'
    }).linkOn(that._renderer.root, 'scale-elements');
    that._scale = new _base_axis.Axis({
      incidentOccurred: that._incidentOccurred,
      renderer: that._renderer,
      axesContainerGroup: that._scaleGroup,
      labelsAxesGroup: that._labelsAxesGroup,
      axisType: that._scaleTypes.type,
      drawingType: that._scaleTypes.drawingType,
      widgetClass: 'dxg',
      getTemplate() {}
    });
  },
  _disposeCore: function () {
    const that = this;
    that.callBase.apply(that, arguments);
    that._scale.dispose();
    that._scaleGroup.linkOff();
    that._labelsAxesGroup.linkOff();
    that._rangeContainer.dispose();
    that._disposeValueIndicators();
    that._subvalueIndicatorContainer.linkOff();
    that._scale = that._scaleGroup = that._labelsAxesGroup = that._rangeContainer = null;
  },
  _disposeValueIndicators: function () {
    const that = this;
    that._valueIndicator && that._valueIndicator.dispose();
    that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.dispose();
    that._valueIndicator = that._subvalueIndicatorsSet = null;
  },
  _setupDomainCore: function () {
    const that = this;
    const scaleOption = that.option('scale') || {};
    let startValue = that.option('startValue');
    let endValue = that.option('endValue');
    startValue = (0, _type.isNumeric)(startValue) ? _Number(startValue) : (0, _type.isNumeric)(scaleOption.startValue) ? _Number(scaleOption.startValue) : 0;
    endValue = (0, _type.isNumeric)(endValue) ? _Number(endValue) : (0, _type.isNumeric)(scaleOption.endValue) ? _Number(scaleOption.endValue) : 100;
    that._baseValue = startValue < endValue ? startValue : endValue;
    that._translator.setDomain(startValue, endValue);
  },
  _cleanContent: function () {
    const that = this;
    that._rangeContainer.clean();
    that._cleanValueIndicators();
  },
  _measureScale: function (scaleOptions) {
    const that = this;
    const majorTick = scaleOptions.tick;
    const majorTickEnabled = majorTick.visible && majorTick.length > 0 && majorTick.width > 0;
    const minorTick = scaleOptions.minorTick;
    const minorTickEnabled = minorTick.visible && minorTick.length > 0 && minorTick.width > 0;
    const label = scaleOptions.label;
    const indentFromTick = Number(label.indentFromTick);
    if (!majorTickEnabled && !minorTickEnabled && !label.visible) {
      return {};
    }
    const textParams = that._scale.measureLabels((0, _extend2.extend)({}, that._canvas));
    const layoutValue = that._getScaleLayoutValue();
    const result = {
      min: layoutValue,
      max: layoutValue
    };
    const coefs = that._getTicksCoefficients(scaleOptions);
    const innerCoef = coefs.inner;
    const outerCoef = coefs.outer;
    if (majorTickEnabled) {
      result.min = _min(result.min, layoutValue - innerCoef * majorTick.length);
      result.max = _max(result.max, layoutValue + outerCoef * majorTick.length);
    }
    if (minorTickEnabled) {
      result.min = _min(result.min, layoutValue - innerCoef * minorTick.length);
      result.max = _max(result.max, layoutValue + outerCoef * minorTick.length);
    }
    label.visible && that._correctScaleIndents(result, indentFromTick, textParams);
    return result;
  },
  _renderContent: function () {
    const that = this;
    const scaleOptions = that._prepareScaleSettings();
    that._rangeContainer.render(_extend(that._getOption('rangeContainer'), {
      vertical: that._area.vertical
    }));
    that._renderScale(scaleOptions);
    that._subvalueIndicatorContainer.linkAppend();
    const elements = (0, _utils.map)([that._rangeContainer].concat(that._prepareValueIndicators()), function (element) {
      return element && element.enabled ? element : null;
    });
    that._applyMainLayout(elements, that._measureScale(scaleOptions));
    elements.forEach(element => element.resize(that._getElementLayout(element.getOffset())));
    that._shiftScale(that._getElementLayout(0), scaleOptions);
    that._beginValueChanging();
    that._updateActiveElements();
    that._endValueChanging();
  },
  _prepareScaleSettings: function () {
    const that = this;
    const userOptions = that.option('scale');
    const scaleOptions = (0, _extend2.extend)(true, {}, that._themeManager.theme('scale'), userOptions);
    scaleOptions.label.indentFromAxis = 0;
    scaleOptions.isHorizontal = !that._area.vertical;
    scaleOptions.forceUserTickInterval |= (0, _type.isDefined)(userOptions) && (0, _type.isDefined)(userOptions.tickInterval) && !(0, _type.isDefined)(userOptions.scaleDivisionFactor);
    scaleOptions.axisDivisionFactor = scaleOptions.scaleDivisionFactor || that._gridSpacingFactor;
    scaleOptions.minorAxisDivisionFactor = scaleOptions.minorScaleDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
    scaleOptions.numberMultipliers = DEFAULT_NUMBER_MULTIPLIERS;
    scaleOptions.tickOrientation = that._getTicksOrientation(scaleOptions);
    if (scaleOptions.label.useRangeColors) {
      scaleOptions.label.customizeColor = function () {
        return that._rangeContainer.getColorForValue(this.value);
      };
    }
    return scaleOptions;
  },
  _renderScale: function (scaleOptions) {
    const that = this;
    const bounds = that._translator.getDomain();
    const startValue = bounds[0];
    const endValue = bounds[1];
    const angles = that._translator.getCodomain();
    const invert = !!(startValue > endValue ^ scaleOptions.inverted);
    const min = _min(startValue, endValue);
    const max = _max(startValue, endValue);
    scaleOptions.min = min;
    scaleOptions.max = max;
    scaleOptions.startAngle = SHIFT_ANGLE - angles[0];
    scaleOptions.endAngle = SHIFT_ANGLE - angles[1];
    scaleOptions.skipViewportExtending = true;
    scaleOptions.inverted = invert;
    that._scale.updateOptions(scaleOptions);
    that._scale.setBusinessRange({
      axisType: 'continuous',
      dataType: 'numeric',
      min: min,
      max: max,
      invert: invert
    });
    that._updateScaleTickIndent(scaleOptions);
    that._scaleGroup.linkAppend();
    that._labelsAxesGroup.linkAppend();
    that._scale.draw((0, _extend2.extend)({}, that._canvas));
  },
  _updateIndicatorSettings: function (settings) {
    const that = this;
    settings.currentValue = settings.baseValue = _isFinite(that._translator.translate(settings.baseValue)) ? _Number(settings.baseValue) : that._baseValue;
    settings.vertical = that._area.vertical;
    if (settings.text && !settings.text.format) {
      settings.text.format = that._defaultFormatOptions;
    }
  },
  _prepareIndicatorSettings: function (options, defaultTypeField) {
    const that = this;
    const theme = that._themeManager.theme('valueIndicators');
    const type = (0, _utils.normalizeEnum)(options.type || that._themeManager.theme(defaultTypeField));
    const settings = _extend(true, {}, theme._default, theme[type], options);
    settings.type = type;
    settings.animation = that._animationSettings;
    settings.containerBackgroundColor = that._containerBackgroundColor;
    that._updateIndicatorSettings(settings);
    return settings;
  },
  _cleanValueIndicators: function () {
    this._valueIndicator && this._valueIndicator.clean();
    this._subvalueIndicatorsSet && this._subvalueIndicatorsSet.clean();
  },
  _prepareValueIndicators: function () {
    const that = this;
    that._prepareValueIndicator();
    that.__subvalues !== null && that._prepareSubvalueIndicators();
    return [that._valueIndicator, that._subvalueIndicatorsSet];
  },
  _updateActiveElements: function () {
    this._updateValueIndicator();
    this._updateSubvalueIndicators();
  },
  _prepareValueIndicator: function () {
    const that = this;
    let target = that._valueIndicator;
    const settings = that._prepareIndicatorSettings(that.option('valueIndicator') || {}, 'valueIndicatorType');
    if (target && target.type !== settings.type) {
      target.dispose();
      target = null;
    }
    if (!target) {
      target = that._valueIndicator = that._createIndicator(settings.type, that._renderer.root, 'dxg-value-indicator', 'value-indicator');
    }
    target.render(settings);
  },
  _createSubvalueIndicatorsSet: function () {
    const that = this;
    const root = that._subvalueIndicatorContainer;
    return new ValueIndicatorsSet({
      createIndicator: function (type, i) {
        return that._createIndicator(type, root, 'dxg-subvalue-indicator', 'subvalue-indicator', i);
      },
      createPalette: function (palette) {
        return that._themeManager.createPalette(palette);
      }
    });
  },
  _prepareSubvalueIndicators: function () {
    const that = this;
    let target = that._subvalueIndicatorsSet;
    const settings = that._prepareIndicatorSettings(that.option('subvalueIndicator') || {}, 'subvalueIndicatorType');
    if (!target) {
      target = that._subvalueIndicatorsSet = that._createSubvalueIndicatorsSet();
    }
    const isRecreate = settings.type !== target.type;
    target.type = settings.type;
    const dummy = that._createIndicator(settings.type, that._renderer.root);
    if (dummy) {
      dummy.dispose();
      target.render(settings, isRecreate);
    }
  },
  _setupValue: function (value) {
    this.__value = processValue(value, this.__value);
  },
  _setupSubvalues: function (subvalues) {
    const vals = subvalues === undefined ? this.__subvalues : parseArrayOfNumbers(subvalues);
    let i;
    let ii;
    let list;
    if (vals === null) return;
    for (i = 0, ii = vals.length, list = []; i < ii; ++i) {
      list.push(processValue(vals[i], this.__subvalues[i]));
    }
    this.__subvalues = list;
  },
  _updateValueIndicator: function () {
    const that = this;
    that._valueIndicator && that._valueIndicator.value(that.__value, that._noAnimation);
  },
  _updateSubvalueIndicators: function () {
    const that = this;
    that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.values(that.__subvalues, that._noAnimation);
  },
  value: function (arg) {
    if (arg !== undefined) {
      this._changeValue(arg);
      return this;
    }
    return this.__value;
  },
  subvalues: function (arg) {
    if (arg !== undefined) {
      this._changeSubvalues(arg);
      return this;
    }
    return this.__subvalues !== null ? this.__subvalues.slice() : undefined;
  },
  _changeValue: function (value) {
    this._setupValue(value);
    this._beginValueChanging();
    this._updateValueIndicator();
    this._updateExtraElements();
    if (this.__value !== this.option(OPTION_VALUE)) {
      this.option(OPTION_VALUE, this.__value);
    }
    this._endValueChanging();
  },
  _changeSubvalues: function (subvalues) {
    if (this.__subvalues !== null) {
      this._setupSubvalues(subvalues);
      this._beginValueChanging();
      this._updateSubvalueIndicators();
      this._updateExtraElements();
      this._endValueChanging();
    } else {
      this.__subvalues = parseArrayOfNumbers(subvalues);
      this._setContentSize();
      this._renderContent();
    }
    if (!(0, _base_gauge.compareArrays)(this.__subvalues, this.option(OPTION_SUBVALUES))) {
      this.option(OPTION_SUBVALUES, this.__subvalues);
    }
  },
  _optionChangesMap: {
    scale: 'DOMAIN',
    rangeContainer: 'MOSTLY_TOTAL',
    valueIndicator: 'MOSTLY_TOTAL',
    subvalueIndicator: 'MOSTLY_TOTAL',
    containerBackgroundColor: 'MOSTLY_TOTAL',
    value: 'VALUE',
    subvalues: 'SUBVALUES',
    valueIndicators: 'MOSTLY_TOTAL'
  },
  _customChangesOrder: ['VALUE', 'SUBVALUES'],
  _change_VALUE: function () {
    this._changeValue(this.option(OPTION_VALUE));
  },
  _change_SUBVALUES: function () {
    this._changeSubvalues(this.option(OPTION_SUBVALUES));
  },
  _applyMainLayout: null,
  _getElementLayout: null,
  _createIndicator: function (type, owner, className, trackerType, trackerIndex, _strict) {
    const that = this;
    const indicator = that._factory.createIndicator({
      renderer: that._renderer,
      translator: that._translator,
      owner: owner,
      tracker: that._tracker,
      className: className
    }, type, _strict);
    if (indicator) {
      indicator.type = type;
      indicator._trackerInfo = {
        type: trackerType,
        index: trackerIndex
      };
    }
    return indicator;
  },
  _getApproximateScreenRange: null
});
function valueGetter(arg) {
  return arg ? arg.value : null;
}
function setupValues(that, fieldName, optionItems) {
  const currentValues = that[fieldName];
  const newValues = _isArray(optionItems) ? (0, _utils.map)(optionItems, valueGetter) : [];
  let i = 0;
  const ii = newValues.length;
  const list = [];
  for (; i < ii; ++i) {
    list.push(processValue(newValues[i], currentValues[i]));
  }
  that[fieldName] = list;
}
function selectMode(gauge) {
  if (gauge.option(OPTION_VALUE) === undefined && gauge.option(OPTION_SUBVALUES) === undefined) {
    if (gauge.option('valueIndicators') !== undefined) {
      disableDefaultMode(gauge);
      selectHardMode(gauge);
    }
  }
}
function disableDefaultMode(that) {
  that.value = that.subvalues = _common.noop;
  that._setupValue = that._setupSubvalues = that._updateValueIndicator = that._updateSubvalueIndicators = null;
}
function selectHardMode(that) {
  that._indicatorValues = [];
  setupValues(that, '_indicatorValues', that.option('valueIndicators'));
  that._valueIndicators = [];
  const _applyMostlyTotalChange = that._applyMostlyTotalChange;
  that._applyMostlyTotalChange = function () {
    setupValues(this, '_indicatorValues', this.option('valueIndicators'));
    _applyMostlyTotalChange.call(this);
  };
  that._updateActiveElements = updateActiveElements_hardMode;
  that._prepareValueIndicators = prepareValueIndicators_hardMode;
  that._disposeValueIndicators = disposeValueIndicators_hardMode;
  that._cleanValueIndicators = cleanValueIndicators_hardMode;
  that.indicatorValue = indicatorValue_hardMode;
}
function updateActiveElements_hardMode() {
  const that = this;
  that._valueIndicators.forEach(valueIndicator => {
    valueIndicator.value(that._indicatorValues[valueIndicator.index], that._noAnimation);
  });
}
function prepareValueIndicators_hardMode() {
  const that = this;
  const valueIndicators = that._valueIndicators || [];
  const userOptions = that.option('valueIndicators');
  const optionList = [];
  let i = 0;
  let ii;
  for (ii = _isArray(userOptions) ? userOptions.length : 0; i < ii; ++i) {
    optionList.push(userOptions[i]);
  }
  for (ii = valueIndicators.length; i < ii; ++i) {
    optionList.push(null);
  }
  const newValueIndicators = [];
  optionList.forEach((userSettings, i) => {
    let valueIndicator = valueIndicators[i];
    if (!userSettings) {
      valueIndicator && valueIndicator.dispose();
      return;
    }
    const settings = that._prepareIndicatorSettings(userSettings, 'valueIndicatorType');
    if (valueIndicator && valueIndicator.type !== settings.type) {
      valueIndicator.dispose();
      valueIndicator = null;
    }
    if (!valueIndicator) {
      valueIndicator = that._createIndicator(settings.type, that._renderer.root, 'dxg-value-indicator', 'value-indicator', i, true);
    }
    if (valueIndicator) {
      valueIndicator.index = i;
      valueIndicator.render(settings);
      newValueIndicators.push(valueIndicator);
    }
  });
  that._valueIndicators = newValueIndicators;
  return that._valueIndicators;
}
function disposeValueIndicators_hardMode() {
  this._valueIndicators.forEach(valueIndicator => valueIndicator.dispose());
  this._valueIndicators = null;
}
function cleanValueIndicators_hardMode() {
  this._valueIndicators.forEach(valueIndicator => valueIndicator.clean());
}
function indicatorValue_hardMode(index, value) {
  return accessPointerValue(this, this._valueIndicators, this._indicatorValues, index, value);
}
function accessPointerValue(that, pointers, values, index, value) {
  if (value !== undefined) {
    if (values[index] !== undefined) {
      values[index] = processValue(value, values[index]);
      pointers[index] && pointers[index].value(values[index]);
    }
    return that;
  } else {
    return values[index];
  }
}
function ValueIndicatorsSet(parameters) {
  this._parameters = parameters;
  this._indicators = [];
}
ValueIndicatorsSet.prototype = {
  constructor: ValueIndicatorsSet,
  dispose: function () {
    const that = this;
    that._indicators.forEach(indicator => indicator.dispose());
    that._parameters = that._options = that._indicators = that._colorPalette = that._palette = null;
    return that;
  },
  clean: function () {
    const that = this;
    that._sample && that._sample.clean().dispose();
    that._indicators.forEach(indicator => indicator.clean());
    that._sample = that._options = that._palette = null;
    return that;
  },
  render: function (options, isRecreate) {
    const that = this;
    that._options = options;
    that._sample = that._parameters.createIndicator(that.type);
    that._sample.render(options);
    that.enabled = that._sample.enabled;
    that._palette = (0, _type.isDefined)(options.palette) ? that._parameters.createPalette(options.palette) : null;
    if (that.enabled) {
      that._generatePalette(that._indicators.length);
      that._indicators = (0, _utils.map)(that._indicators, function (indicator, i) {
        if (isRecreate) {
          indicator.dispose();
          indicator = that._parameters.createIndicator(that.type, i);
        }
        indicator.render(that._getIndicatorOptions(i));
        return indicator;
      });
    }
    return that;
  },
  getOffset: function () {
    return this._sample.getOffset();
  },
  resize: function (layout) {
    const that = this;
    that._layout = layout;
    that._indicators.forEach(indicator => indicator.resize(layout));
    return that;
  },
  measure: function (layout) {
    return this._sample.measure(layout);
  },
  _getIndicatorOptions: function (index) {
    let result = this._options;
    if (this._colorPalette) {
      result = _extend({}, result, {
        color: this._colorPalette[index]
      });
    }
    return result;
  },
  _generatePalette: function (count) {
    const that = this;
    let colors = null;
    if (that._palette) {
      that._palette.reset();
      colors = that._palette.generateColors(count, {
        repeat: true
      });
    }
    that._colorPalette = colors;
  },
  _adjustIndicatorsCount: function (count) {
    const that = this;
    const indicators = that._indicators;
    let i;
    let ii;
    let indicator;
    const indicatorsLen = indicators.length;
    if (indicatorsLen > count) {
      for (i = count, ii = indicatorsLen; i < ii; ++i) {
        indicators[i].clean().dispose();
      }
      that._indicators = indicators.slice(0, count);
      that._generatePalette(indicators.length);
    } else if (indicatorsLen < count) {
      that._generatePalette(count);
      for (i = indicatorsLen, ii = count; i < ii; ++i) {
        indicator = that._parameters.createIndicator(that.type, i);
        indicator.render(that._getIndicatorOptions(i)).resize(that._layout);
        indicators.push(indicator);
      }
    }
  },
  values: function (arg, _noAnimation) {
    const that = this;
    if (!that.enabled) return;
    if (arg !== undefined) {
      if (!_isArray(arg)) {
        arg = _isFinite(arg) ? [Number(arg)] : null;
      }
      if (arg) {
        that._adjustIndicatorsCount(arg.length);
        that._indicators.forEach((indicator, i) => indicator.value(arg[i], _noAnimation));
      }
      return that;
    }
    return (0, _utils.map)(that._indicators, function (indicator) {
      return indicator.value();
    });
  }
};
function createIndicatorCreator(indicators) {
  return function (parameters, type, _strict) {
    const indicatorType = indicators[(0, _utils.normalizeEnum)(type)] || !_strict && indicators._default;
    return indicatorType ? new indicatorType(parameters) : null;
  };
}

/***/ }),

/***/ 62987:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _extend = __webpack_require__(13306);
var _object = __webpack_require__(48013);
var _base_gauge = __webpack_require__(18029);
var _common = __webpack_require__(88917);
var _utils = __webpack_require__(19157);
var linearIndicators = _interopRequireWildcard(__webpack_require__(79615));
var _linear_range_container = _interopRequireDefault(__webpack_require__(74425));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _max = Math.max;
const _min = Math.min;
const _round = Math.round;
const dxLinearGauge = _common.dxGauge.inherit({
  _rootClass: 'dxg-linear-gauge',
  _factoryMethods: {
    rangeContainer: 'createLinearRangeContainer',
    indicator: 'createLinearIndicator'
  },
  _gridSpacingFactor: 25,
  _scaleTypes: {
    type: 'xyAxes',
    drawingType: 'linear'
  },
  _getTicksOrientation: function (scaleOptions) {
    return scaleOptions.isHorizontal ? scaleOptions.verticalOrientation : scaleOptions.horizontalOrientation;
  },
  _getThemeManagerOptions() {
    const options = this.callBase.apply(this, arguments);
    options.subTheme = '_linear';
    return options;
  },
  _getInvertedState() {
    return !this._area.vertical && this.option('rtlEnabled');
  },
  _prepareScaleSettings: function () {
    const scaleOptions = this.callBase();
    scaleOptions.inverted = this._getInvertedState();
    return scaleOptions;
  },
  _updateScaleTickIndent: function (scaleOptions) {
    const indentFromTick = scaleOptions.label.indentFromTick;
    const length = scaleOptions.tick.length;
    const textParams = this._scale.measureLabels((0, _extend.extend)({}, this._canvas));
    const verticalTextCorrection = scaleOptions.isHorizontal ? textParams.height + textParams.y : 0;
    const isIndentPositive = indentFromTick > 0;
    let orientation;
    let textCorrection;
    let tickCorrection;
    if (scaleOptions.isHorizontal) {
      orientation = isIndentPositive ? {
        center: 0.5,
        top: 0,
        bottom: 1
      } : {
        center: 0.5,
        top: 1,
        bottom: 0
      };
      tickCorrection = length * orientation[scaleOptions.verticalOrientation];
      textCorrection = textParams.y;
    } else {
      orientation = isIndentPositive ? {
        center: 0.5,
        left: 0,
        right: 1
      } : {
        center: 0.5,
        left: 1,
        right: 0
      };
      tickCorrection = length * orientation[scaleOptions.horizontalOrientation];
      textCorrection = -textParams.width;
    }
    scaleOptions.label.indentFromAxis = -indentFromTick + (isIndentPositive ? -tickCorrection + textCorrection : tickCorrection - verticalTextCorrection);
    this._scale.updateOptions(scaleOptions);
  },
  _shiftScale: function (layout, scaleOptions) {
    const that = this;
    const canvas = (0, _extend.extend)({}, that._canvas);
    const isHorizontal = scaleOptions.isHorizontal;
    const scale = that._scale;
    canvas[isHorizontal ? 'left' : 'top'] = that._area[isHorizontal ? 'startCoord' : 'endCoord'];
    canvas[isHorizontal ? 'right' : 'bottom'] = canvas[isHorizontal ? 'width' : 'height'] - that._area[isHorizontal ? 'endCoord' : 'startCoord'];
    scale.draw(canvas);
    scale.shift({
      left: -layout.x,
      top: -layout.y
    });
  },
  _setupCodomain: function () {
    const that = this;
    const geometry = that.option('geometry') || {};
    const vertical = (0, _utils.normalizeEnum)(geometry.orientation) === 'vertical';
    const initialStartCoord = -100;
    const initialEndCoord = 100;
    that._area = {
      vertical: vertical,
      x: 0,
      y: 0,
      startCoord: initialStartCoord,
      endCoord: initialEndCoord
    };
    that._rangeContainer.vertical = vertical;
    that._translator.setInverted(that._getInvertedState());
    that._translator.setCodomain(initialStartCoord, initialEndCoord);
  },
  _getScaleLayoutValue: function () {
    return this._area[this._area.vertical ? 'x' : 'y'];
  },
  _getTicksCoefficients: function (options) {
    const coefs = {
      inner: 0,
      outer: 1
    };
    if (this._area.vertical) {
      if (options.horizontalOrientation === 'left') {
        coefs.inner = 1;
        coefs.outer = 0;
      } else if (options.horizontalOrientation === 'center') {
        coefs.inner = coefs.outer = 0.5;
      }
    } else {
      if (options.verticalOrientation === 'top') {
        coefs.inner = 1;
        coefs.outer = 0;
      } else if (options.verticalOrientation === 'center') {
        coefs.inner = coefs.outer = 0.5;
      }
    }
    return coefs;
  },
  _correctScaleIndents: function (result, indentFromTick, textParams) {
    const vertical = this._area.vertical;
    if (indentFromTick >= 0) {
      result.max += indentFromTick + textParams[vertical ? 'width' : 'height'];
    } else {
      result.min -= -indentFromTick + textParams[vertical ? 'width' : 'height'];
    }
    result.indent = textParams[vertical ? 'height' : 'width'] / 2;
  },
  _measureMainElements: function (elements, scaleMeasurement) {
    const that = this;
    const x = that._area.x;
    const y = that._area.y;
    let minBound = 1000;
    let maxBound = 0;
    let indent = 0;
    const scale = that._scale;
    (0, _iterator.each)(elements.concat(scale), function (_, element) {
      const bounds = element.measure ? element.measure({
        x: x + element.getOffset(),
        y: y + element.getOffset()
      }) : scaleMeasurement;
      bounds.max !== undefined && (maxBound = _max(maxBound, bounds.max));
      bounds.min !== undefined && (minBound = _min(minBound, bounds.min));
      bounds.indent > 0 && (indent = _max(indent, bounds.indent));
    });
    return {
      minBound: minBound,
      maxBound: maxBound,
      indent: indent
    };
  },
  _applyMainLayout: function (elements, scaleMeasurement) {
    const that = this;
    const measurements = that._measureMainElements(elements, scaleMeasurement);
    const area = that._area;
    let rect;
    let offset;
    if (area.vertical) {
      rect = selectRectBySizes(that._innerRect, {
        width: measurements.maxBound - measurements.minBound
      });
      offset = (rect.left + rect.right) / 2 - (measurements.minBound + measurements.maxBound) / 2;
      area.startCoord = rect.bottom - measurements.indent;
      area.endCoord = rect.top + measurements.indent;
      area.x = _round(area.x + offset);
    } else {
      rect = selectRectBySizes(that._innerRect, {
        height: measurements.maxBound - measurements.minBound
      });
      offset = (rect.top + rect.bottom) / 2 - (measurements.minBound + measurements.maxBound) / 2;
      area.startCoord = rect.left + measurements.indent;
      area.endCoord = rect.right - measurements.indent;
      area.y = _round(area.y + offset);
    }
    that._translator.setCodomain(area.startCoord, area.endCoord);
    that._innerRect = rect;
  },
  _getElementLayout: function (offset) {
    return {
      x: _round(this._area.x + offset),
      y: _round(this._area.y + offset)
    };
  },
  _getApproximateScreenRange: function () {
    const that = this;
    const area = that._area;
    let s = area.vertical ? that._canvas.height : that._canvas.width;
    s > area.totalSize && (s = area.totalSize);
    s = s * 0.8;
    return s;
  },
  _getDefaultSize: function () {
    const geometry = this.option('geometry') || {};
    if (geometry.orientation === 'vertical') {
      return {
        width: 100,
        height: 300
      };
    } else {
      return {
        width: 300,
        height: 100
      };
    }
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory)
});
function selectRectBySizes(srcRect, sizes, margins) {
  const rect = (0, _extend.extend)({}, srcRect);
  let step;
  margins = margins || {};
  if (sizes) {
    rect.left += margins.left || 0;
    rect.right -= margins.right || 0;
    rect.top += margins.top || 0;
    rect.bottom -= margins.bottom || 0;
    if (sizes.width > 0) {
      step = (rect.right - rect.left - sizes.width) / 2;
      if (step > 0) {
        rect.left += step;
        rect.right -= step;
      }
    }
    if (sizes.height > 0) {
      step = (rect.bottom - rect.top - sizes.height) / 2;
      if (step > 0) {
        rect.top += step;
        rect.bottom -= step;
      }
    }
  }
  return rect;
}
const indicators = dxLinearGauge.prototype._factory.indicators = {};
dxLinearGauge.prototype._factory.createIndicator = (0, _common.createIndicatorCreator)(indicators);

/* eslint-disable import/namespace */
indicators._default = linearIndicators._default;
indicators['rectangle'] = linearIndicators['rectangle'];
indicators['rhombus'] = linearIndicators['rhombus'];
indicators['circle'] = linearIndicators['circle'];
indicators['trianglemarker'] = linearIndicators['trianglemarker'];
indicators['textcloud'] = linearIndicators['textcloud'];
indicators['rangebar'] = linearIndicators['rangebar'];
/* eslint-enable import/namespace */

dxLinearGauge.prototype._factory.RangeContainer = _linear_range_container.default;
(0, _component_registrator.default)('dxLinearGauge', dxLinearGauge);
var _default = exports["default"] = dxLinearGauge;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 79615:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.trianglemarker = exports.textcloud = exports.rhombus = exports.rectangle = exports.rangebar = exports.circle = exports._default = void 0;
var _base_indicators = __webpack_require__(3446);
var _utils = __webpack_require__(19157);
const _Number = Number;
const SimpleIndicator = _base_indicators.BaseIndicator.inherit({
  _move: function () {
    const that = this;
    const delta = that._actualPosition - that._zeroPosition;
    that._rootElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);
    that._trackerElement && that._trackerElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);
  },
  _isEnabled: function () {
    this.vertical = this._options.vertical;
    return this._options.length > 0 && this._options.width > 0;
  },
  _isVisible: function () {
    return true;
  },
  _getTrackerSettings: function () {
    const options = this._options;
    let x1;
    let x2;
    let y1;
    let y2;
    let width = options.width / 2;
    let length = options.length / 2;
    const p = this._zeroPosition;
    width > 10 || (width = 10);
    length > 10 || (length = 10);
    if (this.vertical) {
      x1 = options.x - length;
      x2 = options.x + length;
      y1 = p + width;
      y2 = p - width;
    } else {
      x1 = p - width;
      x2 = p + width;
      y1 = options.y + length;
      y2 = options.y - length;
    }
    return {
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    };
  },
  _render: function () {
    const that = this;
    that._zeroPosition = that._translator.getCodomainStart();
  },
  _clear: function () {
    delete this._element;
  },
  measure: function (layout) {
    const p = this.vertical ? layout.x : layout.y;
    return {
      min: p - this._options.length / 2,
      max: p + this._options.length / 2
    };
  },
  getTooltipParameters: function () {
    const that = this;
    const options = that._options;
    const p = that._actualPosition;
    const parameters = {
      x: p,
      y: p,
      value: that._currentValue,
      color: options.color,
      offset: options.width / 2
    };
    that.vertical ? parameters.x = options.x : parameters.y = options.y;
    return parameters;
  }
});
const rectangle = exports.rectangle = SimpleIndicator.inherit({
  _render: function () {
    const that = this;
    const options = that._options;
    let x1;
    let x2;
    let y1;
    let y2;
    that.callBase();
    const p = that._zeroPosition;
    if (that.vertical) {
      x1 = options.x - options.length / 2;
      x2 = options.x + options.length / 2;
      y1 = p + options.width / 2;
      y2 = p - options.width / 2;
    } else {
      x1 = p - options.width / 2;
      x2 = p + options.width / 2;
      y1 = options.y + options.length / 2;
      y2 = options.y - options.length / 2;
    }
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });
  }
});
const rhombus = exports.rhombus = SimpleIndicator.inherit({
  _render: function () {
    const that = this;
    const options = that._options;
    let x;
    let y;
    let dx;
    let dy;
    that.callBase();
    if (that.vertical) {
      x = options.x;
      y = that._zeroPosition;
      dx = options.length / 2 || 0;
      dy = options.width / 2 || 0;
    } else {
      x = that._zeroPosition;
      y = options.y;
      dx = options.width / 2 || 0;
      dy = options.length / 2 || 0;
    }
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr({
      points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy]
    });
  }
});
const circle = exports.circle = SimpleIndicator.inherit({
  _render: function () {
    const that = this;
    const options = that._options;
    let x;
    let y;
    that.callBase();
    if (that.vertical) {
      x = options.x;
      y = that._zeroPosition;
    } else {
      x = that._zeroPosition;
      y = options.y;
    }
    const r = options.length / 2 || 0;
    that._element = that._element || that._renderer.circle().append(that._rootElement);
    that._element.attr({
      cx: x,
      cy: y,
      r: r
    });
  }
});

// The following is from linearMarker.js

const triangleMarker = exports.trianglemarker = SimpleIndicator.inherit({
  _isEnabled: function () {
    const that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return that._options.length > 0 && that._options.width > 0;
  },
  _isVisible: function () {
    return true;
  },
  _render: function () {
    const that = this;
    const options = that._options;
    let x1;
    let x2;
    let y1;
    let y2;
    const settings = {
      stroke: 'none',
      'stroke-width': 0,
      'stroke-linecap': 'square'
    };
    that.callBase();
    if (that.vertical) {
      x1 = options.x;
      y1 = that._zeroPosition;
      x2 = x1 + _Number(that._inverted ? options.length : -options.length);
      settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2];
    } else {
      y1 = options.y;
      x1 = that._zeroPosition;
      y2 = y1 + _Number(that._inverted ? options.length : -options.length);
      settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2];
    }
    if (options.space > 0) {
      settings['stroke-width'] = Math.min(options.space, options.width / 4) || 0;
      settings.stroke = settings['stroke-width'] > 0 ? options.containerBackgroundColor || 'none' : 'none';
    }
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr(settings).sharp();
  },
  _getTrackerSettings: function () {
    const that = this;
    const options = that._options;
    let width = options.width / 2;
    let length = _Number(options.length);
    let x1;
    let x2;
    let y1;
    let y2;
    let result;
    width > 10 || (width = 10);
    length > 20 || (length = 20);
    if (that.vertical) {
      x1 = options.x;
      x2 = x1 + (that._inverted ? length : -length);
      y1 = that._zeroPosition + width;
      y2 = that._zeroPosition - width;
      result = [x1, y1, x2, y1, x2, y2, x1, y2];
    } else {
      y1 = options.y;
      y2 = y1 + (that._inverted ? length : -length);
      x1 = that._zeroPosition - width;
      x2 = that._zeroPosition + width;
      result = [x1, y1, x1, y2, x2, y2, x2, y1];
    }
    return {
      points: result
    };
  },
  measure: function (layout) {
    const that = this;
    const length = _Number(that._options.length);
    let minBound;
    let maxBound;
    if (that.vertical) {
      minBound = maxBound = layout.x;
      if (that._inverted) {
        maxBound = minBound + length;
      } else {
        minBound = maxBound - length;
      }
    } else {
      minBound = maxBound = layout.y;
      if (that._inverted) {
        maxBound = minBound + length;
      } else {
        minBound = maxBound - length;
      }
    }
    return {
      min: minBound,
      max: maxBound
    };
  },
  getTooltipParameters: function () {
    const that = this;
    const options = that._options;
    const s = (that._inverted ? options.length : -options.length) / 2;
    const parameters = that.callBase();
    that.vertical ? parameters.x += s : parameters.y += s;
    parameters.offset = options.length / 2;
    return parameters;
  }
});
const textCloud = exports.textcloud = _base_indicators.BaseTextCloudMarker.inherit({
  _isEnabled: function () {
    const that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return true;
  },
  _isVisible: function () {
    return true;
  },
  _getTextCloudOptions: function () {
    const that = this;
    let x = that._actualPosition;
    let y = that._actualPosition;
    let type;
    if (that.vertical) {
      x = that._options.x;
      type = that._inverted ? 'top-left' : 'top-right';
    } else {
      y = that._options.y;
      type = that._inverted ? 'right-top' : 'right-bottom';
    }
    return {
      x: x,
      y: y,
      type: type
    };
  },
  measure: function (layout) {
    const that = this;
    let minBound;
    let maxBound;
    const arrowLength = _Number(that._options.arrowLength) || 0;
    that._measureText();
    if (that.vertical) {
      if (that._inverted) {
        minBound = layout.x;
        maxBound = layout.x + arrowLength + that._textFullWidth;
      } else {
        minBound = layout.x - arrowLength - that._textFullWidth;
        maxBound = layout.x;
      }
    } else {
      if (that._inverted) {
        minBound = layout.y;
        maxBound = layout.y + arrowLength + that._textFullHeight;
      } else {
        minBound = layout.y - arrowLength - that._textFullHeight;
        maxBound = layout.y;
      }
    }
    return {
      min: minBound,
      max: maxBound,
      indent: 0
    };
  },
  _correctCloudType(type, _ref, _ref2) {
    let {
      x,
      y
    } = _ref;
    let {
      width,
      height
    } = _ref2;
    if (type === 'right-top' || type === 'right-bottom') {
      if (x - width < this._translator.getCodomainStart()) {
        type = `left-${type.split('-')[1]}`;
      }
    } else if (type === 'top-left' || type === 'top-right') {
      if (y + height > this._translator.getCodomainStart()) {
        type = `bottom-${type.split('-')[1]}`;
      }
    }
    return type;
  }
});

// The following is from linearRangeBar.js

const rangeBar = exports.rangebar = exports._default = _base_indicators.BaseRangeBar.inherit({
  _isEnabled: function () {
    const that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return that._options.size > 0;
  },
  _isVisible: function () {
    return true;
  },
  _createBarItem: function () {
    return this._renderer.path([], 'area').append(this._rootElement);
  },
  _createTracker: function () {
    return this._renderer.path([], 'area');
  },
  _setBarSides: function () {
    const that = this;
    const options = that._options;
    const size = _Number(options.size);
    let minSide;
    let maxSide;
    if (that.vertical) {
      if (that._inverted) {
        minSide = options.x;
        maxSide = options.x + size;
      } else {
        minSide = options.x - size;
        maxSide = options.x;
      }
    } else {
      if (that._inverted) {
        minSide = options.y;
        maxSide = options.y + size;
      } else {
        minSide = options.y - size;
        maxSide = options.y;
      }
    }
    that._minSide = minSide;
    that._maxSide = maxSide;
    that._minBound = minSide;
    that._maxBound = maxSide;
  },
  _getSpace: function () {
    const options = this._options;
    return options.space > 0 ? _Number(options.space) : 0;
  },
  _isTextVisible: function () {
    const textOptions = this._options.text || {};
    return textOptions.indent > 0 || textOptions.indent < 0;
  },
  _getTextAlign: function () {
    return this.vertical ? this._options.text.indent > 0 ? 'left' : 'right' : 'center';
  },
  _setTextItemsSides: function () {
    const that = this;
    const indent = _Number(that._options.text.indent);
    if (indent > 0) {
      that._lineStart = that._maxSide;
      that._lineEnd = that._maxSide + indent;
      that._textPosition = that._lineEnd + (that.vertical ? 2 : that._textHeight / 2);
      that._maxBound = that._textPosition + (that.vertical ? that._textWidth : that._textHeight / 2);
    } else if (indent < 0) {
      that._lineStart = that._minSide;
      that._lineEnd = that._minSide + indent;
      that._textPosition = that._lineEnd - (that.vertical ? 2 : that._textHeight / 2);
      that._minBound = that._textPosition - (that.vertical ? that._textWidth : that._textHeight / 2);
    }
  },
  _getPositions: function () {
    const that = this;
    const startPosition = that._startPosition;
    const endPosition = that._endPosition;
    const space = that._space;
    const basePosition = that._basePosition;
    const actualPosition = that._actualPosition;
    let mainPosition1;
    let mainPosition2;
    let backPosition1;
    let backPosition2;
    if (startPosition < endPosition) {
      if (basePosition < actualPosition) {
        mainPosition1 = basePosition;
        mainPosition2 = actualPosition;
      } else {
        mainPosition1 = actualPosition;
        mainPosition2 = basePosition;
      }
      backPosition1 = mainPosition1 - space;
      backPosition2 = mainPosition2 + space;
    } else {
      if (basePosition > actualPosition) {
        mainPosition1 = basePosition;
        mainPosition2 = actualPosition;
      } else {
        mainPosition1 = actualPosition;
        mainPosition2 = basePosition;
      }
      backPosition1 = mainPosition1 + space;
      backPosition2 = mainPosition2 - space;
    }
    return {
      start: startPosition,
      end: endPosition,
      main1: mainPosition1,
      main2: mainPosition2,
      back1: backPosition1,
      back2: backPosition2
    };
  },
  _buildItemSettings: function (from, to) {
    const that = this;
    const side1 = that._minSide;
    const side2 = that._maxSide;
    const points = that.vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];
    return {
      points: points
    };
  },
  _updateTextPosition: function () {
    const that = this;
    that._text.attr(that.vertical ? {
      x: that._textPosition,
      y: that._actualPosition + that._textVerticalOffset
    } : {
      x: that._actualPosition,
      y: that._textPosition + that._textVerticalOffset
    });
  },
  _updateLinePosition: function () {
    const that = this;
    const actualPosition = that._actualPosition;
    let side1;
    let side2;
    let points;
    if (that.vertical) {
      if (that._basePosition >= actualPosition) {
        side1 = actualPosition;
        side2 = actualPosition + 2;
      } else {
        side1 = actualPosition - 2;
        side2 = actualPosition;
      }
      points = [that._lineStart, side1, that._lineStart, side2, that._lineEnd, side2, that._lineEnd, side1];
    } else {
      if (that._basePosition <= actualPosition) {
        side1 = actualPosition - 2;
        side2 = actualPosition;
      } else {
        side1 = actualPosition;
        side2 = actualPosition + 2;
      }
      points = [side1, that._lineStart, side1, that._lineEnd, side2, that._lineEnd, side2, that._lineStart];
    }
    that._line.attr({
      points: points
    }).sharp();
  },
  _getTooltipPosition: function () {
    const that = this;
    const crossCenter = (that._minSide + that._maxSide) / 2;
    const alongCenter = (that._basePosition + that._actualPosition) / 2;
    return that.vertical ? {
      x: crossCenter,
      y: alongCenter
    } : {
      x: alongCenter,
      y: crossCenter
    };
  },
  measure: function (layout) {
    const that = this;
    const size = _Number(that._options.size);
    const textIndent = _Number(that._options.text.indent);
    let minBound;
    let maxBound;
    let indent;
    that._measureText();
    if (that.vertical) {
      minBound = maxBound = layout.x;
      if (that._inverted) {
        maxBound = maxBound + size;
      } else {
        minBound = minBound - size;
      }
      if (that._hasText) {
        indent = that._textHeight / 2;
        if (textIndent > 0) {
          maxBound += textIndent + that._textWidth;
        }
        if (textIndent < 0) {
          minBound += textIndent - that._textWidth;
        }
      }
    } else {
      minBound = maxBound = layout.y;
      if (that._inverted) {
        maxBound = maxBound + size;
      } else {
        minBound = minBound - size;
      }
      if (that._hasText) {
        indent = that._textWidth / 2;
        if (textIndent > 0) {
          maxBound += textIndent + that._textHeight;
        }
        if (textIndent < 0) {
          minBound += textIndent - that._textHeight;
        }
      }
    }
    return {
      min: minBound,
      max: maxBound,
      indent: indent
    };
  }
});
/* eslint-disable spellcheck/spell-checker */

/***/ }),

/***/ 74425:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _base_range_container = _interopRequireDefault(__webpack_require__(84165));
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _Number = Number;
const _max = Math.max;
const LinearRangeContainer = _base_range_container.default.inherit({
  _processOptions: function () {
    const that = this;
    that.vertical = that._options.vertical;
    that._inner = that._outer = 0;
    if (that.vertical) {
      switch ((0, _utils.normalizeEnum)(that._options.horizontalOrientation)) {
        case 'left':
          that._inner = 1;
          break;
        case 'center':
          that._inner = that._outer = 0.5;
          break;
        default:
          that._outer = 1;
          break;
      }
    } else {
      switch ((0, _utils.normalizeEnum)(that._options.verticalOrientation)) {
        case 'top':
          that._inner = 1;
          break;
        case 'center':
          that._inner = that._outer = 0.5;
          break;
        default:
          that._outer = 1;
          break;
      }
    }
  },
  _isVisible: function () {
    return true;
  },
  _createRange: function (range, layout) {
    const that = this;
    const inner = that._inner;
    const outer = that._outer;
    const startPosition = that._translator.translate(range.start);
    const endPosition = that._translator.translate(range.end);
    let points;
    const x = layout.x;
    const y = layout.y;
    const startWidth = range.startWidth;
    const endWidth = range.endWidth;
    if (that.vertical) {
      points = [x - startWidth * inner, startPosition, x - endWidth * inner, endPosition, x + endWidth * outer, endPosition, x + startWidth * outer, startPosition];
    } else {
      points = [startPosition, y + startWidth * outer, startPosition, y - startWidth * inner, endPosition, y - endWidth * inner, endPosition, y + endWidth * outer];
    }
    return that._renderer.path(points, 'area');
  },
  measure: function (layout) {
    const result = {};
    let width;
    result.min = result.max = layout[this.vertical ? 'x' : 'y'];
    width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    result.min -= this._inner * width;
    result.max += this._outer * width;
    return result;
  }
});
var _default = exports["default"] = LinearRangeContainer;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 41802:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _base_theme_manager = __webpack_require__(43637);
const _extend = _extend2.extend;
const ThemeManager = _base_theme_manager.BaseThemeManager.inherit({
  ctor(options) {
    this.callBase.apply(this, arguments);
    this._subTheme = options.subTheme;
  },
  _initializeTheme: function () {
    const that = this;
    let subTheme;
    if (that._subTheme) {
      subTheme = _extend(true, {}, that._theme[that._subTheme], that._theme);
      _extend(true, that._theme, subTheme);
    }
    that.callBase.apply(that, arguments);
  }
});
var _default = exports["default"] = {
  ThemeManager
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 57298:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _wheel = __webpack_require__(765);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _index = __webpack_require__(39611);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EVENT_NS = 'gauge-tooltip';
const TOOLTIP_HIDE_DELAY = 100;
const ready = _ready_callbacks.default.add;
const Tracker = _class.default.inherit({
  ctor: function (parameters) {
    const that = this;
    that._element = parameters.renderer.g().attr({
      'class': 'dxg-tracker',
      stroke: 'none',
      'stroke-width': 0,
      fill: '#000000',
      opacity: 0.0001
    }).linkOn(parameters.container, {
      name: 'tracker',
      after: 'peripheral'
    });
    that._showTooltipCallback = function () {
      const target = that._tooltipEvent.target;
      const data_target = target['gauge-data-target'];
      const data_info = target['gauge-data-info'];
      that._targetEvent = null; //  Internal state must be reset strictly BEFORE callback is invoked
      if (that._tooltipTarget !== target) {
        const callback = result => {
          result && (that._tooltipTarget = target);
        };
        callback(that._callbacks['tooltip-show'](data_target, data_info, callback));
      }
    };
    that._hideTooltipCallback = function () {
      that._hideTooltipTimeout = null;
      that._targetEvent = null;
      if (that._tooltipTarget) {
        that._callbacks['tooltip-hide']();
        that._tooltipTarget = null;
      }
    };
    that._dispose = function () {
      clearTimeout(that._hideTooltipTimeout);
      that._showTooltipCallback = that._hideTooltipCallback = that._dispose = null;
    };
  },
  dispose: function () {
    const that = this;
    that._dispose();
    that.deactivate();
    that._element.off('.' + EVENT_NS);
    that._element.linkOff();
    that._element = that._context = that._callbacks = null;
    return that;
  },
  activate: function () {
    this._element.linkAppend();
    return this;
  },
  deactivate: function () {
    this._element.linkRemove().clear();
    return this;
  },
  attach: function (element, target, info) {
    element.data({
      'gauge-data-target': target,
      'gauge-data-info': info
    }).append(this._element);
    return this;
  },
  detach: function (element) {
    element.remove();
    return this;
  },
  setTooltipState: function (state) {
    const that = this;
    that._element.off('.' + EVENT_NS);
    if (state) {
      const data = {
        tracker: that
      };
      that._element.on((0, _index.addNamespace)([_pointer.default.move], EVENT_NS), data, handleTooltipMouseOver).on((0, _index.addNamespace)([_pointer.default.out], EVENT_NS), data, handleTooltipMouseOut).on((0, _index.addNamespace)([_pointer.default.down], EVENT_NS), data, handleTooltipTouchStart).on((0, _index.addNamespace)([_pointer.default.up], EVENT_NS), data, handleTooltipTouchEnd).on((0, _index.addNamespace)([_wheel.name], EVENT_NS), data, handleTooltipMouseWheel);
    }
    return that;
  },
  setCallbacks: function (callbacks) {
    this._callbacks = callbacks;
    return this;
  },
  _showTooltip: function (event) {
    const that = this;
    clearTimeout(that._hideTooltipTimeout);
    that._hideTooltipTimeout = null;
    if (that._tooltipTarget === event.target) {
      return;
    }
    that._tooltipEvent = event;
    that._showTooltipCallback();
  },
  _hideTooltip: function (delay) {
    const that = this;
    clearTimeout(that._hideTooltipTimeout);
    if (delay) {
      that._hideTooltipTimeout = setTimeout(that._hideTooltipCallback, delay);
    } else {
      that._hideTooltipCallback();
    }
  }
});
let active_touch_tooltip_tracker = null;
function handleTooltipMouseOver(event) {
  const tracker = event.data.tracker;
  tracker._x = event.pageX;
  tracker._y = event.pageY;
  tracker._showTooltip(event);
}
function handleTooltipMouseOut(event) {
  event.data.tracker._hideTooltip(TOOLTIP_HIDE_DELAY);
}
function handleTooltipMouseWheel(event) {
  event.data.tracker._hideTooltip();
}
function handleTooltipTouchStart(event) {
  const tracker = active_touch_tooltip_tracker = event.data.tracker;
  tracker._touch = true;
  handleTooltipMouseOver(event);
}
function handleTooltipTouchEnd() {
  active_touch_tooltip_tracker._touch = false;
}
function handleDocumentTooltipTouchStart(event) {
  const tracker = active_touch_tooltip_tracker;
  if (tracker && !tracker._touch) {
    tracker._hideTooltip(TOOLTIP_HIDE_DELAY);
    active_touch_tooltip_tracker = null;
  }
}
ready(function () {
  _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), (0, _index.addNamespace)([_pointer.default.down], EVENT_NS), handleDocumentTooltipTouchStart);
});
var _default = exports["default"] = Tracker;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 99630:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _linear_gauge = _interopRequireDefault(__webpack_require__(62987));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _linear_gauge.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 23696:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.createPalette = createPalette;
exports.currentPalette = currentPalette;
exports.generateColors = generateColors;
exports.getAccentColor = getAccentColor;
exports.getDiscretePalette = getDiscretePalette;
exports.getGradientPalette = getGradientPalette;
exports.getPalette = getPalette;
exports.registerPalette = registerPalette;
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
var _color = _interopRequireDefault(__webpack_require__(52752));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _floor = Math.floor;
const _ceil = Math.ceil;
const _isArray = Array.isArray;
const HIGHLIGHTING_STEP = 50;
const DEFAULT_PALETTE = 'material';
const officePalette = {
  simpleSet: ['#5f8b95', '#ba4d51', '#af8a53', '#955f71', '#859666', '#7e688c'],
  indicatingSet: ['#a3b97c', '#e1b676', '#ec7f83'],
  gradientSet: ['#5f8b95', '#ba4d51'],
  accentColor: '#ba4d51'
};
const palettes = {
  [DEFAULT_PALETTE]: {
    simpleSet: ['#1db2f5', '#f5564a', '#97c95c', '#ffc720', '#eb3573', '#a63db8'],
    indicatingSet: ['#97c95c', '#ffc720', '#f5564a'],
    gradientSet: ['#1db2f5', '#97c95c'],
    accentColor: '#1db2f5'
  },
  'office': officePalette,
  'harmony light': {
    simpleSet: ['#fcb65e', '#679ec5', '#ad79ce', '#7abd5c', '#e18e92', '#b6d623', '#b7abea', '#85dbd5'],
    indicatingSet: ['#b6d623', '#fcb65e', '#e18e92'],
    gradientSet: ['#7abd5c', '#fcb65e'],
    accentColor: '#679ec5'
  },
  'soft pastel': {
    simpleSet: ['#60a69f', '#78b6d9', '#6682bb', '#a37182', '#eeba69', '#90ba58', '#456c68', '#7565a4'],
    indicatingSet: ['#90ba58', '#eeba69', '#a37182'],
    gradientSet: ['#78b6d9', '#eeba69'],
    accentColor: '#60a69f'
  },
  'pastel': {
    simpleSet: ['#bb7862', '#70b3a1', '#bb626a', '#057d85', '#ab394b', '#dac599', '#153459', '#b1d2c6'],
    indicatingSet: ['#70b3a1', '#dac599', '#bb626a'],
    gradientSet: ['#bb7862', '#70b3a1'],
    accentColor: '#bb7862'
  },
  'bright': {
    simpleSet: ['#70c92f', '#f8ca00', '#bd1550', '#e97f02', '#9d419c', '#7e4452', '#9ab57e', '#36a3a6'],
    indicatingSet: ['#70c92f', '#f8ca00', '#bd1550'],
    gradientSet: ['#e97f02', '#f8ca00'],
    accentColor: '#e97f02'
  },
  'soft': {
    simpleSet: ['#cbc87b', '#9ab57e', '#e55253', '#7e4452', '#e8c267', '#565077', '#6babac', '#ad6082'],
    indicatingSet: ['#9ab57e', '#e8c267', '#e55253'],
    gradientSet: ['#9ab57e', '#e8c267'],
    accentColor: '#565077'
  },
  'ocean': {
    simpleSet: ['#75c099', '#acc371', '#378a8a', '#5fa26a', '#064970', '#38c5d2', '#00a7c6', '#6f84bb'],
    indicatingSet: ['#c8e394', '#7bc59d', '#397c8b'],
    gradientSet: ['#acc371', '#38c5d2'],
    accentColor: '#378a8a'
  },
  'vintage': {
    simpleSet: ['#dea484', '#efc59c', '#cb715e', '#eb9692', '#a85c4c', '#f2c0b5', '#c96374', '#dd956c'],
    indicatingSet: ['#ffe5c6', '#f4bb9d', '#e57660'],
    gradientSet: ['#efc59c', '#cb715e'],
    accentColor: '#cb715e'
  },
  'violet': {
    simpleSet: ['#d1a1d1', '#eeacc5', '#7b5685', '#7e7cad', '#a13d73', '#5b41ab', '#e287e2', '#689cc1'],
    indicatingSet: ['#d8e2f6', '#d0b2da', '#d56a8a'],
    gradientSet: ['#eeacc5', '#7b5685'],
    accentColor: '#7b5685'
  },
  // generic color schemes related palettes
  'carmine': {
    simpleSet: ['#fb7764', '#73d47f', '#fed85e', '#d47683', '#dde392', '#757ab2'],
    indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
    gradientSet: ['#fb7764', '#73d47f'],
    accentColor: '#f05b41'
  },
  'dark moon': {
    simpleSet: ['#4ddac1', '#f4c99a', '#80dd9b', '#f998b3', '#4aaaa0', '#a5aef1'],
    indicatingSet: ['#59d8a4', '#f0ad4e', '#f9517e'],
    gradientSet: ['#4ddac1', '#f4c99a'],
    accentColor: '#3debd3'
  },
  'soft blue': {
    simpleSet: ['#7ab8eb', '#97da97', '#facb86', '#e78683', '#839bda', '#4db7be'],
    indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
    gradientSet: ['#7ab8eb', '#97da97'],
    accentColor: '#7ab8eb'
  },
  'dark violet': {
    simpleSet: ['#9c63ff', '#64c064', '#eead51', '#d2504b', '#4b6bbf', '#2da7b0'],
    indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
    gradientSet: ['#9c63ff', '#64c064'],
    accentColor: '#9c63ff'
  },
  'green mist': {
    simpleSet: ['#3cbab2', '#8ed962', '#5b9d95', '#efcc7c', '#f1929f', '#4d8dab'],
    indicatingSet: ['#72d63c', '#ffc852', '#f74a5e'],
    gradientSet: ['#3cbab2', '#8ed962'],
    accentColor: '#3cbab2'
  }
};
let currentPaletteName;
function currentPalette(name) {
  if (name === undefined) {
    return currentPaletteName || DEFAULT_PALETTE;
  } else {
    name = (0, _utils.normalizeEnum)(name);
    currentPaletteName = name in palettes ? name : undefined;
  }
}
function generateColors(palette, count) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    keepLastColorInEnd: false
  };
  options.type = options.baseColorSet;
  options.extensionMode = options.paletteExtensionMode;
  return createPalette(palette, options).generateColors(count);
}
function getPalette(palette, parameters) {
  parameters = parameters || {};
  palette = palette || (currentPaletteName === undefined ? parameters.themeDefault : currentPalette());
  let result;
  const type = parameters.type;
  if (_isArray(palette)) {
    return palette.slice(0);
  } else {
    if ((0, _type.isString)(palette)) {
      result = palettes[(0, _utils.normalizeEnum)(palette)];
    }
    if (!result) {
      result = palettes[currentPalette()];
    }
  }
  return type ? result[type].slice(0) : result;
}
function registerPalette(name, palette) {
  const item = {};
  let paletteName;
  if (_isArray(palette)) {
    item.simpleSet = palette.slice(0);
  } else if (palette) {
    item.simpleSet = _isArray(palette.simpleSet) ? palette.simpleSet.slice(0) : undefined;
    item.indicatingSet = _isArray(palette.indicatingSet) ? palette.indicatingSet.slice(0) : undefined;
    item.gradientSet = _isArray(palette.gradientSet) ? palette.gradientSet.slice(0) : undefined;
    item.accentColor = palette.accentColor;
  }
  if (!item.accentColor) {
    item.accentColor = item.simpleSet && item.simpleSet[0];
  }
  if (item.simpleSet || item.indicatingSet || item.gradientSet) {
    paletteName = (0, _utils.normalizeEnum)(name);
    (0, _extend.extend)(palettes[paletteName] = palettes[paletteName] || {}, item);
  }
}
function getAccentColor(palette, themeDefault) {
  palette = getPalette(palette, {
    themeDefault
  });
  return palette.accentColor || palette[0];
}
function RingBuf(buf) {
  let ind = 0;
  this.next = function () {
    const res = buf[ind++];
    if (ind === buf.length) {
      this.reset();
    }
    return res;
  };
  this.reset = function () {
    ind = 0;
  };
}
function getAlternateColorsStrategy(palette, parameters) {
  const stepHighlight = parameters.useHighlight ? HIGHLIGHTING_STEP : 0;
  const paletteSteps = new RingBuf([0, stepHighlight, -stepHighlight]);
  let currentPalette = [];
  function reset() {
    const step = paletteSteps.next();
    currentPalette = step ? getAlteredPalette(palette, step) : palette.slice(0);
  }
  return {
    getColor: function (index) {
      const color = currentPalette[index % palette.length];
      if (index % palette.length === palette.length - 1) {
        reset();
      }
      return color;
    },
    generateColors: function (count) {
      const colors = [];
      count = count || parameters.count;
      for (let i = 0; i < count; i++) {
        colors.push(this.getColor(i));
      }
      return colors;
    },
    reset: function () {
      paletteSteps.reset();
      reset();
    }
  };
}
function getExtrapolateColorsStrategy(palette, parameters) {
  function convertColor(color, cycleIndex, cycleCount) {
    const hsl = new _color.default(color).hsl;
    let l = hsl.l / 100;
    const diapason = cycleCount - 1 / cycleCount;
    let minL = l - diapason * 0.5;
    let maxL = l + diapason * 0.5;
    const cycleMiddle = (cycleCount - 1) / 2;
    const cycleDiff = cycleIndex - cycleMiddle;
    if (minL < Math.min(0.5, l * 0.9)) {
      minL = Math.min(0.5, l * 0.9);
    }
    if (maxL > Math.max(0.8, l + (1 - l) * 0.15)) {
      maxL = Math.max(0.8, l + (1 - l) * 0.15);
    }
    if (cycleDiff < 0) {
      l = l - (minL - l) * cycleDiff / cycleMiddle;
    } else {
      l = l + (maxL - l) * (cycleDiff / cycleMiddle);
    }
    hsl.l = l * 100;
    return _color.default.prototype.fromHSL(hsl).toHex();
  }
  return {
    getColor: function (index, count) {
      const paletteCount = palette.length;
      const cycles = _floor((count - 1) / paletteCount + 1);
      const color = palette[index % paletteCount];
      if (cycles > 1) {
        return convertColor(color, _floor(index / paletteCount), cycles);
      }
      return color;
    },
    generateColors: function (count) {
      const colors = [];
      count = count || parameters.count;
      for (let i = 0; i < count; i++) colors.push(this.getColor(i, count));
      return colors;
    },
    reset: function () {}
  };
}
function getColorMixer(palette, parameters) {
  const paletteCount = palette.length;
  let extendedPalette = [];
  function distributeColors(count, colorsCount, startIndex, distribution) {
    const groupSize = Math.floor(count / colorsCount);
    let extraItems = count - colorsCount * groupSize;
    let i = startIndex;
    let middleIndex;
    let size;
    while (i < startIndex + count) {
      size = groupSize;
      if (extraItems > 0) {
        size += 1;
        extraItems--;
      }
      middleIndex = size > 2 ? Math.floor(size / 2) : 0;
      distribution.push(i + middleIndex);
      i += size;
    }
    return distribution.sort(function (a, b) {
      return a - b;
    });
  }
  function getColorAndDistance(arr, startIndex, count) {
    startIndex = (count + startIndex) % count;
    let distance = 0;
    for (let i = startIndex; i < count * 2; i += 1) {
      const index = (count + i) % count;
      if (arr[index]) {
        return [arr[index], distance];
      }
      distance++;
    }
  }
  function blendColors(paletteWithEmptyColors, paletteLength) {
    for (let i = 0; i < paletteLength; i++) {
      const color = paletteWithEmptyColors[i];
      if (!color) {
        let color1 = paletteWithEmptyColors[i - 1];
        if (!color1) {
          continue;
        } else {
          const c2 = getColorAndDistance(paletteWithEmptyColors, i, paletteLength);
          const color2 = new _color.default(c2[0]);
          color1 = new _color.default(color1);
          for (let j = 0; j < c2[1]; j++, i++) {
            paletteWithEmptyColors[i] = color1.blend(color2, (j + 1) / (c2[1] + 1)).toHex();
          }
        }
      }
    }
    return paletteWithEmptyColors;
  }
  function extendPalette(count) {
    if (count <= paletteCount) {
      return palette;
    }
    let result = [];
    const colorInGroups = paletteCount - 2;
    let currentColorIndex = 0;
    let cleanColorIndices = [];
    if (parameters.keepLastColorInEnd) {
      cleanColorIndices = distributeColors(count - 2, colorInGroups, 1, [0, count - 1]);
    } else {
      cleanColorIndices = distributeColors(count - 1, paletteCount - 1, 1, [0]);
    }
    for (let i = 0; i < count; i++) {
      if (cleanColorIndices.indexOf(i) > -1) {
        result[i] = palette[currentColorIndex++];
      }
    }
    result = blendColors(result, count);
    return result;
  }
  return {
    getColor: function (index, count) {
      count = count || parameters.count || paletteCount;
      if (extendedPalette.length !== count) {
        extendedPalette = extendPalette(count);
      }
      return extendedPalette[index % count];
    },
    generateColors: function (count, repeat) {
      count = count || parameters.count || paletteCount;
      if (repeat && count > paletteCount) {
        const colors = extendPalette(paletteCount);
        for (let i = 0; i < count - paletteCount; i++) {
          colors.push(colors[i]);
        }
        return colors;
      } else {
        return paletteCount > 0 ? extendPalette(count).slice(0, count) : [];
      }
    },
    reset: function () {}
  };
}
function createPalette(palette, parameters, themeDefaultPalette) {
  const paletteObj = {
    dispose() {
      this._extensionStrategy = null;
    },
    getNextColor(count) {
      return this._extensionStrategy.getColor(this._currentColor++, count);
    },
    generateColors(count, parameters) {
      return this._extensionStrategy.generateColors(count, (parameters || {}).repeat);
    },
    reset() {
      this._currentColor = 0;
      this._extensionStrategy.reset();
      return this;
    }
  };
  parameters = parameters || {};
  const extensionMode = (parameters.extensionMode || '').toLowerCase();
  const colors = getPalette(palette, {
    type: parameters.type || 'simpleSet',
    themeDefault: themeDefaultPalette
  });
  if (extensionMode === 'alternate') {
    paletteObj._extensionStrategy = getAlternateColorsStrategy(colors, parameters);
  } else if (extensionMode === 'extrapolate') {
    paletteObj._extensionStrategy = getExtrapolateColorsStrategy(colors, parameters);
  } else {
    paletteObj._extensionStrategy = getColorMixer(colors, parameters);
  }
  paletteObj.reset();
  return paletteObj;
}
function getAlteredPalette(originalPalette, step) {
  const palette = [];
  let i;
  const ii = originalPalette.length;
  for (i = 0; i < ii; ++i) {
    palette.push(getNewColor(originalPalette[i], step));
  }
  return palette;
}
function getNewColor(currentColor, step) {
  let newColor = new _color.default(currentColor).alter(step);
  const lightness = getLightness(newColor);
  if (lightness > 200 || lightness < 55) {
    newColor = new _color.default(currentColor).alter(-step / 2);
  }
  return newColor.toHex();
}
function getLightness(color) {
  return color.r * 0.3 + color.g * 0.59 + color.b * 0.11;
}
function getDiscretePalette(source, size, themeDefaultPalette) {
  const palette = size > 0 ? createDiscreteColors(getPalette(source, {
    type: 'gradientSet',
    themeDefault: themeDefaultPalette
  }), size) : [];
  return {
    getColor: function (index) {
      return palette[index] || null;
    }
  };
}
function createDiscreteColors(source, count) {
  const colorCount = count - 1;
  const sourceCount = source.length - 1;
  const colors = [];
  const gradient = [];
  let i;
  function addColor(pos) {
    const k = sourceCount * pos;
    const kl = _floor(k);
    const kr = _ceil(k);
    gradient.push(colors[kl].blend(colors[kr], k - kl).toHex());
  }
  for (i = 0; i <= sourceCount; ++i) {
    colors.push(new _color.default(source[i]));
  }
  if (colorCount > 0) {
    for (i = 0; i <= colorCount; ++i) {
      addColor(i / colorCount);
    }
  } else {
    addColor(0.5);
  }
  return gradient;
}
function getGradientPalette(source, themeDefaultPalette) {
  // TODO: Looks like some new set is going to be added
  const palette = getPalette(source, {
    type: 'gradientSet',
    themeDefault: themeDefaultPalette
  });
  const color1 = new _color.default(palette[0]);
  const color2 = new _color.default(palette[1]);
  return {
    getColor: function (ratio) {
      return 0 <= ratio && ratio <= 1 ? color1.blend(color2, ratio).toHex() : null;
    }
  };
}

/***/ }),

/***/ 72111:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_pie_chart = _interopRequireDefault(__webpack_require__(88647));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_pie_chart.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 80919:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_polar_chart = _interopRequireDefault(__webpack_require__(86139));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _m_polar_chart.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82879:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _range_selector = _interopRequireDefault(__webpack_require__(91009));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _range_selector.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 11378:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.utils = exports.formatValue = exports.consts = exports.HEIGHT_COMPACT_MODE = void 0;
var _smart_formatter = __webpack_require__(41583);
var _type = __webpack_require__(35922);
const HEIGHT_COMPACT_MODE = exports.HEIGHT_COMPACT_MODE = 24;
const POINTER_SIZE = 4;
const EMPTY_SLIDER_MARKER_TEXT = '. . .';
const utils = exports.utils = {
  trackerSettings: {
    fill: 'grey',
    stroke: 'grey',
    opacity: 0.0001
  },
  animationSettings: {
    duration: 250
  }
};
const consts = exports.consts = {
  emptySliderMarkerText: EMPTY_SLIDER_MARKER_TEXT,
  pointerSize: POINTER_SIZE
};
const formatValue = function (value, formatOptions, tickIntervalsInfo, valueType, type, logarithmBase) {
  const formatObject = {
    value: value,
    valueText: (0, _smart_formatter.smartFormatter)(value, {
      labelOptions: formatOptions,
      ticks: tickIntervalsInfo ? tickIntervalsInfo.ticks : [],
      tickInterval: tickIntervalsInfo ? tickIntervalsInfo.tickInterval : undefined,
      dataType: valueType,
      type: type,
      logarithmBase: logarithmBase
    })
  };
  return String((0, _type.isFunction)(formatOptions.customizeText) ? formatOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText);
};
exports.formatValue = formatValue;

/***/ }),

/***/ 91009:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _type2 = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _math = __webpack_require__(60810);
var _range = __webpack_require__(21177);
var _base_axis = __webpack_require__(41278);
var _parse_utils = __webpack_require__(8587);
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _common = __webpack_require__(11378);
var _sliders_controller = __webpack_require__(56481);
var _tracker = __webpack_require__(43695);
var _range_view = __webpack_require__(25104);
var _series_data_source = __webpack_require__(79302);
var _tick_generator = __webpack_require__(45971);
var _axes_constants = _interopRequireDefault(__webpack_require__(53805));
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _loading_indicator = __webpack_require__(64758);
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _max = Math.max;
const _ceil = Math.ceil;
const _floor = Math.floor;
const START_VALUE = 'startValue';
const END_VALUE = 'endValue';
const DATETIME = 'datetime';
const VALUE = 'value';
const DISCRETE = 'discrete';
const SEMIDISCRETE = 'semidiscrete';
const STRING = 'string';
const VALUE_CHANGED = VALUE + 'Changed';
const CONTAINER_BACKGROUND_COLOR = 'containerBackgroundColor';
const SLIDER_MARKER = 'sliderMarker';
const OPTION_BACKGROUND = 'background';
const LOGARITHMIC = 'logarithmic';
const KEEP = 'keep';
const SHIFT = 'shift';
const RESET = 'reset';
const INVISIBLE_POS = -1000;
const SEMIDISCRETE_GRID_SPACING_FACTOR = 50;
const DEFAULT_AXIS_DIVISION_FACTOR = 30;
const DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;
const logarithmBase = 10;
function calculateMarkerHeight(renderer, value, sliderMarkerOptions) {
  const formattedText = value === undefined ? _common.consts.emptySliderMarkerText : (0, _common.formatValue)(value, sliderMarkerOptions);
  const textBBox = getTextBBox(renderer, formattedText, sliderMarkerOptions.font);
  return _ceil(textBBox.height) + 2 * sliderMarkerOptions.paddingTopBottom + _common.consts.pointerSize;
}
function calculateScaleLabelHalfWidth(renderer, value, scaleOptions, tickIntervalsInfo) {
  const formattedText = (0, _common.formatValue)(value, scaleOptions.label, tickIntervalsInfo, scaleOptions.valueType, scaleOptions.type, scaleOptions.logarithmBase);
  const textBBox = getTextBBox(renderer, formattedText, scaleOptions.label.font);
  return _ceil(textBBox.width / 2);
}
function calculateIndents(renderer, scale, sliderMarkerOptions, indentOptions, tickIntervalsInfo) {
  let leftMarkerHeight;
  let leftScaleLabelWidth = 0;
  let rightScaleLabelWidth = 0;
  let rightMarkerHeight;
  let placeholderWidthLeft;
  let placeholderWidthRight;
  let placeholderHeight;
  const ticks = scale.type === 'semidiscrete' ? scale.customTicks : tickIntervalsInfo.ticks;
  let startTickValue;
  let endTickValue;
  indentOptions = indentOptions || {};
  placeholderWidthLeft = indentOptions.left;
  placeholderWidthRight = indentOptions.right;
  placeholderHeight = sliderMarkerOptions.placeholderHeight;
  if (sliderMarkerOptions.visible) {
    leftMarkerHeight = calculateMarkerHeight(renderer, scale.startValue, sliderMarkerOptions);
    rightMarkerHeight = calculateMarkerHeight(renderer, scale.endValue, sliderMarkerOptions);
    if (placeholderHeight === undefined) {
      placeholderHeight = _max(leftMarkerHeight, rightMarkerHeight);
    }
  }
  if (scale.label.visible) {
    startTickValue = (0, _type2.isDefined)(scale.startValue) ? ticks[0] : undefined;
    endTickValue = (0, _type2.isDefined)(scale.endValue) ? ticks[ticks.length - 1] : undefined;
    leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, startTickValue, scale, tickIntervalsInfo);
    rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, endTickValue, scale, tickIntervalsInfo);
  }
  placeholderWidthLeft = placeholderWidthLeft !== undefined ? placeholderWidthLeft : leftScaleLabelWidth;
  placeholderWidthRight = (placeholderWidthRight !== undefined ? placeholderWidthRight : rightScaleLabelWidth) || 1; // T240698

  return {
    left: placeholderWidthLeft,
    right: placeholderWidthRight,
    top: placeholderHeight || 0,
    bottom: 0
  };
}
function calculateValueType(firstValue, secondValue) {
  const typeFirstValue = (0, _type2.type)(firstValue);
  const typeSecondValue = (0, _type2.type)(secondValue);
  const validType = function (type) {
    return typeFirstValue === type || typeSecondValue === type;
  };
  return validType('date') ? DATETIME : validType('number') ? 'numeric' : validType(STRING) ? STRING : '';
}
function showScaleMarkers(scaleOptions) {
  return scaleOptions.valueType === DATETIME && scaleOptions.marker.visible;
}
function updateTranslatorRangeInterval(translatorRange, scaleOptions) {
  let intervalX = scaleOptions.minorTickInterval || scaleOptions.tickInterval;
  if (scaleOptions.valueType === 'datetime') {
    intervalX = _date.default.dateToMilliseconds(intervalX);
  }
  translatorRange.addRange({
    interval: intervalX
  });
}
function checkLogarithmicOptions(options, defaultLogarithmBase, incidentOccurred) {
  if (!options) {
    return;
  }
  const logarithmBase = options.logarithmBase;
  if (options.type === LOGARITHMIC && logarithmBase <= 0 || logarithmBase && !(0, _type2.isNumeric)(logarithmBase)) {
    options.logarithmBase = defaultLogarithmBase;
    incidentOccurred('E2104');
  } else if (options.type !== LOGARITHMIC) {
    options.logarithmBase = undefined;
  }
}
function calculateScaleAreaHeight(renderer, scaleOptions, visibleMarkers, tickIntervalsInfo) {
  const labelScaleOptions = scaleOptions.label;
  const markerScaleOptions = scaleOptions.marker;
  const placeholderHeight = scaleOptions.placeholderHeight;
  const ticks = scaleOptions.type === 'semidiscrete' ? scaleOptions.customTicks : tickIntervalsInfo.ticks;
  const text = (0, _common.formatValue)(ticks[0], labelScaleOptions);
  if (placeholderHeight) {
    return placeholderHeight;
  } else {
    return (labelScaleOptions.visible ? labelScaleOptions.topIndent + getTextBBox(renderer, text, labelScaleOptions.font).height : 0) + (visibleMarkers ? markerScaleOptions.topIndent + markerScaleOptions.separatorHeight : 0);
  }
}
function getMinorTickIntervalUnit(tickInterval, minorTickInterval, withCorrection) {
  let interval = _date.default.getDateUnitInterval(minorTickInterval);
  const majorUnit = _date.default.getDateUnitInterval(tickInterval);
  const idx = _date.default.dateUnitIntervals.indexOf(interval);
  if (withCorrection && interval === majorUnit && idx > 0) {
    interval = _date.default.dateUnitIntervals[idx - 1];
  }
  return interval;
}
function getNextTickInterval(tickInterval, minorTickInterval, isDateType) {
  if (!tickInterval) {
    tickInterval = minorTickInterval;
  } else {
    if (isDateType) {
      tickInterval = _date.default.getNextDateUnit(tickInterval);
    } else {
      tickInterval += minorTickInterval;
    }
  }
  return tickInterval;
}
function calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta) {
  const minorTickInterval = scaleOptions.minorTickInterval;
  let tickInterval = scaleOptions.tickInterval;
  let interval;
  const isDateType = scaleOptions.valueType === 'datetime';
  const gridSpacingFactor = scaleOptions.axisDivisionFactor || {};
  let tickCountByInterval;
  let tickCountByScreen;
  if (!tickInterval) {
    do {
      interval = getNextTickInterval(tickInterval, minorTickInterval, isDateType);
      if (tickInterval !== interval) {
        tickInterval = interval;
      } else {
        break;
      }
      if (isDateType) {
        interval = _date.default.dateToMilliseconds(tickInterval);
      }
      tickCountByInterval = _ceil((max - min) / interval);
      tickCountByScreen = _floor(screenDelta / (gridSpacingFactor[tickInterval] || SEMIDISCRETE_GRID_SPACING_FACTOR)) || 1;
    } while (interval && tickCountByInterval > tickCountByScreen);
  }
  return {
    tickInterval: tickInterval,
    minorTickInterval: minorTickInterval,
    bounds: {
      minVisible: min,
      maxVisible: max
    },
    ticks: []
  };
}
function updateTickIntervals(scaleOptions, screenDelta, incidentOccurred, range) {
  let result;
  const min = (0, _type2.isDefined)(range.minVisible) ? range.minVisible : range.min;
  const max = (0, _type2.isDefined)(range.maxVisible) ? range.maxVisible : range.max;
  const categoriesInfo = scaleOptions._categoriesInfo;
  let ticksInfo;
  let length;
  const bounds = {};
  if (scaleOptions.type === SEMIDISCRETE) {
    result = calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta);
  } else {
    ticksInfo = (0, _tick_generator.tickGenerator)({
      axisType: scaleOptions.type,
      dataType: scaleOptions.valueType,
      logBase: scaleOptions.logarithmBase,
      allowNegatives: true,
      linearThreshold: Math.abs(scaleOptions.linearThreshold || 0),
      axisDivisionFactor: scaleOptions.axisDivisionFactor,
      minorAxisDivisionFactor: scaleOptions.minorAxisDivisionFactor,
      calculateMinors: true,
      allowDecimals: scaleOptions.allowDecimals,
      endOnTick: scaleOptions.endOnTick,
      incidentOccurred: incidentOccurred,
      rangeIsEmpty: range.isEmpty()
    })({
      min: min,
      max: max,
      categories: (0, _type2.isDefined)(categoriesInfo) ? categoriesInfo.categories : []
    }, screenDelta, scaleOptions.tickInterval, scaleOptions.forceUserTickInterval, undefined, scaleOptions.minorTickInterval, scaleOptions.minorTickCount);
    length = ticksInfo.ticks.length;
    bounds.minVisible = ticksInfo.ticks[0] < min ? ticksInfo.ticks[0] : min;
    bounds.maxVisible = ticksInfo.ticks[length - 1] > max ? ticksInfo.ticks[length - 1] : max;
    result = {
      tickInterval: ticksInfo.tickInterval,
      minorTickInterval: scaleOptions.minorTickInterval === 0 ? 0 : ticksInfo.minorTickInterval,
      bounds: bounds,
      ticks: ticksInfo.ticks
    };
  }
  return result;
}
function getFirstDayOfWeek(options) {
  var _options$workWeek;
  return (_options$workWeek = options.workWeek) === null || _options$workWeek === void 0 ? void 0 : _options$workWeek[0];
}
function calculateTranslatorRange(seriesDataSource, scaleOptions) {
  let minValue;
  let maxValue;
  let inverted = false;
  let startValue = scaleOptions.startValue;
  let endValue = scaleOptions.endValue;
  let categories;
  let categoriesInfo;
  // TODO: There should be something like "seriesDataSource.getArgumentRange()"
  let translatorRange = seriesDataSource ? seriesDataSource.getBoundRange().arg : new _range.Range();
  let rangeForCategories;
  const isDate = scaleOptions.valueType === 'datetime';
  const firstDayOfWeek = getFirstDayOfWeek(scaleOptions);
  const minRange = scaleOptions.minRange;
  if (scaleOptions.type === DISCRETE) {
    rangeForCategories = new _range.Range({
      minVisible: startValue,
      maxVisible: endValue
    });
    rangeForCategories.addRange(translatorRange);
    translatorRange = rangeForCategories;
    categories = seriesDataSource ? seriesDataSource.argCategories : scaleOptions.categories || startValue && endValue && [startValue, endValue];
    categories = categories || [];
    scaleOptions._categoriesInfo = categoriesInfo = (0, _utils.getCategoriesInfo)(categories, startValue, endValue);
  }
  if (scaleOptions.type === SEMIDISCRETE) {
    startValue = scaleOptions.startValue = correctValueByInterval(scaleOptions.startValue, isDate, minRange, firstDayOfWeek);
    endValue = scaleOptions.endValue = correctValueByInterval(scaleOptions.endValue, isDate, minRange, firstDayOfWeek);
    translatorRange.minVisible = correctValueByInterval(translatorRange.minVisible, isDate, minRange, firstDayOfWeek);
    translatorRange.maxVisible = correctValueByInterval(translatorRange.maxVisible, isDate, minRange, firstDayOfWeek);
    translatorRange.min = correctValueByInterval(translatorRange.min, isDate, minRange, firstDayOfWeek);
    translatorRange.max = correctValueByInterval(translatorRange.max, isDate, minRange, firstDayOfWeek);
  }
  if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {
    inverted = categoriesInfo ? categoriesInfo.inverted : startValue > endValue;
    minValue = categoriesInfo ? categoriesInfo.start : inverted ? endValue : startValue;
    maxValue = categoriesInfo ? categoriesInfo.end : inverted ? startValue : endValue;
  } else if ((0, _type2.isDefined)(startValue) || (0, _type2.isDefined)(endValue)) {
    minValue = startValue;
    maxValue = endValue;
  } else if (categoriesInfo) {
    minValue = categoriesInfo.start;
    maxValue = categoriesInfo.end;
  }
  translatorRange.addRange({
    invert: inverted,
    min: minValue,
    max: maxValue,
    minVisible: minValue,
    maxVisible: maxValue,
    dataType: scaleOptions.valueType
  });
  translatorRange.addRange({
    categories: !seriesDataSource ? categories : undefined,
    base: scaleOptions.logarithmBase,
    axisType: scaleOptions.type,
    dataType: scaleOptions.valueType
  });
  seriesDataSource && translatorRange.sortCategories(categories);
  return translatorRange;
}
function startEndNotDefined(start, end) {
  return !(0, _type2.isDefined)(start) || !(0, _type2.isDefined)(end);
}
function getTextBBox(renderer, text, fontOptions) {
  const textElement = renderer.text(text, INVISIBLE_POS, INVISIBLE_POS).css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);
  const textBBox = textElement.getBBox();
  textElement.remove();
  return textBBox;
}
function getDateMarkerVisibilityChecker(screenDelta) {
  return function (isDateScale, isMarkerVisible, min, max, tickInterval) {
    if (isMarkerVisible && isDateScale) {
      if (!(0, _type2.isDefined)(tickInterval) || tickInterval.years || tickInterval.months >= 6 || screenDelta / SEMIDISCRETE_GRID_SPACING_FACTOR < _ceil((max - min) / _date.default.dateToMilliseconds('year')) + 1) {
        isMarkerVisible = false;
      }
    }
    return isMarkerVisible;
  };
}
function updateScaleOptions(scaleOptions, seriesDataSource, translatorRange, tickIntervalsInfo, checkDateMarkerVisibility) {
  let bounds;
  let isEmptyInterval;
  const categoriesInfo = scaleOptions._categoriesInfo;
  let intervals;
  const isDateTime = scaleOptions.valueType === DATETIME;
  if (seriesDataSource && !seriesDataSource.isEmpty() && !translatorRange.isEmpty()) {
    bounds = tickIntervalsInfo.bounds;
    translatorRange.addRange(bounds);
    scaleOptions.startValue = translatorRange.invert ? bounds.maxVisible : bounds.minVisible;
    scaleOptions.endValue = translatorRange.invert ? bounds.minVisible : bounds.maxVisible;
  }
  scaleOptions.marker.visible = checkDateMarkerVisibility(isDateTime && scaleOptions.type.indexOf(DISCRETE) === -1, scaleOptions.marker.visible, scaleOptions.startValue, scaleOptions.endValue, tickIntervalsInfo.tickInterval);
  if (categoriesInfo) {
    scaleOptions.startValue = categoriesInfo.start;
    scaleOptions.endValue = categoriesInfo.end;
  }
  if (scaleOptions.type.indexOf(DISCRETE) === -1) {
    isEmptyInterval = (0, _type2.isDate)(scaleOptions.startValue) && (0, _type2.isDate)(scaleOptions.endValue) && scaleOptions.startValue.getTime() === scaleOptions.endValue.getTime() || scaleOptions.startValue === scaleOptions.endValue;
  }
  scaleOptions.isEmpty = startEndNotDefined(scaleOptions.startValue, scaleOptions.endValue) || isEmptyInterval;
  if (scaleOptions.isEmpty) {
    scaleOptions.startValue = scaleOptions.endValue = undefined;
  } else {
    scaleOptions.minorTickInterval = tickIntervalsInfo.minorTickInterval;
    scaleOptions.tickInterval = tickIntervalsInfo.tickInterval;
    if (isDateTime && (!(0, _type2.isDefined)(scaleOptions.label.format) || scaleOptions.type === SEMIDISCRETE && scaleOptions.minorTickInterval !== scaleOptions.tickInterval)) {
      if (scaleOptions.type === DISCRETE) {
        scaleOptions.label.format = _format_helper.default.getDateFormatByTicks(tickIntervalsInfo.ticks);
      } else {
        if (!scaleOptions.marker.visible) {
          scaleOptions.label.format = _format_helper.default.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.tickInterval);
        } else {
          scaleOptions.label.format = _date.default.getDateFormatByTickInterval(scaleOptions.tickInterval);
        }
      }
    }
  }
  if (scaleOptions.type === SEMIDISCRETE) {
    intervals = getIntervalCustomTicks(scaleOptions);
    scaleOptions.customMinorTicks = intervals.altIntervals;
    scaleOptions.customTicks = intervals.intervals;
    scaleOptions.customBoundTicks = [scaleOptions.customTicks[0]];
  }
}
function prepareScaleOptions(scaleOption, calculatedValueType, incidentOccurred, containerColor) {
  let parsedValue = 0;
  let valueType = (0, _parse_utils.correctValueType)((0, _utils.normalizeEnum)(scaleOption.valueType));
  const validateStartEndValues = function (field, parser) {
    const messageToIncidentOccurred = field === START_VALUE ? 'start' : 'end';
    if ((0, _type2.isDefined)(scaleOption[field])) {
      parsedValue = parser(scaleOption[field]);
      if ((0, _type2.isDefined)(parsedValue)) {
        scaleOption[field] = parsedValue;
      } else {
        scaleOption[field] = undefined;
        incidentOccurred('E2202', [messageToIncidentOccurred]);
      }
    }
  };
  valueType = calculatedValueType || valueType;
  if (!valueType) {
    valueType = calculateValueType(scaleOption.startValue, scaleOption.endValue) || 'numeric';
  }
  if (valueType === STRING || scaleOption.categories) {
    scaleOption.type = DISCRETE;
    valueType = STRING;
  }
  scaleOption.containerColor = containerColor;
  scaleOption.valueType = valueType;
  scaleOption.dataType = valueType;
  const parser = (0, _parse_utils.getParser)(valueType);
  validateStartEndValues(START_VALUE, parser);
  validateStartEndValues(END_VALUE, parser);
  checkLogarithmicOptions(scaleOption, logarithmBase, incidentOccurred);
  if (!scaleOption.type) {
    scaleOption.type = 'continuous';
  }
  scaleOption.parser = parser;
  if (scaleOption.type === SEMIDISCRETE) {
    scaleOption.minorTick.visible = false;
    scaleOption.minorTickInterval = scaleOption.minRange;
    scaleOption.marker.visible = false;
    scaleOption.maxRange = undefined;
  }
  scaleOption.forceUserTickInterval |= (0, _type2.isDefined)(scaleOption.tickInterval) && !(0, _type2.isDefined)(scaleOption.axisDivisionFactor);
  scaleOption.axisDivisionFactor = (0, _type2.isDefined)(scaleOption.axisDivisionFactor) ? scaleOption.axisDivisionFactor : DEFAULT_AXIS_DIVISION_FACTOR;
  scaleOption.minorAxisDivisionFactor = (0, _type2.isDefined)(scaleOption.minorAxisDivisionFactor) ? scaleOption.minorAxisDivisionFactor : DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
  return scaleOption;
}
function correctValueByInterval(value, isDate, interval, firstDayOfWeek) {
  if ((0, _type2.isDefined)(value)) {
    value = isDate ? _date.default.correctDateWithUnitBeginning(new Date(value), interval, null, firstDayOfWeek) : (0, _math.adjust)(_floor((0, _math.adjust)(value / interval)) * interval);
  }
  return value;
}
function getIntervalCustomTicks(options) {
  let min = options.startValue;
  let max = options.endValue;
  const isDate = options.valueType === 'datetime';
  const firstDayOfWeek = getFirstDayOfWeek(options);
  const tickInterval = options.tickInterval;
  const res = {
    intervals: []
  };
  if (!(0, _type2.isDefined)(min) || !(0, _type2.isDefined)(max)) {
    return res;
  }
  res.intervals = _date.default.getSequenceByInterval(min, max, options.minorTickInterval);
  if (tickInterval !== options.minorTickInterval) {
    res.altIntervals = res.intervals;
    min = correctValueByInterval(min, isDate, tickInterval, firstDayOfWeek);
    max = correctValueByInterval(max, isDate, tickInterval, firstDayOfWeek);
    res.intervals = _date.default.getSequenceByInterval(min, max, tickInterval);
    res.intervals[0] = res.altIntervals[0];
  }
  return res;
}
function getPrecisionForSlider(startValue, endValue, screenDelta) {
  const d = Math.abs(endValue - startValue) / screenDelta;
  const tail = d - _floor(d);
  return tail > 0 ? _ceil(Math.abs((0, _math.adjust)((0, _utils.getLog)(tail, 10)))) : 0;
}
const dxRangeSelector = _m_base_widget.default.inherit({
  _toggleParentsScrollSubscription() {},
  _eventsMap: {
    'onValueChanged': {
      name: VALUE_CHANGED
    }
  },
  _rootClassPrefix: 'dxrs',
  _rootClass: 'dxrs-range-selector',
  _dataIsReady: function () {
    return this._dataIsLoaded();
  },
  _initialChanges: ['DATA_SOURCE', 'VALUE'],
  _themeDependentChanges: ['MOSTLY_TOTAL'],
  _themeSection: 'rangeSelector',
  _fontFields: ['scale.label.font', 'sliderMarker.font'],
  _setDeprecatedOptions() {
    this.callBase();
    (0, _extend.extend)(this._deprecatedOptions, {
      'behavior.callValueChanged': {
        since: '23.1',
        message: 'Use the "behavior.valueChangeMode" property instead'
      },
      'scale.aggregateByCategory': {
        since: '23.1',
        message: 'Use the aggregation.enabled property'
      }
    });
  },
  _initCore: function () {
    const that = this;
    const renderer = that._renderer;
    const root = renderer.root;

    // TODO: Move it to the SlidersEventManager
    root.css({
      'touch-action': 'pan-y'
    });

    // RangeContainer
    that._clipRect = renderer.clipRect(); // TODO: Try to remove it
    // TODO: Groups could be created by the corresponding components
    const rangeViewGroup = renderer.g().attr({
      'class': 'dxrs-view'
    }).append(root);
    const slidersGroup = renderer.g().attr({
      'class': 'dxrs-slidersContainer',
      'clip-path': that._clipRect.id
    }).append(root);
    const scaleGroup = renderer.g().attr({
      'class': 'dxrs-scale',
      'clip-path': that._clipRect.id
    }).append(root);
    const labelsAxesGroup = renderer.g().attr({
      'class': 'dxrs-scale-elements',
      'clip-path': that._clipRect.id
    }).append(root);
    const scaleBreaksGroup = renderer.g().attr({
      'class': 'dxrs-scale-breaks'
    }).append(root);
    const trackersGroup = renderer.g().attr({
      'class': 'dxrs-trackers'
    }).append(root);
    that._axis = new AxisWrapper({
      renderer: renderer,
      root: scaleGroup,
      scaleBreaksGroup: scaleBreaksGroup,
      labelsAxesGroup: labelsAxesGroup,
      updateSelectedRange: function (range, e) {
        that.setValue((0, _utils.convertVisualRangeObject)(range), e);
      },
      incidentOccurred: that._incidentOccurred
    });
    that._rangeView = new _range_view.RangeView({
      renderer: renderer,
      root: rangeViewGroup,
      translator: that._axis.getTranslator()
    });
    that._slidersController = new _sliders_controller.SlidersController({
      renderer: renderer,
      root: slidersGroup,
      trackersGroup: trackersGroup,
      updateSelectedRange: function (range, lastSelectedRange, e) {
        if (!that._rangeOption) {
          that.option(VALUE, (0, _utils.convertVisualRangeObject)(range, (0, _type2.isPlainObject)(that._options.silent(VALUE))));
        }
        that._eventTrigger(VALUE_CHANGED, {
          value: (0, _utils.convertVisualRangeObject)(range),
          previousValue: (0, _utils.convertVisualRangeObject)(lastSelectedRange),
          event: e
        });
      },
      axis: that._axis,
      translator: that._axis.getTranslator()
    });
    that._tracker = new _tracker.Tracker({
      renderer: renderer,
      controller: that._slidersController
    });
  },
  _getDefaultSize: function () {
    return {
      width: 400,
      height: 160
    };
  },
  _disposeCore: function () {
    this._axis.dispose();
    this._slidersController.dispose();
    this._tracker.dispose();
  },
  _applySize: function (rect) {
    this._clientRect = rect.slice();
    this._change(['MOSTLY_TOTAL']);
  },
  _optionChangesMap: {
    scale: 'SCALE',
    value: 'VALUE',
    dataSource: 'DATA_SOURCE'
  },
  _optionChangesOrder: ['SCALE', 'DATA_SOURCE'],
  _change_SCALE: function () {
    this._change(['MOSTLY_TOTAL']);
  },
  _setValueByDataSource() {
    const that = this;
    const options = that._options.silent();
    const axis = that._axis;
    if (options.dataSource) {
      let selectedRangeUpdateMode = that.option('selectedRangeUpdateMode');
      const value = that.getValue();
      const valueIsReady = (0, _type2.isDefined)(value[0]) && (0, _type2.isDefined)(value[1]);
      if ((0, _type2.isDefined)(selectedRangeUpdateMode)) {
        selectedRangeUpdateMode = (0, _utils.normalizeEnum)(selectedRangeUpdateMode);
        that.__skipAnimation = true;
      } else if (valueIsReady && !that._dataSourceIsAsync) {
        // T696409 T930471
        selectedRangeUpdateMode = RESET;
      }
      if (selectedRangeUpdateMode === 'auto' && valueIsReady) {
        const rangesInfo = axis.allScaleSelected(value);
        if (rangesInfo.startValue && rangesInfo.endValue) {
          selectedRangeUpdateMode = RESET;
        } else if (rangesInfo.endValue) {
          selectedRangeUpdateMode = SHIFT;
        } else {
          selectedRangeUpdateMode = KEEP;
        }
      }
      if (selectedRangeUpdateMode === RESET) {
        options[VALUE] = null;
      } else if (selectedRangeUpdateMode === SHIFT && valueIsReady) {
        const value = that.getValue();
        that.__skipAnimation = true;
        options[VALUE] = {
          length: axis.getVisualRangeLength({
            minVisible: value[0],
            maxVisible: value[1]
          })
        };
      } else if (selectedRangeUpdateMode === KEEP) {
        that.__skipAnimation = true;
      }
    }
    that._dataSourceIsAsync = undefined;
  },
  _change_DATA_SOURCE: function () {
    if (this._options.silent('dataSource')) {
      this._updateDataSource();
    }
  },
  _customChangesOrder: ['MOSTLY_TOTAL', 'VALUE', 'SLIDER_SELECTION'],
  _change_MOSTLY_TOTAL: function () {
    this._applyMostlyTotalChange();
  },
  _change_SLIDER_SELECTION: function () {
    const that = this;
    const value = that._options.silent(VALUE);
    that._slidersController.setSelectedRange(value && (0, _utils.getVizRangeObject)(value));
  },
  _change_VALUE: function () {
    const that = this;
    const option = that._rangeOption;
    that._dataSourceIsAsync = !that._dataIsReady();
    if (option) {
      that._options.silent(VALUE, option);
      that.setValue(option);
    }
  },
  _validateRange: function (start, end) {
    const ensureValueInvalid = value => (0, _type2.isDefined)(value) && !this._axis.getTranslator().isValid(value);
    if (this._dataIsReady() && (ensureValueInvalid(start) || ensureValueInvalid(end))) {
      this._incidentOccurred('E2203');
    }
  },
  _applyChanges: function () {
    const that = this;
    const value = that._options.silent(VALUE);
    if (that._changes.has('VALUE') && value) {
      that._rangeOption = value;
    }
    that.callBase.apply(that, arguments);
    that._rangeOption = null;
    that.__isResizing = that.__skipAnimation = false;
  },
  _applyMostlyTotalChange: function () {
    const that = this;
    const renderer = that._renderer;
    const rect = that._clientRect;
    let currentAnimationEnabled;
    const canvas = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };
    if (that.__isResizing || that.__skipAnimation) {
      currentAnimationEnabled = renderer.animationEnabled();
      renderer.updateAnimationOptions({
        enabled: false
      });
    }
    that._clipRect.attr({
      x: rect[0],
      y: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    });
    that._axis.getTranslator().update(new _range.Range(), canvas, {
      isHorizontal: true
    });
    that._updateContent({
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    });
    if (that.__isResizing || that.__skipAnimation) {
      renderer.updateAnimationOptions({
        enabled: currentAnimationEnabled
      });
    }
    that._drawn();
  },
  _dataSourceChangedHandler: function () {
    this._setValueByDataSource();
    this._requestChange(['MOSTLY_TOTAL']);
  },
  // It seems that we REALLY like to translate option structures from one form to another.
  // TODO: The more appropriate way is the following:
  // that._rangeView.update([
  //     that._getOption("background"),
  //     that._getOption("chart"),
  //     that.option("dataSource")
  // ]);
  // that._slidersController.update([
  //     that._getOption("sliderHandle"),
  //     that._getOption("sliderMarker"),
  //     that._getOption("shutter"),
  //     that._getOption("behavior")
  // ]);
  // that._axis.update(that._getOption("scale"));
  _completeSeriesDataSourceCreation(scaleOptions, seriesDataSource) {
    const rect = this._clientRect;
    const canvas = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };
    this._axis.updateOptions((0, _extend.extend)({}, scaleOptions, {
      isHorizontal: true,
      label: {}
    }));
    seriesDataSource.isShowChart() && this._axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));
    this._axis.updateCanvas(canvas);
    seriesDataSource.createPoints();
  },
  _updateContent: function (canvas) {
    const that = this;
    const chartOptions = that.option('chart');
    const seriesDataSource = that._createSeriesDataSource(chartOptions);
    const isCompactMode = !(seriesDataSource && seriesDataSource.isShowChart() || that.option('background.image.url'));
    const scaleOptions = prepareScaleOptions(that._getOption('scale'), seriesDataSource && seriesDataSource.getCalculatedValueType(), that._incidentOccurred, this._getOption('containerBackgroundColor', true));
    seriesDataSource && that._completeSeriesDataSourceCreation(scaleOptions, seriesDataSource);
    const argTranslatorRange = calculateTranslatorRange(seriesDataSource, scaleOptions);
    const tickIntervalsInfo = updateTickIntervals(scaleOptions, canvas.width, that._incidentOccurred, argTranslatorRange);
    const chartThemeManager = seriesDataSource && seriesDataSource.isShowChart() && seriesDataSource.getThemeManager();
    if (chartThemeManager) {
      // TODO: Looks like usage of "chartThemeManager" can be replaced with "that._getOption("chart").valueAxis.logarithmBase - check it
      checkLogarithmicOptions(chartOptions && chartOptions.valueAxis, chartThemeManager.getOptions('valueAxis').logarithmBase, that._incidentOccurred);
    }
    updateScaleOptions(scaleOptions, seriesDataSource, argTranslatorRange, tickIntervalsInfo, getDateMarkerVisibilityChecker(canvas.width));
    updateTranslatorRangeInterval(argTranslatorRange, scaleOptions);
    const sliderMarkerOptions = that._prepareSliderMarkersOptions(scaleOptions, canvas.width, tickIntervalsInfo, argTranslatorRange);
    const indents = calculateIndents(that._renderer, scaleOptions, sliderMarkerOptions, that.option('indent'), tickIntervalsInfo);
    const rangeContainerCanvas = {
      left: canvas.left + indents.left,
      top: canvas.top + indents.top,
      width: canvas.left + indents.left + _max(canvas.width - indents.left - indents.right, 1),
      height: _max(!isCompactMode ? canvas.height - indents.top - indents.bottom - calculateScaleAreaHeight(that._renderer, scaleOptions, showScaleMarkers(scaleOptions), tickIntervalsInfo) : _common.HEIGHT_COMPACT_MODE, 0),
      right: 0,
      bottom: 0
    };

    // TODO: There should be one call to some axis method (not 4 methods)
    that._axis.update(scaleOptions, isCompactMode, rangeContainerCanvas, argTranslatorRange, seriesDataSource);
    scaleOptions.minorTickInterval = scaleOptions.isEmpty ? 0 : scaleOptions.minorTickInterval;

    // RangeContainer
    that._updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, rangeContainerCanvas, seriesDataSource);
    if (chartThemeManager) {
      chartThemeManager.dispose(); // TODO: Move it inside "SeriesDataSource"
    }
  },
  _updateElements: function (scaleOptions, sliderMarkerOptions, isCompactMode, canvas, seriesDataSource) {
    const that = this;
    const behavior = that._getOption('behavior');
    const shutterOptions = that._getOption('shutter');
    const isNotSemiDiscrete = scaleOptions.type !== SEMIDISCRETE;
    shutterOptions.color = shutterOptions.color || that._getOption(CONTAINER_BACKGROUND_COLOR, true);
    that._rangeView.update(that.option('background'), that._themeManager.theme('background'), canvas, isCompactMode, behavior.animationEnabled && that._renderer.animationEnabled(), seriesDataSource);

    // TODO: Is entire options bag really needed for SlidersContainer?
    that._isUpdating = true;
    that._slidersController.update([canvas.top, canvas.top + canvas.height], behavior, isCompactMode, that._getOption('sliderHandle'), sliderMarkerOptions, shutterOptions, {
      minRange: isNotSemiDiscrete ? that.option('scale.minRange') : undefined,
      maxRange: isNotSemiDiscrete ? that.option('scale.maxRange') : undefined
    }, that._axis.getFullTicks(), that._getOption('selectedRangeColor', true));
    that._requestChange(['SLIDER_SELECTION']);
    that._isUpdating = false;
    that._tracker.update(!that._axis.getTranslator().getBusinessRange().isEmpty(), behavior);
  },
  _createSeriesDataSource: function (chartOptions) {
    const that = this;
    let seriesDataSource;
    const dataSource = that._dataSourceItems(); // TODO: This code can be executed when data source is not loaded (it is an error)!
    const scaleOptions = that._getOption('scale');
    const valueType = scaleOptions.valueType || calculateValueType(scaleOptions.startValue, scaleOptions.endValue);
    const valueAxis = new _base_axis.Axis({
      renderer: that._renderer,
      axisType: 'xyAxes',
      drawingType: 'linear'
    });
    valueAxis.updateOptions({
      isHorizontal: false,
      label: {},
      categoriesSortingMethod: that._getOption('chart').valueAxis.categoriesSortingMethod
    });
    if (dataSource || chartOptions && chartOptions.series) {
      chartOptions = (0, _extend.extend)({}, chartOptions, {
        theme: that.option('theme')
      });
      seriesDataSource = new _series_data_source.SeriesDataSource({
        renderer: that._renderer,
        dataSource: dataSource,
        valueType: (0, _utils.normalizeEnum)(valueType),
        axisType: scaleOptions.type,
        chart: chartOptions,
        dataSourceField: that.option('dataSourceField'),
        incidentOccurred: that._incidentOccurred,
        categories: scaleOptions.categories,
        argumentAxis: that._axis,
        valueAxis: valueAxis
      });
    }
    return seriesDataSource;
  },
  _prepareSliderMarkersOptions: function (scaleOptions, screenDelta, tickIntervalsInfo, argRange) {
    const that = this;
    const minorTickInterval = tickIntervalsInfo.minorTickInterval;
    const tickInterval = tickIntervalsInfo.tickInterval;
    let interval = tickInterval;
    const endValue = scaleOptions.endValue;
    const startValue = scaleOptions.startValue;
    const sliderMarkerOptions = that._getOption(SLIDER_MARKER);
    const doNotSnap = !that._getOption('behavior').snapToTicks;
    const isTypeDiscrete = scaleOptions.type === DISCRETE;
    const isValueTypeDatetime = scaleOptions.valueType === DATETIME;
    sliderMarkerOptions.borderColor = that._getOption(CONTAINER_BACKGROUND_COLOR, true);
    if (!sliderMarkerOptions.format && !argRange.isEmpty()) {
      if (doNotSnap && (0, _type2.isNumeric)(scaleOptions.startValue)) {
        sliderMarkerOptions.format = {
          type: 'fixedPoint',
          precision: getPrecisionForSlider(startValue, endValue, screenDelta)
        };
      }
      if (isValueTypeDatetime && !isTypeDiscrete) {
        if ((0, _type2.isDefined)(minorTickInterval) && minorTickInterval !== 0) {
          interval = getMinorTickIntervalUnit(tickInterval, minorTickInterval, doNotSnap);
        }
        if (!scaleOptions.marker.visible) {
          if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {
            sliderMarkerOptions.format = _format_helper.default.getDateFormatByTickInterval(startValue, endValue, interval);
          }
        } else {
          sliderMarkerOptions.format = _date.default.getDateFormatByTickInterval(interval);
        }
      }
      // T347293
      if (isValueTypeDatetime && isTypeDiscrete && tickIntervalsInfo.ticks.length) {
        sliderMarkerOptions.format = _format_helper.default.getDateFormatByTicks(tickIntervalsInfo.ticks);
      }
    }
    return sliderMarkerOptions;
  },
  getValue: function () {
    return (0, _utils.convertVisualRangeObject)(this._slidersController.getSelectedRange());
  },
  setValue: function (value, e) {
    const visualRange = (0, _utils.getVizRangeObject)(value);
    if (!this._isUpdating && value) {
      this._validateRange(visualRange.startValue, visualRange.endValue);
      !(0, _utils.rangesAreEqual)(visualRange, this._slidersController.getSelectedRange()) && this._slidersController.setSelectedRange(visualRange, e);
    }
  },
  _setContentSize: function () {
    this.__isResizing = this._changes.count() === 2;
    this.callBase.apply(this, arguments);
  }
});
(0, _iterator.each)(['selectedRangeColor', 'containerBackgroundColor', 'sliderMarker', 'sliderHandle', 'shutter', OPTION_BACKGROUND, 'behavior', 'chart', 'indent'], function (_, name) {
  dxRangeSelector.prototype._optionChangesMap[name] = 'MOSTLY_TOTAL';
});

// AxisWrapper

function prepareAxisOptions(scaleOptions, isCompactMode, height, axisPosition) {
  scaleOptions.marker.label.font = scaleOptions.label.font;
  scaleOptions.color = scaleOptions.marker.color = scaleOptions.tick.color;
  scaleOptions.opacity = scaleOptions.marker.opacity = scaleOptions.tick.opacity;
  scaleOptions.width = scaleOptions.marker.width = scaleOptions.tick.width;
  scaleOptions.placeholderSize = (scaleOptions.placeholderHeight || 0) + axisPosition;
  scaleOptions.argumentType = scaleOptions.valueType;
  scaleOptions.visible = isCompactMode;
  scaleOptions.isHorizontal = true;
  scaleOptions.calculateMinors = true;
  scaleOptions.semiDiscreteInterval = scaleOptions.minRange;
  if (!isCompactMode) {
    scaleOptions.minorTick.length = scaleOptions.tick.length = height;
  }
  scaleOptions.label.indentFromAxis = scaleOptions.label.topIndent + axisPosition;
  return scaleOptions;
}
function createDateMarkersEvent(scaleOptions, markerTrackers, setSelectedRange) {
  (0, _iterator.each)(markerTrackers, function (_, value) {
    value.on('dxpointerdown', onPointerDown);
  });
  function onPointerDown(e) {
    const range = e.target.range;
    const minRange = scaleOptions.minRange ? _date.default.addInterval(range.startValue, scaleOptions.minRange) : undefined;
    const maxRange = scaleOptions.maxRange ? _date.default.addInterval(range.startValue, scaleOptions.maxRange) : undefined;
    if (!(minRange && minRange > range.endValue || maxRange && maxRange < range.endValue)) {
      setSelectedRange(range, e);
    }
  }
}
function getSharpDirection() {
  return 1;
}
function getTickStartPositionShift(length) {
  return length % 2 === 1 ? -_floor(length / 2) : -length / 2;
}
function checkShiftedLabels(majorTicks, boxes, minSpacing, alignment) {
  function checkLabelsOverlapping(nearestLabelsIndexes) {
    if (nearestLabelsIndexes.length === 2 && _axes_constants.default.areLabelsOverlap(boxes[nearestLabelsIndexes[0]], boxes[nearestLabelsIndexes[1]], minSpacing, alignment)) {
      majorTicks[nearestLabelsIndexes[0]].removeLabel();
    }
  }
  function getTwoVisibleLabels(startIndex) {
    const labels = [];
    for (let i = startIndex; labels.length < 2 && i < majorTicks.length; i++) {
      majorTicks[i].label && labels.push(i);
    }
    return labels;
  }
  if (majorTicks.length < 3) {
    return;
  }
  checkLabelsOverlapping(getTwoVisibleLabels(0));
  checkLabelsOverlapping(getTwoVisibleLabels(majorTicks.length - 2).reverse());
}
function AxisWrapper(params) {
  const that = this;
  that._axis = new _base_axis.Axis({
    renderer: params.renderer,
    axesContainerGroup: params.root,
    scaleBreaksGroup: params.scaleBreaksGroup,
    labelsAxesGroup: params.labelsAxesGroup,
    incidentOccurred: params.incidentOccurred,
    // TODO: These dependencies should be statically resolved (not for every new instance)
    axisType: 'xyAxes',
    drawingType: 'linear',
    widgetClass: 'dxrs',
    axisClass: 'range-selector',
    isArgumentAxis: true,
    getTemplate() {}
  });
  that._updateSelectedRangeCallback = params.updateSelectedRange;
  that._axis.getAxisSharpDirection = that._axis.getSharpDirectionByCoords = getSharpDirection;
  that._axis.getTickStartPositionShift = getTickStartPositionShift;
  that._axis._checkShiftedLabels = checkShiftedLabels;
}
AxisWrapper.prototype = {
  constructor: AxisWrapper,
  update: function (options, isCompactMode, canvas, businessRange, seriesDataSource) {
    const axis = this._axis;
    axis.updateOptions(prepareAxisOptions(options, isCompactMode, canvas.height, canvas.height / 2 - _ceil(options.width / 2)));
    axis.validate();
    axis.setBusinessRange(businessRange, true);
    if (seriesDataSource !== undefined && seriesDataSource.isShowChart()) {
      axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));
    }
    axis.draw(canvas);
    axis.shift({
      left: 0,
      bottom: -canvas.height / 2 + canvas.top
    });
    if (axis.getMarkerTrackers()) {
      // TODO: Check who is responsible for destroying events
      createDateMarkersEvent(options, axis.getMarkerTrackers(), this._updateSelectedRangeCallback);
    }
    axis.drawScaleBreaks({
      start: canvas.top,
      end: canvas.top + canvas.height
    });
  },
  visualRange: function () {},
  getViewport: function () {
    return {};
  },
  allScaleSelected(value) {
    const {
      startValue,
      endValue
    } = this._axis.visualRange();
    return {
      startValue: value[0].valueOf() === startValue.valueOf(),
      endValue: value[1].valueOf() === endValue.valueOf()
    };
  },
  getOptions() {
    return this._axis.getOptions() || {};
  }
};
(0, _iterator.each)(_base_axis.Axis.prototype, field => {
  if (field !== 'constructor' && field[0] !== '_' && (0, _type2.isFunction)(_base_axis.Axis.prototype[field]) && !(field in AxisWrapper.prototype)) {
    AxisWrapper.prototype[field] = function () {
      const axis = this._axis;
      return axis[field].apply(axis, arguments);
    };
  }
});
(0, _component_registrator.default)('dxRangeSelector', dxRangeSelector);
var _default = exports["default"] = dxRangeSelector; // PLUGINS_SECTION
dxRangeSelector.addPlugin(_export.plugin);
dxRangeSelector.addPlugin(_title.plugin);
dxRangeSelector.addPlugin(_loading_indicator.plugin);
dxRangeSelector.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 25104:
/***/ (function(__unused_webpack_module, exports) {



exports.RangeView = RangeView;
// TODO: Move it inside the "SeriesDataSource"
function drawSeriesView(root, seriesDataSource, canvas, isAnimationEnabled) {
  const seriesList = seriesDataSource.getSeries();
  if (!seriesList.length) {
    return;
  }
  const valueAxis = seriesList[0].getValueAxis();
  valueAxis.updateCanvas({
    top: canvas.top,
    bottom: 0,
    height: canvas.height + canvas.top
  });
  seriesDataSource.adjustSeriesDimensions();
  const valueRange = seriesDataSource.getBoundRange().val;
  valueRange.sortCategories(valueAxis.getCategoriesSorter());
  valueAxis.setBusinessRange(valueRange);
  seriesList.forEach(series => {
    series._extGroups.seriesGroup = series._extGroups.labelsGroup = root;
    series.draw(isAnimationEnabled);
  });
}
function merge(a, b) {
  return a !== undefined ? a : b;
}
function RangeView(params) {
  this._params = params;
  this._clipRect = params.renderer.clipRect();
  params.root.attr({
    'clip-path': this._clipRect.id
  });
}
RangeView.prototype = {
  constructor: RangeView,
  update: function (backgroundOption, backgroundTheme, canvas, isCompactMode, isAnimationEnabled, seriesDataSource) {
    const renderer = this._params.renderer;
    const root = this._params.root;
    const canvasWidth = canvas.width - canvas.left;
    let seriesGroup;
    backgroundOption = backgroundOption || {};
    root.clear();
    this._clipRect.attr({
      x: canvas.left,
      y: canvas.top,
      width: canvasWidth,
      height: canvas.height
    });
    if (!isCompactMode) {
      if (merge(backgroundOption.visible, backgroundTheme.visible)) {
        if (backgroundOption.color) {
          renderer.rect(canvas.left, canvas.top, canvasWidth + 1, canvas.height).attr({
            // Seems that "backgroundTheme.color" is never used and so can be removed both from here and from themes
            // TODO: Check it (special attention to WidgetsGallery) and remove the option
            fill: merge(backgroundOption.color, backgroundTheme.color),
            'class': 'dx-range-selector-background'
          }).append(root);
        }
        if (backgroundOption.image && backgroundOption.image.url) {
          renderer.image(canvas.left, canvas.top, canvasWidth + 1, canvas.height, backgroundOption.image.url, merge(backgroundOption.image.location, backgroundTheme.image.location)).append(root);
        }
      }
      if (seriesDataSource && seriesDataSource.isShowChart()) {
        seriesGroup = renderer.g().attr({
          'class': 'dxrs-series-group'
        }).append(root);
        drawSeriesView(seriesGroup, seriesDataSource, canvas, isAnimationEnabled);
      }
    }
  }
};

/***/ }),

/***/ 79302:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.SeriesDataSource = void 0;
var _base_series = __webpack_require__(54932);
var _series_family = __webpack_require__(1939);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _range = __webpack_require__(21177);
var _data_validator = __webpack_require__(45865);
var _chart_theme_manager = __webpack_require__(99327);
const createThemeManager = function (chartOptions) {
  return new _chart_theme_manager.ThemeManager({
    options: chartOptions,
    themeSection: 'rangeSelector.chart',
    fontFields: ['commonSeriesSettings.label.font']
  });
};
const processSeriesFamilies = function (series, minBubbleSize, maxBubbleSize, barOptions, negativesAsZeroes) {
  const families = [];
  const types = [];
  (0, _iterator.each)(series, function (i, item) {
    if (!types.includes(item.type)) {
      types.push(item.type);
    }
  });
  (0, _iterator.each)(types, function (_, type) {
    const family = new _series_family.SeriesFamily({
      type: type,
      minBubbleSize: minBubbleSize,
      maxBubbleSize: maxBubbleSize,
      barGroupPadding: barOptions.barGroupPadding,
      barGroupWidth: barOptions.barGroupWidth,
      negativesAsZeroes: negativesAsZeroes
    });
    family.add(series);
    family.adjustSeriesValues();
    families.push(family);
  });
  return families;
};
const SeriesDataSource = function (options) {
  const that = this;
  const themeManager = that._themeManager = createThemeManager(options.chart);
  themeManager.setTheme(options.chart.theme);
  const topIndent = themeManager.getOptions('topIndent');
  const bottomIndent = themeManager.getOptions('bottomIndent');
  that._indent = {
    top: topIndent >= 0 && topIndent < 1 ? topIndent : 0,
    bottom: bottomIndent >= 0 && bottomIndent < 1 ? bottomIndent : 0
  };
  that._valueAxis = themeManager.getOptions('valueAxisRangeSelector') || {};
  that._hideChart = false;
  that._series = that._calculateSeries(options);
  that._seriesFamilies = [];
};
exports.SeriesDataSource = SeriesDataSource;
SeriesDataSource.prototype = {
  constructor: SeriesDataSource,
  _calculateSeries: function (options) {
    const that = this;
    const series = [];
    let particularSeriesOptions;
    let seriesTheme;
    const data = options.dataSource || [];
    let parsedData;
    const chartThemeManager = that._themeManager;
    const seriesTemplate = chartThemeManager.getOptions('seriesTemplate');
    let allSeriesOptions = seriesTemplate ? (0, _utils.processSeriesTemplate)(seriesTemplate, data) : options.chart.series;
    let dataSourceField;
    const valueAxis = that._valueAxis;
    let i;
    let newSeries;
    let groupsData;
    if (options.dataSource && !allSeriesOptions) {
      dataSourceField = options.dataSourceField || 'arg';
      allSeriesOptions = {
        argumentField: dataSourceField,
        valueField: dataSourceField
      };
      that._hideChart = true;
    }
    allSeriesOptions = Array.isArray(allSeriesOptions) ? allSeriesOptions : allSeriesOptions ? [allSeriesOptions] : [];
    for (i = 0; i < allSeriesOptions.length; i++) {
      particularSeriesOptions = (0, _extend.extend)(true, {}, allSeriesOptions[i]);
      particularSeriesOptions.rotated = false;
      seriesTheme = chartThemeManager.getOptions('series', particularSeriesOptions, allSeriesOptions.length);
      seriesTheme.argumentField = seriesTheme.argumentField || options.dataSourceField; // B253068
      if (!seriesTheme.name) {
        seriesTheme.name = 'Series ' + (i + 1).toString();
      }
      if (data && data.length > 0) {
        // TODO
        newSeries = new _base_series.Series({
          renderer: options.renderer,
          argumentAxis: options.argumentAxis,
          valueAxis: options.valueAxis,
          incidentOccurred: options.incidentOccurred
        }, seriesTheme);
        series.push(newSeries);
      }
    }
    if (series.length) {
      groupsData = {
        groups: [{
          series: series,
          valueAxis: options.valueAxis,
          valueOptions: {
            type: valueAxis.type,
            valueType: dataSourceField ? options.valueType : valueAxis.valueType
          }
        }],
        argumentOptions: {
          categories: options.categories,
          argumentType: options.valueType,
          type: options.axisType
        }
      };
      parsedData = (0, _data_validator.validateData)(data, groupsData, options.incidentOccurred, chartThemeManager.getOptions('dataPrepareSettings'));
      that.argCategories = groupsData.categories;
      for (i = 0; i < series.length; i++) {
        series[i].updateData(parsedData[series[i].getArgumentField()]);
      }
    }
    return series;
  },
  createPoints() {
    if (this._series.length === 0) {
      return;
    }
    const series = this._series;
    const viewport = new _range.Range();
    const axis = series[0].getArgumentAxis();
    const themeManager = this._themeManager;
    const negativesAsZeroes = themeManager.getOptions('negativesAsZeroes');
    const negativesAsZeros = themeManager.getOptions('negativesAsZeros'); // misspelling case

    series.forEach(function (s) {
      viewport.addRange(s.getArgumentRange());
    });
    axis.getTranslator().updateBusinessRange(viewport);
    series.forEach(function (s) {
      s.createPoints();
    });
    this._seriesFamilies = processSeriesFamilies(series, themeManager.getOptions('minBubbleSize'), themeManager.getOptions('maxBubbleSize'), {
      barGroupPadding: themeManager.getOptions('barGroupPadding'),
      barGroupWidth: themeManager.getOptions('barGroupWidth')
    }, (0, _type.isDefined)(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros);
  },
  adjustSeriesDimensions: function () {
    (0, _iterator.each)(this._seriesFamilies, function (_, family) {
      family.adjustSeriesDimensions();
    });
  },
  getBoundRange: function () {
    const that = this;
    let rangeData;
    const valueAxis = that._valueAxis;
    const valRange = new _range.Range({
      min: valueAxis.min,
      minVisible: valueAxis.min,
      max: valueAxis.max,
      maxVisible: valueAxis.max,
      axisType: valueAxis.type,
      base: valueAxis.logarithmBase
    });
    const argRange = new _range.Range({});
    let rangeYSize;
    let rangeVisibleSizeY;
    let minIndent;
    let maxIndent;
    (0, _iterator.each)(that._series, function (_, series) {
      rangeData = series.getRangeData();
      valRange.addRange(rangeData.val);
      argRange.addRange(rangeData.arg);
    });
    if (!valRange.isEmpty() && !argRange.isEmpty()) {
      minIndent = valueAxis.inverted ? that._indent.top : that._indent.bottom;
      maxIndent = valueAxis.inverted ? that._indent.bottom : that._indent.top;
      rangeYSize = valRange.max - valRange.min;
      rangeVisibleSizeY = ((0, _type.isNumeric)(valRange.maxVisible) ? valRange.maxVisible : valRange.max) - ((0, _type.isNumeric)(valRange.minVisible) ? valRange.minVisible : valRange.min);
      // B253717
      if ((0, _type.isDate)(valRange.min)) {
        valRange.min = new Date(valRange.min.valueOf() - rangeYSize * minIndent);
      } else {
        valRange.min -= rangeYSize * minIndent;
      }
      if ((0, _type.isDate)(valRange.max)) {
        valRange.max = new Date(valRange.max.valueOf() + rangeYSize * maxIndent);
      } else {
        valRange.max += rangeYSize * maxIndent;
      }
      if ((0, _type.isNumeric)(rangeVisibleSizeY)) {
        valRange.maxVisible = valRange.maxVisible ? valRange.maxVisible + rangeVisibleSizeY * maxIndent : undefined;
        valRange.minVisible = valRange.minVisible ? valRange.minVisible - rangeVisibleSizeY * minIndent : undefined;
      }
      valRange.invert = valueAxis.inverted;
    }
    return {
      arg: argRange,
      val: valRange
    };
  },
  getMarginOptions: function (canvas) {
    const bubbleSize = Math.min(canvas.width, canvas.height) * this._themeManager.getOptions('maxBubbleSize');
    return this._series.reduce(function (marginOptions, series) {
      const seriesOptions = series.getMarginOptions();
      if (seriesOptions.processBubbleSize === true) {
        seriesOptions.size = bubbleSize;
      }
      return (0, _utils.mergeMarginOptions)(marginOptions, seriesOptions);
    }, {});
  },
  getSeries: function () {
    return this._series;
  },
  isEmpty: function () {
    return this.getSeries().length === 0;
  },
  isShowChart: function () {
    return !this._hideChart;
  },
  getCalculatedValueType: function () {
    const series = this._series[0];
    return series === null || series === void 0 ? void 0 : series.argumentType;
  },
  getThemeManager: function () {
    return this._themeManager;
  }
};

/***/ }),

/***/ 48942:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(11378);
var _slider_marker = _interopRequireDefault(__webpack_require__(79090));
var _support = __webpack_require__(60137);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const animationSettings = _common.utils.animationSettings;
const SPLITTER_WIDTH = 8;
const TOUCH_SPLITTER_WIDTH = 20;
function getSliderTrackerWidth(sliderHandleWidth) {
  return _support.touchEvents || _support.pointerEvents ? TOUCH_SPLITTER_WIDTH : SPLITTER_WIDTH < sliderHandleWidth ? sliderHandleWidth : SPLITTER_WIDTH;
}
function Slider(params, index) {
  const that = this;
  that._translator = params.translator;
  that._sliderGroup = params.renderer.g().attr({
    'class': 'slider'
  }).append(params.root);
  that._line = params.renderer.path(null, 'line').append(that._sliderGroup);
  that._marker = new _slider_marker.default(params.renderer, that._sliderGroup, index === 1);
  that._tracker = params.renderer.rect().attr({
    'class': 'slider-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).css({
    cursor: 'w-resize'
  }).append(params.trackersGroup);
}
Slider.prototype = {
  constructor: Slider,
  cancelAnimation: function () {
    this._sliderGroup.stopAnimation();
    this._tracker.stopAnimation();
  },
  applyPosition: function (isAnimated) {
    const that = this;
    const slider = that._sliderGroup;
    const tracker = that._tracker;
    const attrs = {
      translateX: that._position
    };
    that._marker.setPosition(that._position);
    if (isAnimated) {
      slider.animate(attrs, animationSettings);
      tracker.animate(attrs, animationSettings);
    } else {
      slider.attr(attrs);
      tracker.attr(attrs);
    }
  },
  _setValid: function (isValid) {
    this._marker.setValid(isValid);
    this._line.attr({
      stroke: this._colors[Number(isValid)]
    });
  },
  _setText: function (text) {
    this._marker.setText(text);
  },
  update: function (verticalRange, sliderHandleOptions, sliderMarkerOptions) {
    const that = this;
    that._formatOptions = {
      format: sliderMarkerOptions.format,
      customizeText: sliderMarkerOptions.customizeText
    };
    that._marker.applyOptions(sliderMarkerOptions, that._translator.getScreenRange());
    that._colors = [sliderMarkerOptions.invalidRangeColor, sliderHandleOptions.color];
    that._sliderGroup.attr({
      translateY: verticalRange[0]
    });
    that._line.attr({
      'stroke-width': sliderHandleOptions.width,
      stroke: sliderHandleOptions.color,
      'stroke-opacity': sliderHandleOptions.opacity,
      sharp: 'h',
      points: [0, 0, 0, verticalRange[1] - verticalRange[0]]
    });
    const trackerWidth = getSliderTrackerWidth(sliderHandleOptions.width);
    that._tracker.attr({
      x: -trackerWidth / 2,
      y: 0,
      width: trackerWidth,
      height: verticalRange[1] - verticalRange[0],
      translateY: verticalRange[0]
    });
  },
  toForeground: function () {
    this._sliderGroup.toForeground();
  },
  getSliderTracker: function () {
    return this._tracker;
  },
  getPosition: function () {
    return this._position;
  },
  setDisplayValue: function (value) {
    this._value = value;
    this._setText((0, _common.formatValue)(value, this._formatOptions));
  },
  setOverlapped: function (isOverlapped) {
    this._marker.setOverlapped(isOverlapped);
  },
  getValue: function () {
    return this._value;
  },
  on: function (event, handler) {
    this._tracker.on(event, handler);
    this._marker.getTracker().on(event, handler);
  },
  getCloudBorder: function () {
    return this._marker.getBorderPosition();
  },
  dispose: function () {
    this._marker.dispose();
  }
};
var _default = exports["default"] = Slider;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 79090:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(11378);
const POINTER_SIZE = _common.consts.pointerSize;
const SLIDER_MARKER_UPDATE_DELAY = 75;
function SliderMarker(renderer, root, isLeftPointer) {
  const that = this;
  that._isLeftPointer = isLeftPointer;
  that._isOverlapped = false;
  that._group = renderer.g().attr({
    'class': 'slider-marker'
  }).append(root);
  that._area = renderer.path(null, 'area').append(that._group);
  that._label = renderer.text().attr({
    align: 'left'
  }).append(that._group);
  that._tracker = renderer.rect().attr({
    'class': 'slider-marker-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).css({
    cursor: 'pointer'
  }).append(that._group);
  that._border = renderer.rect(0, 0, 1, 0);
}
SliderMarker.prototype = {
  constructor: SliderMarker,
  _getRectSize: function (textSize) {
    return {
      width: Math.round(2 * this._paddingLeftRight + textSize.width),
      height: Math.round(2 * this._paddingTopBottom + textSize.height)
    };
  },
  _getTextSize: function () {
    const textSize = this._label.getBBox();
    if (!this._textHeight && isFinite(textSize.height)) {
      this._textHeight = textSize.height;
    }
    return {
      width: textSize.width,
      height: this._textHeight,
      y: textSize.y
    };
  },
  _getAreaPointsInfo: function (textSize) {
    const that = this;
    const rectSize = that._getRectSize(textSize);
    const rectWidth = rectSize.width;
    const rectHeight = rectSize.height;
    let rectLeftBorder = -rectWidth;
    let rectRightBorder = 0;
    let pointerRightPoint = POINTER_SIZE;
    let pointerCenterPoint = 0;
    let pointerLeftPoint = -POINTER_SIZE;
    const position = that._position;
    const isLeft = that._isLeftPointer;
    const correctCloudBorders = function () {
      rectLeftBorder++;
      rectRightBorder++;
      pointerRightPoint++;
      pointerCenterPoint++;
      pointerLeftPoint++;
    };
    const checkPointerBorders = function () {
      if (pointerRightPoint > rectRightBorder) {
        pointerRightPoint = rectRightBorder;
      } else {
        if (pointerLeftPoint < rectLeftBorder) {
          pointerLeftPoint = rectLeftBorder;
        }
      }
      isLeft && correctCloudBorders();
    };
    let borderPosition = position;
    if (isLeft) {
      if (position > that._range[1] - rectWidth) {
        rectRightBorder = -position + that._range[1];
        rectLeftBorder = rectRightBorder - rectWidth;
        checkPointerBorders();
        borderPosition += rectLeftBorder;
      } else {
        rectLeftBorder = pointerLeftPoint = 0;
        rectRightBorder = rectWidth;
      }
    } else {
      if (position - that._range[0] < rectWidth) {
        rectLeftBorder = -(position - that._range[0]);
        rectRightBorder = rectLeftBorder + rectWidth;
        checkPointerBorders();
        borderPosition += rectRightBorder;
      } else {
        pointerRightPoint = 0;
        correctCloudBorders();
      }
    }
    that._borderPosition = borderPosition;
    return {
      offset: rectLeftBorder,
      isCut: (!isLeft || pointerCenterPoint !== pointerLeftPoint) && (isLeft || pointerCenterPoint !== pointerRightPoint),
      points: [rectLeftBorder, 0, rectRightBorder, 0, rectRightBorder, rectHeight, pointerRightPoint, rectHeight, pointerCenterPoint, rectHeight + POINTER_SIZE, pointerLeftPoint, rectHeight, rectLeftBorder, rectHeight]
    };
  },
  _update: function () {
    const that = this;
    let textSize;
    clearTimeout(that._timeout);
    that._label.attr({
      text: that._text || ''
    });
    const currentTextSize = that._getTextSize();
    const rectSize = that._getRectSize(currentTextSize);
    textSize = that._textSize || currentTextSize;
    textSize = that._textSize = currentTextSize.width > textSize.width || currentTextSize.height > textSize.height ? currentTextSize : textSize;
    that._timeout = setTimeout(function () {
      updateSliderMarker(currentTextSize, rectSize);
      that._textSize = currentTextSize;
    }, SLIDER_MARKER_UPDATE_DELAY);
    function updateSliderMarker(size, rectSize) {
      rectSize = rectSize || that._getRectSize(size);
      that._group.attr({
        translateY: -(rectSize.height + POINTER_SIZE)
      });
      const pointsData = that._getAreaPointsInfo(size);
      const points = pointsData.points;
      const offset = pointsData.offset;
      that._area.attr({
        points: points
      });
      that._border.attr({
        x: that._isLeftPointer ? points[0] - 1 : points[2],
        height: pointsData.isCut ? rectSize.height : rectSize.height + POINTER_SIZE
      });
      that._tracker.attr({
        translateX: offset,
        width: rectSize.width,
        height: rectSize.height + POINTER_SIZE
      });
      that._label.attr({
        translateX: that._paddingLeftRight + offset,
        translateY: rectSize.height / 2 - (size.y + size.height / 2)
      });
    }
    updateSliderMarker(textSize);
  },
  setText: function (value) {
    this._text = value;
  },
  setPosition: function (position) {
    this._position = position;
    this._update();
  },
  applyOptions: function (options, screenRange) {
    const that = this;
    that._range = screenRange;
    that._paddingLeftRight = options.paddingLeftRight;
    that._paddingTopBottom = options.paddingTopBottom;
    that._textHeight = null;
    that._colors = [options.invalidRangeColor, options.color];
    that._area.attr({
      fill: options.color
    });
    that._border.attr({
      fill: options.borderColor
    });
    that._label.css((0, _utils.patchFontOptions)(options.font));
    that._update();
  },
  getTracker: function () {
    return this._tracker;
  },
  setValid: function (isValid) {
    this._area.attr({
      fill: this._colors[Number(isValid)]
    });
  },
  setColor: function (color) {
    this._area.attr({
      fill: color
    });
  },
  dispose: function () {
    clearTimeout(this._timeout);
  },
  setOverlapped: function (isOverlapped) {
    const that = this;
    if (that._isOverlapped !== isOverlapped) {
      if (isOverlapped) {
        that._border.append(that._group);
      } else {
        that._isOverlapped && that._border.remove();
      }
      that._isOverlapped = isOverlapped;
    }
  },
  getBorderPosition: function () {
    return this._borderPosition;
  }
};
var _default = exports["default"] = SliderMarker;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 56481:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.SlidersController = SlidersController;
var _common = __webpack_require__(20576);
var _common2 = __webpack_require__(11378);
var _slider = _interopRequireDefault(__webpack_require__(48942));
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const animationSettings = _common2.utils.animationSettings;
const emptySliderMarkerText = _common2.consts.emptySliderMarkerText;
function buildRectPoints(left, top, right, bottom) {
  return [left, top, right, top, right, bottom, left, bottom];
}
function isLess(a, b) {
  return a < b;
}
function isGreater(a, b) {
  return a > b;
}
function selectClosestValue(target, values) {
  let start = 0;
  let end = values ? values.length - 1 : 0;
  let middle;
  let val = target;
  while (end - start > 1) {
    middle = start + end >> 1;
    val = values[middle];
    if (val === target) {
      return target;
    } else if (target < val) {
      end = middle;
    } else {
      start = middle;
    }
  }
  if (values) {
    val = values[target - values[start] <= values[end] - target ? start : end];
  }
  return val;
}
function dummyProcessSelectionChanged() {
  this._lastSelectedRange = this.getSelectedRange();
  delete this._processSelectionChanged;
}

// See tests in "rangeSelectorWithAssertion.html", "'onSelectedRangeChanged' event" module
function suppressSetSelectedRange(controller) {
  controller.setSelectedRange = _common.noop;
  if (controller._processSelectionChanged === dummyProcessSelectionChanged) {
    controller._processSelectionChanged();
  }
}
function restoreSetSelectedRange(controller) {
  delete controller.setSelectedRange;
}
function SlidersController(params) {
  const that = this;
  const sliderParams = {
    renderer: params.renderer,
    root: params.root,
    trackersGroup: params.trackersGroup,
    translator: params.translator
  };
  that._params = params;
  that._areaTracker = params.renderer.path(null, 'area').attr({
    'class': 'area-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).append(params.trackersGroup);
  that._selectedAreaTracker = params.renderer.path(null, 'area').attr({
    'class': 'selected-area-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).append(params.trackersGroup);
  // Shutter is appended before sliders because later (when they will be foregrounded) it will be at any case located before them.
  that._shutter = params.renderer.path(null, 'area').append(params.root);
  that._sliders = [new _slider.default(sliderParams, 0), new _slider.default(sliderParams, 1)];
  // It seems that there is no special reasons to suppress first event - it was accidentally suppressed.
  // Let it stay so for now.
  that._processSelectionChanged = dummyProcessSelectionChanged;
}
SlidersController.prototype = {
  constructor: SlidersController,
  dispose: function () {
    this._sliders[0].dispose();
    this._sliders[1].dispose();
  },
  getTrackerTargets: function () {
    return {
      area: this._areaTracker,
      selectedArea: this._selectedAreaTracker,
      sliders: this._sliders
    };
  },
  _processSelectionChanged: function (e) {
    const that = this;
    const selectedRange = that.getSelectedRange();
    if (!(0, _utils.rangesAreEqual)(selectedRange, that._lastSelectedRange)) {
      that._params.updateSelectedRange(selectedRange, that._lastSelectedRange, e);
      that._lastSelectedRange = selectedRange;
    }
  },
  update: function (verticalRange, behavior, isCompactMode, sliderHandleOptions, sliderMarkerOptions, shutterOptions, rangeBounds, fullTicks, selectedRangeColor) {
    const that = this;
    const screenRange = that._params.translator.getScreenRange();
    that._verticalRange = verticalRange;
    that._minRange = rangeBounds.minRange;
    that._maxRange = rangeBounds.maxRange;
    // TODO: Investigate reasons of "renderer.animationEnabled" usage - it seems to be useless (if only for vml somehow)
    that._animationEnabled = behavior.animationEnabled && that._params.renderer.animationEnabled();
    that._allowSlidersSwap = behavior.allowSlidersSwap;
    that._sliders[0].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);
    that._sliders[1].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);
    // This is required for placing sliders and shutter into initial position from which initial animation will be going.
    that._sliders[0]._position = that._sliders[1]._position = screenRange[0];
    that._values = !that._params.translator.isValueProlonged && behavior.snapToTicks ? fullTicks : null;
    that._areaTracker.attr({
      points: buildRectPoints(screenRange[0], verticalRange[0], screenRange[1], verticalRange[1])
    });

    // SlidersContainer
    that._isCompactMode = isCompactMode;
    that._shutterOffset = sliderHandleOptions.width / 2;
    that._updateSelectedView(shutterOptions, selectedRangeColor);
    that._isOnMoving = (0, _utils.normalizeEnum)(behavior.valueChangeMode) === 'onhandlemove' || (0, _utils.normalizeEnum)(behavior.callValueChanged) === 'onmoving';
    that._updateSelectedRange();
    // This is placing sliders and shutter into initial position. They all will be animated from that position when "setSelectedRange" is called.
    that._applyTotalPosition(false);
  },
  _updateSelectedView: function (shutterOptions, selectedRangeColor) {
    const settings = {
      fill: null,
      'fill-opacity': null,
      stroke: null,
      'stroke-width': null
    };
    if (this._isCompactMode) {
      settings.stroke = selectedRangeColor;
      settings['stroke-width'] = 3;
      settings.sharp = 'v';
    } else {
      settings.fill = shutterOptions.color;
      settings['fill-opacity'] = shutterOptions.opacity;
    }
    this._shutter.attr(settings);
  },
  _updateSelectedRange: function () {
    const that = this;
    const sliders = that._sliders;
    sliders[0].cancelAnimation();
    sliders[1].cancelAnimation();
    that._shutter.stopAnimation();
    if (that._params.translator.getBusinessRange().isEmpty()) {
      sliders[0]._setText(emptySliderMarkerText);
      sliders[1]._setText(emptySliderMarkerText);
      sliders[0]._value = sliders[1]._value = undefined;
      sliders[0]._position = that._params.translator.getScreenRange()[0];
      sliders[1]._position = that._params.translator.getScreenRange()[1];
      that._applyTotalPosition(false);
      suppressSetSelectedRange(that);
    } else {
      restoreSetSelectedRange(that);
    }
  },
  _applyTotalPosition: function (isAnimated) {
    const sliders = this._sliders;
    isAnimated = this._animationEnabled && isAnimated;
    sliders[0].applyPosition(isAnimated);
    sliders[1].applyPosition(isAnimated);
    const areOverlapped = sliders[0].getCloudBorder() > sliders[1].getCloudBorder();
    sliders[0].setOverlapped(areOverlapped);
    sliders[1].setOverlapped(areOverlapped);
    this._applyAreaTrackersPosition();
    this._applySelectedRangePosition(isAnimated);
  },
  _applyAreaTrackersPosition: function () {
    const that = this;
    const position1 = that._sliders[0].getPosition();
    const position2 = that._sliders[1].getPosition();
    that._selectedAreaTracker.attr({
      points: buildRectPoints(position1, that._verticalRange[0], position2, that._verticalRange[1])
    }).css({
      cursor: Math.abs(that._params.translator.getScreenRange()[1] - that._params.translator.getScreenRange()[0] - position2 + position1) < 0.001 ? 'default' : 'pointer'
    });
  },
  _applySelectedRangePosition: function (isAnimated) {
    const that = this;
    const verticalRange = that._verticalRange;
    const pos1 = that._sliders[0].getPosition();
    const pos2 = that._sliders[1].getPosition();
    let screenRange;
    let points;
    if (that._isCompactMode) {
      points = [pos1 + Math.ceil(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2, pos2 - Math.floor(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2];
    } else {
      screenRange = that._params.axis.getVisibleArea();
      points = [buildRectPoints(screenRange[0], verticalRange[0], Math.max(pos1 - Math.floor(that._shutterOffset), screenRange[0]), verticalRange[1]), buildRectPoints(screenRange[1], verticalRange[0], Math.min(pos2 + Math.ceil(that._shutterOffset), screenRange[1]), verticalRange[1])];
    }
    if (isAnimated) {
      that._shutter.animate({
        points: points
      }, animationSettings);
    } else {
      that._shutter.attr({
        points: points
      });
    }
  },
  getSelectedRange: function () {
    return {
      startValue: this._sliders[0].getValue(),
      endValue: this._sliders[1].getValue()
    };
  },
  setSelectedRange: function (visualRange, e) {
    visualRange = visualRange || {};
    const that = this;
    const translator = that._params.translator;
    const businessRange = translator.getBusinessRange();
    const compare = businessRange.axisType === 'discrete' ? function (a, b) {
      return a < b;
    } : function (a, b) {
      return a <= b;
    };
    let {
      startValue,
      endValue
    } = (0, _utils.adjustVisualRange)({
      dataType: businessRange.dataType,
      axisType: businessRange.axisType,
      base: businessRange.base
    }, {
      startValue: translator.isValid(visualRange.startValue) ? translator.getCorrectValue(visualRange.startValue, +1) : undefined,
      endValue: translator.isValid(visualRange.endValue) ? translator.getCorrectValue(visualRange.endValue, -1) : undefined,
      length: visualRange.length
    }, {
      min: businessRange.minVisible,
      max: businessRange.maxVisible,
      categories: businessRange.categories
    });
    startValue = (0, _type.isNumeric)(startValue) ? (0, _math.adjust)(startValue) : startValue;
    endValue = (0, _type.isNumeric)(endValue) ? (0, _math.adjust)(endValue) : endValue;
    const values = compare(translator.to(startValue, -1), translator.to(endValue, +1)) ? [startValue, endValue] : [endValue, startValue];
    that._sliders[0].setDisplayValue(values[0]);
    that._sliders[1].setDisplayValue(values[1]);
    that._sliders[0]._position = translator.to(values[0], -1);
    that._sliders[1]._position = translator.to(values[1], +1);
    that._applyTotalPosition(true);
    that._processSelectionChanged(e);
  },
  beginSelectedAreaMoving: function (initialPosition) {
    const that = this;
    const sliders = that._sliders;
    const offset = (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - initialPosition;
    let currentPosition = initialPosition;
    move.complete = function (e) {
      that._dockSelectedArea(e);
    };
    return move;
    function move(position, e) {
      if (position !== currentPosition && position > currentPosition === position > (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - offset) {
        that._moveSelectedArea(position + offset, false, e);
      }
      currentPosition = position;
    }
  },
  _dockSelectedArea: function (e) {
    const translator = this._params.translator;
    const sliders = this._sliders;
    sliders[0]._position = translator.to(sliders[0].getValue(), -1);
    sliders[1]._position = translator.to(sliders[1].getValue(), +1);
    this._applyTotalPosition(true);
    this._processSelectionChanged(e);
  },
  moveSelectedArea: function (screenPosition, e) {
    this._moveSelectedArea(screenPosition, true, e);
    this._dockSelectedArea(e);
  },
  _moveSelectedArea: function (screenPosition, isAnimated, e) {
    const that = this;
    const translator = that._params.translator;
    const sliders = that._sliders;
    const interval = sliders[1].getPosition() - sliders[0].getPosition();
    let startPosition = screenPosition - interval / 2;
    let endPosition = screenPosition + interval / 2;
    if (startPosition < translator.getScreenRange()[0]) {
      startPosition = translator.getScreenRange()[0];
      endPosition = startPosition + interval;
    }
    if (endPosition > translator.getScreenRange()[1]) {
      endPosition = translator.getScreenRange()[1];
      startPosition = endPosition - interval;
    }

    // Check for "minRange" and "maxRange" is not performed because it was not performed in the previous code, though I find it strange.
    const startValue = selectClosestValue(translator.from(startPosition, -1), that._values);
    sliders[0].setDisplayValue(startValue);
    sliders[1].setDisplayValue(selectClosestValue(translator.from(translator.to(startValue, -1) + interval, +1), that._values));
    sliders[0]._position = startPosition;
    sliders[1]._position = endPosition;
    that._applyTotalPosition(isAnimated);
    if (that._isOnMoving) {
      that._processSelectionChanged(e);
    }
  },
  placeSliderAndBeginMoving: function (firstPosition, secondPosition, e) {
    const that = this;
    const translator = that._params.translator;
    const sliders = that._sliders;
    const index = firstPosition < secondPosition ? 0 : 1;
    const dir = index > 0 ? +1 : -1;
    const compare = index > 0 ? isGreater : isLess;
    const antiCompare = index > 0 ? isLess : isGreater;
    let thresholdPosition;
    const positions = [];
    const values = [];
    values[index] = translator.from(firstPosition, dir);
    values[1 - index] = translator.from(secondPosition, -dir);
    positions[1 - index] = secondPosition;
    if (translator.isValueProlonged) {
      // Ensure that first value is strictly to the outer side from the "firstPosition".
      if (compare(firstPosition, translator.to(values[index], dir))) {
        values[index] = translator.from(firstPosition, -dir);
      }
      // Check - if "secondPosition" is closer to "firstPosition" than a span of a single category.
      if (compare(secondPosition, translator.to(values[index], -dir))) {
        values[1 - index] = values[index];
      }
    }
    if (that._minRange) {
      thresholdPosition = translator.to(translator.add(selectClosestValue(values[index], that._values), that._minRange, -dir), -dir);
      // Check - if "secondPosition" is closer to "firstPosition" than it is allowed by "minRange".
      if (compare(secondPosition, thresholdPosition)) {
        values[1 - index] = translator.add(values[index], that._minRange, -dir);
      }
      thresholdPosition = translator.to(translator.add(translator.getRange()[1 - index], that._minRange, dir), -dir);
      // Check - if "firstPosition" is closer to an end than it is allowed by "minRange".
      // So there is definitely not enough space for both sliders - the first  (as the one which is farther from the end) has to be moved away by "minRange".
      if (antiCompare(firstPosition, thresholdPosition)) {
        values[1 - index] = translator.getRange()[1 - index];
        values[index] = translator.add(values[1 - index], that._minRange, dir);
        positions[1 - index] = firstPosition;
      }
    }
    values[0] = selectClosestValue(values[0], that._values);
    values[1] = selectClosestValue(values[1], that._values);
    positions[index] = translator.to(values[index], dir);
    sliders[0].setDisplayValue(values[0]);
    sliders[1].setDisplayValue(values[1]);
    sliders[0]._position = positions[0];
    sliders[1]._position = positions[1];
    that._applyTotalPosition(true);
    if (that._isOnMoving) {
      that._processSelectionChanged(e);
    }
    const handler = that.beginSliderMoving(1 - index, secondPosition);
    sliders[1 - index]._sliderGroup.stopAnimation();
    that._shutter.stopAnimation();
    handler(secondPosition);
    return handler;
  },
  beginSliderMoving: function (initialIndex, initialPosition) {
    const that = this;
    const translator = that._params.translator;
    const sliders = that._sliders;
    const minPosition = translator.getScreenRange()[0];
    const maxPosition = translator.getScreenRange()[1];
    let index = initialIndex;
    const staticPosition = sliders[1 - index].getPosition();
    let currentPosition = initialPosition;
    let dir = index > 0 ? +1 : -1;
    let compareMin = index > 0 ? isLess : isGreater;
    let compareMax = index > 0 ? isGreater : isLess;
    let moveOffset = sliders[index].getPosition() - initialPosition;
    let swapOffset = compareMin(sliders[index].getPosition(), initialPosition) ? -moveOffset : moveOffset;
    move.complete = function (e) {
      sliders[index]._setValid(true);
      that._dockSelectedArea(e);
    };
    return move;
    function move(position, e) {
      let isValid;
      let temp;
      let pos;
      let slider;
      let value;
      if (position !== currentPosition) {
        if (compareMin(position + swapOffset, staticPosition)) {
          isValid = that._allowSlidersSwap;
          // TODO: Validate "_minRange" so that for discrete translator it is always null - that will allow to split "isValueProlonged" and "_minRange" checks
          if (isValid && !translator.isValueProlonged && that._minRange) {
            isValid = translator.isValid(translator.add(sliders[1 - index].getValue(), that._minRange, -dir));
          }
          if (isValid) {
            that._changeMovingSlider(index);
            index = 1 - index;
            dir = -dir;
            temp = compareMin;
            compareMin = compareMax;
            compareMax = temp;
            moveOffset = -dir * Math.abs(moveOffset);
            swapOffset = -moveOffset;
          }
        }
        if (compareMax(position + moveOffset, staticPosition)) {
          slider = sliders[index];
          value = sliders[1 - index].getValue();
          pos = Math.max(Math.min(position + moveOffset, maxPosition), minPosition);
          // TODO: Write it as single operation (isValid = ... && ... && ...) when code is stable.
          // Check - if moving slider is closer to static slider than a span of a single category.
          isValid = translator.isValueProlonged ? !compareMin(pos, translator.to(value, dir)) : true;
          let invalidStateValue;
          // Check - if moving slider is closer to static slider than it is allowed "minRange".
          if (isValid && that._minRange) {
            isValid = !compareMin(pos, translator.to(translator.add(value, that._minRange, dir), dir));
            if (!isValid) {
              invalidStateValue = translator.add(value, that._minRange, dir);
            }
          }
          // Check - if moving slider is farther from static slider than it is allowed by "maxRange"
          if (isValid && that._maxRange) {
            isValid = !compareMax(pos, translator.to(translator.add(value, that._maxRange, dir), dir));
            if (!isValid) {
              invalidStateValue = translator.add(value, that._maxRange, dir);
            }
          }
          slider._setValid(isValid);
          slider.setDisplayValue(isValid ? selectClosestValue(translator.from(pos, dir), that._values) : (0, _type.isDefined)(invalidStateValue) ? invalidStateValue : slider.getValue());
          slider._position = pos;
          that._applyTotalPosition(false);
          slider.toForeground();
          if (that._isOnMoving) {
            that._processSelectionChanged(e);
          }
        }
      }
      currentPosition = position;
    }
  },
  _changeMovingSlider: function (index) {
    const that = this;
    const translator = that._params.translator;
    const sliders = that._sliders;
    const position = sliders[1 - index].getPosition();
    const dir = index > 0 ? +1 : -1;
    let newValue;
    sliders[index].setDisplayValue(selectClosestValue(translator.from(position, dir), that._values));
    newValue = translator.from(position, -dir);
    if (translator.isValueProlonged) {
      newValue = translator.from(position, dir);
    } else if (that._minRange) {
      // TODO: Consider adding "translator.isValid" check - that will allow to split "if-else" into two "if"
      newValue = translator.add(newValue, that._minRange, -dir);
    }
    sliders[1 - index].setDisplayValue(selectClosestValue(newValue, that._values));
    sliders[index]._setValid(true);
    sliders[index]._marker._update(); // This is to update "text" element
    sliders[0]._position = sliders[1]._position = position;
  },
  foregroundSlider: function (index) {
    this._sliders[index].toForeground();
  }
};

/***/ }),

/***/ 43695:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Tracker = Tracker;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _iterator = __webpack_require__(95479);
var _support = __webpack_require__(60137);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const MIN_MANUAL_SELECTING_WIDTH = 10;
const window = (0, _window.getWindow)();
function isLeftButtonPressed(event) {
  const e = event || window.event;
  const originalEvent = e.originalEvent;
  const touches = e.touches;
  const pointerType = originalEvent ? originalEvent.pointerType : false;
  const eventTouches = originalEvent ? originalEvent.touches : false;
  const isMSPointerLeftClick = originalEvent && pointerType !== undefined && (pointerType === (originalEvent.MSPOINTER_TYPE_TOUCH || 'touch') || pointerType === (originalEvent.MSPOINTER_TYPE_MOUSE || 'mouse') && originalEvent.buttons === 1);
  const isTouches = touches && touches.length > 0 || eventTouches && eventTouches.length > 0;
  return e.which === 1 || isMSPointerLeftClick || isTouches;
}
function isMultiTouches(event) {
  const originalEvent = event.originalEvent;
  const touches = event.touches;
  const eventTouches = originalEvent && originalEvent.touches;
  return touches && touches.length > 1 || eventTouches && eventTouches.length > 1 || null;
}
function preventDefault(e) {
  if (!isMultiTouches(e)) {
    e.preventDefault();
  }
}
function stopPropagationAndPreventDefault(e) {
  if (!isMultiTouches(e)) {
    e.stopPropagation();
    e.preventDefault();
  }
}

// Q375042
function isTouchEventArgs(e) {
  return e && e.type && e.type.indexOf('touch') === 0;
}
function getEventPageX(event) {
  const originalEvent = event.originalEvent;
  let result = 0;
  if (event.pageX) {
    result = event.pageX;
  } else if (originalEvent && originalEvent.pageX) {
    result = originalEvent.pageX;
  }
  if (originalEvent && originalEvent.touches) {
    if (originalEvent.touches.length > 0) {
      result = originalEvent.touches[0].pageX;
    } else if (originalEvent.changedTouches.length > 0) {
      result = originalEvent.changedTouches[0].pageX;
    }
  }
  return result;
}
function initializeAreaEvents(controller, area, state, getRootOffsetLeft) {
  let isTouchEvent;
  let isActive = false;
  let initialPosition;
  let movingHandler = null;
  const docEvents = {
    [_pointer.default.move](e) {
      let position;
      let offset;
      if (isTouchEvent !== isTouchEventArgs(e)) return;
      if (!isLeftButtonPressed(e)) {
        cancel(e);
      }
      if (isActive) {
        position = getEventPageX(e);
        offset = getRootOffsetLeft();
        if (movingHandler) {
          movingHandler(position - offset, e);
        } else {
          if (state.manualRangeSelectionEnabled && Math.abs(initialPosition - position) >= MIN_MANUAL_SELECTING_WIDTH) {
            movingHandler = controller.placeSliderAndBeginMoving(initialPosition - offset, position - offset, e);
          }
        }
      }
    },
    [_pointer.default.up](e) {
      let position;
      if (isActive) {
        position = getEventPageX(e);
        if (!movingHandler && state.moveSelectedRangeByClick && Math.abs(initialPosition - position) < MIN_MANUAL_SELECTING_WIDTH) {
          controller.moveSelectedArea(position - getRootOffsetLeft(), e);
        }
        cancel(e);
      }
    }
  };
  function cancel(e) {
    if (isActive) {
      isActive = false;
      if (movingHandler) {
        movingHandler.complete(e);
        movingHandler = null;
      }
    }
  }
  area.on(_pointer.default.down, function (e) {
    if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
    isActive = true;
    isTouchEvent = isTouchEventArgs(e);
    initialPosition = getEventPageX(e);
  });
  return docEvents;
}
function initializeSelectedAreaEvents(controller, area, state, getRootOffsetLeft) {
  let isTouchEvent;
  let isActive = false;
  let movingHandler = null;
  const docEvents = {
    [_pointer.default.move](e) {
      if (isTouchEvent !== isTouchEventArgs(e)) return;
      if (!isLeftButtonPressed(e)) {
        cancel(e);
      }
      if (isActive) {
        preventDefault(e);
        movingHandler(getEventPageX(e) - getRootOffsetLeft(), e);
      }
    },
    [_pointer.default.up]: cancel
  };
  function cancel(e) {
    if (isActive) {
      isActive = false;
      movingHandler.complete(e);
      movingHandler = null;
    }
  }
  area.on(_pointer.default.down, function (e) {
    if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
    isActive = true;
    isTouchEvent = isTouchEventArgs(e);
    movingHandler = controller.beginSelectedAreaMoving(getEventPageX(e) - getRootOffsetLeft());
    stopPropagationAndPreventDefault(e);
  });
  return docEvents;
}
function initializeSliderEvents(controller, sliders, state, getRootOffsetLeft) {
  let isTouchEvent;
  let isActive = false;
  let movingHandler = null;
  const docEvents = {
    [_pointer.default.move](e) {
      if (isTouchEvent !== isTouchEventArgs(e)) return;
      if (!isLeftButtonPressed(e)) {
        cancel(e);
      }
      if (isActive) {
        preventDefault(e);
        movingHandler(getEventPageX(e) - getRootOffsetLeft(), e);
      }
    },
    [_pointer.default.up]: cancel
  };
  (0, _iterator.each)(sliders, function (i, slider) {
    slider.on({
      [_pointer.default.down](e) {
        if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
        isActive = true;
        isTouchEvent = isTouchEventArgs(e);
        movingHandler = controller.beginSliderMoving(i, getEventPageX(e) - getRootOffsetLeft());
        stopPropagationAndPreventDefault(e);
      },
      [_pointer.default.move]() {
        if (!movingHandler) {
          controller.foregroundSlider(i);
        }
      }
    });
  });
  function cancel(e) {
    if (isActive) {
      isActive = false;
      movingHandler.complete(e);
      movingHandler = null;
    }
  }
  return docEvents;
}
function Tracker(params) {
  const state = this._state = {};
  const targets = params.controller.getTrackerTargets();
  if (_support.pointerEvents) {
    params.renderer.root.css({
      'msTouchAction': 'pinch-zoom'
    });
  }
  this._docEvents = [initializeSelectedAreaEvents(params.controller, targets.selectedArea, state, getRootOffsetLeft), initializeAreaEvents(params.controller, targets.area, state, getRootOffsetLeft), initializeSliderEvents(params.controller, targets.sliders, state, getRootOffsetLeft)];
  // TODO: 3 "move" and 3 "end" events - do we really need that much?
  (0, _iterator.each)(this._docEvents, function (_, events) {
    _events_engine.default.on(_dom_adapter.default.getDocument(), events);
  });
  function getRootOffsetLeft() {
    return params.renderer.getRootOffset().left;
  }
}
Tracker.prototype = {
  constructor: Tracker,
  dispose: function () {
    (0, _iterator.each)(this._docEvents, function (_, events) {
      _events_engine.default.off(_dom_adapter.default.getDocument(), events);
    });
  },
  update: function (enabled, behavior) {
    const state = this._state;
    state.enabled = enabled;
    state.moveSelectedRangeByClick = behavior.moveSelectedRangeByClick;
    state.manualRangeSelectionEnabled = behavior.manualRangeSelectionEnabled;
  }
};

/***/ }),

/***/ 34377:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _sankey = _interopRequireDefault(__webpack_require__(66422));
var _tooltip = __webpack_require__(38516);
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _tracker = __webpack_require__(29823);
var _tooltip2 = __webpack_require__(14371);
var _loading_indicator = __webpack_require__(64758);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
_sankey.default.addPlugin(_export.plugin);
_sankey.default.addPlugin(_title.plugin);
_sankey.default.addPlugin(_tracker.plugin);
_sankey.default.addPlugin(_loading_indicator.plugin);
_sankey.default.addPlugin(_tooltip2.plugin);
(0, _tooltip.setTooltipCustomOptions)(_sankey.default);
var _default = exports["default"] = _sankey.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 74878:
/***/ (function(__unused_webpack_module, exports) {



exports.COLOR_MODE_TARGET = exports.COLOR_MODE_SOURCE = exports.COLOR_MODE_NONE = exports.COLOR_MODE_GRADIENT = void 0;
const COLOR_MODE_GRADIENT = exports.COLOR_MODE_GRADIENT = 'gradient';
const COLOR_MODE_SOURCE = exports.COLOR_MODE_SOURCE = 'source';
const COLOR_MODE_TARGET = exports.COLOR_MODE_TARGET = 'target';
const COLOR_MODE_NONE = exports.COLOR_MODE_NONE = 'none';

/***/ }),

/***/ 86547:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _graph = _interopRequireDefault(__webpack_require__(65538));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const validator = {
  validate: function (data, incidentOccurred) {
    let result = null;
    if (this._hasCycle(data)) {
      result = 'E2006';
      incidentOccurred('E2006');
    }
    return result;
  },
  _hasCycle: function (data) {
    return _graph.default.struct.hasCycle(data);
  }
};
var _default = exports["default"] = validator;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 65538:
/***/ (function(module, exports) {



exports["default"] = void 0;
const WHITE = 'white';
const GRAY = 'gray';
const BLACK = 'black';
const routines = {
  maxOfArray: function (arr, callback) {
    let m = 0;
    let callback_function = v => {
      return v;
    };
    if (callback) {
      callback_function = callback;
    }
    for (let i = 0; i < arr.length; i++) {
      if (callback_function(arr[i]) > m) m = callback_function(arr[i]);
    }
    return m;
  }
};
const getVertices = function (links) {
  const vert = [];
  links.forEach(link => {
    if (vert.indexOf(link[0]) === -1) {
      vert.push(link[0]);
    }
    if (vert.indexOf(link[1]) === -1) {
      vert.push(link[1]);
    }
  });
  return vert;
};
const getAdjacentVertices = function (links, vertex) {
  const avert = [];
  links.forEach(link => {
    if (link[0] === vertex && avert.indexOf(link[1]) === -1) {
      avert.push(link[1]);
    }
  });
  return avert;
};
const getReverseAdjacentVertices = function (links, vertex) {
  const avert = [];
  links.forEach(link => {
    if (link[1] === vertex && avert.indexOf(link[0]) === -1) {
      avert.push(link[0]);
    }
  });
  return avert;
};
const struct = {
  _hasCycle: false,
  _sortedList: [],
  hasCycle: function (links) {
    // detects if the graph has cycle
    // sorts the vertices (modifies the _sortedList variable)
    this._hasCycle = false;
    this._sortedList = [];
    const vertices = {};
    const allVertices = getVertices(links);
    allVertices.forEach(vertex => {
      vertices[vertex] = {
        color: WHITE
      };
    });
    allVertices.forEach(vertex => {
      if (vertices[vertex].color === WHITE) {
        this._depthFirstSearch(links, vertices, vertex);
      }
    });
    this._sortedList.reverse();
    return this._hasCycle;
  },
  _depthFirstSearch: function (links, vertices, vertex) {
    vertices[vertex].color = GRAY;
    const averts = getAdjacentVertices(links, vertex);
    for (let a = 0; a < averts.length; a++) {
      if (vertices[averts[a]].color === WHITE) {
        this._depthFirstSearch(links, vertices, averts[a]);
      } else if (vertices[averts[a]].color === GRAY) {
        this._hasCycle = true;
      }
    }
    this._sortedList.push({
      name: vertex,
      lp: null,
      incoming: getReverseAdjacentVertices(links, vertex),
      outgoing: getAdjacentVertices(links, vertex)
    });
    vertices[vertex].color = BLACK;
  },
  computeLongestPaths(links) {
    // calculates longets paths for all vertices
    // method expects sorted vertices array to be in this._sortedList
    const sortedVertices = this._sortedList;
    sortedVertices.forEach(vertex => {
      const averts = getReverseAdjacentVertices(links, vertex.name); // neigbours who INCOME to the vertex
      if (averts.length === 0) {
        vertex.lp = 0; // 'lp' means 'Longest Path'
      } else {
        const maxLP = [];
        // get max through avertex.lp and add 1 to it
        averts.forEach(adjacentVertex => {
          maxLP.push(sortedVertices.filter(sv => sv.name === adjacentVertex)[0].lp);
        });
        vertex.lp = routines.maxOfArray(maxLP) + 1;
      }
    });
    return this._sortedList;
  }
};
var _default = exports["default"] = {
  struct: struct,
  routines: routines,
  getVertices: getVertices,
  getAdjacentVertices: getAdjacentVertices,
  getReverseAdjacentVertices: getReverseAdjacentVertices
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 68856:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.layout = void 0;
var _graph = _interopRequireDefault(__webpack_require__(65538));
var _data_validator = _interopRequireDefault(__webpack_require__(86547));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _SPLINE_TENSION = 0.3;
const _ALIGNMENT_CENTER = 'center';
const _ALIGNMENT_BOTTOM = 'bottom';
const _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;
const layout = exports.layout = {
  _weightPerPixel: null,
  _getCascadeIdx: function (nodeTitle, cascadesConfig) {
    const nodeInfo = cascadesConfig.filter(c => {
      return c.name === nodeTitle;
    })[0];
    if (nodeInfo.outgoing.length > 0) {
      // in common case number of cascade is the longest path to the node
      return nodeInfo.lp;
    } else {
      // but if the node is last (ie has no outgoing edges) lets move it to the LAST cascade
      return _graph.default.routines.maxOfArray(cascadesConfig.map(c => {
        return c.lp;
      }));
    }
  },
  _getInWeightForNode: function (nodeTitle, links) {
    let w = 0;
    links.forEach(link => {
      if (link[1] === nodeTitle) {
        w += link[2];
      }
    });
    return w;
  },
  _getOutWeightForNode: function (nodeTitle, links) {
    let w = 0;
    links.forEach(link => {
      if (link[0] === nodeTitle) {
        w += link[2];
      }
    });
    return w;
  },
  _computeCascades: function (links) {
    const cascadesConfig = _graph.default.struct.computeLongestPaths(links);
    const maxCascade = _graph.default.routines.maxOfArray(cascadesConfig.map(c => {
      return c.lp;
    }));
    const cascades = [];

    // init cascades
    for (let i = 0; i < maxCascade + 1; i++) {
      cascades.push({});
    }

    // add nodes to cascades
    links.forEach(link => {
      let cascade = cascades[this._getCascadeIdx(link[0], cascadesConfig)];
      if (!cascade[link[0]]) {
        cascade[link[0]] = {
          nodeTitle: link[0]
        };
      }
      cascade = cascades[this._getCascadeIdx(link[1], cascadesConfig)];
      if (!cascade[link[1]]) {
        cascade[link[1]] = {
          nodeTitle: link[1]
        };
      }
    });

    // compute in and out weightes of all nodes of cascades
    cascades.forEach(cascade => {
      Object.keys(cascade).forEach(nodeTitle => {
        const node = cascade[nodeTitle];
        node.inWeight = this._getInWeightForNode(node.nodeTitle, links);
        node.outWeight = this._getOutWeightForNode(node.nodeTitle, links);
        node.maxWeight = Math.max(node.inWeight, node.outWeight);
      });
    });
    return cascades;
  },
  _getWeightForCascade: function (cascades, cascadeIdx) {
    let wMax = 0;
    const cascade = cascades[cascadeIdx];
    Object.keys(cascade).forEach(nodeTitle => {
      wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight);
    });
    return wMax;
  },
  _getMaxWeightThroughCascades: function (cascades) {
    const max = [];
    cascades.forEach(cascade => {
      let mW = 0;
      Object.keys(cascade).forEach(nodeTitle => {
        const node = cascade[nodeTitle];
        mW += Math.max(node.inWeight, node.outWeight);
      });
      max.push(mW);
    });
    return _graph.default.routines.maxOfArray(max);
  },
  _computeNodes: function (cascades, options) {
    const rects = [];
    const maxWeight = this._getMaxWeightThroughCascades(cascades);
    const maxNodeNum = _graph.default.routines.maxOfArray(cascades.map(nodesInCascade => Object.keys(nodesInCascade).length));
    let nodePadding = options.nodePadding;
    let heightAvailable = options.height - nodePadding * (maxNodeNum - 1);
    if (heightAvailable < 0) {
      // when the available height is too small, e.g. sum of all paddings is more then available height
      nodePadding = 0;
      heightAvailable = options.height - nodePadding * (maxNodeNum - 1);
    }
    this._weightPerPixel = maxWeight / heightAvailable;

    // compute in and out weightes of all nodes of cascades
    let cascadeIdx = 0;
    cascades.forEach(cascade => {
      const cascadeRects = [];
      let y = 0;
      const nodesInCascade = Object.keys(cascade).length;
      const cascadeHeight = this._getWeightForCascade(cascades, cascadeIdx) / this._weightPerPixel + nodePadding * (nodesInCascade - 1);
      let cascadeAlign;
      if (Array.isArray(options.nodeAlign)) {
        cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT;
      } else {
        cascadeAlign = options.nodeAlign;
      }
      if (cascadeAlign === _ALIGNMENT_BOTTOM) {
        y = options.height - cascadeHeight;
      } else if (cascadeAlign === _ALIGNMENT_CENTER) {
        y = 0.5 * (options.height - cascadeHeight);
      }
      y = Math.round(y);
      Object.keys(cascade).forEach(nodeTitle => {
        cascade[nodeTitle].sort = this._sort && Object.prototype.hasOwnProperty.call(this._sort, nodeTitle) ? this._sort[nodeTitle] : 1;
      });
      Object.keys(cascade).sort((a, b) => {
        return cascade[a].sort - cascade[b].sort;
      }).forEach(nodeTitle => {
        const node = cascade[nodeTitle];
        const height = Math.floor(heightAvailable * node.maxWeight / maxWeight);
        const x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (cascadeIdx === 0 ? 0 : options.nodeWidth);
        const rect = {};
        rect._name = nodeTitle;
        rect.width = options.nodeWidth;
        rect.height = height;
        rect.x = x + options.x;
        rect.y = y + options.y;
        y += height + nodePadding;
        cascadeRects.push(rect);
      });
      cascadeIdx++;
      rects.push(cascadeRects);
    });
    return rects;
  },
  _findRectByName: function (rects, name) {
    for (let c = 0; c < rects.length; c++) {
      for (let r = 0; r < rects[c].length; r++) {
        if (name === rects[c][r]._name) return rects[c][r];
      }
    }
    return null;
  },
  _findIndexByName: function (rects, nodeTitle) {
    let index = 0;
    for (let c = 0; c < rects.length; c++) {
      for (let r = 0; r < rects[c].length; r++) {
        if (nodeTitle === rects[c][r]._name) return index;
        index++;
      }
    }
    return null;
  },
  _computeLinks: function (links, rects, cascades) {
    const yOffsets = {};
    const paths = [];
    const result = [];
    cascades.forEach(cascade => {
      Object.keys(cascade).forEach(nodeTitle => {
        yOffsets[nodeTitle] = {
          in: 0,
          out: 0
        };
      });
    });
    rects.forEach(rectsOfCascade => {
      rectsOfCascade.forEach(nodeRect => {
        const nodeTitle = nodeRect._name;
        const rectFrom = this._findRectByName(rects, nodeTitle);
        const linksFromNode = links.filter(link => {
          return link[0] === nodeTitle;
        }); // all outgoing links from the node

        // all outgoing links should be sorted according to the order of their target nodes
        linksFromNode.forEach(link => {
          link.sort = this._findIndexByName(rects, link[1]);
        });
        linksFromNode.sort((a, b) => {
          return a.sort - b.sort;
        }).forEach(link => {
          const rectTo = this._findRectByName(rects, link[1]);
          const height = Math.round(link[2] / this._weightPerPixel);
          const yOffsetFrom = yOffsets[link[0]].out;
          const yOffsetTo = yOffsets[link[1]].in;
          // heights of left and right parts of the link must fit the nodes on it's left and right
          const heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;
          const heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;
          paths.push({
            from: {
              x: rectFrom.x,
              y: rectFrom.y + yOffsetFrom,
              width: rectFrom.width,
              height: heightFrom,
              node: rectFrom,
              weight: link[2]
            },
            to: {
              x: rectTo.x,
              y: rectTo.y + yOffsetTo,
              width: rectTo.width,
              height: heightTo,
              node: rectTo
            }
          });
          yOffsets[link[0]].out += height;
          yOffsets[link[1]].in += height;
        });
      });
    });
    paths.forEach(link => {
      const path = {
        d: this._spline(link.from, link.to),
        _boundingRect: {
          x: link.from.x + link.from.width,
          y: Math.min(link.from.y, link.to.y),
          width: link.to.x - (link.from.x + link.from.width),
          height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)
        },
        _weight: link.from.weight,
        _from: link.from.node,
        _to: link.to.node
      };
      result.push(path);
    });
    this._fitAllNodesHeight(rects, paths);
    return result;
  },
  _fitNodeHeight: function (nodeName, nodeRects, paths) {
    const targetRect = this._findRectByName(nodeRects, nodeName);
    let heightOfLinksSummaryIn = 0;
    let heightOfLinksSummaryOut = 0;
    paths.forEach(function (path) {
      if (path.from.node._name === nodeName) {
        heightOfLinksSummaryOut += path.from.height;
      }
      if (path.to.node._name === nodeName) {
        heightOfLinksSummaryIn += path.to.height;
      }
    });
    targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut);
  },
  _fitAllNodesHeight: function (nodeRects, paths) {
    for (let c = 0; c < nodeRects.length; c++) {
      for (let r = 0; r < nodeRects[c].length; r++) {
        this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths);
      }
    }
  },
  _spline: function (rectLeft, rectRight) {
    const p_UpLeft = {
      x: rectLeft.x + rectLeft.width,
      y: rectLeft.y
    };
    const p_DownLeft = {
      x: rectLeft.x + rectLeft.width,
      y: rectLeft.y + rectLeft.height
    };
    const p_UpRight = {
      x: rectRight.x,
      y: rectRight.y
    };
    const p_DownRight = {
      x: rectRight.x,
      y: rectRight.y + rectRight.height
    };
    const curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);
    const result = `M ${p_UpLeft.x} ${p_UpLeft.y} C ${p_UpLeft.x + curve_width} ${p_UpLeft.y} ${p_UpRight.x - curve_width} ${p_UpRight.y} ${p_UpRight.x} ${p_UpRight.y} L ${p_DownRight.x} ${p_DownRight.y} C ${p_DownRight.x - curve_width} ${p_DownRight.y} ${p_DownLeft.x + curve_width} ${p_DownLeft.y} ${p_DownLeft.x} ${p_DownLeft.y} Z`;
    return result;
  },
  computeLayout: function (linksData, sortData, options, incidentOccurred) {
    this._sort = sortData;
    const result = {};
    const validateResult = _data_validator.default.validate(linksData, incidentOccurred);
    if (!validateResult) {
      result.cascades = this._computeCascades(linksData);
      result.nodes = this._computeNodes(result.cascades, {
        width: options.availableRect.width,
        height: options.availableRect.height,
        x: options.availableRect.x,
        y: options.availableRect.y,
        nodePadding: options.nodePadding,
        nodeWidth: options.nodeWidth,
        nodeAlign: options.nodeAlign
      });
      result.links = this._computeLinks(linksData, result.nodes, result.cascades);
    } else {
      result.error = validateResult;
    }
    return result;
  },
  overlap: function (box1, box2) {
    return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y);
  }
};

/***/ }),

/***/ 18170:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _constants = __webpack_require__(74878);
var _type = __webpack_require__(35922);
const states = ['normal', 'adjacentNodeHover', 'hover'];
function compileAttrs(color, itemOptions, itemBaseOptions, gradient) {
  const border = itemOptions.border;
  const baseBorder = itemBaseOptions.border;
  const borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  const borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  const borderOpacity = (0, _type.isDefined)(border.opacity) ? border.opacity : (0, _type.isDefined)(baseBorder.opacity) ? baseBorder.opacity : 1;
  const opacity = (0, _type.isDefined)(itemOptions.opacity) ? itemOptions.opacity : (0, _type.isDefined)(itemBaseOptions.opacity) ? itemBaseOptions.opacity : 1;
  let fill = itemOptions.color || color;
  if (itemBaseOptions.colorMode === _constants.COLOR_MODE_TARGET || itemBaseOptions.colorMode === _constants.COLOR_MODE_SOURCE) {
    fill = color;
  } else if (itemBaseOptions.colorMode === _constants.COLOR_MODE_GRADIENT && gradient && (0, _type.isDefined)(gradient.id)) {
    fill = gradient.id;
  }
  return {
    fill: fill,
    'stroke-width': borderVisible ? borderWidth : 0,
    stroke: itemOptions.border.color || itemBaseOptions.border.color,
    'stroke-opacity': borderOpacity,
    opacity: opacity,
    hatching: itemOptions.hatching
  };
}
function Link(widget, params) {
  const that = this;
  const widgetOffset = widget._renderer.getRootOffset();
  that.code = 0;
  that.widget = widget;
  that.color = params.color;
  that.connection = params.connection;
  that.d = params.d;
  that.options = params.options;
  that.boundingRect = params.boundingRect, that.coords = {
    x: params.boundingRect.x + params.boundingRect.width / 2 + widgetOffset.left,
    y: params.boundingRect.y + params.boundingRect.height / 2 + widgetOffset.top
  };
  that.states = {
    normal: compileAttrs(that.color, that.options, that.options, params.gradient),
    adjacentNodeHover: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options, params.gradient),
    hover: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options, params.gradient)
  };
  that.overlayStates = {
    normal: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options),
    adjacentNodeHover: compileAttrs(that.color, that.options.hoverStyle, that.options),
    hover: compileAttrs(that.color, that.options.hoverStyle, that.options)
  };
}
Link.prototype = {
  getState: function () {
    return states[this.code];
  },
  isHovered: function () {
    return this.code === 2;
  },
  isAdjacentNodeHovered: function () {
    return this.code === 1;
  },
  setState: function (code, state) {
    if (state) {
      this.code = code;
    } else {
      this.code = 0;
      this.hideTooltip();
    }
    this.widget._applyLinksAppearance();
  },
  setHover: function () {
    this.hover(true);
  },
  hover: function (state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }
    this.widget._suspend();
    state && this.widget.clearHover();
    this.setState(2, state);
    this.widget._eventTrigger('linkHoverChanged', {
      target: this
    });
    this.widget._resume();
  },
  adjacentNodeHover: function (state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isAdjacentNodeHovered()) {
      return;
    }
    this.widget._suspend();
    this.setState(1, state);
    this.widget._resume();
  },
  setAdjacentNodeHover: function () {
    this.adjacentNodeHover(true);
  },
  showTooltip: function (coords) {
    this.widget._getOption('hoverEnabled', true) && this.widget._tooltip && this.widget._tooltip.show({
      type: 'link',
      info: {
        source: this.connection.source,
        target: this.connection.target,
        weight: this.connection.weight
      }
    }, typeof coords !== 'undefined' ? {
      x: coords[0],
      y: coords[1]
    } : this.coords);
  },
  hideTooltip: function () {
    this.widget._tooltip && this.widget._tooltip.hide();
  }
};
var _default = exports["default"] = Link;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 47248:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
const states = ['normal', 'hover'];
function compileAttrs(color, itemOptions, itemBaseOptions) {
  const border = itemOptions.border;
  const baseBorder = itemBaseOptions.border;
  const borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  const borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  const borderOpacity = (0, _type.isDefined)(border.opacity) ? border.opacity : (0, _type.isDefined)(baseBorder.opacity) ? baseBorder.opacity : 1;
  const opacity = (0, _type.isDefined)(itemOptions.opacity) ? itemOptions.opacity : (0, _type.isDefined)(itemBaseOptions.opacity) ? itemBaseOptions.opacity : 1;
  return {
    fill: itemOptions.color || color,
    'stroke-width': borderVisible ? borderWidth : 0,
    stroke: itemOptions.border.color || itemBaseOptions.border.color,
    'stroke-opacity': borderOpacity,
    opacity: opacity,
    hatching: itemOptions.hatching
  };
}
function compileLabelAttrs(labelOptions, filter, node) {
  const _patchFontOptions = _utils.patchFontOptions;
  if (labelOptions.useNodeColors) {
    labelOptions.font.color = node.color;
  }
  const borderVisible = (0, _type.isDefined)(labelOptions.border.visible) ? labelOptions.border.visible : false;
  const borderWidth = (0, _type.isDefined)(labelOptions.border.width) ? labelOptions.border.width : 0;
  const borderColor = (0, _type.isDefined)(labelOptions.border.color) ? labelOptions.border.color : labelOptions.font.color;
  const borderOpacity = (0, _type.isDefined)(labelOptions.border.opacity) ? labelOptions.border.opacity : 1;
  const attr = {
    filter: filter
  };
  if (borderVisible && borderWidth) {
    attr.stroke = borderColor;
    attr['stroke-width'] = borderVisible ? borderWidth : 0;
    attr['stroke-opacity'] = borderOpacity;
  }
  return {
    attr: attr,
    css: _patchFontOptions(labelOptions.font)
  };
}
function Node(widget, params) {
  const that = this;
  const widgetOffset = widget._renderer.getRootOffset();
  that.code = 0;
  that.widget = widget;
  that.color = params.color;
  that.options = params.options;
  that.rect = params.rect;
  that.label = that.title = params.rect._name;
  that.coords = {
    x: params.rect.x + params.rect.width / 2 + widgetOffset.left,
    y: params.rect.y + params.rect.height / 2 + widgetOffset.top
  };
  that.id = params.id;
  that.linksIn = params.linksIn;
  that.linksOut = params.linksOut;
  this.states = {
    normal: compileAttrs(this.color, that.options, that.options),
    hover: compileAttrs(this.color, that.options.hoverStyle, that.options)
  };
}
Node.prototype = {
  compileAttrs: function () {
    return compileAttrs(this.color, this.options);
  },
  getState: function () {
    return states[this.code];
  },
  isHovered: function () {
    return !!(this.code & 1);
  },
  setState: function (code, state) {
    if (state) {
      this.code |= code;
    } else {
      this.code &= ~code;
    }
    if (state) {
      this.linksIn.concat(this.linksOut).forEach(adjacentLink => {
        this.widget._links[adjacentLink.index].setAdjacentNodeHover(true);
      });
    } else {
      this.widget._links.forEach(function (link) {
        link.isAdjacentNodeHovered() && link.adjacentNodeHover(false);
      });
      this.hideTooltip();
    }
    this.widget._applyNodesAppearance();
    this.widget._applyLinksAppearance();
  },
  hover: function (state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }
    this.widget._suspend();
    state && this.widget.clearHover();
    this.setState(1, state);
    this.widget._eventTrigger('nodeHoverChanged', {
      target: this
    });
    this.widget._resume();
  },
  setHover: function () {
    this.hover(true);
  },
  showTooltip: function (coords) {
    this.widget._getOption('hoverEnabled', true) && this.widget._tooltip && this.widget._tooltip.show({
      type: 'node',
      info: {
        label: this.label,
        title: this.label,
        weightIn: this.linksIn.reduce(function (previousValue, currentValue) {
          return previousValue + currentValue.weight;
        }, 0),
        weightOut: this.linksOut.reduce(function (previousValue, currentValue) {
          return previousValue + currentValue.weight;
        }, 0)
      }
    }, typeof coords !== 'undefined' ? {
      x: coords[0],
      y: coords[1]
    } : this.coords);
  },
  hideTooltip: function () {
    this.widget._tooltip && this.widget._tooltip.hide();
  },
  getLabelAttributes: function (labelSettings, filter) {
    return compileLabelAttrs(labelSettings, filter, this);
  }
};
var _default = exports["default"] = Node;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 66422:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _constants = __webpack_require__(74878);
var _common = __webpack_require__(20576);
var _node_item = _interopRequireDefault(__webpack_require__(47248));
var _link_item = _interopRequireDefault(__webpack_require__(18170));
var _layout = __webpack_require__(68856);
var _type = __webpack_require__(35922);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function moveLabel(node, labelOptions, availableLabelWidth, rect) {
  if (node._label.getBBox().width > availableLabelWidth) {
    node.labelText.applyEllipsis(availableLabelWidth);
  }
  const bBox = node._label.getBBox();
  const verticalOffset = labelOptions.verticalOffset;
  const horizontalOffset = labelOptions.horizontalOffset;
  let labelOffsetY = Math.round(node.rect.y + node.rect.height / 2 - bBox.y - bBox.height / 2) + verticalOffset;
  let labelOffsetX = node.rect.x + horizontalOffset + node.rect.width - bBox.x;
  if (labelOffsetX + bBox.width >= rect[2] - rect[0]) {
    labelOffsetX = node.rect.x - horizontalOffset - bBox.x - bBox.width;
  }
  if (labelOffsetY >= rect[3]) {
    labelOffsetY = rect[3];
  }
  if (labelOffsetY - bBox.height < rect[1]) {
    labelOffsetY = node.rect.y - bBox.y + verticalOffset;
  }
  node.labelText.attr({
    translateX: labelOffsetX,
    translateY: labelOffsetY
  });
}
function getConnectedLinks(layout, nodeName, linkType) {
  const result = [];
  const attrName = linkType === 'in' ? '_to' : '_from';
  const invertedAttrName = linkType === 'in' ? '_from' : '_to';
  layout.links.map(link => {
    return link[attrName]._name === nodeName;
  }).forEach((connected, idx) => {
    connected && result.push({
      index: idx,
      weight: layout.links[idx]._weight,
      node: layout.links[idx][invertedAttrName]._name
    });
  });
  return result;
}
const dxSankey = _m_base_widget.default.inherit({
  _rootClass: 'dxs-sankey',
  _rootClassPrefix: 'dxs',
  _proxyData: [],
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    sortData: 'DATA_SOURCE',
    alignment: 'DATA_SOURCE',
    node: 'BUILD_LAYOUT',
    label: 'LABELS',
    link: 'BUILD_LAYOUT',
    palette: 'BUILD_LAYOUT',
    paletteExtensionMode: 'BUILD_LAYOUT'
  },
  _themeDependentChanges: ['BUILD_LAYOUT'],
  _getDefaultSize: function () {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'sankey',
  _fontFields: ['label.font'],
  _optionChangesOrder: ['DATA_SOURCE'],
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function () {
    this._groupLinks = this._renderer.g().append(this._renderer.root);
    this._groupNodes = this._renderer.g().append(this._renderer.root);
    this._groupLabels = this._renderer.g().attr({
      class: this._rootClassPrefix + '-labels'
    }).append(this._renderer.root);
    this._drawLabels = true;
    this._nodes = [];
    this._links = [];
    this._gradients = [];
  },
  _disposeCore: _common.noop,
  _applySize: function (rect) {
    this._rect = rect.slice();
    const adaptiveLayout = this._getOption('adaptiveLayout');
    if (adaptiveLayout.keepLabels || this._rect[2] - this._rect[0] > adaptiveLayout.width) {
      this._drawLabels = true;
    } else {
      this._drawLabels = false;
    }
    this._change(['BUILD_LAYOUT']);
    return this._rect;
  },
  _eventsMap: {
    onNodeHoverChanged: {
      name: 'nodeHoverChanged'
    },
    onLinkHoverChanged: {
      name: 'linkHoverChanged'
    }
  },
  _customChangesOrder: ['BUILD_LAYOUT', 'NODES_DRAW', 'LINKS_DRAW', 'LABELS', 'DRAWN'],
  _dataSourceChangedHandler: function () {
    this._requestChange(['BUILD_LAYOUT']);
  },
  _change_DRAWN: function () {
    this._drawn();
  },
  _change_DATA_SOURCE: function () {
    this._change(['DRAWN']);
    this._updateDataSource();
  },
  _change_LABELS: function () {
    this._applyLabelsAppearance();
  },
  _change_BUILD_LAYOUT: function () {
    this._groupNodes.clear();
    this._groupLinks.clear();
    this._groupLabels.clear();
    this._buildLayout();
  },
  _change_NODES_DRAW: function () {
    const that = this;
    const nodes = that._nodes;
    nodes.forEach(function (node, index) {
      const element = that._renderer.rect().attr(node.rect).append(that._groupNodes);
      node.element = element;
    });
    this._applyNodesAppearance();
  },
  _change_LINKS_DRAW: function () {
    const that = this;
    const links = that._links;
    links.forEach(function (link, index) {
      const group = that._renderer.g().attr({
        class: 'link',
        'data-link-idx': index
      }).append(that._groupLinks);
      link.overlayElement = that._renderer.path([], 'area').attr({
        d: link.d
      }).append(group);
      link.element = that._renderer.path([], 'area').attr({
        d: link.d
      }).append(group);
    });
    this._applyLinksAppearance();
  },
  _suspend: function () {
    if (!this._applyingChanges) {
      this._suspendChanges();
    }
  },
  _resume: function () {
    if (!this._applyingChanges) {
      this._resumeChanges();
    }
  },
  _showTooltip: _common.noop,
  hideTooltip: _common.noop,
  clearHover: function () {
    this._suspend();
    this._nodes.forEach(function (node) {
      node.isHovered() && node.hover(false);
    });
    this._links.forEach(function (link) {
      link.isHovered() && link.hover(false);
      link.isAdjacentNodeHovered() && link.adjacentNodeHover(false);
    });
    this._resume();
  },
  _applyNodesAppearance: function () {
    this._nodes.forEach(function (node) {
      const state = node.getState();
      node.element.smartAttr(node.states[state]);
    });
  },
  _applyLinksAppearance: function () {
    this._links.forEach(function (link) {
      const state = link.getState();
      link.element.smartAttr(link.states[state]);
      link.overlayElement.smartAttr(link.overlayStates[state]);
    });
  },
  _hitTestTargets: function (x, y) {
    const that = this;
    let data;
    this._proxyData.some(function (callback) {
      data = callback.call(that, x, y);
      if (data) {
        return true;
      }
    });
    return data;
  },
  _getData: function () {
    const that = this;
    const data = that._dataSourceItems() || [];
    const sourceField = that._getOption('sourceField', true);
    const targetField = that._getOption('targetField', true);
    const weightField = that._getOption('weightField', true);
    const processedData = [];
    data.forEach(function (item) {
      const hasItemOwnProperty = Object.prototype.hasOwnProperty.bind(item);
      if (!hasItemOwnProperty(sourceField)) {
        that._incidentOccurred('E2007', sourceField);
      } else if (!hasItemOwnProperty(targetField)) {
        that._incidentOccurred('E2007', targetField);
      } else if (!hasItemOwnProperty(weightField)) {
        that._incidentOccurred('E2007', weightField);
      } else {
        if (!(0, _type.isString)(item[sourceField])) {
          that._incidentOccurred('E2008', sourceField);
        } else if (!(0, _type.isString)(item[targetField])) {
          that._incidentOccurred('E2008', targetField);
        } else if (!(0, _type.isNumeric)(item[weightField]) || item[weightField] <= 0) {
          that._incidentOccurred('E2009', weightField);
        } else {
          processedData.push([item[sourceField], item[targetField], item[weightField]]);
        }
      }
    });
    return processedData;
  },
  _buildLayout: function () {
    const that = this;
    const data = that._getData();
    const availableRect = this._rect;
    const nodeOptions = that._getOption('node');
    const sortData = that._getOption('sortData');
    const layoutBuilder = that._getOption('layoutBuilder', true) || _layout.layout;
    const rect = {
      x: availableRect[0],
      y: availableRect[1],
      width: availableRect[2] - availableRect[0],
      height: availableRect[3] - availableRect[1]
    };
    const layout = layoutBuilder.computeLayout(data, sortData, {
      availableRect: rect,
      nodePadding: nodeOptions.padding,
      nodeWidth: nodeOptions.width,
      nodeAlign: that._getOption('alignment', true)
    }, that._incidentOccurred);
    that._layoutMap = layout;
    if (!Object.prototype.hasOwnProperty.call(layout, 'error')) {
      const nodeColors = {};
      let nodeIdx = 0;
      const linkOptions = that._getOption('link');
      const totalNodesNum = layout.nodes.map(item => {
        return item.length;
      }).reduce((previousValue, currentValue) => {
        return previousValue + currentValue;
      }, 0);
      const palette = that._themeManager.createPalette(that._getOption('palette', true), {
        useHighlight: true,
        extensionMode: that._getOption('paletteExtensionMode', true),
        count: totalNodesNum
      });
      that._nodes = [];
      that._links = [];
      that._gradients.forEach(gradient => {
        gradient.dispose();
      });
      that._gradients = [];
      that._shadowFilter && that._shadowFilter.dispose();
      layout.nodes.forEach(cascadeNodes => {
        cascadeNodes.forEach(node => {
          const color = nodeOptions.color || palette.getNextColor();
          const nodeItem = new _node_item.default(that, {
            id: nodeIdx,
            color: color,
            rect: node,
            options: nodeOptions,
            linksIn: getConnectedLinks(layout, node._name, 'in'),
            linksOut: getConnectedLinks(layout, node._name, 'out')
          });
          that._nodes.push(nodeItem);
          nodeIdx++;
          nodeColors[node._name] = color;
        });
      });
      layout.links.forEach(link => {
        let gradient = null;
        if (linkOptions.colorMode === _constants.COLOR_MODE_GRADIENT) {
          gradient = that._renderer.linearGradient([{
            offset: '0%',
            'stop-color': nodeColors[link._from._name]
          }, {
            offset: '100%',
            'stop-color': nodeColors[link._to._name]
          }]);
          this._gradients.push(gradient);
        }
        let color = linkOptions.color;
        if (linkOptions.colorMode === _constants.COLOR_MODE_SOURCE) {
          color = nodeColors[link._from._name];
        } else if (linkOptions.colorMode === _constants.COLOR_MODE_TARGET) {
          color = nodeColors[link._to._name];
        }
        const linkItem = new _link_item.default(that, {
          d: link.d,
          boundingRect: link._boundingRect,
          color: color,
          options: linkOptions,
          connection: {
            source: link._from._name,
            target: link._to._name,
            weight: link._weight
          },
          gradient: gradient
        });
        that._links.push(linkItem);
      });
      that._renderer.initDefsElements();
      that._change(['NODES_DRAW', 'LINKS_DRAW', 'LABELS']);
    }
    that._change(['DRAWN']);
  },
  _applyLabelsAppearance: function () {
    const that = this;
    const labelOptions = that._getOption('label');
    const availableWidth = that._rect[2] - that._rect[0];
    const nodeOptions = that._getOption('node');
    that._shadowFilter = that._renderer.shadowFilter('-50%', '-50%', '200%', '200%').attr(labelOptions.shadow);
    that._groupLabels.clear();
    if (that._drawLabels && labelOptions.visible) {
      // emtpy space between cascades with 'labelOptions.horizontalOffset' subtracted
      const availableLabelWidth = (availableWidth - (nodeOptions.width + labelOptions.horizontalOffset) - that._layoutMap.cascades.length * nodeOptions.width) / (that._layoutMap.cascades.length - 1) - labelOptions.horizontalOffset;
      that._nodes.forEach(function (node) {
        that._createLabel(node, labelOptions, that._shadowFilter.id);
        moveLabel(node, labelOptions, availableLabelWidth, that._rect);
      });

      // test and handle labels overlapping here
      if (labelOptions.overlappingBehavior !== 'none') {
        that._nodes.forEach(function (thisNode) {
          const thisBox = thisNode._label.getBBox();
          that._nodes.forEach(function (otherNode) {
            const otherBox = otherNode._label.getBBox();
            if (thisNode.id !== otherNode.id && _layout.layout.overlap(thisBox, otherBox)) {
              if (labelOptions.overlappingBehavior === 'ellipsis') {
                thisNode.labelText.applyEllipsis(otherBox.x - thisBox.x);
              } else if (labelOptions.overlappingBehavior === 'hide') {
                thisNode.labelText.remove();
              }
            }
          });
        });
      }
    }
  },
  _createLabel: function (node, labelOptions, filter) {
    const textData = labelOptions.customizeText(node);
    const settings = node.getLabelAttributes(labelOptions, filter);
    if (textData) {
      node._label = this._renderer.g().append(this._groupLabels);
      node.labelText = this._renderer.text(textData).attr(settings.attr).css(settings.css);
      node.labelText.append(node._label);
    }
  },
  _getMinSize: function () {
    const adaptiveLayout = this._getOption('adaptiveLayout');
    return [adaptiveLayout.width, adaptiveLayout.height];
  },
  getAllNodes: function () {
    return this._nodes.slice();
  },
  getAllLinks: function () {
    return this._links.slice();
  }
});
(0, _component_registrator.default)('dxSankey', dxSankey);
var _default = exports["default"] = dxSankey; // PLUGINS_SECTION
dxSankey.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 38516:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.setTooltipCustomOptions = setTooltipCustomOptions;
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
const defaultCustomizeLinkTooltip = formatter => function (info) {
  return {
    html: `<strong>${info.source} > ${info.target}</strong><br/>Weight: ${formatter(info.weight)}`
  };
};
const defaultCustomizeNodeTooltip = formatter => function (info) {
  return {
    html: `<strong>${info.label}</strong><br/>Incoming weight: ${formatter(info.weightIn)}<br/>Outgoing weight: ${formatter(info.weightOut)}`
  };
};
const generateCustomCallback = function (customCallback, defaultCallback) {
  return function (objectInfo) {
    let res = (0, _type.isFunction)(customCallback) ? customCallback.call(objectInfo, objectInfo) : {};
    const hasOwnProperty = Object.prototype.hasOwnProperty.bind(res);
    if (!hasOwnProperty('html') && !hasOwnProperty('text')) {
      res = (0, _extend2.extend)(res, defaultCallback.call(objectInfo, objectInfo));
    }
    return res;
  };
};
function setTooltipCustomOptions(sankey) {
  sankey.prototype._setTooltipOptions = function () {
    const tooltip = this._tooltip;
    const options = tooltip && this._getOption('tooltip');
    let linkTemplate;
    let nodeTemplate;
    if (options.linkTooltipTemplate) {
      linkTemplate = this._getTemplate(options.linkTooltipTemplate);
    }
    if (options.nodeTooltipTemplate) {
      nodeTemplate = this._getTemplate(options.nodeTooltipTemplate);
    }
    tooltip && tooltip.update((0, _extend2.extend)({}, options, {
      customizeTooltip: function (args) {
        if (!(linkTemplate && args.type === 'link' || nodeTemplate && args.type === 'node')) {
          args.skipTemplate = true;
        }
        const formatter = value => tooltip.formatValue(value);
        if (args.type === 'node') {
          return generateCustomCallback(options.customizeNodeTooltip, defaultCustomizeNodeTooltip(formatter))(args.info);
        } else if (args.type === 'link') {
          return generateCustomCallback(options.customizeLinkTooltip, defaultCustomizeLinkTooltip(formatter))(args.info);
        }
        return {};
      },
      contentTemplate(arg, div) {
        const templateArgs = {
          model: arg.info,
          container: div
        };
        if (linkTemplate && arg.type === 'link') {
          return linkTemplate.render(templateArgs);
        }
        if (nodeTemplate && arg.type === 'node') {
          return nodeTemplate.render(templateArgs);
        }
      },
      enabled: options.enabled
    }));
  };
  sankey.prototype.hideTooltip = function () {
    this._tooltip && this._tooltip.hide();
  };
}

/***/ }),

/***/ 29823:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _sankey = _interopRequireDefault(__webpack_require__(66422));
var _tracker = __webpack_require__(88997);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const proto = _sankey.default.prototype;
const DATA_KEY_BASE = '__sankey_data_';
let dataKeyModifier = 0;
proto._eventsMap.onNodeClick = {
  name: 'nodeClick'
};
proto._eventsMap.onLinkClick = {
  name: 'linkClick'
};
const getDataKey = function () {
  return DATA_KEY_BASE + dataKeyModifier++;
};
const plugin = exports.plugin = {
  name: 'tracker',
  init: function () {
    const that = this;
    const dataKey = getDataKey();
    that._tracker = new _tracker.Tracker({
      widget: that,
      root: that._renderer.root,
      getData: function (e) {
        const target = e.target;
        return target[dataKey];
      },
      getNode: function (index) {
        if (index < that._nodes.length) {
          return that._nodes[index];
        } else {
          return that._links[index - that._nodes.length];
        }
      },
      click: function (e) {
        const eventName = this.getData(e.event) < that._nodes.length ? 'nodeClick' : 'linkClick';
        that._eventTrigger(eventName, {
          target: e.node,
          event: e.event
        });
      }
    });
    this._dataKey = dataKey;
  },
  dispose: function () {
    this._tracker.dispose();
  },
  extenders: {
    _change_LINKS_DRAW: function () {
      const dataKey = this._dataKey;
      this._nodes.concat(this._links).forEach(function (item, index) {
        item.element.data(dataKey, index);
      });
    }
  }
};

/***/ }),

/***/ 90048:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _object = __webpack_require__(48013);
var _extend2 = __webpack_require__(13306);
var _scatter_series = __webpack_require__(21667);
var _line_series = __webpack_require__(7222);
var _utils = __webpack_require__(19157);
// there are area, steparea, stackedarea, fullstackedarea, splinearea

const chartLineSeries = _line_series.chart.line;
const polarLineSeries = _line_series.polar.line;
const _extend = _extend2.extend;
const calculateBezierPoints = _line_series.chart['spline']._calculateBezierPoints;
const chart = exports.chart = {};
const polar = exports.polar = {};
const baseAreaMethods = {
  _createBorderElement: chartLineSeries._createMainElement,
  _createLegendState: function (styleOptions, defaultColor) {
    return {
      fill: (0, _utils.extractColor)(styleOptions.color) || defaultColor,
      opacity: styleOptions.opacity,
      hatching: styleOptions.hatching,
      filter: styleOptions.highlight
    };
  },
  _getColorId: function (options) {
    var _options$color;
    return (_options$color = options.color) === null || _options$color === void 0 ? void 0 : _options$color.fillId;
  },
  getValueRangeInitialValue: function () {
    if (this.valueAxisType !== 'logarithmic' && this.valueType !== 'datetime' && this.showZero !== false) {
      return 0;
    } else {
      return _scatter_series.chart.getValueRangeInitialValue.call(this);
    }
  },
  _getDefaultSegment: function (segment) {
    const defaultSegment = chartLineSeries._getDefaultSegment(segment);
    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());
    return defaultSegment;
  },
  _updateElement: function (element, segment, animate, complete) {
    const lineParams = {
      points: segment.line
    };
    const areaParams = {
      points: segment.area
    };
    const borderElement = element.line;
    if (animate) {
      borderElement && borderElement.animate(lineParams);
      element.area.animate(areaParams, {}, complete);
    } else {
      borderElement && borderElement.attr(lineParams);
      element.area.attr(areaParams);
    }
  },
  _removeElement: function (element) {
    element.line && element.line.remove();
    element.area.remove();
  },
  _drawElement: function (segment) {
    return {
      line: this._bordersGroup && this._createBorderElement(segment.line, {
        'stroke-width': this._styles.normal.border['stroke-width']
      }).append(this._bordersGroup),
      area: this._createMainElement(segment.area).append(this._elementsGroup)
    };
  },
  _applyStyle: function (style) {
    const that = this;
    that._elementsGroup && that._elementsGroup.smartAttr(style.elements);
    that._bordersGroup && that._bordersGroup.attr(style.border);
    (that._graphics || []).forEach(function (graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.border['stroke-width']
      }).sharp();
    });
  },
  _parseStyle: function (options, defaultColor, defaultBorderColor) {
    const borderOptions = options.border || {};
    const borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);
    borderStyle.stroke = borderOptions.visible && borderStyle['stroke-width'] ? borderStyle.stroke : 'none';
    borderStyle['stroke-width'] = borderStyle['stroke-width'] || 1;
    return {
      border: borderStyle,
      elements: {
        stroke: 'none',
        fill: (0, _utils.extractColor)(options.color) || defaultColor,
        hatching: options.hatching,
        opacity: options.opacity,
        filter: options.highlight ?? null
      }
    };
  },
  _areBordersVisible: function () {
    const options = this._options;
    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible;
  },
  _createMainElement: function (points, settings) {
    return this._renderer.path(points, 'area').attr(settings);
  },
  _getTrackerSettings: function (segment) {
    return {
      'stroke-width': segment.singlePointSegment ? this._defaultTrackerWidth : 0
    };
  },
  _getMainPointsFromSegment: function (segment) {
    return segment.area;
  }
};
function createAreaPoints(points) {
  return (0, _utils.map)(points, function (pt) {
    return pt.getCoords();
  }).concat((0, _utils.map)(points.slice().reverse(), function (pt) {
    return pt.getCoords(true);
  }));
}
const areaSeries = chart['area'] = _extend({}, chartLineSeries, baseAreaMethods, {
  _prepareSegment(points, rotated) {
    const that = this;
    const processedPoints = that._processSinglePointsAreaSegment(points, rotated);
    const areaPoints = createAreaPoints(processedPoints);
    const argAxis = that.getArgumentAxis();
    if (argAxis.getAxisPosition) {
      const argAxisPosition = argAxis.getAxisPosition();
      const axisOptions = argAxis.getOptions();
      const edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);
      if (axisOptions.visible) {
        areaPoints.forEach((p, i) => {
          if (p) {
            const index = points.length === 1 ? 0 : i < points.length ? i : areaPoints.length - 1 - i;
            rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);
            !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset);
          }
        });
      }
    }
    return {
      line: processedPoints,
      area: areaPoints,
      singlePointSegment: processedPoints !== points
    };
  },
  _processSinglePointsAreaSegment: function (points, rotated) {
    if (points && points.length === 1) {
      const p = points[0];
      const p1 = (0, _object.clone)(p);
      p1[rotated ? 'y' : 'x'] += 1;
      p1.argument = null;
      return [p, p1];
    }
    return points;
  }
});
polar['area'] = _extend({}, polarLineSeries, baseAreaMethods, {
  _prepareSegment: function (points, rotated, lastSegment) {
    lastSegment && polarLineSeries._closeSegment.call(this, points);
    return areaSeries._prepareSegment.call(this, points);
  },
  _processSinglePointsAreaSegment: function (points) {
    return _line_series.polar.line._prepareSegment.call(this, points).line;
  }
});
chart['steparea'] = _extend({}, areaSeries, {
  _prepareSegment: function (points, rotated) {
    const stepLineSeries = _line_series.chart['stepline'];
    points = areaSeries._processSinglePointsAreaSegment(points, rotated);
    return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated);
  },
  getSeriesPairCoord: _line_series.chart['stepline'].getSeriesPairCoord
});
chart['splinearea'] = _extend({}, areaSeries, {
  _areaPointsToSplineAreaPoints: function (areaPoints) {
    const previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];
    const middlePoint = areaPoints[areaPoints.length / 2];
    areaPoints.splice(areaPoints.length / 2, 0, {
      x: previousMiddlePoint.x,
      y: previousMiddlePoint.y
    }, {
      x: middlePoint.x,
      y: middlePoint.y
    });
  },
  _prepareSegment: function (points, rotated) {
    const processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);
    const areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));
    this._areaPointsToSplineAreaPoints(areaSegment.area);
    areaSegment.singlePointSegment = processedPoints !== points;
    return areaSegment;
  },
  _getDefaultSegment: function (segment) {
    const areaDefaultSegment = areaSeries._getDefaultSegment(segment);
    this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);
    return areaDefaultSegment;
  },
  _createMainElement: function (points, settings) {
    return this._renderer.path(points, 'bezierarea').attr(settings);
  },
  _createBorderElement: _line_series.chart['spline']._createMainElement,
  getSeriesPairCoord: _line_series.chart['spline'].getSeriesPairCoord,
  _getNearestPoints: _line_series.chart['spline']._getNearestPoints,
  _getBezierPoints: _line_series.chart['spline']._getBezierPoints,
  obtainCubicBezierTCoef: _line_series.chart['spline'].obtainCubicBezierTCoef
});

/***/ }),

/***/ 58821:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var scatterSeries = _interopRequireWildcard(__webpack_require__(21667));
var _area_series = __webpack_require__(90048);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const areaSeries = _area_series.chart.area;
const chartSeries = scatterSeries.chart;
const polarSeries = scatterSeries.polar;
const _extend = _extend2.extend;
const _each = _iterator.each;
const chart = exports.chart = {};
const polar = exports.polar = {};
const baseBarSeriesMethods = {
  _createLegendState: function (styleOptions, defaultColor) {
    return {
      fill: (0, _utils.extractColor)(styleOptions.color) || defaultColor,
      hatching: styleOptions.hatching,
      filter: styleOptions.highlight
    };
  },
  _getColorId: areaSeries._getColorId,
  _parsePointStyle: function (style, defaultColor, defaultBorderColor) {
    const color = (0, _utils.extractColor)(style.color) || defaultColor;
    const base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);
    base.fill = color;
    base.hatching = style.hatching;
    base.filter = style.highlight;
    base.dashStyle = style.border && style.border.dashStyle || 'solid';
    delete base.r;
    return base;
  },
  _applyMarkerClipRect: function (settings) {
    settings['clip-path'] = null;
  },
  _setGroupsSettings: function (animationEnabled, firstDrawing) {
    const that = this;
    let settings = {};
    chartSeries._setGroupsSettings.apply(that, arguments);
    if (animationEnabled && firstDrawing) {
      settings = this._getAffineCoordOptions();
    } else if (!animationEnabled) {
      settings = {
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0
      };
    }
    that._markersGroup.attr(settings);
  },
  _drawPoint: function (options) {
    options.hasAnimation = options.hasAnimation && !options.firstDrawing;
    options.firstDrawing = false;
    chartSeries._drawPoint.call(this, options);
  },
  _getMainColor: function () {
    return this._options.mainSeriesColor;
  },
  _createPointStyles: function (pointOptions) {
    var _pointOptions$color;
    const that = this;
    const mainColor = (0, _utils.extractColor)(pointOptions.color, true) || that._getMainColor();
    const colorId = (_pointOptions$color = pointOptions.color) === null || _pointOptions$color === void 0 ? void 0 : _pointOptions$color.fillId;
    const hoverStyle = pointOptions.hoverStyle || {};
    const selectionStyle = pointOptions.selectionStyle || {};
    if (colorId) {
      that._turnOffHatching(hoverStyle, selectionStyle);
    }
    return {
      labelColor: mainColor,
      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
      hover: that._parsePointStyle(hoverStyle, colorId || mainColor, mainColor),
      selection: that._parsePointStyle(selectionStyle, colorId || mainColor, mainColor)
    };
  },
  _updatePointsVisibility: function () {
    const visibility = this._options.visible;
    (0, _iterator.each)(this._points, function (_, point) {
      point._options.visible = visibility;
    });
  },
  _getOptionsForPoint: function () {
    return this._options;
  },
  _animate: function (firstDrawing) {
    const that = this;
    const complete = function () {
      that._animateComplete();
    };
    const animateFunc = function (drawnPoints, complete) {
      const lastPointIndex = drawnPoints.length - 1;
      _each(drawnPoints || [], function (i, point) {
        point.animate(i === lastPointIndex ? complete : undefined, point.getMarkerCoords());
      });
    };
    that._animatePoints(firstDrawing, complete, animateFunc);
  },
  getValueRangeInitialValue: areaSeries.getValueRangeInitialValue,
  _patchMarginOptions: function (options) {
    var _this$getArgumentAxis;
    options.checkInterval = !this.useAggregation() || ((_this$getArgumentAxis = this.getArgumentAxis()) === null || _this$getArgumentAxis === void 0 ? void 0 : _this$getArgumentAxis.aggregatedPointBetweenTicks());
    return options;
  },
  _defaultAggregator: 'sum',
  _defineDrawingState() {},
  usePointsToDefineAutoHiding() {
    return false;
  }
};
chart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {
  _getAffineCoordOptions: function () {
    const rotated = this._options.rotated;
    const direction = rotated ? 'X' : 'Y';
    const settings = {
      scaleX: rotated ? 0.001 : 1,
      scaleY: rotated ? 1 : 0.001
    };
    settings['translate' + direction] = this.getValueAxis().getTranslator().translate('canvas_position_default');
    return settings;
  },
  _animatePoints: function (firstDrawing, complete, animateFunc) {
    const that = this;
    that._markersGroup.animate({
      scaleX: 1,
      scaleY: 1,
      translateY: 0,
      translateX: 0
    }, undefined, complete);
    if (!firstDrawing) {
      animateFunc(that._drawnPoints, complete);
    }
  },
  checkSeriesViewportCoord(axis, coord) {
    if (!chartSeries.checkSeriesViewportCoord.call(this)) {
      return false;
    }
    if (axis.isArgumentAxis) {
      return true;
    }
    const translator = axis.getTranslator();
    const range = this.getViewport();
    const min = translator.translate(range.categories ? range.categories[0] : range.min);
    const max = translator.translate(range.categories ? range.categories[range.categories.length - 1] : range.max);
    const rotated = this.getOptions().rotated;
    const inverted = axis.getOptions().inverted;
    return rotated && !inverted || !rotated && inverted ? coord >= min && coord <= max : coord >= max && coord <= min;
  },
  getSeriesPairCoord(coord, isArgument) {
    let oppositeCoord = null;
    const {
      rotated
    } = this._options;
    const isOpposite = !isArgument && !rotated || isArgument && rotated;
    const coordName = isOpposite ? 'vy' : 'vx';
    const oppositeCoordName = isOpposite ? 'vx' : 'vy';
    const points = this.getPoints();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      let tmpCoord;
      if (isArgument) {
        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : undefined;
      } else {
        tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : undefined;
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  }
});
polar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {
  _animatePoints: function (firstDrawing, complete, animateFunc) {
    animateFunc(this._drawnPoints, complete);
  },
  _setGroupsSettings: chartSeries._setGroupsSettings,
  _drawPoint: function (point, groups, animationEnabled) {
    chartSeries._drawPoint.call(this, point, groups, animationEnabled);
  },
  _parsePointStyle: function (style) {
    const base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);
    base.opacity = style.opacity;
    return base;
  },
  _createGroups: chartSeries._createGroups,
  _setMarkerGroupSettings: function () {
    const that = this;
    const markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
    markersSettings['class'] = 'dxc-markers';
    that._applyMarkerClipRect(markersSettings);
    const groupSettings = _extend({}, markersSettings);
    delete groupSettings.opacity; // T110796
    that._markersGroup.attr(groupSettings);
  },
  getSeriesPairCoord(params, isArgument) {
    let coords = null;
    const paramName = isArgument ? 'argument' : 'radius';
    const points = this.getVisiblePoints();
    const argAxis = this.getArgumentAxis();
    const startAngle = argAxis.getAngles()[0];
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const tmpPoint = (0, _type.isDefined)(p[paramName]) && (0, _type.isDefined)(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? (0, _utils.convertPolarToXY)(argAxis.getCenter(), startAngle, -argAxis.getTranslatedAngle(p.angle), p.radius) : undefined;
      if ((0, _type.isDefined)(tmpPoint)) {
        coords = tmpPoint;
        break;
      }
    }
    return coords;
  },
  _createLegendState: areaSeries._createLegendState
});

/***/ }),

/***/ 54932:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Series = Series;
exports.mixins = void 0;
var _type = __webpack_require__(35922);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _base_point = __webpack_require__(54497);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _range_data_calculator = _interopRequireDefault(__webpack_require__(63407));
var scatterSeries = _interopRequireWildcard(__webpack_require__(21667));
var lineSeries = _interopRequireWildcard(__webpack_require__(7222));
var areaSeries = _interopRequireWildcard(__webpack_require__(90048));
var barSeries = _interopRequireWildcard(__webpack_require__(58821));
var _range_series = __webpack_require__(57402);
var _bubble_series = __webpack_require__(64216);
var pieSeries = _interopRequireWildcard(__webpack_require__(80610));
var financialSeries = _interopRequireWildcard(__webpack_require__(29788));
var stackedSeries = _interopRequireWildcard(__webpack_require__(92057));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const seriesNS = {};
const states = _consts.default.states;
const DISCRETE = 'discrete';
const SELECTED_STATE = states.selectedMark;
const HOVER_STATE = states.hoverMark;
const HOVER = states.hover;
const NORMAL = states.normal;
const SELECTION = states.selection;
const APPLY_SELECTED = states.applySelected;
const APPLY_HOVER = states.applyHover;
const RESET_ITEM = states.resetItem;
const NONE_MODE = 'none';
const INCLUDE_POINTS = 'includepoints';
const NEAREST_POINT = 'nearestpoint';
const SERIES_SELECTION_CHANGED = 'seriesSelectionChanged';
const POINT_SELECTION_CHANGED = 'pointSelectionChanged';
const SERIES_HOVER_CHANGED = 'seriesHoverChanged';
const POINT_HOVER_CHANGED = 'pointHoverChanged';
const ALL_SERIES_POINTS = 'allseriespoints';
const ALL_ARGUMENT_POINTS = 'allargumentpoints';
const POINT_HOVER = 'pointHover';
const CLEAR_POINT_HOVER = 'clearPointHover';
const SERIES_SELECT = 'seriesSelect';
const POINT_SELECT = 'pointSelect';
const POINT_DESELECT = 'pointDeselect';
const getEmptyBusinessRange = function () {
  return {
    arg: {},
    val: {}
  };
};
function triggerEvent(element, event, point) {
  element && element.trigger(event, point);
}
seriesNS.mixins = {
  chart: {},
  pie: {},
  polar: {}
};
seriesNS.mixins.chart.scatter = scatterSeries.chart;
seriesNS.mixins.polar.scatter = scatterSeries.polar;
(0, _extend2.extend)(seriesNS.mixins.pie, pieSeries);
(0, _extend2.extend)(seriesNS.mixins.chart, lineSeries.chart, areaSeries.chart, barSeries.chart, _range_series.chart, _bubble_series.chart, financialSeries, stackedSeries.chart);
(0, _extend2.extend)(seriesNS.mixins.polar, lineSeries.polar, areaSeries.polar, barSeries.polar, stackedSeries.polar);
function includePointsMode(mode) {
  mode = (0, _utils.normalizeEnum)(mode);
  return mode === INCLUDE_POINTS || mode === ALL_SERIES_POINTS;
}
function getLabelOptions(labelOptions, defaultColor) {
  const opt = labelOptions || {};
  const labelFont = (0, _extend2.extend)({}, opt.font) || {};
  const labelBorder = opt.border || {};
  const labelConnector = opt.connector || {};
  const backgroundAttr = {
    fill: opt.backgroundColor || defaultColor,
    'stroke-width': labelBorder.visible ? labelBorder.width || 0 : 0,
    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : 'none',
    dashStyle: labelBorder.dashStyle
  };
  const connectorAttr = {
    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : 'none',
    'stroke-width': labelConnector.visible ? labelConnector.width || 0 : 0
  };
  labelFont.color = opt.backgroundColor === 'none' && (0, _utils.normalizeEnum)(labelFont.color) === '#ffffff' && opt.position !== 'inside' ? defaultColor : labelFont.color;
  return {
    alignment: opt.alignment,
    format: opt.format,
    argumentFormat: opt.argumentFormat,
    customizeText: (0, _type.isFunction)(opt.customizeText) ? opt.customizeText : undefined,
    attributes: {
      font: labelFont
    },
    visible: labelFont.size !== 0 ? opt.visible : false,
    showForZeroValues: opt.showForZeroValues,
    horizontalOffset: opt.horizontalOffset,
    verticalOffset: opt.verticalOffset,
    radialOffset: opt.radialOffset,
    background: backgroundAttr,
    position: opt.position,
    connector: connectorAttr,
    rotationAngle: opt.rotationAngle,
    wordWrap: opt.wordWrap,
    textOverflow: opt.textOverflow,
    cssClass: opt.cssClass,
    displayFormat: opt.displayFormat
  };
}
function setPointHoverState(point, legendCallback) {
  point.fullState |= HOVER_STATE;
  point.applyView(legendCallback);
}
function releasePointHoverState(point, legendCallback) {
  point.fullState &= ~HOVER_STATE;
  point.applyView(legendCallback);
  point.releaseHoverState();
}
function setPointSelectedState(point, legendCallback) {
  point.fullState |= SELECTED_STATE;
  point.applyView(legendCallback);
}
function releasePointSelectedState(point, legendCallback) {
  point.fullState &= ~SELECTED_STATE;
  point.applyView(legendCallback);
}
function mergePointOptionsCore(base, extra) {
  const options = (0, _extend2.extend)({}, base, extra);
  options.border = (0, _extend2.extend)({}, base && base.border, extra && extra.border);
  return options;
}
function mergePointOptions(base, extra) {
  const options = mergePointOptionsCore(base, extra);
  options.image = (0, _extend2.extend)(true, {}, base.image, extra.image);
  options.selectionStyle = mergePointOptionsCore(base.selectionStyle, extra.selectionStyle);
  options.hoverStyle = mergePointOptionsCore(base.hoverStyle, extra.hoverStyle);
  return options;
}
function Series(settings, options) {
  const that = this;
  that.fullState = 0;
  that._extGroups = settings;
  that._renderer = settings.renderer;
  that._group = settings.renderer.g().attr({
    'class': 'dxc-series'
  });
  that._eventTrigger = settings.eventTrigger;
  that._eventPipe = settings.eventPipe;
  that._incidentOccurred = settings.incidentOccurred;
  that._legendCallback = _common.noop;
  that.updateOptions(options, settings);
}
function getData(pointData) {
  return pointData.data;
}
function getValueChecker(axisType, axis) {
  if (!axis || axisType !== 'logarithmic' || axis.getOptions().allowNegatives !== false) {
    return () => true;
  } else {
    return value => value > 0;
  }
}
Series.prototype = {
  constructor: Series,
  _createLegendState: _common.noop,
  getLegendStyles: function () {
    return this._styles.legendStyles;
  },
  _createStyles: function (options) {
    const that = this;
    const mainSeriesColor = options.mainSeriesColor;
    const colorId = this._getColorId(options);
    const hoverStyle = options.hoverStyle || {};
    const selectionStyle = options.selectionStyle || {};
    if (colorId) {
      that._turnOffHatching(hoverStyle, selectionStyle);
    }
    that._styles = {
      labelColor: mainSeriesColor,
      normal: that._parseStyle(options, mainSeriesColor, mainSeriesColor),
      hover: that._parseStyle(hoverStyle, colorId || mainSeriesColor, mainSeriesColor),
      selection: that._parseStyle(selectionStyle, colorId || mainSeriesColor, mainSeriesColor),
      legendStyles: {
        normal: that._createLegendState(options, colorId || mainSeriesColor),
        hover: that._createLegendState(hoverStyle, colorId || mainSeriesColor),
        selection: that._createLegendState(selectionStyle, colorId || mainSeriesColor)
      }
    };
  },
  setClippingParams(baseId, wideId, forceClipping) {
    let clipLabels = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    this._paneClipRectID = baseId;
    this._widePaneClipRectID = wideId;
    this._forceClipping = forceClipping;
    this._clipLabels = clipLabels;
  },
  applyClip: function () {
    this._group.attr({
      'clip-path': this._paneClipRectID
    });
  },
  resetClip: function () {
    this._group.attr({
      'clip-path': null
    });
  },
  getTagField: function () {
    return this._options.tagField || 'tag';
  },
  getValueFields: _common.noop,
  getSizeField: _common.noop,
  getArgumentField: _common.noop,
  getPoints: function () {
    return this._points;
  },
  getPointsInViewPort: function () {
    return _range_data_calculator.default.getPointsInViewPort(this);
  },
  _createPoint: function (data, index, oldPoint) {
    data.index = index;
    const that = this;
    const pointsByArgument = that.pointsByArgument;
    const options = that._getCreatingPointOptions(data);
    const arg = data.argument.valueOf();
    let point = oldPoint;
    if (point) {
      point.update(data, options);
    } else {
      point = new _base_point.Point(that, data, options);
      if (that.isSelected() && includePointsMode(that.lastSelectionMode)) {
        point.setView(SELECTION);
      }
    }
    const pointByArgument = pointsByArgument[arg];
    if (pointByArgument) {
      pointByArgument.push(point);
    } else {
      pointsByArgument[arg] = [point];
    }
    if (point.hasValue()) {
      that.customizePoint(point, data);
    }
    return point;
  },
  getRangeData: function () {
    return this._visible ? this._getRangeData() : getEmptyBusinessRange();
  },
  getArgumentRange: function () {
    return this._visible ? _range_data_calculator.default.getArgumentRange(this) : getEmptyBusinessRange();
  },
  getViewport: function () {
    return _range_data_calculator.default.getViewport(this);
  },
  _deleteGroup: function (groupName) {
    const group = this[groupName];
    if (group) {
      group.dispose();
      this[groupName] = null;
    }
  },
  updateOptions(newOptions, settings) {
    const that = this;
    const widgetType = newOptions.widgetType;
    const oldType = that.type;
    const newType = newOptions.type;
    that.type = newType && (0, _utils.normalizeEnum)(newType.toString());
    if (!that._checkType(widgetType) || that._checkPolarBarType(widgetType, newOptions)) {
      that.dispose();
      that.isUpdated = false;
      return;
    }
    if (oldType !== that.type) {
      that._firstDrawing = true;
      that._resetType(oldType, widgetType);
      that._setType(that.type, widgetType);
    } else {
      that._defineDrawingState();
    }
    that._options = newOptions;
    that._pointOptions = null;
    that.name = newOptions.name;
    that.pane = newOptions.pane;
    that.tag = newOptions.tag;
    if (settings) {
      that._seriesModes = settings.commonSeriesModes || that._seriesModes;
      that._valueAxis = settings.valueAxis || that._valueAxis;
      that.axis = that._valueAxis && that._valueAxis.name;
      that._argumentAxis = settings.argumentAxis || that._argumentAxis;
    }
    that._createStyles(newOptions);
    that._stackName = null;
    that._updateOptions(newOptions);
    that._visible = newOptions.visible;
    that.isUpdated = true;
    that.stack = newOptions.stack;
    that.barOverlapGroup = newOptions.barOverlapGroup;
    that._createGroups();
    that._processEmptyValue = newOptions.ignoreEmptyPoints ? x => x === null ? undefined : x : x => x;
  },
  _defineDrawingState() {
    this._firstDrawing = true;
  },
  _disposePoints: function (points) {
    (0, _iterator.each)(points || [], function (_, p) {
      p.dispose();
    });
  },
  updateDataType: function (settings) {
    const that = this;
    that.argumentType = settings.argumentType;
    that.valueType = settings.valueType;
    that.argumentAxisType = settings.argumentAxisType;
    that.valueAxisType = settings.valueAxisType;
    that.showZero = settings.showZero;
    this._argumentChecker = getValueChecker(settings.argumentAxisType, that.getArgumentAxis());
    this._valueChecker = getValueChecker(settings.valueAxisType, that.getValueAxis());
    return that;
  },
  _argumentChecker: function () {
    return true;
  },
  _valueChecker: function () {
    return true;
  },
  getOptions: function () {
    return this._options;
  },
  _getOldPoint: function (data, oldPointsByArgument, index) {
    const arg = data.argument && data.argument.valueOf();
    const point = (oldPointsByArgument[arg] || [])[0];
    if (point) {
      oldPointsByArgument[arg].splice(0, 1);
    }
    return point;
  },
  updateData: function (data) {
    const that = this;
    const options = that._options;
    const nameField = options.nameField;
    data = data || [];
    if (data.length) {
      that._canRenderCompleteHandle = true;
    }
    const dataSelector = this._getPointDataSelector();
    let itemsWithoutArgument = 0;
    that._data = data.reduce((data, dataItem, index) => {
      const pointDataItem = dataSelector(dataItem);
      if ((0, _type.isDefined)(pointDataItem.argument)) {
        if (!nameField || dataItem[nameField] === options.nameFieldValue) {
          pointDataItem.index = index;
          data.push(pointDataItem);
        }
      } else {
        itemsWithoutArgument++;
      }
      return data;
    }, []);
    if (itemsWithoutArgument && itemsWithoutArgument === data.length) {
      that._incidentOccurred('W2002', [that.name, that.getArgumentField()]);
    }
    that._endUpdateData();
  },
  _getData() {
    let data = this._data || [];
    if (this.useAggregation()) {
      const argumentRange = this.argumentAxisType !== DISCRETE ? this.getArgumentRange() : {};
      const aggregationInfo = this.getArgumentAxis().getAggregationInfo(this._useAllAggregatedPoints, argumentRange);
      data = this._resample(aggregationInfo, data);
    }
    return data;
  },
  useAggregation: function () {
    const aggregation = this.getOptions().aggregation;
    return aggregation && aggregation.enabled;
  },
  autoHidePointMarkersEnabled: _common.noop,
  usePointsToDefineAutoHiding: _common.noop,
  createPoints(useAllAggregatedPoints) {
    this._normalizeUsingAllAggregatedPoints(useAllAggregatedPoints);
    this._createPoints();
  },
  _normalizeUsingAllAggregatedPoints: function (useAllAggregatedPoints) {
    this._useAllAggregatedPoints = this.useAggregation() && (this.argumentAxisType === DISCRETE || (this._data || []).length > 1 && !!useAllAggregatedPoints);
  },
  _createPoints: function () {
    const that = this;
    const oldPointsByArgument = that.pointsByArgument || {};
    const data = that._getData();
    that.pointsByArgument = {};
    that._calculateErrorBars(data);
    const skippedFields = {};
    const points = data.reduce((points, pointDataItem) => {
      if (that._checkData(pointDataItem, skippedFields)) {
        const pointIndex = points.length;
        const oldPoint = that._getOldPoint(pointDataItem, oldPointsByArgument, pointIndex);
        const point = that._createPoint(pointDataItem, pointIndex, oldPoint);
        points.push(point);
      }
      return points;
    }, []);
    for (const field in skippedFields) {
      if (skippedFields[field] === data.length) {
        that._incidentOccurred('W2002', [that.name, field]);
      }
    }
    Object.keys(oldPointsByArgument).forEach(key => that._disposePoints(oldPointsByArgument[key]));
    that._points = points;
  },
  _removeOldSegments: function () {
    const that = this;
    const startIndex = that._segments.length;
    (0, _iterator.each)(that._graphics.splice(startIndex, that._graphics.length) || [], function (_, elem) {
      that._removeElement(elem);
    });
    if (that._trackers) {
      (0, _iterator.each)(that._trackers.splice(startIndex, that._trackers.length) || [], function (_, elem) {
        elem.remove();
      });
    }
  },
  _prepareSegmentsPosition() {
    const points = this._points || [];
    const isCloseSegment = points[0] && points[0].hasValue() && this._options.closed;
    const segments = points.reduce(function (segments, p) {
      const segment = segments.at(-1);
      if (!p.translated) {
        p.setDefaultCoords();
      }
      if (p.hasValue() && p.hasCoords()) {
        segment.push(p);
      } else if (!p.hasValue() && segment.length) {
        segments.push([]);
      }
      return segments;
    }, [[]]);
    this._drawSegments(segments, isCloseSegment, false);
  },
  _drawElements(animationEnabled, firstDrawing) {
    const that = this;
    const points = that._points || [];
    const isCloseSegment = points[0] && points[0].hasValue() && that._options.closed;
    const groupForPoint = {
      markers: that._markersGroup,
      errorBars: that._errorBarGroup
    };
    that._drawnPoints = [];
    that._graphics = that._graphics || [];
    that._segments = [];
    const segments = points.reduce(function (segments, p) {
      const segment = segments.at(-1);
      if (p.hasValue() && p.hasCoords()) {
        that._drawPoint({
          point: p,
          groups: groupForPoint,
          hasAnimation: animationEnabled,
          firstDrawing
        });
        segment.push(p);
      } else if (!p.hasValue()) {
        segment.length && segments.push([]);
      } else {
        p.setInvisibility();
      }
      return segments;
    }, [[]]);
    that._drawSegments(segments, isCloseSegment, animationEnabled);
    that._firstDrawing = !points.length;
    that._removeOldSegments();
    animationEnabled && that._animate(firstDrawing);
  },
  _drawSegments(segments, closeSegment, animationEnabled) {
    segments.forEach((segment, index) => {
      if (segment.length) {
        const lastSegment = closeSegment && index === segments.length - 1;
        this._drawSegment(segment, animationEnabled, index, lastSegment);
      }
    });
  },
  draw(animationEnabled, hideLayoutLabels, legendCallback) {
    const that = this;
    const firstDrawing = that._firstDrawing;
    that._legendCallback = legendCallback || that._legendCallback;
    if (!that._visible) {
      that._group.remove();
      return;
    }
    that._appendInGroup();
    if (!that._isAllPointsTranslated) {
      that.prepareCoordinatesForPoints();
    }
    that._setGroupsSettings(animationEnabled, firstDrawing);
    !firstDrawing && !that._resetApplyingAnimation && that._prepareSegmentsPosition();
    that._drawElements(animationEnabled, firstDrawing);
    hideLayoutLabels && that.hideLabels();
    if (that.isSelected()) {
      that._changeStyle(that.lastSelectionMode, undefined, true);
    } else if (that.isHovered()) {
      that._changeStyle(that.lastHoverMode, undefined, true);
    } else {
      that._applyStyle(that._styles.normal);
    }
    that._isAllPointsTranslated = false;
    that._resetApplyingAnimation = false;
  },
  _translatePoints() {
    const points = this._points ?? [];
    points.forEach(p => {
      p.translate();
    });
  },
  prepareCoordinatesForPoints() {
    this._applyVisibleArea();
    this._translatePoints();
    this._isAllPointsTranslated = true;
  },
  _setLabelGroupSettings: function (animationEnabled) {
    const settings = {
      'class': 'dxc-labels',
      'pointer-events': 'none'
    };
    this._clipLabels && this._applyElementsClipRect(settings);
    this._applyClearingSettings(settings);
    animationEnabled && (settings.opacity = 0.001);
    this._labelsGroup.attr(settings).append(this._extGroups.labelsGroup);
  },
  _checkType: function (widgetType) {
    return !!seriesNS.mixins[widgetType][this.type];
  },
  _checkPolarBarType: function (widgetType, options) {
    return widgetType === 'polar' && options.spiderWidget && this.type.indexOf('bar') !== -1;
  },
  _resetType: function (seriesType, widgetType) {
    let methodName;
    let methods;
    if (seriesType) {
      methods = seriesNS.mixins[widgetType][seriesType];
      for (methodName in methods) {
        delete this[methodName];
      }
    }
  },
  _setType: function (seriesType, widgetType) {
    let methodName;
    const methods = seriesNS.mixins[widgetType][seriesType];
    for (methodName in methods) {
      this[methodName] = methods[methodName];
    }
  },
  _setPointsView: function (view, target) {
    this.getPoints().forEach(function (point) {
      if (target !== point) {
        point.setView(view);
      }
    });
  },
  _resetPointsView: function (view, target) {
    this.getPoints().forEach(function (point) {
      if (target !== point) {
        point.resetView(view);
      }
    });
  },
  _resetNearestPoint: function () {
    const that = this;
    that._nearestPoint && that._nearestPoint.series !== null && that._nearestPoint.resetView(HOVER);
    that._nearestPoint = null;
  },
  _setSelectedState: function (mode) {
    const that = this;
    that.lastSelectionMode = (0, _utils.normalizeEnum)(mode || that._options.selectionMode);
    that.fullState = that.fullState | SELECTED_STATE;
    that._resetNearestPoint();
    that._changeStyle(that.lastSelectionMode);
    if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {
      that._resetPointsView(HOVER);
    }
  },
  _releaseSelectedState: function () {
    const that = this;
    that.fullState = that.fullState & ~SELECTED_STATE;
    that._changeStyle(that.lastSelectionMode, SELECTION);
    if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {
      that._setPointsView(HOVER);
    }
  },
  isFullStackedSeries: function () {
    return this.type.indexOf('fullstacked') === 0;
  },
  isStackedSeries: function () {
    return this.type.indexOf('stacked') === 0;
  },
  resetApplyingAnimation: function (isFirstDrawing) {
    this._resetApplyingAnimation = true;
    if (isFirstDrawing) {
      this._firstDrawing = true;
    }
  },
  isFinancialSeries: function () {
    return this.type === 'stock' || this.type === 'candlestick';
  },
  _canChangeView: function () {
    return !this.isSelected() && (0, _utils.normalizeEnum)(this._options.hoverMode) !== NONE_MODE;
  },
  _changeStyle: function (mode, resetView, skipPoints) {
    const that = this;
    let state = that.fullState;
    const styles = [NORMAL, HOVER, SELECTION, SELECTION];
    if (that.lastHoverMode === 'none') {
      state &= ~HOVER_STATE;
    }
    if (that.lastSelectionMode === 'none') {
      state &= ~SELECTED_STATE;
    }
    if (includePointsMode(mode) && !skipPoints) {
      if (!resetView) {
        that._setPointsView(styles[state]);
      } else {
        that._resetPointsView(resetView);
      }
    }
    that._legendCallback([RESET_ITEM, APPLY_HOVER, APPLY_SELECTED, APPLY_SELECTED][state]);
    that._applyStyle(that._styles[styles[state]]);
  },
  updateHover: function (x, y) {
    const that = this;
    const currentNearestPoint = that._nearestPoint;
    const point = that.isHovered() && that.lastHoverMode === NEAREST_POINT && that.getNeighborPoint(x, y);
    if (point !== currentNearestPoint && !(that.isSelected() && that.lastSelectionMode !== NONE_MODE)) {
      that._resetNearestPoint();
      if (point) {
        point.setView(HOVER);
        that._nearestPoint = point;
      }
    }
  },
  _getMainAxisName: function () {
    return this._options.rotated ? 'X' : 'Y';
  },
  areLabelsVisible: function () {
    return !(0, _type.isDefined)(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount;
  },
  getLabelVisibility: function () {
    return this.areLabelsVisible() && this._options.label && this._options.label.visible;
  },
  customizePoint: function (point, pointData) {
    const that = this;
    const options = that._options;
    const customizePoint = options.customizePoint;
    let customizeObject;
    let pointOptions;
    let customLabelOptions;
    let customOptions;
    const customizeLabel = options.customizeLabel;
    let useLabelCustomOptions;
    let usePointCustomOptions;
    if (customizeLabel && customizeLabel.call) {
      customizeObject = (0, _extend2.extend)({
        seriesName: that.name
      }, pointData);
      customizeObject.series = that;
      customLabelOptions = customizeLabel.call(customizeObject, customizeObject);
      useLabelCustomOptions = customLabelOptions && !(0, _type.isEmptyObject)(customLabelOptions);
      customLabelOptions = useLabelCustomOptions ? (0, _extend2.extend)(true, {}, options.label, customLabelOptions) : null;
    }
    if (customizePoint && customizePoint.call) {
      customizeObject = customizeObject || (0, _extend2.extend)({
        seriesName: that.name
      }, pointData);
      customizeObject.series = that;
      customOptions = customizePoint.call(customizeObject, customizeObject);
      usePointCustomOptions = customOptions && !(0, _type.isEmptyObject)(customOptions);
    }
    if (useLabelCustomOptions || usePointCustomOptions) {
      pointOptions = that._parsePointOptions(that._preparePointOptions(customOptions), customLabelOptions || options.label, pointData, point);
      pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;
      pointOptions.styles.usePointCustomOptions = usePointCustomOptions;
      point.updateOptions(pointOptions);
    }
  },
  show: function () {
    if (!this._visible) {
      this._changeVisibility(true);
    }
  },
  hide: function () {
    if (this._visible) {
      this._changeVisibility(false);
    }
  },
  _changeVisibility: function (visibility) {
    const that = this;
    that._visible = that._options.visible = visibility;
    that._updatePointsVisibility();
    that.hidePointTooltip();
    that._options.visibilityChanged(that);
  },
  // TODO. Problem related to 'point' option for bar-like series. Revisit this code once options parsing is changed
  // see T243839, T231939
  _updatePointsVisibility: _common.noop,
  hideLabels: function () {
    (0, _iterator.each)(this._points, function (_, point) {
      point._label.draw(false);
    });
  },
  _turnOffHatching(hoverStyle, selectionStyle) {
    if (hoverStyle.hatching) {
      hoverStyle.hatching.direction = 'none';
    }
    if (selectionStyle.hatching) {
      selectionStyle.hatching.direction = 'none';
    }
  },
  _parsePointOptions: function (pointOptions, labelOptions, data, point) {
    const that = this;
    const options = that._options;
    const styles = that._createPointStyles(pointOptions, data, point);
    const parsedOptions = (0, _extend2.extend)({}, pointOptions, {
      type: options.type,
      rotated: options.rotated,
      styles: styles,
      widgetType: options.widgetType,
      visibilityChanged: options.visibilityChanged
    });
    parsedOptions.label = getLabelOptions(labelOptions, styles.labelColor);
    if (that.areErrorBarsVisible()) {
      parsedOptions.errorBars = options.valueErrorBar;
    }
    return parsedOptions;
  },
  _preparePointOptions: function (customOptions) {
    const pointOptions = this._getOptionsForPoint();
    return customOptions ? mergePointOptions(pointOptions, customOptions) : pointOptions;
  },
  _getMarkerGroupOptions: function () {
    return (0, _extend2.extend)(false, {}, this._getOptionsForPoint(), {
      hoverStyle: {},
      selectionStyle: {}
    });
  },
  _getAggregationMethod: function (isDiscrete, aggregateByCategory) {
    const options = this.getOptions().aggregation;
    const method = (0, _utils.normalizeEnum)(options.method);
    const customAggregator = method === 'custom' && options.calculate;
    let aggregator;
    if (isDiscrete && !aggregateByCategory) {
      aggregator = _ref => {
        let {
          data
        } = _ref;
        return data[0];
      };
    } else {
      aggregator = this._aggregators[method] || this._aggregators[this._defaultAggregator];
    }
    return customAggregator || aggregator;
  },
  _resample(_ref2, data) {
    let {
      interval,
      ticks,
      aggregateByCategory
    } = _ref2;
    const that = this;
    const isDiscrete = that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE;
    let dataIndex = 0;
    const dataSelector = this._getPointDataSelector();
    const options = that.getOptions();
    const addAggregatedData = (target, data, aggregationInfo) => {
      if (!data) {
        return;
      }
      const processData = d => {
        const pointData = d && dataSelector(d, options);
        if (pointData && that._checkData(pointData)) {
          pointData.aggregationInfo = aggregationInfo;
          target.push(pointData);
        }
      };
      if (Array.isArray(data)) {
        data.forEach(processData);
      } else {
        processData(data);
      }
    };
    const aggregationMethod = this._getAggregationMethod(isDiscrete, aggregateByCategory);
    if (isDiscrete) {
      if (aggregateByCategory) {
        const categories = this.getArgumentAxis().getTranslator().getBusinessRange().categories;
        const groups = categories.reduce((g, category) => {
          g[category.valueOf()] = [];
          return g;
        }, {});
        data.forEach(dataItem => {
          groups[dataItem.argument.valueOf()].push(dataItem);
        });
        return categories.reduce((result, c) => {
          addAggregatedData(result, aggregationMethod({
            aggregationInterval: null,
            intervalStart: c,
            intervalEnd: c,
            data: groups[c.valueOf()].map(getData)
          }, that));
          return result;
        }, []);
      } else {
        return data.reduce((result, dataItem, index, data) => {
          result[1].push(dataItem);
          if (index === data.length - 1 || (index + 1) % interval === 0) {
            const dataInInterval = result[1];
            const aggregationInfo = {
              aggregationInterval: interval,
              data: dataInInterval.map(getData)
            };
            addAggregatedData(result[0], aggregationMethod(aggregationInfo, that));
            result[1] = [];
          }
          return result;
        }, [[], []])[0];
      }
    }
    const aggregatedData = [];
    if (ticks.length === 1) {
      const aggregationInfo = {
        intervalStart: ticks[0],
        intervalEnd: ticks[0],
        aggregationInterval: null,
        data: data.map(getData)
      };
      addAggregatedData(aggregatedData, aggregationMethod(aggregationInfo, that), aggregationInfo);
    } else {
      for (let i = 1; i < ticks.length; i++) {
        const intervalEnd = ticks[i];
        const intervalStart = ticks[i - 1];
        const dataInInterval = [];
        while (data[dataIndex] && data[dataIndex].argument < intervalEnd) {
          if (data[dataIndex].argument >= intervalStart) {
            dataInInterval.push(data[dataIndex]);
          }
          dataIndex++;
        }
        const aggregationInfo = {
          intervalStart,
          intervalEnd,
          aggregationInterval: interval,
          data: dataInInterval.map(getData)
        };
        addAggregatedData(aggregatedData, aggregationMethod(aggregationInfo, that), aggregationInfo);
      }
    }
    that._endUpdateData();
    return aggregatedData;
  },
  canRenderCompleteHandle: function () {
    const result = this._canRenderCompleteHandle;
    delete this._canRenderCompleteHandle;
    return !!result;
  },
  isHovered: function () {
    return !!(this.fullState & 1);
  },
  isSelected: function () {
    return !!(this.fullState & 2);
  },
  isVisible: function () {
    return this._visible;
  },
  getAllPoints: function () {
    this._createAllAggregatedPoints();
    return (this._points || []).slice();
  },
  getPointByPos: function (pos) {
    this._createAllAggregatedPoints();
    return (this._points || [])[pos];
  },
  getVisiblePoints: function () {
    return (this._drawnPoints || []).slice();
  },
  selectPoint: function (point) {
    if (!point.isSelected()) {
      setPointSelectedState(point, this._legendCallback);
      this._eventPipe({
        action: POINT_SELECT,
        target: point
      });
      this._eventTrigger(POINT_SELECTION_CHANGED, {
        target: point
      });
    }
  },
  deselectPoint: function (point) {
    if (point.isSelected()) {
      releasePointSelectedState(point, this._legendCallback);
      this._eventPipe({
        action: POINT_DESELECT,
        target: point
      });
      this._eventTrigger(POINT_SELECTION_CHANGED, {
        target: point
      });
    }
  },
  hover: function (mode) {
    const that = this;
    const eventTrigger = that._eventTrigger;
    if (that.isHovered()) {
      return;
    }
    that.lastHoverMode = (0, _utils.normalizeEnum)(mode || that._options.hoverMode);
    that.fullState = that.fullState | HOVER_STATE;
    that._changeStyle(that.lastHoverMode, undefined, that.isSelected() && that.lastSelectionMode !== NONE_MODE);
    eventTrigger(SERIES_HOVER_CHANGED, {
      target: that
    });
  },
  clearHover: function () {
    const that = this;
    const eventTrigger = that._eventTrigger;
    if (!that.isHovered()) {
      return;
    }
    that._resetNearestPoint();
    that.fullState = that.fullState & ~HOVER_STATE;
    that._changeStyle(that.lastHoverMode, HOVER, that.isSelected() && that.lastSelectionMode !== NONE_MODE);
    eventTrigger(SERIES_HOVER_CHANGED, {
      target: that
    });
  },
  hoverPoint: function (point) {
    const that = this;
    if (!point.isHovered()) {
      point.clearHover();
      setPointHoverState(point, that._legendCallback);
      that._canChangeView() && that._applyStyle(that._styles.hover);
      that._eventPipe({
        action: POINT_HOVER,
        target: point
      });
      that._eventTrigger(POINT_HOVER_CHANGED, {
        target: point
      });
    }
  },
  clearPointHover: function () {
    const that = this;
    that.getPoints().some(function (currentPoint) {
      if (currentPoint.isHovered()) {
        releasePointHoverState(currentPoint, that._legendCallback);
        that._canChangeView() && that._applyStyle(that._styles.normal);
        that._eventPipe({
          action: CLEAR_POINT_HOVER,
          target: currentPoint
        });
        that._eventTrigger(POINT_HOVER_CHANGED, {
          target: currentPoint
        });
        return true;
      }
      return false;
    });
  },
  showPointTooltip: function (point) {
    triggerEvent(this._extGroups.seriesGroup, 'showpointtooltip', point);
  },
  hidePointTooltip: function (point) {
    triggerEvent(this._extGroups.seriesGroup, 'hidepointtooltip', point);
  },
  select: function () {
    const that = this;
    if (!that.isSelected()) {
      that._setSelectedState(that._options.selectionMode);
      that._eventPipe({
        action: SERIES_SELECT,
        target: that
      });
      that._group.toForeground();
      that._eventTrigger(SERIES_SELECTION_CHANGED, {
        target: that
      });
    }
  },
  clearSelection: function clearSelection() {
    const that = this;
    if (that.isSelected()) {
      that._releaseSelectedState();
      that._eventTrigger(SERIES_SELECTION_CHANGED, {
        target: that
      });
    }
  },
  getPointsByArg: function (arg, skipPointsCreation) {
    const that = this;
    const argValue = arg.valueOf();
    let points = that.pointsByArgument[argValue];
    if (!points && !skipPointsCreation && that._createAllAggregatedPoints()) {
      points = that.pointsByArgument[argValue];
    }
    return points || [];
  },
  _createAllAggregatedPoints: function () {
    if (this.useAggregation() && !this._useAllAggregatedPoints) {
      this.createPoints(true);
      return true;
    }
    return false;
  },
  getPointsByKeys: function (arg) {
    return this.getPointsByArg(arg);
  },
  notify: function (data) {
    const that = this;
    const action = data.action;
    const seriesModes = that._seriesModes;
    const target = data.target;
    const targetOptions = target.getOptions();
    const pointHoverMode = (0, _utils.normalizeEnum)(targetOptions.hoverMode);
    const selectionModeOfPoint = (0, _utils.normalizeEnum)(targetOptions.selectionMode);
    if (action === POINT_HOVER) {
      that._hoverPointHandler(target, pointHoverMode, data.notifyLegend);
    } else if (action === CLEAR_POINT_HOVER) {
      that._clearPointHoverHandler(target, pointHoverMode, data.notifyLegend);
    } else if (action === SERIES_SELECT) {
      target !== that && seriesModes.seriesSelectionMode === 'single' && that.clearSelection();
    } else if (action === POINT_SELECT) {
      if (seriesModes.pointSelectionMode === 'single') {
        that.getPoints().some(function (currentPoint) {
          if (currentPoint !== target && currentPoint.isSelected()) {
            that.deselectPoint(currentPoint);
            return true;
          }
          return false;
        });
      }
      that._selectPointHandler(target, selectionModeOfPoint);
    } else if (action === POINT_DESELECT) {
      that._deselectPointHandler(target, selectionModeOfPoint);
    }
  },
  _selectPointHandler: function (target, mode) {
    const that = this;
    if (mode === ALL_SERIES_POINTS) {
      target.series === that && that._setPointsView(SELECTION, target);
    } else if (mode === ALL_ARGUMENT_POINTS) {
      that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint !== target && currentPoint.setView(SELECTION);
      });
    }
  },
  _deselectPointHandler: function (target, mode) {
    if (mode === ALL_SERIES_POINTS) {
      target.series === this && this._resetPointsView(SELECTION, target);
    } else if (mode === ALL_ARGUMENT_POINTS) {
      this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint !== target && currentPoint.resetView(SELECTION);
      });
    }
  },
  _hoverPointHandler: function (target, mode, notifyLegend) {
    const that = this;
    if (target.series !== that && mode === ALL_ARGUMENT_POINTS) {
      that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint.setView(HOVER);
      });
      notifyLegend && that._legendCallback(target);
    } else if (mode === ALL_SERIES_POINTS && target.series === that) {
      that._setPointsView(HOVER, target);
    }
  },
  _clearPointHoverHandler: function (target, mode, notifyLegend) {
    const that = this;
    if (mode === ALL_ARGUMENT_POINTS) {
      target.series !== that && that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint.resetView(HOVER);
      });
      notifyLegend && that._legendCallback(target);
    } else if (mode === ALL_SERIES_POINTS && target.series === that) {
      that._resetPointsView(HOVER, target);
    }
  },
  _deletePoints: function () {
    const that = this;
    that._disposePoints(that._points);
    that._points = that._drawnPoints = null;
  },
  _deleteTrackers: function () {
    const that = this;
    (0, _iterator.each)(that._trackers || [], function (_, tracker) {
      tracker.remove();
    });
    that._trackersGroup && that._trackersGroup.dispose();
    that._trackers = that._trackersGroup = null;
  },
  dispose: function () {
    const that = this;
    that._deletePoints();
    that._group.dispose();
    that._labelsGroup && that._labelsGroup.dispose();
    that._errorBarGroup && that._errorBarGroup.dispose();
    that._deleteTrackers();
    that._group = that._extGroups = that._markersGroup = that._elementsGroup = that._bordersGroup = that._labelsGroup = that._errorBarGroup = that._graphics = that._rangeData = that._renderer = that._styles = that._options = that._pointOptions = that._drawnPoints = that.pointsByArgument = that._segments = that._prevSeries = null;
  },
  correctPosition: _common.noop,
  drawTrackers: _common.noop,
  getNeighborPoint: _common.noop,
  areErrorBarsVisible: _common.noop,
  _getColorId: _common.noop,
  getMarginOptions: function () {
    return this._patchMarginOptions({
      percentStick: this.isFullStackedSeries()
    });
  },
  getColor: function () {
    return this.getLegendStyles().normal.fill;
  },
  getOpacity: function () {
    return this._options.opacity;
  },
  getStackName: function () {
    return this._stackName;
  },
  getBarOverlapGroup: function () {
    return this._options.barOverlapGroup;
  },
  getPointByCoord: function (x, y) {
    const point = this.getNeighborPoint(x, y);
    return point !== null && point !== void 0 && point.coordsIn(x, y) ? point : null;
  },
  getValueAxis: function () {
    return this._valueAxis;
  },
  getArgumentAxis: function () {
    return this._argumentAxis;
  },
  getMarkersGroup() {
    return this._markersGroup;
  },
  getRenderer() {
    return this._renderer;
  },
  removePointElements() {
    if (this._markersGroup) {
      (0, _iterator.each)(this._points, (_, p) => p.deleteMarker());
      this._markersGroup.dispose();
      this._markersGroup = null;
    }
  },
  removeGraphicElements() {
    const that = this;
    if (that._elementsGroup) {
      that._elementsGroup.dispose();
      that._elementsGroup = null;
    }
    (0, _iterator.each)(that._graphics || [], (_, elem) => {
      that._removeElement(elem);
    });
    that._graphics = null;
  },
  removeBordersGroup() {
    if (this._bordersGroup) {
      this._bordersGroup.dispose();
      this._bordersGroup = null;
    }
  }
};
const mixins = exports.mixins = seriesNS.mixins;

/***/ }),

/***/ 64216:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.chart = void 0;
var _line_series = __webpack_require__(7222);
var _scatter_series = __webpack_require__(21667);
var _area_series = __webpack_require__(90048);
var _bar_series = __webpack_require__(58821);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _common = __webpack_require__(20576);
const lineSeries = _line_series.chart.line;
const areaSeries = _area_series.chart.area;
const chartBarSeries = _bar_series.chart.bar;
const polarBarSeries = _bar_series.polar.bar;
const _extend = _extend2.extend;
const _each = _iterator.each;
const _noop = _common.noop;
const chart = exports.chart = {};
chart.bubble = _extend({}, _scatter_series.chart, {
  _calculateErrorBars: _noop,
  _getMainColor: chartBarSeries._getMainColor,
  _createPointStyles: chartBarSeries._createPointStyles,
  _updatePointsVisibility: chartBarSeries._updatePointsVisibility,
  _getOptionsForPoint: chartBarSeries._getOptionsForPoint,
  _applyMarkerClipRect: lineSeries._applyElementsClipRect,
  _parsePointStyle: polarBarSeries._parsePointStyle,
  _createLegendState: areaSeries._createLegendState,
  _getColorId: areaSeries._getColorId,
  _setMarkerGroupSettings: polarBarSeries._setMarkerGroupSettings,
  areErrorBarsVisible: _noop,
  _createErrorBarGroup: _noop,
  _checkData: function (data, skippedFields) {
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      value: this.getValueFields()[0],
      size: this.getSizeField()
    });
  },
  _getPointDataSelector: function (data, options) {
    const sizeField = this.getSizeField();
    const baseGetter = _scatter_series.chart._getPointDataSelector.call(this);
    return data => {
      const pointData = baseGetter(data);
      pointData.size = data[sizeField];
      return pointData;
    };
  },
  _aggregators: {
    avg(_ref, series) {
      let {
        data,
        intervalStart,
        intervalEnd
      } = _ref;
      if (!data.length) {
        return;
      }
      const valueField = series.getValueFields()[0];
      const sizeField = series.getSizeField();
      const aggregate = data.reduce((result, item) => {
        result[0] += item[valueField];
        result[1] += item[sizeField];
        result[2]++;
        return result;
      }, [0, 0, 0]);
      return {
        [valueField]: aggregate[0] / aggregate[2],
        [sizeField]: aggregate[1] / aggregate[2],
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
      };
    }
  },
  getValueFields: function () {
    return [this._options.valueField || 'val'];
  },
  getSizeField: function () {
    return this._options.sizeField || 'size';
  },
  _animate: function () {
    const that = this;
    const lastPointIndex = that._drawnPoints.length - 1;
    const labelsGroup = that._labelsGroup;
    const labelAnimFunc = function () {
      labelsGroup && labelsGroup.animate({
        opacity: 1
      }, {
        duration: that._defaultDuration
      });
    };
    _each(that._drawnPoints || [], function (i, p) {
      p.animate(i === lastPointIndex ? labelAnimFunc : undefined, {
        r: p.bubbleSize,
        translateX: p.x,
        translateY: p.y
      });
    });
  },
  _patchMarginOptions: function (options) {
    options.processBubbleSize = true;
    return options;
  }
});

/***/ }),

/***/ 29788:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.stock = exports.candlestick = void 0;
var _scatter_series = __webpack_require__(21667);
var _bar_series = __webpack_require__(58821);
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
// there are stock, candlestick

const barSeries = _bar_series.chart.bar;
const DEFAULT_FINANCIAL_POINT_SIZE = 10;
const stock = exports.stock = (0, _extend2.extend)({}, _scatter_series.chart, {
  _animate: _common.noop,
  _applyMarkerClipRect: function (settings) {
    settings['clip-path'] = this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID;
  },
  _updatePointsVisibility: barSeries._updatePointsVisibility,
  _getOptionsForPoint: barSeries._getOptionsForPoint,
  _createErrorBarGroup: _common.noop,
  areErrorBarsVisible: _common.noop,
  _createGroups: _scatter_series.chart._createGroups,
  _setMarkerGroupSettings: function () {
    const that = this;
    const markersGroup = that._markersGroup;
    const styles = that._createPointStyles(that._getMarkerGroupOptions());
    const defaultStyle = (0, _extend2.extend)(styles.normal, {
      'class': 'default-markers'
    });
    const defaultPositiveStyle = (0, _extend2.extend)(styles.positive.normal, {
      'class': 'default-positive-markers'
    });
    const reductionStyle = (0, _extend2.extend)(styles.reduction.normal, {
      'class': 'reduction-markers'
    });
    const reductionPositiveStyle = (0, _extend2.extend)(styles.reductionPositive.normal, {
      'class': 'reduction-positive-markers'
    });
    const markerSettings = {
      'class': 'dxc-markers'
    };
    that._applyMarkerClipRect(markerSettings);
    markersGroup.attr(markerSettings);
    that._createGroup('defaultMarkersGroup', markersGroup, markersGroup, defaultStyle);
    that._createGroup('reductionMarkersGroup', markersGroup, markersGroup, reductionStyle);
    that._createGroup('defaultPositiveMarkersGroup', markersGroup, markersGroup, defaultPositiveStyle);
    that._createGroup('reductionPositiveMarkersGroup', markersGroup, markersGroup, reductionPositiveStyle);
  },
  _setGroupsSettings: function () {
    _scatter_series.chart._setGroupsSettings.call(this, false);
  },
  _getCreatingPointOptions: function () {
    const that = this;
    let defaultPointOptions;
    let creatingPointOptions = that._predefinedPointOptions;
    if (!creatingPointOptions) {
      defaultPointOptions = this._getPointOptions();
      that._predefinedPointOptions = creatingPointOptions = (0, _extend2.extend)(true, {
        styles: {}
      }, defaultPointOptions);
      creatingPointOptions.styles.normal = creatingPointOptions.styles.positive.normal = creatingPointOptions.styles.reduction.normal = creatingPointOptions.styles.reductionPositive.normal = {
        'stroke-width': defaultPointOptions.styles && defaultPointOptions.styles.normal && defaultPointOptions.styles.normal['stroke-width']
      };
    }
    return creatingPointOptions;
  },
  _checkData: function (data, skippedFields) {
    const valueFields = this.getValueFields();
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      openValue: valueFields[0],
      highValue: valueFields[1],
      lowValue: valueFields[2],
      closeValue: valueFields[3]
    }) && data.highValue === data.highValue && data.lowValue === data.lowValue;
  },
  _getPointDataSelector: function (data, options) {
    const that = this;
    let level;
    const valueFields = that.getValueFields();
    const argumentField = that.getArgumentField();
    const openValueField = valueFields[0];
    const highValueField = valueFields[1];
    const lowValueField = valueFields[2];
    const closeValueField = valueFields[3];
    that.level = that._options.reduction.level;
    switch ((0, _utils.normalizeEnum)(that.level)) {
      case 'open':
        level = openValueField;
        break;
      case 'high':
        level = highValueField;
        break;
      case 'low':
        level = lowValueField;
        break;
      default:
        level = closeValueField;
        that.level = 'close';
        break;
    }
    let prevLevelValue;
    return data => {
      const reductionValue = data[level];
      let isReduction = false;
      if ((0, _type.isDefined)(reductionValue)) {
        if ((0, _type.isDefined)(prevLevelValue)) {
          isReduction = reductionValue < prevLevelValue;
        }
        prevLevelValue = reductionValue;
      }
      return {
        argument: data[argumentField],
        highValue: this._processEmptyValue(data[highValueField]),
        lowValue: this._processEmptyValue(data[lowValueField]),
        closeValue: this._processEmptyValue(data[closeValueField]),
        openValue: this._processEmptyValue(data[openValueField]),
        reductionValue: reductionValue,
        tag: data[that.getTagField()],
        isReduction: isReduction,
        data: data
      };
    };
  },
  _parsePointStyle: function (style, defaultColor, innerColor) {
    const color = (0, _utils.extractColor)(style.color, true);
    return {
      stroke: color || defaultColor,
      'stroke-width': style.width,
      fill: color || innerColor
    };
  },
  _getDefaultStyle: function (options) {
    const that = this;
    const mainPointColor = (0, _utils.extractColor)(options.color, true) || that._options.mainSeriesColor;
    return {
      normal: that._parsePointStyle(options, mainPointColor, mainPointColor),
      hover: that._parsePointStyle(options.hoverStyle, mainPointColor, mainPointColor),
      selection: that._parsePointStyle(options.selectionStyle, mainPointColor, mainPointColor)
    };
  },
  _getReductionStyle: function (options) {
    const that = this;
    const reductionColor = options.reduction.color;
    return {
      normal: that._parsePointStyle({
        color: reductionColor,
        width: options.width,
        hatching: options.hatching
      }, reductionColor, reductionColor),
      hover: that._parsePointStyle(options.hoverStyle, reductionColor, reductionColor),
      selection: that._parsePointStyle(options.selectionStyle, reductionColor, reductionColor)
    };
  },
  _createPointStyles: function (pointOptions) {
    const that = this;
    const innerColor = that._options.innerColor;
    const styles = that._getDefaultStyle(pointOptions);
    const positiveStyle = (0, _extend2.extend)(true, {}, styles);
    const reductionStyle = that._getReductionStyle(pointOptions);
    const reductionPositiveStyle = (0, _extend2.extend)(true, {}, reductionStyle);
    positiveStyle.normal.fill = positiveStyle.hover.fill = positiveStyle.selection.fill = innerColor;
    reductionPositiveStyle.normal.fill = reductionPositiveStyle.hover.fill = reductionPositiveStyle.selection.fill = innerColor;
    styles.positive = positiveStyle;
    styles.reduction = reductionStyle;
    styles.reductionPositive = reductionPositiveStyle;
    styles.labelColor = that._options.mainSeriesColor;
    return styles;
  },
  _endUpdateData: function () {
    delete this._predefinedPointOptions;
  },
  _defaultAggregator: 'ohlc',
  _aggregators: {
    'ohlc': (_ref, series) => {
      let {
        intervalStart,
        intervalEnd,
        data
      } = _ref;
      if (!data.length) {
        return;
      }
      let result = {};
      const valueFields = series.getValueFields();
      const highValueField = valueFields[1];
      const lowValueField = valueFields[2];
      result[highValueField] = -Infinity;
      result[lowValueField] = Infinity;
      result = data.reduce(function (result, item) {
        if (item[highValueField] !== null) {
          result[highValueField] = Math.max(result[highValueField], item[highValueField]);
        }
        if (item[lowValueField] !== null) {
          result[lowValueField] = Math.min(result[lowValueField], item[lowValueField]);
        }
        return result;
      }, result);
      result[valueFields[0]] = data[0][valueFields[0]];
      result[valueFields[3]] = data[data.length - 1][valueFields[3]];
      if (!isFinite(result[highValueField])) {
        result[highValueField] = null;
      }
      if (!isFinite(result[lowValueField])) {
        result[lowValueField] = null;
      }
      result[series.getArgumentField()] = series._getIntervalCenter(intervalStart, intervalEnd);
      return result;
    }
  },
  getValueFields: function () {
    const options = this._options;
    return [options.openValueField || 'open', options.highValueField || 'high', options.lowValueField || 'low', options.closeValueField || 'close'];
  },
  getArgumentField: function () {
    return this._options.argumentField || 'date';
  },
  _patchMarginOptions: function (options) {
    const pointOptions = this._getCreatingPointOptions();
    const styles = pointOptions.styles;
    const border = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {
      return Math.max(max, style['stroke-width']);
    }, 0);
    options.size = DEFAULT_FINANCIAL_POINT_SIZE + border;
    options.sizePointNormalState = DEFAULT_FINANCIAL_POINT_SIZE;
    return options;
  },
  getSeriesPairCoord(coord, isArgument) {
    let oppositeCoord = null;
    const points = this.getVisiblePoints();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      let tmpCoord;
      if (isArgument) {
        tmpCoord = p.vx === coord ? (p.openY + p.closeY) / 2 : undefined;
      } else {
        const coords = [Math.min(p.lowY, p.highY), Math.max(p.lowY, p.highY)];
        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p.vx : undefined;
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  },
  usePointsToDefineAutoHiding() {
    return false;
  }
});
const candlestick = exports.candlestick = (0, _extend2.extend)({}, stock, {
  _parsePointStyle: function (style, defaultColor, innerColor) {
    const color = (0, _utils.extractColor)(style.color, true) || innerColor;
    const base = stock._parsePointStyle.call(this, style, defaultColor, color);
    base.fill = color;
    base.hatching = style.hatching;
    return base;
  }
});

/***/ }),

/***/ 10656:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.processDisplayFormat = processDisplayFormat;
var _localization = __webpack_require__(94484);
const startPlaceHolderChar = '{';
const endPlaceHolderChar = '}';
const placeholderFormatDelimiter = ':';
function formatValue(value, format) {
  if (format) {
    if (value instanceof Date) {
      return (0, _localization.formatDate)(value, format);
    }
    if (typeof value === 'number') {
      return (0, _localization.formatNumber)(value, format);
    }
  }
  return value;
}
function getValueByPlaceHolder(placeHolder, pointInfo) {
  let customFormat = '';
  const customFormatIndex = placeHolder.indexOf(placeholderFormatDelimiter);
  if (customFormatIndex > 0) {
    customFormat = placeHolder.substr(customFormatIndex + 1);
    placeHolder = placeHolder.substr(0, customFormatIndex);
  }
  return formatValue(pointInfo[placeHolder], customFormat);
}
function processDisplayFormat(displayFormat, pointInfo) {
  let actualText = displayFormat;
  let continueProcess = true;
  while (continueProcess) {
    const startBracketIndex = actualText.indexOf(startPlaceHolderChar);
    const endBracketIndex = actualText.indexOf(endPlaceHolderChar);
    if (startBracketIndex >= 0 && endBracketIndex > 0) {
      const placeHolder = actualText.substring(startBracketIndex + 1, endBracketIndex);
      const value = getValueByPlaceHolder(placeHolder, pointInfo);
      actualText = actualText.substr(0, startBracketIndex) + value + actualText.substr(endBracketIndex + 1);
    } else {
      continueProcess = false;
    }
  }
  return actualText;
}

/***/ }),

/***/ 63407:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
const DISCRETE = 'discrete';
const {
  abs,
  floor,
  ceil,
  min
} = Math;
function continuousRangeCalculator(range, minValue, maxValue) {
  range.min = range.min < minValue ? range.min : minValue;
  range.max = range.max > maxValue ? range.max : maxValue;
}
function createGetLogFunction(axisType, axis) {
  if (axisType !== 'logarithmic') {
    return null;
  }
  const base = axis.getOptions().logarithmBase;
  return value => {
    const log = (0, _utils.getLog)(abs(value), base);
    const round = log < 0 ? floor : ceil;
    return round(log);
  };
}
function getRangeCalculator(axisType, axis, getLog) {
  let rangeCalculator = continuousRangeCalculator;
  if (axisType === DISCRETE) {
    rangeCalculator = function (range, minValue, maxValue) {
      if (minValue !== maxValue) {
        range.categories.push(maxValue);
      }
      range.categories.push(minValue);
    };
  } else if (axis) {
    rangeCalculator = function (range, value) {
      const interval = axis.calculateInterval(value, range.prevValue);
      const minInterval = range.interval;
      range.interval = (minInterval < interval ? minInterval : interval) || minInterval;
      range.prevValue = value;
      continuousRangeCalculator(range, value, value);
    };
  }
  if (getLog) {
    return (range, minValue, maxValue) => {
      const minArgs = [];
      rangeCalculator(range, minValue, maxValue);
      minValue !== 0 && minArgs.push(getLog(minValue));
      maxValue !== 0 && minArgs.push(getLog(maxValue));
      const linearThreshold = min.apply(null, minArgs);
      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;
    };
  }
  return rangeCalculator;
}
function getInitialRange(axisType, dataType, firstValue) {
  const range = {
    axisType: axisType,
    dataType: dataType
  };
  if (axisType === DISCRETE) {
    range.categories = [];
  } else {
    range.min = (0, _type.isObject)(firstValue) ? firstValue.min : firstValue;
    range.max = (0, _type.isObject)(firstValue) ? firstValue.max : firstValue;
  }
  return range;
}
function processCategories(range) {
  if (range.categories) {
    range.categories = (0, _utils.unique)(range.categories);
  }
  return range;
}
function getValueForArgument(point, extraPoint, x, range) {
  if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {
    const y1 = point.value;
    const y2 = extraPoint.value;
    const x1 = point.argument;
    const x2 = extraPoint.argument;
    const r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();
    return range.dataType === 'datetime' ? new Date(r) : r;
  } else {
    return point.value;
  }
}
function calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {
  const value = getValueForArgument(point, prevPoint, bound, range);
  rangeCalculator(range, value, value);
}
function isLineSeries(series) {
  return series.type.toLowerCase().indexOf('line') >= 0 || series.type.toLowerCase().indexOf('area') >= 0;
}
function getViewportReducer(series) {
  const rangeCalculator = getRangeCalculator(series.valueAxisType);
  const argumentAxis = series.getArgumentAxis();
  const viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};
  const calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;
  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {
    const range = series.getArgumentAxis().getTranslator().getBusinessRange();
    const add = (0, _utils.getAddFunction)(range, false);
    const interval = range.interval;
    if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {
      viewport.startValue = add(viewport.startValue, interval, -1);
      viewport.endValue = add(viewport.endValue, interval);
    }
  }
  const viewportFilter = getViewPortFilter(viewport);
  return function (range, point, index, points) {
    const argument = point.argument;
    if (!point.hasValue()) {
      return range;
    }
    if (viewportFilter(argument)) {
      if (!range.startCalc) {
        range.startCalc = true;
        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);
      }
      rangeCalculator(range, point.getMinValue(), point.getMaxValue());
    } else if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {
      if (!range.startCalc) {
        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);
      }
      range.endCalc = true;
      calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);
    }
    return range;
  };
}
function getViewPortFilter(viewport) {
  if (viewport.categories) {
    const dictionary = viewport.categories.reduce((result, category) => {
      result[category.valueOf()] = true;
      return result;
    }, {});
    return argument => (0, _type.isDefined)(argument) && dictionary[argument.valueOf()];
  }
  if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {
    return () => true;
  }
  if (!(0, _type.isDefined)(viewport.endValue)) {
    return argument => argument >= viewport.startValue;
  }
  if (!(0, _type.isDefined)(viewport.startValue)) {
    return argument => argument <= viewport.endValue;
  }
  return argument => argument >= viewport.startValue && argument <= viewport.endValue;
}
var _default = exports["default"] = {
  getViewPortFilter,
  getArgumentRange: function (series) {
    const data = series._data || [];
    let range = {};
    if (data.length) {
      if (series.argumentAxisType === DISCRETE) {
        range = {
          categories: data.map(item => item.argument)
        };
      } else {
        let interval;
        if (data.length > 1) {
          const i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);
          const i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);
          interval = min(i1, i2);
        }
        range = {
          min: data[0].argument,
          max: data[data.length - 1].argument,
          interval
        };
      }
    }
    return processCategories(range);
  },
  getRangeData: function (series) {
    const points = series.getPoints();
    const useAggregation = series.useAggregation();
    const argumentAxis = series.getArgumentAxis();
    const argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && argumentAxis, createGetLogFunction(series.argumentAxisType, argumentAxis));
    const valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));
    const viewportReducer = getViewportReducer(series);
    const range = points.reduce(function (range, point, index, points) {
      const argument = point.argument;
      if (!point.isArgumentCorrect()) {
        return range;
      }
      argumentCalculator(range.arg, argument, argument);
      if (point.hasValue()) {
        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());
        viewportReducer(range.viewport, point, index, points);
      }
      return range;
    }, {
      arg: getInitialRange(series.argumentAxisType, series.argumentType, argumentAxis !== null && argumentAxis !== void 0 && argumentAxis.aggregatedPointBetweenTicks() ? undefined : series.getArgumentRangeInitialValue()),
      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined),
      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined)
    });
    if (useAggregation) {
      const argumentRange = this.getArgumentRange(series);
      if (series.argumentAxisType === DISCRETE) {
        range.arg = argumentRange;
      } else {
        const viewport = argumentAxis.getViewport();
        if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {
          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);
        }
        if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {
          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);
        }
      }
    }
    processCategories(range.arg);
    processCategories(range.val);
    return range;
  },
  getViewport: function (series) {
    const points = series.getPoints();
    let range = {};
    const reducer = getViewportReducer(series);
    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined);
    points.some(function (point, index) {
      reducer(range, point, index, points);
      return range.endCalc;
    });
    return range;
  },
  getPointsInViewPort: function (series) {
    const argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});
    const valueViewPort = series.getValueAxis().visualRange() || {};
    const valueViewPortFilter = getViewPortFilter(valueViewPort);
    const points = series.getPoints();
    const addValue = function (values, point, isEdge) {
      const minValue = point.getMinValue();
      const maxValue = point.getMaxValue();
      const isMinValueInViewPort = valueViewPortFilter(minValue);
      const isMaxValueInViewPort = valueViewPortFilter(maxValue);
      if (isMinValueInViewPort) {
        values.push(minValue);
      }
      if (maxValue !== minValue && isMaxValueInViewPort) {
        values.push(maxValue);
      }
      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {
        if (!values.length) {
          values.push(valueViewPort.startValue);
        } else {
          values.push(valueViewPort.endValue);
        }
      }
    };
    const addEdgePoints = isLineSeries(series) ? function (result, points, index) {
      const point = points[index];
      const prevPoint = points[index - 1];
      const nextPoint = points[index + 1];
      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {
        addValue(result[1], point, true);
      }
      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {
        addValue(result[1], point, true);
      }
    } : _common.noop;
    const checkPointInViewport = function (result, point, index) {
      if (argumentViewPortFilter(point.argument)) {
        addValue(result[0], point);
      } else {
        addEdgePoints(result, points, index);
      }
      return result;
    };
    return points.reduce(checkPointInViewport, [[], []]);
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 7222:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _scatter_series = __webpack_require__(21667);
var _object = __webpack_require__(48013);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _math = __webpack_require__(60810);
// there are line, stepline, stackedline, fullstackedline, spline

const DISCRETE = 'discrete';
const {
  round,
  sqrt,
  pow,
  min,
  max,
  abs
} = Math;
const chart = exports.chart = {};
const polar = exports.polar = {};
function clonePoint(point, newX, newY, newAngle) {
  const p = (0, _object.clone)(point);
  p.x = newX;
  p.y = newY;
  p.angle = newAngle;
  return p;
}
function getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {
  const correctAngle = point.angle + nextStepAngle;
  const cosSin = (0, _utils.getCosAndSin)(correctAngle);
  const x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;
  const y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;
  return clonePoint(prevPoint, x, y, correctAngle);
}
function obtainCubicBezierTCoef(p, p0, p1, p2, p3) {
  const d = p0 - p;
  const c = 3 * p1 - 3 * p0;
  const b = 3 * p2 - 6 * p1 + 3 * p0;
  const a = p3 - 3 * p2 + 3 * p1 - p0;
  return (0, _math.solveCubicEquation)(a, b, c, d);
}
const lineMethods = {
  autoHidePointMarkersEnabled() {
    return true;
  },
  _applyGroupSettings: function (style, settings, group) {
    const that = this;
    settings = (0, _extend.extend)(settings, style);
    that._applyElementsClipRect(settings);
    group.attr(settings);
  },
  _setGroupsSettings: function (animationEnabled) {
    const that = this;
    const style = that._styles.normal;
    that._applyGroupSettings(style.elements, {
      'class': 'dxc-elements'
    }, that._elementsGroup);
    that._bordersGroup && that._applyGroupSettings(style.border, {
      'class': 'dxc-borders'
    }, that._bordersGroup);
    _scatter_series.chart._setGroupsSettings.call(that, animationEnabled);
    animationEnabled && that._markersGroup && that._markersGroup.attr({
      opacity: 0.001
    });
  },
  _createGroups: function () {
    const that = this;
    that._createGroup('_elementsGroup', that, that._group);
    that._areBordersVisible() && that._createGroup('_bordersGroup', that, that._group);
    _scatter_series.chart._createGroups.call(that);
  },
  _areBordersVisible: function () {
    return false;
  },
  _getDefaultSegment: function (segment) {
    return {
      line: (0, _utils.map)(segment.line || [], function (pt) {
        return pt.getDefaultCoords();
      })
    };
  },
  _prepareSegment: function (points) {
    return {
      line: points
    };
  },
  _parseLineOptions: function (options, defaultColor) {
    return {
      stroke: (0, _utils.extractColor)(options.color, true) || defaultColor,
      'stroke-width': options.width,
      dashStyle: options.dashStyle || 'solid'
    };
  },
  _parseStyle: function (options, defaultColor) {
    return {
      elements: this._parseLineOptions(options, defaultColor)
    };
  },
  _applyStyle: function (style) {
    const that = this;
    that._elementsGroup && that._elementsGroup.attr(style.elements);
    (0, _iterator.each)(that._graphics || [], function (_, graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.elements['stroke-width']
      }).sharp();
    });
  },
  _drawElement: function (segment, group) {
    return {
      line: this._createMainElement(segment.line, {
        'stroke-width': this._styles.normal.elements['stroke-width']
      }).append(group)
    };
  },
  _removeElement: function (element) {
    element.line.remove();
  },
  _updateElement: function (element, segment, animate, animationComplete) {
    const params = {
      points: segment.line
    };
    const lineElement = element.line;
    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);
  },
  _animateComplete: function () {
    const that = this;
    _scatter_series.chart._animateComplete.call(that);
    that._markersGroup && that._markersGroup.animate({
      opacity: 1
    }, {
      duration: that._defaultDuration
    });
  },
  _animate: function () {
    const that = this;
    const lastIndex = that._graphics.length - 1;
    (0, _iterator.each)(that._graphics || [], function (i, elem) {
      let complete;
      if (i === lastIndex) {
        complete = function () {
          that._animateComplete();
        };
      }
      that._updateElement(elem, that._segments[i], true, complete);
    });
  },
  _drawPoint: function (options) {
    _scatter_series.chart._drawPoint.call(this, {
      point: options.point,
      groups: options.groups
    });
  },
  _createMainElement: function (points, settings) {
    return this._renderer.path(points, 'line').attr(settings);
  },
  _sortPoints: function (points, rotated) {
    return rotated ? points.sort(function (p1, p2) {
      return p2.y - p1.y;
    }) : points.sort(function (p1, p2) {
      return p1.x - p2.x;
    });
  },
  _drawSegment: function (points, animationEnabled, segmentCount, lastSegment) {
    const that = this;
    const rotated = that._options.rotated;
    const segment = that._prepareSegment(points, rotated, lastSegment);
    that._segments.push(segment);
    if (!that._graphics[segmentCount]) {
      that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup);
    } else if (!animationEnabled) {
      that._updateElement(that._graphics[segmentCount], segment);
    }
  },
  _getTrackerSettings: function () {
    const that = this;
    const defaultTrackerWidth = that._defaultTrackerWidth;
    const strokeWidthFromElements = that._styles.normal.elements['stroke-width'];
    return {
      'stroke-width': strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,
      fill: 'none'
    };
  },
  _getMainPointsFromSegment: function (segment) {
    return segment.line;
  },
  _drawTrackerElement: function (segment) {
    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));
  },
  _updateTrackerElement: function (segment, element) {
    const settings = this._getTrackerSettings(segment);
    settings.points = this._getMainPointsFromSegment(segment);
    element.attr(settings);
  },
  checkSeriesViewportCoord(axis, coord) {
    if (!_scatter_series.chart.checkSeriesViewportCoord.call(this)) {
      return false;
    }
    const range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();
    const min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);
    const max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);
    const rotated = this.getOptions().rotated;
    const inverted = axis.getOptions().inverted;
    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;
  }
};
const lineSeries = chart['line'] = (0, _extend.extend)({}, _scatter_series.chart, lineMethods, {
  getPointCenterByArg(arg) {
    const value = this.getArgumentAxis().getTranslator().translate(arg);
    return {
      x: value,
      y: value
    };
  },
  getSeriesPairCoord(coord, isArgument) {
    const that = this;
    let oppositeCoord = null;
    const nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
    const needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;
    for (let i = 0; i < nearestPoints.length; i++) {
      const p = nearestPoints[i];
      const k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);
      const b = p[0].vy - p[0].vx * k;
      let tmpCoord;
      if (p[1].vx - p[0].vx === 0) {
        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;
      } else {
        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  }
});
chart['stepline'] = (0, _extend.extend)({}, lineSeries, {
  _calculateStepLinePoints(points) {
    const segment = [];
    const coordName = this._options.rotated ? 'x' : 'y';
    (0, _iterator.each)(points, function (i, pt) {
      let point;
      if (!i) {
        segment.push(pt);
        return;
      }
      const step = segment[segment.length - 1][coordName];
      if (step !== pt[coordName]) {
        point = (0, _object.clone)(pt);
        point[coordName] = step;
        segment.push(point);
      }
      segment.push(pt);
    });
    return segment;
  },
  _prepareSegment: function (points) {
    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));
  },
  getSeriesPairCoord(coord, isArgument) {
    let oppositeCoord;
    const rotated = this._options.rotated;
    const isOpposite = !isArgument && !rotated || isArgument && rotated;
    const coordName = !isOpposite ? 'vx' : 'vy';
    const oppositeCoordName = !isOpposite ? 'vy' : 'vx';
    const nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
    for (let i = 0; i < nearestPoints.length; i++) {
      const p = nearestPoints[i];
      let tmpCoord;
      if (isArgument) {
        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];
      } else {
        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  }
});
chart['spline'] = (0, _extend.extend)({}, lineSeries, {
  _calculateBezierPoints: function (src, rotated) {
    const bezierPoints = [];
    const pointsCopy = src;
    const checkExtremum = function (otherPointCoord, pointCoord, controlCoord) {
      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;
    };
    if (pointsCopy.length !== 1) {
      pointsCopy.forEach(function (curPoint, i) {
        let leftControlX;
        let leftControlY;
        let rightControlX;
        let rightControlY;
        const prevPoint = pointsCopy[i - 1];
        const nextPoint = pointsCopy[i + 1];
        let x1;
        let x2;
        let y1;
        let y2;
        const lambda = 0.5;
        let a;
        let b;
        let c;
        let xc;
        let yc;
        let shift;
        if (!i || i === pointsCopy.length - 1) {
          bezierPoints.push(curPoint, curPoint);
          return;
        }
        const xCur = curPoint.x;
        const yCur = curPoint.y;
        x1 = prevPoint.x;
        x2 = nextPoint.x;
        y1 = prevPoint.y;
        y2 = nextPoint.y;

        // check for extremum
        const curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));
        if (curIsExtremum) {
          if (!rotated) {
            rightControlY = leftControlY = yCur;
            rightControlX = (xCur + nextPoint.x) / 2;
            leftControlX = (xCur + prevPoint.x) / 2;
          } else {
            rightControlX = leftControlX = xCur;
            rightControlY = (yCur + nextPoint.y) / 2;
            leftControlY = (yCur + prevPoint.y) / 2;
          }
        } else {
          a = y2 - y1;
          b = x1 - x2;
          c = y1 * x2 - x1 * y2;
          if (!rotated) {
            if (!b) {
              bezierPoints.push(curPoint, curPoint, curPoint);
              return;
            }
            xc = xCur;
            yc = -1 * (a * xc + c) / b;
            shift = yc - yCur;
            y1 -= shift;
            y2 -= shift;
          } else {
            if (!a) {
              bezierPoints.push(curPoint, curPoint, curPoint);
              return;
            }
            yc = yCur;
            xc = -1 * (b * yc + c) / a;
            shift = xc - xCur;
            x1 -= shift;
            x2 -= shift;
          }
          rightControlX = (xCur + lambda * x2) / (1 + lambda);
          rightControlY = (yCur + lambda * y2) / (1 + lambda);
          leftControlX = (xCur + lambda * x1) / (1 + lambda);
          leftControlY = (yCur + lambda * y1) / (1 + lambda);
        }

        // check control points for extremum
        if (!rotated) {
          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);
          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);
        } else {
          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);
          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);
        }
        const leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
        const rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
        bezierPoints.push(leftPoint, curPoint, rightPoint);
      });
    } else {
      bezierPoints.push(pointsCopy[0]);
    }
    return bezierPoints;
  },
  _prepareSegment: function (points, rotated) {
    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));
  },
  _createMainElement: function (points, settings) {
    return this._renderer.path(points, 'bezier').attr(settings);
  },
  getSeriesPairCoord(coord, isArgument) {
    const that = this;
    let oppositeCoord = null;
    const isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;
    const coordName = !isOpposite ? 'vx' : 'vy';
    const bezierCoordName = !isOpposite ? 'x' : 'y';
    const oppositeCoordName = !isOpposite ? 'vy' : 'vx';
    const bezierOppositeCoordName = !isOpposite ? 'y' : 'x';
    const axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();
    const visibleArea = axis.getVisibleArea();
    const nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
    for (let i = 0; i < nearestPoints.length; i++) {
      const p = nearestPoints[i];
      if (p.length === 1) {
        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);
      } else {
        const ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);
        ts.forEach(t => {
          if (t >= 0 && t <= 1) {
            const tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];
            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {
              oppositeCoord = tmpCoord;
            }
          }
        });
      }
      if (oppositeCoord !== null) {
        break;
      }
    }
    return oppositeCoord;
  },
  _getNearestPoints(point, nextPoint, bezierPoints) {
    const index = bezierPoints.indexOf(point);
    return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint];
  },
  _getBezierPoints() {
    return this._segments.length > 0 ? this._segments.reduce((a, seg) => a.concat(seg.line), []) : [];
  }
});
polar.line = (0, _extend.extend)({}, _scatter_series.polar, lineMethods, {
  _sortPoints: function (points) {
    return points;
  },
  _prepareSegment: function (points, rotated, lastSegment) {
    let preparedPoints = [];
    const centerPoint = this.getValueAxis().getCenter();
    let i;
    lastSegment && this._closeSegment(points);
    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {
      for (i = 1; i < points.length; i++) {
        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint, i === points.length - 1));
      }
      if (!preparedPoints.length) {
        // T174220
        preparedPoints = points;
      }
    } else {
      return lineSeries._prepareSegment.call(this, points);
    }
    return {
      line: preparedPoints
    };
  },
  _getRemainingAngle: function (angle) {
    const normAngle = (0, _utils.normalizeAngle)(angle);
    return angle >= 0 ? 360 - normAngle : -normAngle;
  },
  _closeSegment(points) {
    const point = this._segments.length ? this._segments[0].line[0] : points[0];
    let newPoint = clonePoint(point, point.x, point.y, point.angle);
    newPoint = this._modifyReflectedPoint(newPoint, points.at(-1));
    if (newPoint) {
      points.push(newPoint);
    }
  },
  _modifyReflectedPoint(point, lastPoint) {
    if (lastPoint.angle === point.angle) {
      return undefined;
    }
    if ((0, _utils.normalizeAngle)(round(lastPoint.angle)) === (0, _utils.normalizeAngle)(round(point.angle))) {
      point.angle = lastPoint.angle;
    } else {
      const differenceAngle = lastPoint.angle - point.angle;
      point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle);
    }
    return point;
  },
  _getTangentPoints: function (point, prevPoint, centerPoint, isLastSegment) {
    let tangentPoints = [];
    const betweenAngle = Math.round(prevPoint.angle - point.angle);
    const tan = (prevPoint.radius - point.radius) / betweenAngle;
    let i;
    if (betweenAngle === 0) {
      tangentPoints = [prevPoint, point];
    } else if (betweenAngle > 0) {
      const angle = isLastSegment ? betweenAngle : betweenAngle - 1;
      for (i = angle; i >= 0; i--) {
        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));
      }
    } else {
      const angle = isLastSegment ? betweenAngle : betweenAngle + 1;
      for (i = 0; i >= angle; i--) {
        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));
      }
    }
    return tangentPoints;
  },
  getSeriesPairCoord(params, isArgument) {
    const that = this;
    const argAxis = that.getArgumentAxis();
    const paramName = isArgument ? 'angle' : 'radius';
    const coordParam = params[paramName];
    const centerPoint = argAxis.getCenter();
    const getLengthByCoords = (p1, p2) => {
      return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
    };
    const isInsideInterval = (prevPoint, point, _ref) => {
      let {
        x,
        y
      } = _ref;
      return getLengthByCoords({
        x,
        y
      }, centerPoint) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;
    };
    let coords;
    const neighborPoints = that.getNeighborPoints(coordParam, paramName);
    if (neighborPoints.length === 1) {
      coords = neighborPoints[0];
    } else if (neighborPoints.length > 1) {
      const prevPoint = neighborPoints[0];
      const point = neighborPoints[1];
      if (that.argumentAxisType !== DISCRETE && that.valueAxisType !== DISCRETE) {
        let tan;
        let stepAngle;
        if (isArgument) {
          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);
          stepAngle = coordParam - point.angle;
        } else {
          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);
          stepAngle = (coordParam - point.radius) / tan;
        }
        coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle);
      } else {
        if (isArgument) {
          const cosSin = (0, _utils.getCosAndSin)(-coordParam);
          const k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);
          const b1 = prevPoint.y - prevPoint.x * k1;
          const k2 = cosSin.sin / cosSin.cos;
          const b2 = centerPoint.y - k2 * centerPoint.x;
          const x = (b2 - b1) / (k1 - k2);
          const y = k1 * x + b1;
          if (isInsideInterval(prevPoint, point, {
            x,
            y
          })) {
            const quarter = abs((0, _math.trunc)((360 + coordParam) / 90) % 4);
            if (quarter === 0 && x >= centerPoint.x && y <= centerPoint.y || quarter === 1 && x <= centerPoint.x && y <= centerPoint.y || quarter === 2 && x <= centerPoint.x && y >= centerPoint.y || quarter === 3 && x >= centerPoint.x && y >= centerPoint.y) {
              coords = {
                x,
                y
              };
            }
          }
        } else {
          const k = (point.y - prevPoint.y) / (point.x - prevPoint.x);
          const y0 = prevPoint.y - prevPoint.x * k;
          const a = 1 + k * k;
          const b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;
          const c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);
          const d = b * b - 4 * a * c;
          if (d >= 0) {
            const x1 = (-b - sqrt(d)) / (2 * a);
            const x2 = (-b + sqrt(d)) / (2 * a);
            const y1 = k * x1 + y0;
            const y2 = k * x2 + y0;
            coords = isInsideInterval(prevPoint, point, {
              x: x1,
              y: y1
            }) ? {
              x: x1,
              y: y1
            } : isInsideInterval(prevPoint, point, {
              x: x2,
              y: y2
            }) ? {
              x: x2,
              y: y2
            } : undefined;
          }
        }
      }
    }
    return coords;
  },
  getNeighborPoints(param, paramName) {
    let points = this.getPoints();
    const neighborPoints = [];
    if (this.getOptions().closed) {
      points = (0, _extend.extend)(true, [], points);
      const lastPoint = points[points.length - 1];
      const firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);
      const lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);
      const rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);
      const forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);
      if (forwardRefPoint) {
        points.unshift(forwardRefPoint);
      }
      if (rearwardRefPoint) {
        points.push(rearwardRefPoint);
      }
    }
    for (let i = 1; i < points.length; i++) {
      if (points[i - 1][paramName] === param) {
        neighborPoints.push(points[i - 1]);
      } else if (points[i][paramName] === param) {
        neighborPoints.push(points[i]);
      } else if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {
        neighborPoints.push(points[i - 1]);
        neighborPoints.push(points[i]);
      }
      if (neighborPoints.length > 0) {
        break;
      }
    }
    return neighborPoints;
  }
});

/***/ }),

/***/ 80610:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.pie = exports.doughnut = exports.donut = void 0;
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _scatter_series = __webpack_require__(21667);
var _utils = __webpack_require__(19157);
var _extend2 = __webpack_require__(13306);
var _bar_series = __webpack_require__(58821);
// there are pie, doughnut

const chartScatterSeries = _scatter_series.chart;
const barSeries = _bar_series.chart.bar;
const _extend = _extend2.extend;
const _each = _iterator.each;
const _noop = _common.noop;
const _map = _utils.map;
const _isFinite = isFinite;
const _max = Math.max;
const ANIMATION_DURATION = 0.7;
const INSIDE = 'inside';
const pie = exports.pie = _extend({}, barSeries, {
  _setGroupsSettings: function () {
    chartScatterSeries._setGroupsSettings.apply(this, arguments);
    this._labelsGroup.attr({
      'pointer-events': null
    });
  },
  _createErrorBarGroup: _noop,
  _drawPoint: function (options) {
    const point = options.point;
    const legendCallback = this._legendCallback;
    chartScatterSeries._drawPoint.call(this, options);
    !point.isVisible() && point.setInvisibility();
    point.isSelected() && legendCallback();
  },
  _getOldPoint: function (data, oldPointsByArgument, index) {
    const point = (this._points || [])[index];
    if (point) {
      oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(p => p !== point);
    }
    return point;
  },
  adjustLabels: function (moveLabelsFromCenter) {
    return (this._points || []).reduce((r, p) => {
      if (p._label.isVisible()) {
        p.setLabelTrackerData();
        r = p.applyWordWrap(moveLabelsFromCenter) || r;
        p.updateLabelCoord(moveLabelsFromCenter);
        return r;
      }
    }, false);
  },
  _applyElementsClipRect: _noop,
  getColor: _noop,
  areErrorBarsVisible: _noop,
  drawLabelsWOPoints: function () {
    const that = this;
    if (that._options.label.position === INSIDE) {
      return false;
    }
    that._labelsGroup.append(that._extGroups.labelsGroup);
    (that._points || []).forEach(function (point) {
      point.drawLabel();
    });
    return true;
  },
  getPointsCount: function () {
    return this._data.filter(d => this._checkData(d)).length;
  },
  setMaxPointsCount: function (count) {
    this._pointsCount = count;
  },
  _getCreatingPointOptions: function (data, dataIndex) {
    return this._getPointOptions(data, dataIndex);
  },
  _updateOptions: function (options) {
    this.labelSpace = 0;
    this.innerRadius = this.type === 'pie' ? 0 : options.innerRadius;
  },
  _checkData: function (data, skippedFields) {
    const base = barSeries._checkData.call(this, data, skippedFields, {
      value: this.getValueFields()[0]
    });
    return this._options.paintNullPoints ? base : base && data.value !== null;
  },
  _createGroups: chartScatterSeries._createGroups,
  _setMarkerGroupSettings: function () {
    this._markersGroup.attr({
      'class': 'dxc-markers'
    });
  },
  _getMainColor(data, point) {
    const pointsByArg = this.getPointsByArg(data.argument);
    const argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;
    return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount);
  },
  _getPointOptions: function (data) {
    return this._parsePointOptions(this._preparePointOptions(), this._options.label, data);
  },
  _getRangeData: function () {
    return this._rangeData;
  },
  _createPointStyles: function (pointOptions, data, point) {
    var _pointOptions$color;
    const that = this;
    const mainColor = (0, _utils.extractColor)(pointOptions.color, true) || that._getMainColor(data, point);
    const colorId = (_pointOptions$color = pointOptions.color) === null || _pointOptions$color === void 0 ? void 0 : _pointOptions$color.fillId;
    const hoverStyle = pointOptions.hoverStyle || {};
    const selectionStyle = pointOptions.selectionStyle || {};
    if (colorId) {
      that._turnOffHatching(hoverStyle, selectionStyle);
    }
    return {
      labelColor: mainColor,
      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
      hover: that._parsePointStyle(hoverStyle, colorId || mainColor, mainColor),
      selection: that._parsePointStyle(selectionStyle, colorId || mainColor, mainColor),
      legendStyles: {
        normal: that._createLegendState(pointOptions, mainColor),
        hover: that._createLegendState(hoverStyle, colorId || mainColor),
        selection: that._createLegendState(selectionStyle, colorId || mainColor)
      }
    };
  },
  _getArrangeMinShownValue: function (points, total) {
    const minSegmentSize = this._options.minSegmentSize;
    let totalMinSegmentSize = 0;
    let totalNotMinValues = 0;
    total = total || points.length;
    _each(points, function (_, point) {
      if (point.isVisible()) {
        if (point.normalInitialValue < minSegmentSize * total / 360) {
          totalMinSegmentSize += minSegmentSize;
        } else {
          totalNotMinValues += point.normalInitialValue;
        }
      }
    });
    return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0;
  },
  _applyArrangeCorrection: function (points, minShownValue, total) {
    const options = this._options;
    const isClockWise = options.segmentsDirection !== 'anticlockwise';
    const shiftedAngle = _isFinite(options.startAngle) ? (0, _utils.normalizeAngle)(options.startAngle) : 0;
    const minSegmentSize = options.minSegmentSize;
    let percent;
    let correction = 0;
    let zeroTotalCorrection = 0;
    if (total === 0) {
      total = points.filter(function (el) {
        return el.isVisible();
      }).length;
      zeroTotalCorrection = 1;
    }
    _each(isClockWise ? points : points.concat([]).reverse(), function (_, point) {
      const val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;
      let updatedZeroValue;
      if (minSegmentSize && point.isVisible() && val < minShownValue) {
        updatedZeroValue = minShownValue;
      }
      percent = val / total;
      point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));
      point.shiftedAngle = shiftedAngle;
      correction = correction + (updatedZeroValue || val);
    });
    this._rangeData = {
      val: {
        min: 0,
        max: correction
      }
    };
  },
  _removePoint: function (point) {
    const points = this.getPointsByArg(point.argument);
    points.splice(points.indexOf(point), 1); // T485210
    point.dispose();
  },
  arrangePoints: function () {
    const that = this;
    const originalPoints = that._points || [];
    const minSegmentSize = that._options.minSegmentSize;
    let minShownValue;
    let isAllPointsNegative = true;
    let i = 0;
    const len = originalPoints.length;
    while (i < len && isAllPointsNegative) {
      isAllPointsNegative = originalPoints[i].value <= 0;
      i++;
    }
    const points = that._points = _map(originalPoints, function (point) {
      if (point.value === null || !isAllPointsNegative && point.value < 0) {
        that._removePoint(point);
        return null;
      } else {
        return point;
      }
    });
    const maxValue = points.reduce(function (max, p) {
      return _max(max, Math.abs(p.initialValue));
    }, 0);
    points.forEach(function (p) {
      p.normalInitialValue = p.initialValue / (maxValue !== 0 ? maxValue : 1);
    });
    const total = points.reduce(function (total, point) {
      return total + (point.isVisible() ? point.normalInitialValue : 0);
    }, 0);
    if (minSegmentSize) {
      minShownValue = this._getArrangeMinShownValue(points, total);
    }
    that._applyArrangeCorrection(points, minShownValue, total);
  },
  correctPosition: function (correction, canvas) {
    _each(this._points, function (_, point) {
      point.correctPosition(correction);
    });
    this.setVisibleArea(canvas);
  },
  correctRadius: function (correction) {
    this._points.forEach(function (point) {
      point.correctRadius(correction);
    });
  },
  correctLabelRadius: function (labelRadius) {
    this._points.forEach(function (point) {
      point.correctLabelRadius(labelRadius);
    });
  },
  setVisibleArea: function (canvas) {
    this._visibleArea = {
      minX: canvas.left,
      maxX: canvas.width - canvas.right,
      minY: canvas.top,
      maxY: canvas.height - canvas.bottom
    };
  },
  _applyVisibleArea: _noop,
  _animate: function (firstDrawing) {
    const that = this;
    const points = that._points;
    const pointsCount = points && points.length;
    const completeFunc = function () {
      that._animateComplete();
    };
    let animatePoint;
    if (firstDrawing) {
      animatePoint = function (p, i) {
        p.animate(i === pointsCount - 1 ? completeFunc : undefined, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1));
      };
    } else {
      animatePoint = function (p, i) {
        p.animate(i === pointsCount - 1 ? completeFunc : undefined);
      };
    }
    points.forEach(animatePoint);
  },
  getVisiblePoints: function () {
    return _map(this._points, function (p) {
      return p.isVisible() ? p : null;
    });
  },
  getPointsByKeys: function (arg, argumentIndex) {
    const pointsByArg = this.getPointsByArg(arg);
    return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || [];
  }
});
const doughnut = exports.doughnut = pie;
const donut = exports.donut = pie;

/***/ }),

/***/ 27428:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _extend = _extend2.extend;
const _math = Math;
const _floor = _math.floor;
const _abs = _math.abs;
const CANVAS_POSITION_DEFAULT = 'canvas_position_default';
const DEFAULT_BAR_TRACKER_SIZE = 9;
const CORRECTING_BAR_TRACKER_VALUE = 4;
const RIGHT = 'right';
const LEFT = 'left';
const TOP = 'top';
const BOTTOM = 'bottom';
function getLabelOrientation(point) {
  const initialValue = point.initialValue;
  const invert = point._getValTranslator().getBusinessRange().invert;
  const isDiscreteValue = point.series.valueAxisType === 'discrete';
  const isFullStacked = point.series.isFullStackedSeries();
  const notAxisInverted = !isDiscreteValue && (initialValue >= 0 && !invert || initialValue < 0 && invert) || isDiscreteValue && !invert || isFullStacked;
  return notAxisInverted ? TOP : BOTTOM;
}
var _default = exports["default"] = _extend({}, _symbol_point.default, {
  correctCoordinates(correctOptions) {
    const that = this;
    const correction = _floor(correctOptions.offset - correctOptions.width / 2);
    if (that._options.rotated) {
      that.height = correctOptions.width;
      that.yCorrection = correction;
      that.xCorrection = null;
    } else {
      that.width = correctOptions.width;
      that.xCorrection = correction;
      that.yCorrection = null;
    }
  },
  _calculateVisibility: function (x, y, width, height) {
    const {
      minX,
      maxX,
      minY,
      maxY
    } = this._getVisibleArea();
    this.inVisibleArea = minX <= x + width && maxX >= x && minY <= y + height && maxY >= y;
  },
  _cacheVisibility: function (x, y, minY, rotated) {
    const size = Math.abs(y - minY);
    y = Math.min(y, minY);
    if (rotated) {
      this._calculateVisibility(y, x, size, this.height);
    } else {
      this._calculateVisibility(x, y, this.width, size);
    }
  },
  _getGraphicBBox: function (location) {
    const bBox = {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
    if (location) {
      const isTop = location === 'top';
      if (!this._options.rotated) {
        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
        bBox.height = 0;
      } else {
        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
        bBox.width = 0;
      }
    }
    return bBox;
  },
  _getLabelConnector: function (location) {
    return this._getGraphicBBox(location);
  },
  _getLabelPosition: function () {
    let position = getLabelOrientation(this);
    if (this._options.rotated) {
      position = position === TOP ? RIGHT : LEFT;
    }
    return position;
  },
  _getLabelCoords: function (label) {
    const that = this;
    let coords;
    if (that.initialValue === 0 && that.series.isFullStackedSeries()) {
      if (!this._options.rotated) {
        coords = that._getLabelCoordOfPosition(label, TOP);
      } else {
        coords = that._getLabelCoordOfPosition(label, RIGHT);
      }
    } else if (label.getLayoutOptions().position === 'inside') {
      coords = that._getLabelCoordOfPosition(label, 'inside');
    } else {
      coords = _symbol_point.default._getLabelCoords.call(this, label);
    }
    return coords;
  },
  _drawLabel: function () {
    this._label.pointPosition = this._label.getLayoutOptions().position !== 'inside' && getLabelOrientation(this);
    _symbol_point.default._drawLabel.call(this);
  },
  hideInsideLabel: function (label, coord) {
    const graphicBBox = this._getGraphicBBox();
    const labelBBox = label.getBoundingRect();
    if (this._options.resolveLabelsOverlapping) {
      if ((coord.y <= graphicBBox.y && coord.y + labelBBox.height >= graphicBBox.y + graphicBBox.height || coord.x <= graphicBBox.x && coord.x + labelBBox.width >= graphicBBox.x + graphicBBox.width) && !(coord.y > graphicBBox.y + graphicBBox.height || coord.y + labelBBox.height < graphicBBox.y || coord.x > graphicBBox.x + graphicBBox.width || coord.x + labelBBox.width < graphicBBox.x)) {
        label.draw(false);
        return true;
      }
    }
    return false;
  },
  _showForZeroValues: function () {
    return this._options.label.showForZeroValues || this.initialValue;
  },
  _drawMarker(renderer, group, animationEnabled) {
    const that = this;
    const style = that._getStyle();
    const r = that._options.cornerRadius;
    const rotated = that._options.rotated;
    let {
      x,
      y,
      width,
      height
    } = that.getMarkerCoords();
    if (animationEnabled) {
      if (rotated) {
        width = 0;
        x = that.defaultX;
      } else {
        height = 0;
        y = that.defaultY;
      }
    }
    that.graphic = renderer.rect(x, y, width, height).attr({
      rx: r,
      ry: r
    }).smartAttr(style).data({
      'chart-data-point': that
    }).append(group);
  },
  _getSettingsForTracker: function () {
    const that = this;
    let y = that.y;
    let height = that.height;
    let x = that.x;
    let width = that.width;
    if (that._options.rotated) {
      if (width === 1) {
        width = DEFAULT_BAR_TRACKER_SIZE;
        x -= CORRECTING_BAR_TRACKER_VALUE;
      }
    } else {
      if (height === 1) {
        height = DEFAULT_BAR_TRACKER_SIZE;
        y -= CORRECTING_BAR_TRACKER_VALUE;
      }
    }
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  getGraphicSettings: function () {
    const graphic = this.graphic;
    return {
      x: graphic.attr('x'),
      y: graphic.attr('y'),
      height: graphic.attr('height'),
      width: graphic.attr('width')
    };
  },
  _getEdgeTooltipParams() {
    const isPositive = this.value >= 0;
    let xCoord;
    let yCoord;
    const invertedBusinessRange = this._getValTranslator().getBusinessRange().invert;
    const {
      x,
      y,
      width,
      height
    } = this;
    if (this._options.rotated) {
      yCoord = y + height / 2;
      if (invertedBusinessRange) {
        xCoord = isPositive ? x : x + width;
      } else {
        xCoord = isPositive ? x + width : x;
      }
    } else {
      xCoord = x + width / 2;
      if (invertedBusinessRange) {
        yCoord = isPositive ? y + height : y;
      } else {
        yCoord = isPositive ? y : y + height;
      }
    }
    return {
      x: xCoord,
      y: yCoord,
      offset: 0
    };
  },
  getTooltipParams: function (location) {
    if (location === 'edge') {
      return this._getEdgeTooltipParams();
    }
    const center = this.getCenterCoord();
    center.offset = 0;
    return center;
  },
  getCenterCoord() {
    const {
      width,
      height,
      x,
      y
    } = this;
    return {
      x: x + width / 2,
      y: y + height / 2
    };
  },
  _truncateCoord: function (coord, bounds) {
    if (coord === null) {
      return coord;
    }
    if (coord < bounds[0]) {
      return bounds[0];
    }
    if (coord > bounds[1]) {
      return bounds[1];
    }
    return coord;
  },
  _getErrorBarBaseEdgeLength() {
    return this._options.rotated ? this.height : this.width;
  },
  _translateErrorBars: function (argVisibleArea) {
    _symbol_point.default._translateErrorBars.call(this);
    if (this._errorBarPos < argVisibleArea[0] || this._errorBarPos > argVisibleArea[1]) {
      this._errorBarPos = undefined;
    }
  },
  // TODO check & rework
  _translate: function () {
    const that = this;
    const rotated = that._options.rotated;
    const valAxis = rotated ? 'x' : 'y';
    const argAxis = rotated ? 'y' : 'x';
    const valIntervalName = rotated ? 'width' : 'height';
    const argIntervalName = rotated ? 'height' : 'width';
    const argTranslator = that._getArgTranslator();
    const valTranslator = that._getValTranslator();
    const argVisibleArea = that.series.getArgumentAxis().getVisibleArea();
    const valVisibleArea = that.series.getValueAxis().getVisibleArea();
    let arg = argTranslator.translate(that.argument);
    let val = valTranslator.translate(that.value, 1);
    let minVal = valTranslator.translate(that.minValue, -1);
    that[argAxis] = arg = arg === null ? arg : arg + (that[argAxis + 'Correction'] || 0);
    that['v' + valAxis] = val;
    that['v' + argAxis] = arg + that[argIntervalName] / 2;
    this._cacheVisibility(arg, val, minVal, rotated);
    val = that._truncateCoord(val, valVisibleArea);
    minVal = that._truncateCoord(minVal, valVisibleArea);
    that[valIntervalName] = _abs(val - minVal);
    val = val < minVal ? val : minVal;
    that[valAxis] = val === null ? val : val + (that[valAxis + 'Correction'] || 0);
    that['min' + valAxis.toUpperCase()] = minVal === null ? minVal : minVal + (that[valAxis + 'Correction'] || 0);
    that['default' + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);
    that._translateErrorBars(argVisibleArea);
    if (that.inVisibleArea && that[argAxis] !== null) {
      if (that[argAxis] < argVisibleArea[0]) {
        that[argIntervalName] = that[argIntervalName] - (argVisibleArea[0] - that[argAxis]);
        that[argAxis] = argVisibleArea[0];
      }
      if (that[argAxis] + that[argIntervalName] > argVisibleArea[1]) {
        that[argIntervalName] = argVisibleArea[1] - that[argAxis];
      }
    }
  },
  _updateMarker: function (animationEnabled, style) {
    this.graphic.smartAttr(_extend({}, style, !animationEnabled ? this.getMarkerCoords() : {}));
  },
  getMarkerCoords: function () {
    const that = this;
    let x = that.x;
    const y = that.y;
    let width = that.width;
    let height = that.height;
    const argAxis = that.series.getArgumentAxis();
    const rotated = that._options.rotated;
    if (argAxis.getAxisPosition) {
      const axisOptions = argAxis.getOptions();
      const edgeOffset = Math.round(axisOptions.width / 2);
      const argAxisPosition = argAxis.getAxisPosition();
      if (axisOptions.visible) {
        if (!rotated) {
          height -= that.minY === that.defaultY && that.minY === argAxisPosition - argAxis.getAxisShift() ? edgeOffset : 0;
          height < 0 && (height = 0);
        } else {
          const isStartFromAxis = that.minX === that.defaultX && that.minX === argAxisPosition - argAxis.getAxisShift();
          x += isStartFromAxis ? edgeOffset : 0;
          width -= isStartFromAxis ? edgeOffset : 0;
          width < 0 && (width = 0);
        }
      }
    }
    return {
      x,
      y,
      width,
      height
    };
  },
  coordsIn: function (x, y) {
    const that = this;
    return x >= that.x && x <= that.x + that.width && y >= that.y && y <= that.y + that.height;
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 54497:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Point = Point;
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _bar_point = _interopRequireDefault(__webpack_require__(27428));
var _bubble_point = _interopRequireDefault(__webpack_require__(37440));
var _pie_point = _interopRequireDefault(__webpack_require__(85912));
var _range_symbol_point = _interopRequireDefault(__webpack_require__(97319));
var _range_bar_point = _interopRequireDefault(__webpack_require__(73206));
var _candlestick_point = _interopRequireDefault(__webpack_require__(69297));
var _stock_point = _interopRequireDefault(__webpack_require__(71678));
var _polar_point = __webpack_require__(38234);
var _utils = __webpack_require__(19157);
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const mixins = {};
const _extend = _extend2.extend;
const statesConsts = _consts.default.states;
const SYMBOL_POINT = 'symbolPoint';
const POLAR_SYMBOL_POINT = 'polarSymbolPoint';
const BAR_POINT = 'barPoint';
const POLAR_BAR_POINT = 'polarBarPoint';
const PIE_POINT = 'piePoint';
const SELECTED_STATE = statesConsts.selectedMark;
const HOVER_STATE = statesConsts.hoverMark;
const NORMAL_STATE = statesConsts.normalMark;
const HOVER = statesConsts.hover;
const NORMAL = statesConsts.normal;
const SELECTION = statesConsts.selection;
const pointTypes = {
  chart: {
    'scatter': SYMBOL_POINT,
    'line': SYMBOL_POINT,
    'spline': SYMBOL_POINT,
    'stepline': SYMBOL_POINT,
    'stackedline': SYMBOL_POINT,
    'fullstackedline': SYMBOL_POINT,
    'stackedspline': SYMBOL_POINT,
    'fullstackedspline': SYMBOL_POINT,
    'stackedsplinearea': SYMBOL_POINT,
    'fullstackedsplinearea': SYMBOL_POINT,
    'area': SYMBOL_POINT,
    'splinearea': SYMBOL_POINT,
    'steparea': SYMBOL_POINT,
    'stackedarea': SYMBOL_POINT,
    'fullstackedarea': SYMBOL_POINT,
    'rangearea': 'rangeSymbolPoint',
    'bar': BAR_POINT,
    'stackedbar': BAR_POINT,
    'fullstackedbar': BAR_POINT,
    'rangebar': 'rangeBarPoint',
    'bubble': 'bubblePoint',
    'stock': 'stockPoint',
    'candlestick': 'candlestickPoint'
  },
  pie: {
    'pie': PIE_POINT,
    'doughnut': PIE_POINT,
    'donut': PIE_POINT
  },
  polar: {
    'scatter': POLAR_SYMBOL_POINT,
    'line': POLAR_SYMBOL_POINT,
    'area': POLAR_SYMBOL_POINT,
    'bar': POLAR_BAR_POINT,
    'stackedbar': POLAR_BAR_POINT
  }
};
function isNoneMode(mode) {
  return (0, _utils.normalizeEnum)(mode) === 'none';
}
function Point(series, dataItem, options) {
  this.fullState = NORMAL_STATE;
  this.series = series;
  this.update(dataItem, options);
  this._viewCounters = {
    hover: 0,
    selection: 0
  };
  this._emptySettings = {
    fill: null,
    stroke: null,
    dashStyle: null,
    filter: null
  };
}
mixins.symbolPoint = _symbol_point.default;
mixins.barPoint = _bar_point.default;
mixins.bubblePoint = _bubble_point.default;
mixins.piePoint = _pie_point.default;
mixins.rangeSymbolPoint = _range_symbol_point.default;
mixins.rangeBarPoint = _range_bar_point.default;
mixins.candlestickPoint = _candlestick_point.default;
mixins.stockPoint = _stock_point.default;
mixins.polarSymbolPoint = _polar_point.polarSymbolPoint;
mixins.polarBarPoint = _polar_point.polarBarPoint;
Point.prototype = {
  constructor: Point,
  getColor: function () {
    if (!this.hasValue() && !this._styles.usePointCustomOptions) {
      this.series.customizePoint(this, this._dataItem);
    }
    return this._styles.normal.fill || this.series.getColor();
  },
  _getStyle: function () {
    return this._styles[this._currentStyle || 'normal'];
  },
  update: function (dataItem, options) {
    this.updateOptions(options);
    this.updateData(dataItem);
  },
  updateData: function (dataItem) {
    const that = this;
    const argumentWasChanged = that.argument !== dataItem.argument;
    that.argument = that.initialArgument = that.originalArgument = dataItem.argument;
    that.tag = dataItem.tag;
    that.index = dataItem.index;
    that._dataItem = dataItem;
    that.data = dataItem.data;
    that.lowError = dataItem.lowError;
    that.highError = dataItem.highError;
    that.aggregationInfo = dataItem.aggregationInfo;
    that._updateData(dataItem, argumentWasChanged);
    !that.hasValue() && that.setInvisibility();
    that._fillStyle();
    that._updateLabelData();
  },
  deleteMarker: function () {
    const that = this;
    if (that.graphic) {
      that.graphic.dispose();
    }
    that.graphic = null;
  },
  draw: function (renderer, groups, animationEnabled, firstDrawing) {
    const that = this;
    if (that._needDeletingOnDraw || that.series.autoHidePointMarkers && !that.isSelected()) {
      that.deleteMarker();
      that._needDeletingOnDraw = false;
    }
    if (that._needClearingOnDraw) {
      that.clearMarker();
      that._needClearingOnDraw = false;
    }
    if (!that._hasGraphic()) {
      that.getMarkerVisibility() && !that.series.autoHidePointMarkers && that._drawMarker(renderer, groups.markers, animationEnabled, firstDrawing);
    } else {
      that._updateMarker(animationEnabled, this._getStyle(), groups.markers);
    }
    that._drawLabel();
    that._drawErrorBar(renderer, groups.errorBars, animationEnabled);
    return that;
  },
  _getViewStyle: function () {
    let state = NORMAL_STATE;
    let fullState = this.fullState;
    const styles = [NORMAL, HOVER, SELECTION, SELECTION];
    if (this._viewCounters.hover) {
      state |= HOVER_STATE;
    }
    if (this._viewCounters.selection) {
      state |= SELECTED_STATE;
    }
    if (isNoneMode(this.getOptions().selectionMode)) {
      fullState &= ~SELECTED_STATE;
    }
    if (isNoneMode(this.getOptions().hoverMode)) {
      fullState &= ~HOVER_STATE;
    }
    state |= fullState;
    return styles[state];
  },
  applyView: function (legendCallback) {
    const that = this;
    const style = that._getViewStyle();
    that._currentStyle = style;
    if (!that.graphic && that.getMarkerVisibility() && that.series.autoHidePointMarkers && (style === SELECTION || style === HOVER)) {
      that._drawMarker(that.series.getRenderer(), that.series.getMarkersGroup());
    }
    if (that.graphic) {
      if (that.series.autoHidePointMarkers && style !== SELECTION && style !== HOVER) {
        that.deleteMarker();
      } else {
        if (style === 'normal') {
          that.clearMarker();
        } else {
          that.graphic.toForeground();
        }
        that._updateMarker(true, that._styles[style], undefined, legendCallback);
      }
    }
  },
  setView: function (style) {
    this._viewCounters[style]++;
    this.applyView();
  },
  resetView: function (style) {
    const viewCounters = this._viewCounters;
    --viewCounters[style];
    if (viewCounters[style] < 0) {
      // T661080
      viewCounters[style] = 0;
    }
    this.applyView();
  },
  releaseHoverState: function () {
    const that = this;
    if (that.graphic && !that.isSelected()) {
      that.graphic.toBackground();
    }
  },
  select: function () {
    this.series.selectPoint(this);
  },
  clearSelection: function () {
    this.series.deselectPoint(this);
  },
  hover: function () {
    this.series.hoverPoint(this);
  },
  clearHover: function () {
    this.series.clearPointHover();
  },
  showTooltip: function () {
    this.series.showPointTooltip(this);
  },
  hideTooltip: function () {
    this.series.hidePointTooltip(this);
  },
  _checkLabelsChanging: function (oldType, newType) {
    const isNewRange = ~newType.indexOf('range');
    const isOldRange = ~oldType.indexOf('range');
    return isOldRange && !isNewRange || !isOldRange && isNewRange;
  },
  updateOptions: function (newOptions) {
    if (!newOptions) {
      return;
    }
    const that = this;
    const oldOptions = that._options;
    const widgetType = newOptions.widgetType;
    const oldType = oldOptions && oldOptions.type;
    const newType = newOptions.type;
    const newPointTypeMixin = pointTypes[widgetType][newType];
    if (oldType !== newType) {
      that._needDeletingOnDraw = true;
      that._needClearingOnDraw = false;
      if (oldType) {
        that._checkLabelsChanging(oldType, newType) && that.deleteLabel();
        that._resetType(mixins[pointTypes[oldType]]);
      }
      that._setType(mixins[newPointTypeMixin]);
    } else {
      that._needDeletingOnDraw = that._checkSymbol(oldOptions, newOptions);
      that._needClearingOnDraw = that._checkCustomize(oldOptions, newOptions);
    }
    that._options = newOptions;
    that._fillStyle();
    that._updateLabelOptions(newPointTypeMixin);
  },
  translate: function () {
    if (this.hasValue()) {
      this._translate();
      this.translated = true;
    }
  },
  _checkCustomize: function (oldOptions, newOptions) {
    return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions;
  },
  _getCustomLabelVisibility: function () {
    return this._styles.useLabelCustomOptions ? !!this._options.label.visible : null;
  },
  getBoundingRect: function () {
    return this._getGraphicBBox();
  },
  _resetType: function (methods) {
    for (const methodName in methods) {
      delete this[methodName];
    }
  },
  _setType: function (methods) {
    for (const methodName in methods) {
      this[methodName] = methods[methodName];
    }
  },
  isInVisibleArea: function () {
    return this.inVisibleArea;
  },
  isSelected: function () {
    return !!(this.fullState & SELECTED_STATE);
  },
  isHovered: function () {
    return !!(this.fullState & HOVER_STATE);
  },
  getOptions: function () {
    return this._options;
  },
  animate: function (complete, settings, partitionDuration) {
    if (!this.graphic) {
      complete && complete();
      return;
    }
    this.graphic.animate(settings, {
      partitionDuration: partitionDuration
    }, complete);
  },
  getCoords: function (min) {
    const that = this;
    if (!min) {
      return {
        x: that.x,
        y: that.y
      };
    }
    if (!that._options.rotated) {
      return {
        x: that.x,
        y: that.minY + (that.y - that.minY ? 0 : 1)
      };
    }
    return {
      x: that.minX - (that.x - that.minX ? 0 : 1),
      y: that.y
    };
  },
  getDefaultCoords: function () {
    const that = this;
    return !that._options.rotated ? {
      x: that.x,
      y: that.defaultY
    } : {
      x: that.defaultX,
      y: that.y
    };
  },
  setDefaultCoords() {
    const coords = this.getDefaultCoords();
    this.x = coords.x;
    this.y = coords.y;
  },
  _getVisibleArea: function () {
    return this.series.getVisibleArea();
  },
  _getArgTranslator: function () {
    return this.series.getArgumentAxis().getTranslator();
  },
  _getValTranslator: function () {
    return this.series.getValueAxis().getTranslator();
  },
  isArgumentCorrect() {
    return this.series._argumentChecker(this.argument);
  },
  isValueCorrect() {
    const valueChecker = this.series._valueChecker;
    return valueChecker(this.getMinValue()) && valueChecker(this.getMaxValue());
  },
  hasValue: function () {
    return this.value !== null && this.minValue !== null && this.isArgumentCorrect() && this.isValueCorrect();
  },
  hasCoords: _common.noop,
  correctPosition: _common.noop,
  correctRadius: _common.noop,
  correctLabelRadius: _common.noop,
  getCrosshairData: _common.noop,
  getPointRadius: _common.noop,
  _populatePointShape: _common.noop,
  _checkSymbol: _common.noop,
  getMarkerCoords: _common.noop,
  hide: _common.noop,
  show: _common.noop,
  hideMarker: _common.noop,
  setInvisibility: _common.noop,
  clearVisibility: _common.noop,
  isVisible: _common.noop,
  resetCorrection: _common.noop,
  correctValue: _common.noop,
  resetValue: _common.noop,
  setPercentValue: _common.noop,
  correctCoordinates: _common.noop,
  coordsIn: _common.noop,
  getTooltipParams: _common.noop,
  applyWordWrap: _common.noop,
  setLabelTrackerData: _common.noop,
  updateLabelCoord: _common.noop,
  drawLabel: _common.noop,
  correctLabelPosition: _common.noop,
  getMinValue: _common.noop,
  getMaxValue: _common.noop,
  _drawErrorBar: _common.noop,
  getMarkerVisibility: _common.noop,
  dispose: function () {
    const that = this;
    that.deleteMarker();
    that.deleteLabel();
    that._errorBar && this._errorBar.dispose();
    that._options = that._styles = that.series = that._errorBar = null;
  },
  getTooltipFormatObject: function (tooltip, stackPoints) {
    const that = this;
    const tooltipFormatObject = that._getFormatObject(tooltip);
    const sharedTooltipValuesArray = [];
    const tooltipStackPointsFormatObject = [];
    if (stackPoints) {
      stackPoints.forEach(point => {
        if (!point.isVisible()) return;
        const formatObject = point._getFormatObject(tooltip);
        tooltipStackPointsFormatObject.push(formatObject);
        sharedTooltipValuesArray.push(formatObject.seriesName + ': ' + formatObject.valueText);
      });
      _extend(tooltipFormatObject, {
        points: tooltipStackPointsFormatObject,
        valueText: sharedTooltipValuesArray.join('\n'),
        stackName: that.series.getStackName() || null
      });
    }
    const aggregationInfo = that.aggregationInfo;
    if (aggregationInfo) {
      const axis = that.series.getArgumentAxis();
      const rangeText = axis.formatRange(aggregationInfo.intervalStart, aggregationInfo.intervalEnd, aggregationInfo.aggregationInterval, tooltip.getOptions().argumentFormat);
      if (rangeText) {
        tooltipFormatObject.valueText += `\n${rangeText}`;
      }
    }
    return tooltipFormatObject;
  },
  setHole: function (holeValue, position) {
    const that = this;
    const minValue = isFinite(that.minValue) ? that.minValue : 0;
    if ((0, _type.isDefined)(holeValue)) {
      if (position === 'left') {
        that.leftHole = that.value - holeValue;
        that.minLeftHole = minValue - holeValue;
      } else {
        that.rightHole = that.value - holeValue;
        that.minRightHole = minValue - holeValue;
      }
    }
  },
  resetHoles: function () {
    this.leftHole = null;
    this.minLeftHole = null;
    this.rightHole = null;
    this.minRightHole = null;
  },
  getLabel: function () {
    return this._label;
  },
  getLabels: function () {
    return [this._label];
  },
  getCenterCoord() {
    return {
      x: this.x,
      y: this.y
    };
  }
};

/***/ }),

/***/ 37440:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _extend = _extend2.extend;
const MIN_BUBBLE_HEIGHT = 20;
var _default = exports["default"] = _extend({}, _symbol_point.default, {
  correctCoordinates: function (diameter) {
    this.bubbleSize = diameter / 2;
  },
  _drawMarker: function (renderer, group, animationEnabled) {
    const that = this;
    const attr = _extend({
      translateX: that.x,
      translateY: that.y
    }, that._getStyle());
    that.graphic = renderer.circle(0, 0, animationEnabled ? 0 : that.bubbleSize).smartAttr(attr).data({
      'chart-data-point': that
    }).append(group);
  },
  getTooltipParams: function (location) {
    const that = this;
    const graphic = that.graphic;
    if (!graphic) {
      return;
    }
    const height = graphic.getBBox().height;
    return {
      x: that.x,
      y: that.y,
      offset: height < MIN_BUBBLE_HEIGHT || location === 'edge' ? height / 2 : 0
    };
  },
  _getLabelFormatObject: function () {
    const formatObject = _symbol_point.default._getLabelFormatObject.call(this);
    formatObject.size = this.initialSize;
    return formatObject;
  },
  _updateData: function (data) {
    _symbol_point.default._updateData.call(this, data);
    this.size = this.initialSize = data.size;
  },
  _getGraphicBBox: function () {
    const that = this;
    return that._getSymbolBBox(that.x, that.y, that.bubbleSize);
  },
  _updateMarker: function (animationEnabled, style) {
    const that = this;
    if (!animationEnabled) {
      style = _extend({
        r: that.bubbleSize,
        translateX: that.x,
        translateY: that.y
      }, style);
    }
    that.graphic.smartAttr(style);
  },
  _getFormatObject: function (tooltip) {
    const formatObject = _symbol_point.default._getFormatObject.call(this, tooltip);
    formatObject.sizeText = tooltip.formatValue(this.initialSize);
    return formatObject;
  },
  _storeTrackerR: function () {
    return this.bubbleSize;
  },
  _getLabelCoords: function (label) {
    let coords;
    if (label.getLayoutOptions().position === 'inside') {
      coords = this._getLabelCoordOfPosition(label, 'inside');
    } else {
      coords = _symbol_point.default._getLabelCoords.call(this, label);
    }
    return coords;
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 69297:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _bar_point = _interopRequireDefault(__webpack_require__(27428));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _math = Math;
const _abs = _math.abs;
const _min = _math.min;
const _max = _math.max;
const _round = _math.round;
const DEFAULT_FINANCIAL_TRACKER_MARGIN = 2;
var _default = exports["default"] = (0, _extend2.extend)({}, _bar_point.default, {
  _calculateVisibility: _symbol_point.default._calculateVisibility,
  _getContinuousPoints: function (openCoord, closeCoord) {
    const that = this;
    const x = that.x;
    const createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };
    const width = that.width;
    const highCoord = that.highY;
    const max = _abs(highCoord - openCoord) < _abs(highCoord - closeCoord) ? openCoord : closeCoord;
    const min = max === closeCoord ? openCoord : closeCoord;
    let points;
    if (min === max) {
      points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, that.closeY)).concat(createPoint(x - width / 2, that.closeY)).concat(createPoint(x + width / 2, that.closeY)).concat(createPoint(x, that.closeY));
    } else {
      points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, max)).concat(createPoint(x + width / 2, max)).concat(createPoint(x + width / 2, min)).concat(createPoint(x, min)).concat(createPoint(x, that.lowY)).concat(createPoint(x, min)).concat(createPoint(x - width / 2, min)).concat(createPoint(x - width / 2, max)).concat(createPoint(x, max));
    }
    return points;
  },
  _getCrockPoints: function (y) {
    const that = this;
    const x = that.x;
    const createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };
    return [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, y)).concat(createPoint(x - that.width / 2, y)).concat(createPoint(x + that.width / 2, y)).concat(createPoint(x, y));
  },
  _getPoints: function () {
    const that = this;
    let points;
    const closeCoord = that.closeY;
    const openCoord = that.openY;
    if (closeCoord !== null && openCoord !== null) {
      points = that._getContinuousPoints(openCoord, closeCoord);
    } else {
      if (openCoord === closeCoord) {
        points = [that.x, that.highY, that.x, that.lowY];
      } else {
        points = that._getCrockPoints(openCoord !== null ? openCoord : closeCoord);
      }
    }
    return points;
  },
  getColor: function () {
    const that = this;
    return that._isReduction ? that._options.reduction.color : that._styles.normal.stroke || that.series.getColor();
  },
  _drawMarkerInGroup: function (group, attributes, renderer) {
    const that = this;
    that.graphic = renderer.path(that._getPoints(), 'area').attr({
      'stroke-linecap': 'square'
    }).attr(attributes).data({
      'chart-data-point': that
    }).sharp().append(group);
  },
  _fillStyle: function () {
    const that = this;
    const styles = that._options.styles;
    if (that._isReduction && that._isPositive) {
      that._styles = styles.reductionPositive;
    } else if (that._isReduction) {
      that._styles = styles.reduction;
    } else if (that._isPositive) {
      that._styles = styles.positive;
    } else {
      that._styles = styles;
    }
  },
  _getMinTrackerWidth: function () {
    return 2 + 2 * this._styles.normal['stroke-width'];
  },
  correctCoordinates: function (correctOptions) {
    const minWidth = this._getMinTrackerWidth();
    const maxWidth = 10;
    let width = correctOptions.width;
    width = width < minWidth ? minWidth : width > maxWidth ? maxWidth : width;
    this.width = width + width % 2;
    this.xCorrection = correctOptions.offset;
  },
  _getMarkerGroup: function (group) {
    const that = this;
    let markerGroup;
    if (that._isReduction && that._isPositive) {
      markerGroup = group.reductionPositiveMarkersGroup;
    } else if (that._isReduction) {
      markerGroup = group.reductionMarkersGroup;
    } else if (that._isPositive) {
      markerGroup = group.defaultPositiveMarkersGroup;
    } else {
      markerGroup = group.defaultMarkersGroup;
    }
    return markerGroup;
  },
  _drawMarker: function (renderer, group) {
    this._drawMarkerInGroup(this._getMarkerGroup(group), this._getStyle(), renderer);
  },
  _getSettingsForTracker: function () {
    const that = this;
    let highY = that.highY;
    let lowY = that.lowY;
    const rotated = that._options.rotated;
    let x;
    let y;
    let width;
    let height;
    if (highY === lowY) {
      highY = rotated ? highY + DEFAULT_FINANCIAL_TRACKER_MARGIN : highY - DEFAULT_FINANCIAL_TRACKER_MARGIN;
      lowY = rotated ? lowY - DEFAULT_FINANCIAL_TRACKER_MARGIN : lowY + DEFAULT_FINANCIAL_TRACKER_MARGIN;
    }
    if (rotated) {
      x = _min(lowY, highY);
      y = that.x - that.width / 2;
      width = _abs(lowY - highY);
      height = that.width;
    } else {
      x = that.x - that.width / 2;
      y = _min(lowY, highY);
      width = that.width;
      height = _abs(lowY - highY);
    }
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  _getGraphicBBox: function (location) {
    const that = this;
    const rotated = that._options.rotated;
    const x = that.x;
    const width = that.width;
    let lowY = that.lowY;
    let highY = that.highY;
    if (location) {
      const valVisibleArea = that.series.getValueAxis().getVisibleArea();
      highY = that._truncateCoord(highY, valVisibleArea);
      lowY = that._truncateCoord(lowY, valVisibleArea);
    }
    const bBox = {
      x: !rotated ? x - _round(width / 2) : lowY,
      y: !rotated ? highY : x - _round(width / 2),
      width: !rotated ? width : highY - lowY,
      height: !rotated ? lowY - highY : width
    };
    if (location) {
      const isTop = location === 'top';
      if (!this._options.rotated) {
        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
        bBox.height = 0;
      } else {
        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
        bBox.width = 0;
      }
    }
    return bBox;
  },
  getTooltipParams: function (location) {
    const that = this;
    if (that.graphic) {
      const minValue = _min(that.lowY, that.highY);
      const maxValue = _max(that.lowY, that.highY);
      const visibleArea = that._getVisibleArea();
      const rotated = that._options.rotated;
      const minVisible = rotated ? visibleArea.minX : visibleArea.minY;
      const maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
      const min = _max(minVisible, minValue);
      const max = _min(maxVisible, maxValue);
      const centerCoord = that.getCenterCoord();
      if (location === 'edge') {
        centerCoord[rotated ? 'x' : 'y'] = rotated ? max : min;
      }
      centerCoord.offset = 0;
      return centerCoord;
    }
  },
  getCenterCoord() {
    if (this.graphic) {
      const that = this;
      let x;
      let y;
      const minValue = _min(that.lowY, that.highY);
      const maxValue = _max(that.lowY, that.highY);
      const visibleArea = that._getVisibleArea();
      const rotated = that._options.rotated;
      const minVisible = rotated ? visibleArea.minX : visibleArea.minY;
      const maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
      const min = _max(minVisible, minValue);
      const max = _min(maxVisible, maxValue);
      const center = min + (max - min) / 2;
      if (rotated) {
        y = that.x;
        x = center;
      } else {
        x = that.x;
        y = center;
      }
      return {
        x: x,
        y: y
      };
    }
  },
  hasValue: function () {
    return this.highValue !== null && this.lowValue !== null;
  },
  hasCoords: function () {
    return this.x !== null && this.lowY !== null && this.highY !== null;
  },
  _translate: function () {
    const that = this;
    const rotated = that._options.rotated;
    const valTranslator = that._getValTranslator();
    const x = that._getArgTranslator().translate(that.argument);
    that.vx = that.vy = that.x = x === null ? x : x + (that.xCorrection || 0);
    that.openY = that.openValue !== null ? valTranslator.translate(that.openValue) : null;
    that.highY = valTranslator.translate(that.highValue);
    that.lowY = valTranslator.translate(that.lowValue);
    that.closeY = that.closeValue !== null ? valTranslator.translate(that.closeValue) : null;
    const centerValue = _min(that.lowY, that.highY) + _abs(that.lowY - that.highY) / 2;
    that._calculateVisibility(!rotated ? that.x : centerValue, !rotated ? centerValue : that.x);
  },
  getCrosshairData: function (x, y) {
    const that = this;
    const rotated = that._options.rotated;
    const origY = rotated ? x : y;
    let yValue;
    const argument = that.argument;
    let coords;
    let coord = 'low';
    if (_abs(that.lowY - origY) < _abs(that.closeY - origY)) {
      yValue = that.lowY;
    } else {
      yValue = that.closeY;
      coord = 'close';
    }
    if (_abs(yValue - origY) >= _abs(that.openY - origY)) {
      yValue = that.openY;
      coord = 'open';
    }
    if (_abs(yValue - origY) >= _abs(that.highY - origY)) {
      yValue = that.highY;
      coord = 'high';
    }
    if (rotated) {
      coords = {
        y: that.vy,
        x: yValue,
        xValue: that[coord + 'Value'],
        yValue: argument
      };
    } else {
      coords = {
        x: that.vx,
        y: yValue,
        xValue: argument,
        yValue: that[coord + 'Value']
      };
    }
    coords.axis = that.series.axis;
    return coords;
  },
  _updateData: function (data) {
    const that = this;
    const label = that._label;
    const reductionColor = this._options.reduction.color;
    that.value = that.initialValue = data.reductionValue;
    that.originalValue = data.value;
    that.lowValue = that.originalLowValue = data.lowValue;
    that.highValue = that.originalHighValue = data.highValue;
    that.openValue = that.originalOpenValue = data.openValue;
    that.closeValue = that.originalCloseValue = data.closeValue;
    that._isPositive = data.openValue < data.closeValue;
    that._isReduction = data.isReduction;
    if (that._isReduction) {
      label.setColor(reductionColor);
    }
  },
  _updateMarker: function (animationEnabled, style, group) {
    const that = this;
    const graphic = that.graphic;
    graphic.attr({
      points: that._getPoints()
    }).smartAttr(style).sharp();
    group && graphic.append(that._getMarkerGroup(group));
  },
  _getLabelFormatObject: function () {
    const that = this;
    return {
      openValue: that.openValue,
      highValue: that.highValue,
      lowValue: that.lowValue,
      closeValue: that.closeValue,
      reductionValue: that.initialValue,
      argument: that.initialArgument,
      value: that.initialValue,
      seriesName: that.series.name,
      originalOpenValue: that.originalOpenValue,
      originalCloseValue: that.originalCloseValue,
      originalLowValue: that.originalLowValue,
      originalHighValue: that.originalHighValue,
      originalArgument: that.originalArgument,
      point: that
    };
  },
  _getFormatObject: function (tooltip) {
    const that = this;
    const highValue = tooltip.formatValue(that.highValue);
    const openValue = tooltip.formatValue(that.openValue);
    const closeValue = tooltip.formatValue(that.closeValue);
    const lowValue = tooltip.formatValue(that.lowValue);
    const symbolMethods = _symbol_point.default;
    const formatObject = symbolMethods._getFormatObject.call(that, tooltip);
    return (0, _extend2.extend)({}, formatObject, {
      valueText: 'h: ' + highValue + (openValue !== '' ? ' o: ' + openValue : '') + (closeValue !== '' ? ' c: ' + closeValue : '') + ' l: ' + lowValue,
      highValueText: highValue,
      openValueText: openValue,
      closeValueText: closeValue,
      lowValueText: lowValue
    });
  },
  getMaxValue: function () {
    return this.highValue;
  },
  getMinValue: function () {
    return this.lowValue;
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 28318:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Label = Label;
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _utils = __webpack_require__(19157);
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _display_format_parser = __webpack_require__(10656);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _format = _format_helper.default.format;
const _math = Math;
const _round = _math.round;
const _floor = _math.floor;
const _abs = _math.abs;
const CONNECTOR_LENGTH = 12;
const LABEL_BACKGROUND_PADDING_X = 8;
const LABEL_BACKGROUND_PADDING_Y = 4;
function getClosestCoord(point, coords) {
  let closestDistance = Infinity;
  let closestCoord;
  (0, _iterator.each)(coords, function (_, coord) {
    const x = point[0] - coord[0];
    const y = point[1] - coord[1];
    const distance = x * x + y * y;
    if (distance < closestDistance) {
      closestDistance = distance;
      closestCoord = coord;
    }
  });
  return [_floor(closestCoord[0]), _floor(closestCoord[1])];
}
function getCrossCoord(rect, coord, indexOffset) {
  return (coord - rect[0 + indexOffset]) / (rect[2 + indexOffset] - rect[0 + indexOffset]) * (rect[3 - indexOffset] - rect[1 - indexOffset]) + rect[1 - indexOffset];
}

// We could always conside center of label as label point (with appropriate connector path clipping). In that case we do not depend neither on background nor on rotation.

const barPointStrategy = {
  isLabelInside: function (labelPoint, figure) {
    const xc = labelPoint.x + labelPoint.width / 2;
    const yc = labelPoint.y + labelPoint.height / 2;
    return figure.x <= xc && xc <= figure.x + figure.width && figure.y <= yc && yc <= figure.y + figure.height;
  },
  prepareLabelPoints: function (bBox, rotatedBBox, isHorizontal, angle, figureCenter) {
    const x1 = rotatedBBox.x;
    const xc = x1 + rotatedBBox.width / 2;
    const x2 = x1 + rotatedBBox.width - 1;
    const y1 = rotatedBBox.y;
    const yc = y1 + rotatedBBox.height / 2;
    const y2 = y1 + rotatedBBox.height - 1;
    let labelPoints;
    const isRectangular = _abs(angle) % 90 === 0;
    if (figureCenter[0] > x1 && figureCenter[0] < x2) {
      if (isRectangular) {
        labelPoints = [[figureCenter[0], _abs(figureCenter[1] - y1) < _abs(figureCenter[1] - y2) ? y1 : y2]];
      } else {
        labelPoints = [[figureCenter[0], getCrossCoord([x1, y1, x2, y2], figureCenter[0], 0)]];
      }
    } else if (figureCenter[1] > y1 && figureCenter[1] < y2) {
      if (isRectangular) {
        labelPoints = [[_abs(figureCenter[0] - x1) < _abs(figureCenter[0] - x2) ? x1 : x2, figureCenter[1]]];
      } else {
        labelPoints = [[getCrossCoord([x1, y1, x2, y2], figureCenter[1], 1), figureCenter[1]]];
      }
    } else {
      if (isRectangular) {
        labelPoints = [[x1, y1], [isHorizontal ? x1 : xc, isHorizontal ? yc : y1], [x2, y1], [x1, y2], [isHorizontal ? x2 : xc, isHorizontal ? yc : y2], [x2, y2]];
      } else {
        labelPoints = [[xc, yc]];
      }
    }
    return labelPoints;
  },
  isHorizontal: function (bBox, figure) {
    return bBox.x > figure.x + figure.width || bBox.x + bBox.width < figure.x;
  },
  getFigureCenter: function (figure) {
    return [_floor(figure.x + figure.width / 2), _floor(figure.y + figure.height / 2)];
  },
  findFigurePoint: function (figure, labelPoint) {
    const figureCenter = barPointStrategy.getFigureCenter(figure);
    const point = getClosestCoord(labelPoint, [[figure.x, figureCenter[1]], [figureCenter[0], figure.y + figure.height], [figure.x + figure.width, figureCenter[1]], [figureCenter[0], figure.y]]);
    return point;
  },
  adjustPoints: function (points) {
    const lineIsVertical = _abs(points[1] - points[3]) <= 1;
    const lineIsHorizontal = _abs(points[0] - points[2]) <= 1;
    if (lineIsHorizontal) {
      points[0] = points[2];
    }
    if (lineIsVertical) {
      points[1] = points[3];
    }
    return points;
  }
};
const symbolPointStrategy = {
  isLabelInside: function () {
    return false;
  },
  prepareLabelPoints: barPointStrategy.prepareLabelPoints,
  isHorizontal: function (bBox, figure) {
    return bBox.x > figure.x + figure.r || bBox.x + bBox.width < figure.x - figure.r;
  },
  getFigureCenter: function (figure) {
    return [figure.x, figure.y];
  },
  findFigurePoint: function (figure, labelPoint) {
    const angle = Math.atan2(figure.y - labelPoint[1], labelPoint[0] - figure.x);
    return [_round(figure.x + figure.r * Math.cos(angle)), _round(figure.y - figure.r * Math.sin(angle))];
  },
  adjustPoints: barPointStrategy.adjustPoints
};
const piePointStrategy = {
  isLabelInside: function (_0, _1, isOutside) {
    return !isOutside;
  },
  prepareLabelPoints: function (bBox, rotatedBBox, isHorizontal, angle) {
    const xl = bBox.x;
    const xr = xl + bBox.width;
    const xc = xl + _round(bBox.width / 2);
    const yt = bBox.y;
    const yb = yt + bBox.height;
    const yc = yt + _round(bBox.height / 2);
    let points = [[[xl, yt], [xr, yt]], [[xr, yt], [xr, yb]], [[xr, yb], [xl, yb]], [[xl, yb], [xl, yt]]];
    const cosSin = (0, _utils.getCosAndSin)(angle);
    if (angle === 0) {
      points = isHorizontal ? [[xl, yc], [xr, yc]] : [[xc, yt], [xc, yb]];
    } else {
      points = points.map(function (pair) {
        return pair.map(function (point) {
          return [_round((point[0] - xc) * cosSin.cos + (point[1] - yc) * cosSin.sin + xc), _round(-(point[0] - xc) * cosSin.sin + (point[1] - yc) * cosSin.cos + yc)];
        });
      }).reduce(function (r, pair) {
        const point1x = pair[0][0];
        const point1y = pair[0][1];
        const point2x = pair[1][0];
        const point2y = pair[1][1];
        if (isHorizontal) {
          if (point1y >= yc && yc >= point2y || point1y <= yc && yc <= point2y) {
            r.push([(yc - point1y) * (point2x - point1x) / (point2y - point1y) + point1x, yc]);
          }
        } else {
          if (point1x >= xc && xc >= point2x || point1x <= xc && xc <= point2x) {
            r.push([xc, (xc - point1x) * (point2y - point1y) / (point2x - point1x) + point1y]);
          }
        }
        return r;
      }, []);
    }
    return points;
  },
  isHorizontal: function (bBox, figure) {
    return bBox.x > figure.x || figure.x > bBox.x + bBox.width;
  },
  getFigureCenter: symbolPointStrategy.getFigureCenter,
  findFigurePoint: function (figure, labelPoint, isHorizontal) {
    if (!isHorizontal) {
      return [figure.x, figure.y];
    }
    const labelX = labelPoint[0];
    const x = _round(figure.x + (figure.y - labelPoint[1]) / Math.tan((0, _utils.degreesToRadians)(figure.angle)));
    let points = [figure.x, figure.y, x, labelPoint[1]];
    if (!(figure.x <= x && x <= labelX) && !(labelX <= x && x <= figure.x)) {
      if (_abs(figure.x - labelX) < CONNECTOR_LENGTH) {
        points = [figure.x, figure.y];
      } else if (figure.x <= labelX) {
        points[2] = figure.x + CONNECTOR_LENGTH;
      } else {
        points[2] = figure.x - CONNECTOR_LENGTH;
      }
    }
    return points;
  },
  adjustPoints: function (points) {
    return points;
  }
};
function selectStrategy(figure) {
  return figure.angle !== undefined && piePointStrategy || figure.r !== undefined && symbolPointStrategy || barPointStrategy;
}
function disposeItem(obj, field) {
  obj[field] && obj[field].dispose();
  obj[field] = null;
}
function checkBackground(background) {
  return background && (background.fill && background.fill !== 'none' || background['stroke-width'] > 0 && background.stroke && background.stroke !== 'none');
}
function checkConnector(connector) {
  return connector && connector['stroke-width'] > 0 && connector.stroke && connector.stroke !== 'none';
}
function formatText(data, options) {
  const format = options.format;
  data.valueText = _format(data.value, format);
  data.argumentText = _format(data.argument, options.argumentFormat);
  if (data.percent !== undefined) {
    data.percentText = _format(data.percent, {
      type: 'percent',
      precision: format && format.percentPrecision
    });
  }
  if (data.total !== undefined) {
    data.totalText = _format(data.total, format);
  }
  if (data.openValue !== undefined) {
    data.openValueText = _format(data.openValue, format);
  }
  if (data.closeValue !== undefined) {
    data.closeValueText = _format(data.closeValue, format);
  }
  if (data.lowValue !== undefined) {
    data.lowValueText = _format(data.lowValue, format);
  }
  if (data.highValue !== undefined) {
    data.highValueText = _format(data.highValue, format);
  }
  if (data.reductionValue !== undefined) {
    data.reductionValueText = _format(data.reductionValue, format);
  }
  return options.customizeText ? options.customizeText.call(data, data) : options.displayFormat ? (0, _display_format_parser.processDisplayFormat)(options.displayFormat, data) : data.valueText;
}
function Label(renderSettings) {
  this._renderer = renderSettings.renderer;
  this._container = renderSettings.labelsGroup;
  this._point = renderSettings.point;
  this._strategy = renderSettings.strategy;
  this._rowCount = 1;
}
Label.prototype = {
  constructor: Label,
  setColor: function (color) {
    this._color = color;
  },
  setOptions: function (options) {
    this._options = options;
  },
  setData: function (data) {
    this._data = data;
  },
  setDataField: function (fieldName, fieldValue) {
    // Is this laziness really required?
    this._data = this._data || {};
    this._data[fieldName] = fieldValue;
  },
  getData: function () {
    return this._data;
  },
  setFigureToDrawConnector: function (figure) {
    this._figure = figure;
  },
  dispose: function () {
    const that = this;
    disposeItem(that, '_group');
    that._data = that._options = that._textContent = that._visible = that._insideGroup = that._text = that._background = that._connector = that._figure = null;
  },
  // The following method is required because we support partial visibility for labels
  // entire labels group can be hidden and any particular label can be visible at the same time
  // in order to do that label must have visibility:"visible" attribute
  _setVisibility: function (value, state) {
    this._group && this._group.attr({
      visibility: value
    });
    this._visible = state;
  },
  isVisible: function () {
    return this._visible;
  },
  hide: function (holdInvisible) {
    this._holdVisibility = !!holdInvisible;
    this._hide();
  },
  _hide: function () {
    this._setVisibility('hidden', false);
  },
  show: function (holdVisible) {
    const correctPosition = !this._drawn;
    if (this._point.hasValue()) {
      this._holdVisibility = !!holdVisible;
      this._show();
      correctPosition && this._point.correctLabelPosition(this);
    }
  },
  _show: function () {
    const that = this;
    const renderer = that._renderer;
    const container = that._container;
    const options = that._options || {};
    const text = that._textContent = formatText(that._data, options) || null;
    if (text) {
      if (!that._group) {
        that._group = renderer.g().append(container);
        that._insideGroup = renderer.g().append(that._group);
        that._text = renderer.text('', 0, 0).append(that._insideGroup);
      }
      that._text.css(options.attributes ? (0, _utils.patchFontOptions)(options.attributes.font) : {});
      if (checkBackground(options.background)) {
        that._background = that._background || renderer.rect().append(that._insideGroup).toBackground();
        that._background.attr(options.background);
        // The following is because "this._options" is shared between all labels and so cannot be modified
        that._color && that._background.attr({
          fill: that._color
        });
      } else {
        disposeItem(that, '_background');
      }
      if (checkConnector(options.connector)) {
        that._connector = that._connector || renderer.path([], 'line').sharp().append(that._group).toBackground();
        that._connector.attr(options.connector);
        // The following is because "this._options" is shared between all labels and so cannot be modified
        that._color && that._connector.attr({
          stroke: that._color
        });
      } else {
        disposeItem(that, '_connector');
      }
      that._text.attr({
        text: text,
        align: options.textAlignment,
        'class': options.cssClass
      });
      that._updateBackground(that._text.getBBox());
      that._setVisibility('visible', true);
      that._drawn = true;
    } else {
      that._hide();
    }
  },
  _getLabelVisibility: function (isVisible) {
    return this._holdVisibility ? this.isVisible() : isVisible;
  },
  draw: function (isVisible) {
    if (this._getLabelVisibility(isVisible)) {
      this._show();
      this._point && this._point.correctLabelPosition(this);
    } else {
      this._drawn = false;
      this._hide();
    }
    return this;
  },
  _updateBackground: function (bBox) {
    const that = this;
    if (that._background) {
      bBox.x -= LABEL_BACKGROUND_PADDING_X;
      bBox.y -= LABEL_BACKGROUND_PADDING_Y;
      bBox.width += 2 * LABEL_BACKGROUND_PADDING_X;
      bBox.height += 2 * LABEL_BACKGROUND_PADDING_Y;
      that._background.attr(bBox);
    }
    that._bBoxWithoutRotation = (0, _extend.extend)({}, bBox);
    const rotationAngle = that._options.rotationAngle || 0;
    that._insideGroup.rotate(rotationAngle, bBox.x + bBox.width / 2, bBox.y + bBox.height / 2);
    // Angle is transformed from svg to right-handed cartesian space
    bBox = (0, _utils.rotateBBox)(bBox, [bBox.x + bBox.width / 2, bBox.y + bBox.height / 2], -rotationAngle);
    that._bBox = bBox;
  },
  getFigureCenter() {
    const figure = this._figure;
    const strategy = this._strategy || selectStrategy(figure);
    return strategy.getFigureCenter(figure);
  },
  _getConnectorPoints: function () {
    const that = this;
    const figure = that._figure;
    const options = that._options;
    const strategy = that._strategy || selectStrategy(figure);
    const bBox = that._shiftBBox(that._bBoxWithoutRotation);
    const rotatedBBox = that.getBoundingRect();
    let labelPoint;
    let points = [];
    let isHorizontal;
    if (!strategy.isLabelInside(bBox, figure, options.position !== 'inside')) {
      isHorizontal = strategy.isHorizontal(bBox, figure);
      const figureCenter = that.getFigureCenter();
      points = strategy.prepareLabelPoints(bBox, rotatedBBox, isHorizontal, -options.rotationAngle || 0, figureCenter);
      labelPoint = getClosestCoord(figureCenter, points);
      points = strategy.findFigurePoint(figure, labelPoint, isHorizontal);
      points = points.concat(labelPoint);
    }
    return strategy.adjustPoints(points);
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  fit: function (maxWidth) {
    const padding = this._background ? 2 * LABEL_BACKGROUND_PADDING_X : 0;
    let rowCountChanged = false;
    if (this._text) {
      const result = this._text.setMaxSize(maxWidth - padding, undefined, this._options);
      let rowCount = result.rowCount;
      if (rowCount === 0) {
        rowCount = 1;
      }
      if (rowCount !== this._rowCount) {
        rowCountChanged = true;
        this._rowCount = rowCount;
      }
      result.textIsEmpty && disposeItem(this, '_background');
    }
    this._updateBackground(this._text.getBBox());
    return rowCountChanged;
  },
  resetEllipsis: function () {
    this._text && this._text.restoreText();
    this._updateBackground(this._text.getBBox());
  },
  setTrackerData: function (point) {
    this._text.data({
      'chart-data-point': point
    });
    this._background && this._background.data({
      'chart-data-point': point
    });
  },
  hideInsideLabel: function (coords) {
    return this._point.hideInsideLabel(this, coords);
  },
  getPoint() {
    return this._point;
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  shift: function (x, y) {
    const that = this;
    if (that._textContent) {
      that._insideGroup.attr({
        translateX: that._x = _round(x - that._bBox.x),
        translateY: that._y = _round(y - that._bBox.y)
      });
      if (that._connector) {
        that._connector.attr({
          points: that._getConnectorPoints()
        });
      }
    }
    return that;
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  getBoundingRect: function () {
    return this._shiftBBox(this._bBox);
  },
  _shiftBBox: function (bBox) {
    return this._textContent ? {
      x: bBox.x + this._x,
      y: bBox.y + this._y,
      width: bBox.width,
      height: bBox.height
    } : {};
  },
  getLayoutOptions: function () {
    const options = this._options;
    return {
      alignment: options.alignment,
      background: checkBackground(options.background),
      horizontalOffset: options.horizontalOffset,
      verticalOffset: options.verticalOffset,
      radialOffset: options.radialOffset,
      position: options.position,
      connectorOffset: (checkConnector(options.connector) ? CONNECTOR_LENGTH : 0) + (checkBackground(options.background) ? LABEL_BACKGROUND_PADDING_X : 0)
    };
  }
};

/***/ }),

/***/ 85912:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _consts = _interopRequireDefault(__webpack_require__(32410));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _extend = _extend2.extend;
const _round = Math.round;
const _sqrt = Math.sqrt;
const _acos = Math.acos;
const DEG = 180 / Math.PI;
const _abs = Math.abs;
const RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;
var _default = exports["default"] = _extend({}, _symbol_point.default, {
  _updateData: function (data, argumentChanged) {
    const that = this;
    _symbol_point.default._updateData.call(this, data);
    if (argumentChanged || !(0, _type.isDefined)(that._visible)) {
      that._visible = true;
    }
    that.minValue = that.initialMinValue = that.originalMinValue = (0, _type.isDefined)(data.minValue) ? data.minValue : 0;
  },
  animate: function (complete, duration, delay) {
    const that = this;
    that.graphic.animate({
      x: that.centerX,
      y: that.centerY,
      outerRadius: that.radiusOuter,
      innerRadius: that.radiusInner,
      startAngle: that.toAngle,
      endAngle: that.fromAngle
    }, {
      delay: delay,
      partitionDuration: duration
    }, complete);
  },
  correctPosition: function (correction) {
    const that = this;
    that.correctRadius(correction);
    that.correctLabelRadius(correction.radiusOuter + RADIAL_LABEL_INDENT);
    that.centerX = correction.centerX;
    that.centerY = correction.centerY;
  },
  correctRadius: function (correction) {
    this.radiusInner = correction.radiusInner;
    this.radiusOuter = correction.radiusOuter;
  },
  correctLabelRadius: function (radiusLabels) {
    this.radiusLabels = radiusLabels;
  },
  correctValue: function (correction, percent, base) {
    const that = this;
    that.value = (base || that.normalInitialValue) + correction;
    that.minValue = correction;
    that.percent = percent;
    that._label.setDataField('percent', percent);
  },
  _updateLabelData: function () {
    this._label.setData(this._getLabelFormatObject());
  },
  _getShiftLabelCoords: function () {
    const that = this;
    const bBox = that._label.getBoundingRect();
    const coord = that._getLabelCoords(that._label);
    const visibleArea = that._getVisibleArea();
    if (that._isLabelDrawingWithoutPoints) {
      return that._checkLabelPosition(coord, bBox, visibleArea);
    } else {
      return that._getLabelExtraCoord(coord, that._checkVerticalLabelPosition(coord, bBox, visibleArea), bBox);
    }
  },
  _getLabelPosition: function (options) {
    return options.position;
  },
  getAnnotationCoords: function (location) {
    return this._getElementCoords(location !== 'edge' ? 'inside' : 'outside', this.radiusOuter, 0);
  },
  _getElementCoords: function (position, elementRadius, radialOffset) {
    let bBox = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    const that = this;
    const angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    const radiusInner = that.radiusInner;
    const radiusOuter = that.radiusOuter;
    const columnsPosition = position === 'columns';
    let rad;
    let x;
    if (position === 'inside') {
      rad = radiusInner + (radiusOuter - radiusInner) / 2 + radialOffset;
      x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;
    } else {
      rad = elementRadius + radialOffset;
      if (angleFunctions.cos > 0.1 || columnsPosition && angleFunctions.cos >= 0) {
        x = that.centerX + rad * angleFunctions.cos;
      } else if (angleFunctions.cos < -0.1 || columnsPosition && angleFunctions.cos < 0) {
        x = that.centerX + rad * angleFunctions.cos - bBox.width;
      } else {
        x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;
      }
    }
    return {
      x: x,
      y: _round(that.centerY - rad * angleFunctions.sin - bBox.height / 2)
    };
  },
  _getLabelCoords: function (label) {
    const that = this;
    const bBox = label.getBoundingRect();
    const options = label.getLayoutOptions();
    const position = that._getLabelPosition(options);
    return that._getElementCoords(position, that.radiusLabels, options.radialOffset, bBox);
  },
  _correctLabelCoord: function (coord, moveLabelsFromCenter) {
    const that = this;
    const label = that._label;
    const bBox = label.getBoundingRect();
    const labelWidth = bBox.width;
    const options = label.getLayoutOptions();
    const visibleArea = that._getVisibleArea();
    const rightBorderX = visibleArea.maxX - labelWidth;
    const leftBorderX = visibleArea.minX;
    const angleOfPoint = (0, _utils.normalizeAngle)(that.middleAngle);
    const centerX = that.centerX;
    const connectorOffset = options.connectorOffset;
    let x = coord.x;
    if (options.position === 'columns') {
      if (angleOfPoint <= 90 || angleOfPoint >= 270) {
        x = rightBorderX;
      } else {
        x = leftBorderX;
      }
      coord.x = x;
    } else if (options.position !== 'inside' && moveLabelsFromCenter) {
      if (angleOfPoint <= 90 || angleOfPoint >= 270) {
        if (x - connectorOffset < centerX) {
          x = centerX + connectorOffset;
        }
      } else {
        if (x + labelWidth + connectorOffset > centerX) {
          x = centerX - labelWidth - connectorOffset;
        }
      }
      coord.x = x;
    }
    return coord;
  },
  drawLabel: function () {
    this.translate();

    // this function is called for drawing labels without points for checking size of labels
    this._isLabelDrawingWithoutPoints = true;
    this._drawLabel();
    this._isLabelDrawingWithoutPoints = false;
  },
  updateLabelCoord: function (moveLabelsFromCenter) {
    const that = this;
    const bBox = that._label.getBoundingRect();
    let coord = that._correctLabelCoord(bBox, moveLabelsFromCenter);
    coord = that._checkHorizontalLabelPosition(coord, bBox, that._getVisibleArea());
    that._label.shift(_round(coord.x), _round(bBox.y));
  },
  _checkVerticalLabelPosition: function (coord, box, visibleArea) {
    const x = coord.x;
    let y = coord.y;
    if (coord.y + box.height > visibleArea.maxY) {
      y = visibleArea.maxY - box.height;
    } else if (coord.y < visibleArea.minY) {
      y = visibleArea.minY;
    }
    return {
      x: x,
      y: y
    };
  },
  _getLabelExtraCoord: function (coord, shiftCoord, box) {
    return coord.y !== shiftCoord.y ? (0, _utils.getVerticallyShiftedAngularCoords)({
      x: coord.x,
      y: coord.y,
      width: box.width,
      height: box.height
    }, shiftCoord.y - coord.y, {
      x: this.centerX,
      y: this.centerY
    }) : coord;
  },
  _checkHorizontalLabelPosition: function (coord, box, visibleArea) {
    let x = coord.x;
    const y = coord.y;
    if (coord.x + box.width > visibleArea.maxX) {
      x = visibleArea.maxX - box.width;
    } else if (coord.x < visibleArea.minX) {
      x = visibleArea.minX;
    }
    return {
      x: x,
      y: y
    };
  },
  applyWordWrap: function (moveLabelsFromCenter) {
    const that = this;
    const label = that._label;
    const box = label.getBoundingRect();
    const visibleArea = that._getVisibleArea();
    const position = label.getLayoutOptions().position;
    let width = box.width;
    let rowCountChanged = false;
    if (position === 'columns' && that.series.index > 0) {
      width = visibleArea.maxX - that.centerX - that.radiusLabels;
    } else if (position === 'inside') {
      if (width > visibleArea.maxX - visibleArea.minX) {
        width = visibleArea.maxX - visibleArea.minX;
      }
    } else {
      if (moveLabelsFromCenter && box.x < that.centerX && box.width + box.x > that.centerX) {
        width = Math.floor((visibleArea.maxX - visibleArea.minX) / 2);
      } else if (box.x + width > visibleArea.maxX) {
        width = visibleArea.maxX - box.x;
      } else if (box.x < visibleArea.minX) {
        width = box.x + width - visibleArea.minX;
      }
    }
    if (width < box.width) {
      rowCountChanged = label.fit(width);
    }
    return rowCountChanged;
  },
  setLabelTrackerData: function () {
    this._label.setTrackerData(this);
  },
  _checkLabelPosition: function (coord, bBox, visibleArea) {
    coord = this._checkHorizontalLabelPosition(coord, bBox, visibleArea);
    return this._checkVerticalLabelPosition(coord, bBox, visibleArea);
  },
  _getLabelConnector: function () {
    const that = this;
    const rad = that.radiusOuter;
    const seriesStyle = that._options.styles.normal;
    const strokeWidthBy2 = seriesStyle['stroke-width'] / 2;
    const borderWidth = that.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2);
    const angleFunctions = (0, _utils.getCosAndSin)(_round(that.middleAngle));
    return {
      x: _round(that.centerX + (rad - borderWidth) * angleFunctions.cos),
      y: _round(that.centerY - (rad - borderWidth) * angleFunctions.sin),
      angle: that.middleAngle
    };
  },
  _drawMarker: function (renderer, group, animationEnabled, firstDrawing) {
    const that = this;
    let radiusOuter = that.radiusOuter;
    let radiusInner = that.radiusInner;
    let fromAngle = that.fromAngle;
    let toAngle = that.toAngle;
    if (animationEnabled) {
      radiusInner = radiusOuter = 0;
      if (!firstDrawing) {
        fromAngle = toAngle = that.shiftedAngle;
      }
    }
    that.graphic = renderer.arc(that.centerX, that.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({
      'stroke-linejoin': 'round'
    }).smartAttr(that._getStyle()).data({
      'chart-data-point': that
    }).sharp().append(group);
  },
  getTooltipParams: function () {
    const that = this;
    const angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    const radiusInner = that.radiusInner;
    const radiusOuter = that.radiusOuter;
    return {
      x: that.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,
      y: that.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,
      offset: 0
    };
  },
  _translate: function () {
    const that = this;
    const angle = that.shiftedAngle || 0;
    const value = that.value;
    const minValue = that.minValue;
    const translator = that._getValTranslator();
    that.fromAngle = translator.translate(minValue) + angle;
    that.toAngle = translator.translate(value) + angle;
    that.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;
    if (!that.isVisible()) {
      that.middleAngle = that.toAngle = that.fromAngle = that.fromAngle || angle;
    }
  },
  getMarkerVisibility: function () {
    return true;
  },
  _updateMarker: function (animationEnabled, style, _, callback) {
    const that = this;
    if (!animationEnabled) {
      style = _extend({
        x: that.centerX,
        y: that.centerY,
        outerRadius: that.radiusOuter,
        innerRadius: that.radiusInner,
        startAngle: that.toAngle,
        endAngle: that.fromAngle
      }, style);
    }
    that.graphic.smartAttr(style).sharp();
    callback && callback();
  },
  getLegendStyles: function () {
    return this._styles.legendStyles;
  },
  isInVisibleArea: function () {
    return true;
  },
  hide: function () {
    const that = this;
    if (that._visible) {
      that._visible = false;
      that.hideTooltip();
      that._options.visibilityChanged();
    }
  },
  show: function () {
    const that = this;
    if (!that._visible) {
      that._visible = true;
      that._options.visibilityChanged();
    }
  },
  setInvisibility: function () {
    this._label.draw(false);
  },
  isVisible: function () {
    return this._visible;
  },
  _getFormatObject: function (tooltip) {
    const formatObject = _symbol_point.default._getFormatObject.call(this, tooltip);
    const percent = this.percent;
    formatObject.percent = percent;
    formatObject.percentText = tooltip.formatValue(percent, 'percent');
    return formatObject;
  },
  getColor: function () {
    return this._styles.normal.fill;
  },
  coordsIn: function (x, y) {
    const that = this;
    const lx = x - that.centerX;
    const ly = y - that.centerY;
    const r = _sqrt(lx * lx + ly * ly);
    const fromAngle = that.fromAngle % 360;
    const toAngle = that.toAngle % 360;
    let angle;
    if (r < that.radiusInner || r > that.radiusOuter || r === 0) {
      return false;
    }
    angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);
    if (angle < 0) {
      angle += 360;
    }
    if (fromAngle === toAngle && _abs(that.toAngle - that.fromAngle) > 1E-4) {
      return true;
    } else {
      return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle);
    }
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 38234:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polarSymbolPoint = exports.polarBarPoint = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _bar_point = _interopRequireDefault(__webpack_require__(27428));
var _pie_point = _interopRequireDefault(__webpack_require__(85912));
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _consts = _interopRequireDefault(__webpack_require__(32410));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _extend = _extend2.extend;
const _math = Math;
const _max = _math.max;
const RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;
const ERROR_BARS_ANGLE_OFFSET = 90;
const CANVAS_POSITION_START = 'canvas_position_start';
const CANVAS_POSITION_END = 'canvas_position_end';
const CANVAS_POSITION_DEFAULT = 'canvas_position_default';
const polarSymbolPoint = exports.polarSymbolPoint = _extend({}, _symbol_point.default, {
  _getLabelCoords: _pie_point.default._getLabelCoords,
  _getElementCoords: _pie_point.default._getElementCoords,
  _moveLabelOnCanvas: function (coord, visibleArea, labelBBox) {
    let x = coord.x;
    let y = coord.y;
    if (visibleArea.minX > x) {
      x = visibleArea.minX;
    }
    if (visibleArea.maxX < x + labelBBox.width) {
      x = visibleArea.maxX - labelBBox.width;
    }
    if (visibleArea.minY > y) {
      y = visibleArea.minY;
    }
    if (visibleArea.maxY < y + labelBBox.height) {
      y = visibleArea.maxY - labelBBox.height;
    }
    return {
      x: x,
      y: y
    };
  },
  _getLabelPosition: function () {
    return 'outside';
  },
  _getCoords: function (argument, value) {
    const axis = this.series.getValueAxis();
    const startAngle = axis.getAngles()[0];
    const angle = this._getArgTranslator().translate(argument);
    const radius = this._getValTranslator().translate(value);
    const coords = (0, _utils.convertPolarToXY)(axis.getCenter(), axis.getAngles()[0], angle, radius);
    coords.angle = angle + startAngle - 90, coords.radius = radius;
    return coords;
  },
  _translate() {
    const that = this;
    const center = that.series.getValueAxis().getCenter();
    const coord = that._getCoords(that.argument, that.value);
    const translator = that._getValTranslator();
    const maxRadius = translator.isInverted() ? translator.translate(CANVAS_POSITION_START) : translator.translate(CANVAS_POSITION_END);
    const normalizedRadius = (0, _type.isDefined)(coord.radius) && coord.radius >= 0 ? coord.radius : null;
    that.vx = (0, _utils.normalizeAngle)(coord.angle);
    that.vy = that.radiusOuter = that.radiusLabels = normalizedRadius;
    that.radiusLabels += RADIAL_LABEL_INDENT;
    that.radius = normalizedRadius;
    that.middleAngle = -coord.angle;
    that.angle = -coord.angle;
    that.x = coord.x;
    that.y = coord.y;
    that.defaultX = that.centerX = center.x;
    that.defaultY = that.centerY = center.y;
    that._translateErrorBars();
    that.inVisibleArea = that._checkRadiusForVisibleArea(normalizedRadius, maxRadius);
  },
  _checkRadiusForVisibleArea(radius, maxRadius) {
    return (0, _type.isDefined)(radius) && radius <= maxRadius;
  },
  _translateErrorBars: function () {
    const that = this;
    const errorBars = that._options.errorBars;
    const translator = that._getValTranslator();
    if (!errorBars) {
      return;
    }
    (0, _type.isDefined)(that.lowError) && (that._lowErrorCoord = that.centerY - translator.translate(that.lowError));
    (0, _type.isDefined)(that.highError) && (that._highErrorCoord = that.centerY - translator.translate(that.highError));
    that._errorBarPos = that.centerX;
    that._baseErrorBarPos = errorBars.type === 'stdDeviation' ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : that.centerY - that.radius;
  },
  _getTranslates: function (animationEnabled) {
    return animationEnabled ? this.getDefaultCoords() : {
      x: this.x,
      y: this.y
    };
  },
  getDefaultCoords: function () {
    const cosSin = (0, _utils.getCosAndSin)(-this.angle);
    const radius = this._getValTranslator().translate(CANVAS_POSITION_DEFAULT);
    const x = this.defaultX + radius * cosSin.cos;
    const y = this.defaultY + radius * cosSin.sin;
    return {
      x: x,
      y: y
    };
  },
  _addLabelAlignmentAndOffset: function (label, coord) {
    return coord;
  },
  _checkLabelPosition: function (label, coord) {
    const that = this;
    const visibleArea = that._getVisibleArea();
    const graphicBBox = that._getGraphicBBox();
    if (that._isPointInVisibleArea(visibleArea, graphicBBox)) {
      coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect());
    }
    return coord;
  },
  _getErrorBarSettings: function (errorBarOptions, animationEnabled) {
    const settings = _symbol_point.default._getErrorBarSettings.call(this, errorBarOptions, animationEnabled);
    settings.rotate = ERROR_BARS_ANGLE_OFFSET - this.angle;
    settings.rotateX = this.centerX;
    settings.rotateY = this.centerY;
    return settings;
  },
  getCoords: function (min) {
    return min ? this.getDefaultCoords() : {
      x: this.x,
      y: this.y
    };
  }
});
const polarBarPoint = exports.polarBarPoint = _extend({}, _bar_point.default, {
  _translateErrorBars: polarSymbolPoint._translateErrorBars,
  _getErrorBarSettings: polarSymbolPoint._getErrorBarSettings,
  _moveLabelOnCanvas: polarSymbolPoint._moveLabelOnCanvas,
  _getLabelCoords: _pie_point.default._getLabelCoords,
  _getElementCoords: _pie_point.default._getElementCoords,
  _getLabelConnector: _pie_point.default._getLabelConnector,
  getTooltipParams: _pie_point.default.getTooltipParams,
  _getLabelPosition: _pie_point.default._getLabelPosition,
  _getCoords: polarSymbolPoint._getCoords,
  _translate() {
    const that = this;
    const translator = that._getValTranslator();
    const businessRange = translator.getBusinessRange();
    const maxRadius = translator.isInverted() ? translator.translate(CANVAS_POSITION_START) : translator.translate(CANVAS_POSITION_END);
    that.radiusInner = translator.translate(that.minValue);
    polarSymbolPoint._translate.call(that);
    if (that.radiusInner === null) {
      that.radiusInner = that.radius = maxRadius;
    } else if (that.radius === null) {
      that.radius = that.value >= businessRange.minVisible ? maxRadius : 0;
    } else if (that.radius > maxRadius) {
      that.radius = maxRadius;
    }
    that.radiusOuter = that.radiusLabels = _max(that.radiusInner, that.radius);
    that.radiusLabels += RADIAL_LABEL_INDENT;
    that.radiusInner = that.defaultRadius = _math.min(that.radiusInner, that.radius);
    that.middleAngle = that.angle = -(0, _utils.normalizeAngle)(that.middleAngleCorrection - that.angle);
  },
  _checkRadiusForVisibleArea(radius) {
    return (0, _type.isDefined)(radius) || this._getValTranslator().translate(this.minValue) > 0;
  },
  _getErrorBarBaseEdgeLength() {
    const coord = this.getMarkerCoords();
    return _math.PI * coord.outerRadius * _math.abs(coord.startAngle - coord.endAngle) / 180;
  },
  getMarkerCoords: function () {
    return {
      x: this.centerX,
      y: this.centerY,
      outerRadius: this.radiusOuter,
      innerRadius: this.defaultRadius,
      startAngle: this.middleAngle - this.interval / 2,
      endAngle: this.middleAngle + this.interval / 2
    };
  },
  _drawMarker: function (renderer, group, animationEnabled) {
    const that = this;
    const styles = that._getStyle();
    const coords = that.getMarkerCoords();
    let innerRadius = coords.innerRadius;
    let outerRadius = coords.outerRadius;
    const start = that._getCoords(that.argument, CANVAS_POSITION_DEFAULT);
    let x = coords.x;
    let y = coords.y;
    if (animationEnabled) {
      innerRadius = 0;
      outerRadius = 0;
      x = start.x;
      y = start.y;
    }
    that.graphic = renderer.arc(x, y, innerRadius, outerRadius, coords.startAngle, coords.endAngle).attr(styles).data({
      'chart-data-point': that
    }).append(group);
  },
  _checkLabelPosition: function (label, coord) {
    const that = this;
    const visibleArea = that._getVisibleArea();
    const angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    const x = that.centerX + that.defaultRadius * angleFunctions.cos;
    const y = that.centerY - that.defaultRadius * angleFunctions.sin;
    if (x > visibleArea.minX && x < visibleArea.maxX && y > visibleArea.minY && y < visibleArea.maxY) {
      coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect());
    }
    return coord;
  },
  _addLabelAlignmentAndOffset: function (label, coord) {
    return coord;
  },
  correctCoordinates: function (correctOptions) {
    this.middleAngleCorrection = correctOptions.offset;
    this.interval = correctOptions.width;
  },
  coordsIn: function (x, y) {
    const val = (0, _utils.convertXYToPolar)(this.series.getValueAxis().getCenter(), x, y);
    const coords = this.getMarkerCoords();
    const isBetweenAngles = coords.startAngle < coords.endAngle ? -val.phi >= coords.startAngle && -val.phi <= coords.endAngle : -val.phi <= coords.startAngle && -val.phi >= coords.endAngle;
    return val.r >= coords.innerRadius && val.r <= coords.outerRadius && isBetweenAngles;
  }
});

/***/ }),

/***/ 73206:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _bar_point = _interopRequireDefault(__webpack_require__(27428));
var _range_symbol_point = _interopRequireDefault(__webpack_require__(97319));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _extend = _extend2.extend;
var _default = exports["default"] = _extend({}, _bar_point.default, {
  deleteLabel: _range_symbol_point.default.deleteLabel,
  _getFormatObject: _range_symbol_point.default._getFormatObject,
  clearVisibility: function () {
    const graphic = this.graphic;
    if (graphic && graphic.attr('visibility')) {
      graphic.attr({
        visibility: null
      });
    }
  },
  setInvisibility: function () {
    const graphic = this.graphic;
    if (graphic && graphic.attr('visibility') !== 'hidden') {
      graphic.attr({
        visibility: 'hidden'
      });
    }
    this._topLabel.draw(false);
    this._bottomLabel.draw(false);
  },
  getTooltipParams: function (location) {
    const that = this;
    const edgeLocation = location === 'edge';
    let x;
    let y;
    if (that._options.rotated) {
      x = edgeLocation ? that.x + that.width : that.x + that.width / 2;
      y = that.y + that.height / 2;
    } else {
      x = that.x + that.width / 2;
      y = edgeLocation ? that.y : that.y + that.height / 2;
    }
    return {
      x: x,
      y: y,
      offset: 0
    };
  },
  _translate: function () {
    const that = this;
    const barMethods = _bar_point.default;
    barMethods._translate.call(that);
    if (that._options.rotated) {
      that.width = that.width || 1;
    } else {
      that.height = that.height || 1;
    }
  },
  hasCoords: _range_symbol_point.default.hasCoords,
  _updateData: _range_symbol_point.default._updateData,
  _getLabelPosition: _range_symbol_point.default._getLabelPosition,
  _getLabelMinFormatObject: _range_symbol_point.default._getLabelMinFormatObject,
  _updateLabelData: _range_symbol_point.default._updateLabelData,
  _updateLabelOptions: _range_symbol_point.default._updateLabelOptions,
  getCrosshairData: _range_symbol_point.default.getCrosshairData,
  _createLabel: _range_symbol_point.default._createLabel,
  _checkOverlay: _range_symbol_point.default._checkOverlay,
  _checkLabelsOverlay: _range_symbol_point.default._checkLabelsOverlay,
  _getOverlayCorrections: _range_symbol_point.default._getOverlayCorrections,
  _drawLabel: _range_symbol_point.default._drawLabel,
  _getLabelCoords: _range_symbol_point.default._getLabelCoords,
  getLabel: _range_symbol_point.default.getLabel,
  getLabels: _range_symbol_point.default.getLabels,
  getBoundingRect: _common.noop,
  getMinValue: _range_symbol_point.default.getMinValue,
  getMaxValue: _range_symbol_point.default.getMaxValue
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97319:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _extend2 = __webpack_require__(13306);
var _common = __webpack_require__(20576);
var _label = __webpack_require__(28318);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _extend = _extend2.extend;
const _math = Math;
const _abs = _math.abs;
const _min = _math.min;
const _max = _math.max;
const _round = _math.round;
const DEFAULT_IMAGE_WIDTH = 20;
const DEFAULT_IMAGE_HEIGHT = 20;
var _default = exports["default"] = _extend({}, _symbol_point.default, {
  deleteLabel: function () {
    const that = this;
    that._topLabel.dispose();
    that._topLabel = null;
    that._bottomLabel.dispose();
    that._bottomLabel = null;
  },
  hideMarker: function (type) {
    const graphic = this.graphic;
    const marker = graphic && graphic[type + 'Marker'];
    const label = this['_' + type + 'Label'];
    if (marker && marker.attr('visibility') !== 'hidden') {
      marker.attr({
        visibility: 'hidden'
      });
    }
    label.draw(false);
  },
  setInvisibility: function () {
    this.hideMarker('top');
    this.hideMarker('bottom');
  },
  clearVisibility: function () {
    const that = this;
    const graphic = that.graphic;
    const topMarker = graphic && graphic.topMarker;
    const bottomMarker = graphic && graphic.bottomMarker;
    if (topMarker && topMarker.attr('visibility')) {
      topMarker.attr({
        visibility: null
      });
    }
    if (bottomMarker && bottomMarker.attr('visibility')) {
      bottomMarker.attr({
        visibility: null
      });
    }
  },
  clearMarker: function () {
    const that = this;
    const graphic = that.graphic;
    const topMarker = graphic && graphic.topMarker;
    const bottomMarker = graphic && graphic.bottomMarker;
    const emptySettings = that._emptySettings;
    topMarker && topMarker.attr(emptySettings);
    bottomMarker && bottomMarker.attr(emptySettings);
  },
  _getLabelPosition: function (markerType) {
    let position;
    const labelsInside = this._options.label.position === 'inside';
    if (!this._options.rotated) {
      position = markerType === 'top' ^ labelsInside ? 'top' : 'bottom';
    } else {
      position = markerType === 'top' ^ labelsInside ? 'right' : 'left';
    }
    return position;
  },
  _getLabelMinFormatObject: function () {
    const that = this;
    return {
      index: 0,
      argument: that.initialArgument,
      value: that.initialMinValue,
      seriesName: that.series.name,
      originalValue: that.originalMinValue,
      originalArgument: that.originalArgument,
      point: that
    };
  },
  _updateLabelData: function () {
    const maxFormatObject = this._getLabelFormatObject();
    maxFormatObject.index = 1;
    this._topLabel.setData(maxFormatObject);
    this._bottomLabel.setData(this._getLabelMinFormatObject());
  },
  _updateLabelOptions: function () {
    const that = this;
    const options = this._options.label;
    (!that._topLabel || !that._bottomLabel) && that._createLabel();
    that._topLabel.setOptions(options);
    that._bottomLabel.setOptions(options);
  },
  _createLabel: function () {
    const options = {
      renderer: this.series._renderer,
      labelsGroup: this.series._labelsGroup,
      point: this
    };
    this._topLabel = new _label.Label(options);
    this._bottomLabel = new _label.Label(options);
  },
  _getGraphicBBox: function (location) {
    const options = this._options;
    const images = this._getImage(options.image);
    const image = location === 'top' ? this._checkImage(images.top) : this._checkImage(images.bottom);
    let bBox;
    const coord = this._getPositionFromLocation(location);
    if (options.visible) {
      bBox = image ? this._getImageBBox(coord.x, coord.y) : this._getSymbolBBox(coord.x, coord.y, options.styles.normal.r);
    } else {
      bBox = {
        x: coord.x,
        y: coord.y,
        width: 0,
        height: 0
      };
    }
    return bBox;
  },
  _getPositionFromLocation: function (location) {
    let x;
    let y;
    const isTop = location === 'top';
    if (!this._options.rotated) {
      x = this.x;
      y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY);
    } else {
      x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);
      y = this.y;
    }
    return {
      x: x,
      y: y
    };
  },
  _checkOverlay: function (bottomCoord, topCoord, topValue) {
    return bottomCoord < topCoord + topValue;
  },
  _getOverlayCorrections: function (topCoords, bottomCoords) {
    const rotated = this._options.rotated;
    const coordSelector = !rotated ? 'y' : 'x';
    const valueSelector = !rotated ? 'height' : 'width';
    const visibleArea = this.series.getValueAxis().getVisibleArea();
    const minBound = visibleArea[0];
    const maxBound = visibleArea[1];
    let delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2);
    let coord1 = topCoords[coordSelector] - delta;
    let coord2 = bottomCoords[coordSelector] + delta;
    if (coord1 < minBound) {
      delta = minBound - coord1;
      coord1 += delta;
      coord2 += delta;
    } else if (coord2 + bottomCoords[valueSelector] > maxBound) {
      delta = maxBound - coord2 - bottomCoords[valueSelector];
      coord1 += delta;
      coord2 += delta;
    }
    return {
      coord1: coord1,
      coord2: coord2
    };
  },
  _checkLabelsOverlay: function (topLocation) {
    const that = this;
    const topCoords = that._topLabel.getBoundingRect();
    const bottomCoords = that._bottomLabel.getBoundingRect();
    let corrections = {};
    if (!that._options.rotated) {
      if (topLocation === 'top') {
        if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {
          corrections = this._getOverlayCorrections(topCoords, bottomCoords);
          that._topLabel.shift(topCoords.x, corrections.coord1);
          that._bottomLabel.shift(bottomCoords.x, corrections.coord2);
        }
      } else {
        if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {
          corrections = this._getOverlayCorrections(bottomCoords, topCoords);
          that._topLabel.shift(topCoords.x, corrections.coord2);
          that._bottomLabel.shift(bottomCoords.x, corrections.coord1);
        }
      }
    } else {
      if (topLocation === 'top') {
        if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {
          corrections = this._getOverlayCorrections(bottomCoords, topCoords);
          that._topLabel.shift(corrections.coord2, topCoords.y);
          that._bottomLabel.shift(corrections.coord1, bottomCoords.y);
        }
      } else {
        if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {
          corrections = this._getOverlayCorrections(topCoords, bottomCoords);
          that._topLabel.shift(corrections.coord1, topCoords.y);
          that._bottomLabel.shift(corrections.coord2, bottomCoords.y);
        }
      }
    }
  },
  _drawLabel: function () {
    const that = this;
    const labels = [];
    const notInverted = that._options.rotated ? that.x >= that.minX : that.y < that.minY;
    const customVisibility = that._getCustomLabelVisibility();
    const topLabel = that._topLabel;
    const bottomLabel = that._bottomLabel;
    topLabel.pointPosition = notInverted ? 'top' : 'bottom';
    bottomLabel.pointPosition = notInverted ? 'bottom' : 'top';
    if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue() && customVisibility !== false) {
      that.visibleTopMarker !== false && labels.push(topLabel);
      that.visibleBottomMarker !== false && labels.push(bottomLabel);
      (0, _iterator.each)(labels, function (_, label) {
        label.draw(true);
      });
      that._checkLabelsOverlay(that._topLabel.pointPosition);
    } else {
      topLabel.draw(false);
      bottomLabel.draw(false);
    }
  },
  _getImage: function (imageOption) {
    const image = {};
    if ((0, _type.isDefined)(imageOption)) {
      if (typeof imageOption === 'string') {
        image.top = image.bottom = imageOption;
      } else {
        image.top = {
          url: typeof imageOption.url === 'string' ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,
          width: typeof imageOption.width === 'number' ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,
          height: typeof imageOption.height === 'number' ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint
        };
        image.bottom = {
          url: typeof imageOption.url === 'string' ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,
          width: typeof imageOption.width === 'number' ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,
          height: typeof imageOption.height === 'number' ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint
        };
      }
    }
    return image;
  },
  _checkSymbol: function (oldOptions, newOptions) {
    const that = this;
    const oldSymbol = oldOptions.symbol;
    const newSymbol = newOptions.symbol;
    const symbolChanged = oldSymbol === 'circle' && newSymbol !== 'circle' || oldSymbol !== 'circle' && newSymbol === 'circle';
    const oldImages = that._getImage(oldOptions.image);
    const newImages = that._getImage(newOptions.image);
    const topImageChanged = that._checkImage(oldImages.top) !== that._checkImage(newImages.top);
    const bottomImageChanged = that._checkImage(oldImages.bottom) !== that._checkImage(newImages.bottom);
    return symbolChanged || topImageChanged || bottomImageChanged;
  },
  _getSettingsForTwoMarkers: function (style) {
    const that = this;
    const options = that._options;
    const settings = {};
    const x = options.rotated ? _min(that.x, that.minX) : that.x;
    const y = options.rotated ? that.y : _min(that.y, that.minY);
    const radius = style.r;
    const points = that._populatePointShape(options.symbol, radius);
    settings.top = _extend({
      translateX: x + that.width,
      translateY: y,
      r: radius
    }, style);
    settings.bottom = _extend({
      translateX: x,
      translateY: y + that.height,
      r: radius
    }, style);
    if (points) {
      settings.top.points = settings.bottom.points = points;
    }
    return settings;
  },
  _hasGraphic: function () {
    return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker;
  },
  _drawOneMarker: function (renderer, markerType, imageSettings, settings) {
    const that = this;
    const graphic = that.graphic;
    if (graphic[markerType]) {
      that._updateOneMarker(markerType, settings);
    } else {
      graphic[markerType] = that._createMarker(renderer, graphic, imageSettings, settings);
    }
  },
  _drawMarker: function (renderer, group, animationEnabled, firstDrawing, style) {
    const that = this;
    const settings = that._getSettingsForTwoMarkers(style || that._getStyle());
    const image = that._getImage(that._options.image);
    if (that._checkImage(image.top)) {
      settings.top = that._getImageSettings(settings.top, image.top);
    }
    if (that._checkImage(image.bottom)) {
      settings.bottom = that._getImageSettings(settings.bottom, image.bottom);
    }
    that.graphic = that.graphic || renderer.g().append(group);
    that.visibleTopMarker && that._drawOneMarker(renderer, 'topMarker', image.top, settings.top);
    that.visibleBottomMarker && that._drawOneMarker(renderer, 'bottomMarker', image.bottom, settings.bottom);
  },
  _getSettingsForTracker: function (radius) {
    const that = this;
    const rotated = that._options.rotated;
    return {
      translateX: rotated ? _min(that.x, that.minX) - radius : that.x - radius,
      translateY: rotated ? that.y - radius : _min(that.y, that.minY) - radius,
      width: that.width + 2 * radius,
      height: that.height + 2 * radius
    };
  },
  isInVisibleArea: function () {
    const that = this;
    const rotated = that._options.rotated;
    const argument = !rotated ? that.x : that.y;
    const maxValue = !rotated ? _max(that.minY, that.y) : _max(that.minX, that.x);
    const minValue = !rotated ? _min(that.minY, that.y) : _min(that.minX, that.x);
    let tmp;
    let visibleTopMarker;
    let visibleBottomMarker;
    let visibleRangeArea = true;
    const visibleArgArea = that.series.getArgumentAxis().getVisibleArea();
    const visibleValArea = that.series.getValueAxis().getVisibleArea();
    const notVisibleByArg = visibleArgArea[1] < argument || visibleArgArea[0] > argument;
    const notVisibleByVal = visibleValArea[0] > minValue && visibleValArea[0] > maxValue || visibleValArea[1] < minValue && visibleValArea[1] < maxValue;
    if (notVisibleByArg || notVisibleByVal) {
      visibleTopMarker = visibleBottomMarker = visibleRangeArea = false;
    } else {
      visibleTopMarker = visibleValArea[0] <= minValue && visibleValArea[1] > minValue;
      visibleBottomMarker = visibleValArea[0] < maxValue && visibleValArea[1] >= maxValue;
      if (rotated) {
        tmp = visibleTopMarker;
        visibleTopMarker = visibleBottomMarker;
        visibleBottomMarker = tmp;
      }
    }
    that.visibleTopMarker = visibleTopMarker;
    that.visibleBottomMarker = visibleBottomMarker;
    return visibleRangeArea;
  },
  getTooltipParams: function () {
    const that = this;
    let x;
    let y;
    const rotated = that._options.rotated;
    const minValue = !rotated ? _min(that.y, that.minY) : _min(that.x, that.minX);
    const side = !rotated ? 'height' : 'width';
    const visibleArea = that._getVisibleArea();
    const minVisible = rotated ? visibleArea.minX : visibleArea.minY;
    const maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
    const min = _max(minVisible, minValue);
    const max = _min(maxVisible, minValue + that[side]);
    if (!rotated) {
      x = that.x;
      y = min + (max - min) / 2;
    } else {
      y = that.y;
      x = min + (max - min) / 2;
    }
    return {
      x: x,
      y: y,
      offset: 0
    };
  },
  _translate: function () {
    const that = this;
    const rotated = that._options.rotated;
    _symbol_point.default._translate.call(that);
    that.height = rotated ? 0 : _abs(that.minY - that.y);
    that.width = rotated ? _abs(that.x - that.minX) : 0;
  },
  hasCoords: function () {
    return _symbol_point.default.hasCoords.call(this) && !(this.minX === null || this.minY === null);
  },
  _updateData: function (data) {
    const that = this;
    _symbol_point.default._updateData.call(that, data);
    that.minValue = that.initialMinValue = that.originalMinValue = data.minValue;
  },
  _getImageSettings: function (settings, image) {
    return {
      href: image.url || image.toString(),
      width: image.width || DEFAULT_IMAGE_WIDTH,
      height: image.height || DEFAULT_IMAGE_HEIGHT,
      translateX: settings.translateX,
      translateY: settings.translateY
    };
  },
  getCrosshairData: function (x, y) {
    const that = this;
    const rotated = that._options.rotated;
    const minX = that.minX;
    const minY = that.minY;
    const vx = that.vx;
    const vy = that.vy;
    const value = that.value;
    const minValue = that.minValue;
    const argument = that.argument;
    const coords = {
      axis: that.series.axis,
      x: vx,
      y: vy,
      yValue: value,
      xValue: argument
    };
    if (rotated) {
      coords.yValue = argument;
      if (_abs(vx - x) < _abs(minX - x)) {
        coords.xValue = value;
      } else {
        coords.x = minX;
        coords.xValue = minValue;
      }
    } else {
      if (_abs(vy - y) >= _abs(minY - y)) {
        coords.y = minY;
        coords.yValue = minValue;
      }
    }
    return coords;
  },
  _updateOneMarker: function (markerType, settings) {
    this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings);
  },
  _updateMarker: function (animationEnabled, style) {
    this._drawMarker(undefined, undefined, false, false, style);
  },
  _getFormatObject: function (tooltip) {
    const that = this;
    const initialMinValue = that.initialMinValue;
    const initialValue = that.initialValue;
    const initialArgument = that.initialArgument;
    const minValue = tooltip.formatValue(initialMinValue);
    const value = tooltip.formatValue(initialValue);
    return {
      argument: initialArgument,
      argumentText: tooltip.formatValue(initialArgument, 'argument'),
      valueText: minValue + ' - ' + value,
      rangeValue1Text: minValue,
      rangeValue2Text: value,
      rangeValue1: initialMinValue,
      rangeValue2: initialValue,
      seriesName: that.series.name,
      point: that,
      originalMinValue: that.originalMinValue,
      originalValue: that.originalValue,
      originalArgument: that.originalArgument
    };
  },
  getLabel: function () {
    return [this._topLabel, this._bottomLabel];
  },
  getLabels: function () {
    return [this._topLabel, this._bottomLabel];
  },
  getBoundingRect: _common.noop,
  coordsIn: function (x, y) {
    const trackerRadius = this._storeTrackerR();
    const xCond = x >= this.x - trackerRadius && x <= this.x + trackerRadius;
    const yCond = y >= this.y - trackerRadius && y <= this.y + trackerRadius;
    if (this._options.rotated) {
      return yCond && (xCond || x >= this.minX - trackerRadius && x <= this.minX + trackerRadius);
    } else {
      return xCond && (yCond || y >= this.minY - trackerRadius && y <= this.minY + trackerRadius);
    }
  },
  getMaxValue: function () {
    if (this.series.valueAxisType !== 'discrete') {
      return this.minValue > this.value ? this.minValue : this.value;
    }
    return this.value;
  },
  getMinValue: function () {
    if (this.series.valueAxisType !== 'discrete') {
      return this.minValue < this.value ? this.minValue : this.value;
    }
    return this.minValue;
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 71678:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _candlestick_point = _interopRequireDefault(__webpack_require__(69297));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _extend = _extend2.extend;
const _isNumeric = _type.isNumeric;
var _default = exports["default"] = _extend({}, _candlestick_point.default, {
  _getPoints: function () {
    const that = this;
    const createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };
    const openYExist = _isNumeric(that.openY);
    const closeYExist = _isNumeric(that.closeY);
    const x = that.x;
    const width = that.width;
    let points = [].concat(createPoint(x, that.highY));
    openYExist && (points = points.concat(createPoint(x, that.openY)));
    openYExist && (points = points.concat(createPoint(x - width / 2, that.openY)));
    openYExist && (points = points.concat(createPoint(x, that.openY)));
    closeYExist && (points = points.concat(createPoint(x, that.closeY)));
    closeYExist && (points = points.concat(createPoint(x + width / 2, that.closeY)));
    closeYExist && (points = points.concat(createPoint(x, that.closeY)));
    points = points.concat(createPoint(x, that.lowY));
    return points;
  },
  _drawMarkerInGroup: function (group, attributes, renderer) {
    this.graphic = renderer.path(this._getPoints(), 'line').attr({
      'stroke-linecap': 'square'
    }).attr(attributes).data({
      'chart-data-point': this
    }).sharp().append(group);
  },
  _getMinTrackerWidth: function () {
    const width = 2 + this._styles.normal['stroke-width'];
    return width + width % 2;
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 24894:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _common = __webpack_require__(20576);
var _window = __webpack_require__(58201);
var _label = __webpack_require__(28318);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
const window = (0, _window.getWindow)();
const _extend = _extend2.extend;
const _math = Math;
const _round = _math.round;
const _floor = _math.floor;
const _ceil = _math.ceil;
const DEFAULT_IMAGE_WIDTH = 20;
const DEFAULT_IMAGE_HEIGHT = 20;
const LABEL_OFFSET = 10;
const CANVAS_POSITION_DEFAULT = 'canvas_position_default';
function getSquareMarkerCoords(radius) {
  return [-radius, -radius, radius, -radius, radius, radius, -radius, radius, -radius, -radius];
}
function getPolygonMarkerCoords(radius) {
  const r = _ceil(radius); // T100386
  return [-r, 0, 0, -r, r, 0, 0, r, -r, 0];
}
function getCrossMarkerCoords(radius) {
  const r = _ceil(radius); // T100386
  const floorHalfRadius = _floor(r / 2);
  const ceilHalfRadius = _ceil(r / 2);
  return [-r, -floorHalfRadius, -floorHalfRadius, -r, 0, -ceilHalfRadius, floorHalfRadius, -r, r, -floorHalfRadius, ceilHalfRadius, 0, r, floorHalfRadius, floorHalfRadius, r, 0, ceilHalfRadius, -floorHalfRadius, r, -r, floorHalfRadius, -ceilHalfRadius, 0];
}
function getTriangleDownMarkerCoords(radius) {
  return [-radius, -radius, radius, -radius, 0, radius, -radius, -radius];
}
function getTriangleUpMarkerCoords(radius) {
  return [-radius, radius, radius, radius, 0, -radius, -radius, radius];
}
var _default = exports["default"] = {
  deleteLabel: function () {
    this._label.dispose();
    this._label = null;
  },
  _hasGraphic: function () {
    return this.graphic;
  },
  clearVisibility: function () {
    const that = this;
    const graphic = that.graphic;
    if (graphic && graphic.attr('visibility')) {
      graphic.attr({
        visibility: null
      });
    }
  },
  isVisible: function () {
    return this.inVisibleArea && this.series.isVisible();
  },
  setInvisibility: function () {
    const that = this;
    const graphic = that.graphic;
    if (graphic && graphic.attr('visibility') !== 'hidden') {
      graphic.attr({
        visibility: 'hidden'
      });
    }
    that._errorBar && that._errorBar.attr({
      visibility: 'hidden'
    });
    that._label.draw(false);
  },
  clearMarker: function () {
    const graphic = this.graphic;
    graphic && graphic.attr(this._emptySettings);
  },
  _createLabel: function () {
    this._label = new _label.Label({
      renderer: this.series._renderer,
      labelsGroup: this.series._labelsGroup,
      point: this
    });
  },
  _calculateVisibility: function (x, y) {
    const {
      minX,
      maxX,
      minY,
      maxY
    } = this._getVisibleArea();
    this.inVisibleArea = minX <= x && maxX >= x && minY <= y && maxY >= y;
  },
  _updateLabelData: function () {
    this._label.setData(this._getLabelFormatObject());
  },
  _updateLabelOptions: function () {
    !this._label && this._createLabel();
    this._label.setOptions(this._options.label);
  },
  _checkImage: function (image) {
    return (0, _type.isDefined)(image) && (typeof image === 'string' || (0, _type.isDefined)(image.url));
  },
  _fillStyle: function () {
    this._styles = this._options.styles;
  },
  _checkSymbol: function (oldOptions, newOptions) {
    const oldSymbol = oldOptions.symbol;
    const newSymbol = newOptions.symbol;
    const symbolChanged = oldSymbol === 'circle' && newSymbol !== 'circle' || oldSymbol !== 'circle' && newSymbol === 'circle';
    const imageChanged = this._checkImage(oldOptions.image) !== this._checkImage(newOptions.image);
    return !!(symbolChanged || imageChanged);
  },
  _populatePointShape: function (symbol, radius) {
    switch (symbol) {
      case 'square':
        return getSquareMarkerCoords(radius);
      case 'polygon':
        return getPolygonMarkerCoords(radius);
      case 'triangle':
      case 'triangleDown':
        return getTriangleDownMarkerCoords(radius);
      case 'triangleUp':
        return getTriangleUpMarkerCoords(radius);
      case 'cross':
        return getCrossMarkerCoords(radius);
    }
  },
  hasCoords: function () {
    return this.x !== null && this.y !== null;
  },
  correctValue: function (correction) {
    const that = this;
    const axis = that.series.getValueAxis();
    if (that.hasValue()) {
      that.value = that.properValue = axis.validateUnit(that.initialValue.valueOf() + correction.valueOf());
      that.minValue = axis.validateUnit(correction);
    }
  },
  resetCorrection: function () {
    this.value = this.properValue = this.initialValue;
    this.minValue = CANVAS_POSITION_DEFAULT;
  },
  resetValue: function () {
    const that = this;
    if (that.hasValue()) {
      that.value = that.properValue = that.initialValue = 0;
      that.minValue = 0;
      that._label.setDataField('value', that.value);
    }
  },
  _getTranslates: function (animationEnabled) {
    let translateX = this.x;
    let translateY = this.y;
    if (animationEnabled) {
      if (this._options.rotated) {
        translateX = this.defaultX;
      } else {
        translateY = this.defaultY;
      }
    }
    return {
      x: translateX,
      y: translateY
    };
  },
  _createImageMarker: function (renderer, settings, options) {
    const width = options.width || DEFAULT_IMAGE_WIDTH;
    const height = options.height || DEFAULT_IMAGE_HEIGHT;
    return renderer.image(-_round(width * 0.5), -_round(height * 0.5), width, height, options.url ? options.url.toString() : options.toString(), 'center').attr({
      translateX: settings.translateX,
      translateY: settings.translateY,
      visibility: settings.visibility
    });
  },
  _createSymbolMarker: function (renderer, pointSettings) {
    let marker;
    const symbol = this._options.symbol;
    if (symbol === 'circle') {
      delete pointSettings.points;
      marker = renderer.circle().attr(pointSettings);
    } else if (symbol === 'square' || symbol === 'polygon' || symbol === 'triangle' || symbol === 'triangleDown' || symbol === 'triangleUp' || symbol === 'cross') {
      marker = renderer.path([], 'area').attr(pointSettings).sharp();
    }
    return marker;
  },
  _createMarker: function (renderer, group, image, settings) {
    const that = this;
    const marker = that._checkImage(image) ? that._createImageMarker(renderer, settings, image) : that._createSymbolMarker(renderer, settings);
    if (marker) {
      marker.data({
        'chart-data-point': that
      }).append(group);
    }
    return marker;
  },
  _getSymbolBBox: function (x, y, r) {
    return {
      x: x - r,
      y: y - r,
      width: r * 2,
      height: r * 2
    };
  },
  _getImageBBox: function (x, y) {
    const image = this._options.image;
    const width = image.width || DEFAULT_IMAGE_WIDTH;
    const height = image.height || DEFAULT_IMAGE_HEIGHT;
    return {
      x: x - _round(width / 2),
      y: y - _round(height / 2),
      width: width,
      height: height
    };
  },
  _getGraphicBBox: function () {
    const that = this;
    const options = that._options;
    const x = that.x;
    const y = that.y;
    let bBox;
    if (options.visible) {
      bBox = that._checkImage(options.image) ? that._getImageBBox(x, y) : that._getSymbolBBox(x, y, options.styles.normal.r);
    } else {
      bBox = {
        x: x,
        y: y,
        width: 0,
        height: 0
      };
    }
    return bBox;
  },
  hideInsideLabel: _common.noop,
  _getShiftLabelCoords: function (label) {
    const coord = this._addLabelAlignmentAndOffset(label, this._getLabelCoords(label));
    return this._checkLabelPosition(label, coord);
  },
  _drawLabel: function () {
    const that = this;
    const customVisibility = that._getCustomLabelVisibility();
    const label = that._label;
    const isVisible = that._showForZeroValues() && that.hasValue() && customVisibility !== false && (that.series.getLabelVisibility() || customVisibility);
    label.draw(!!isVisible);
  },
  correctLabelPosition: function (label) {
    const that = this;
    const coord = that._getShiftLabelCoords(label);
    if (!that.hideInsideLabel(label, coord)) {
      label.setFigureToDrawConnector(that._getLabelConnector(label.pointPosition));
      label.shift(_round(coord.x), _round(coord.y));
    }
  },
  _showForZeroValues: function () {
    return true;
  },
  _getLabelConnector: function (pointPosition) {
    const bBox = this._getGraphicBBox(pointPosition);
    const w2 = bBox.width / 2;
    const h2 = bBox.height / 2;
    // This is to make label connector end at the center of point; "width" and "height" are required by the path building algorithm
    // TODO: When path building algorithm is updated remove "width" and "height"
    return {
      x: bBox.x + w2,
      y: bBox.y + h2,
      r: this._options.visible ? Math.max(w2, h2) : 0
    };
  },
  _getPositionFromLocation: function () {
    return {
      x: this.x,
      y: this.y
    };
  },
  _isPointInVisibleArea: function (visibleArea, graphicBBox) {
    return visibleArea.minX <= graphicBBox.x + graphicBBox.width && visibleArea.maxX >= graphicBBox.x && visibleArea.minY <= graphicBBox.y + graphicBBox.height && visibleArea.maxY >= graphicBBox.y;
  },
  _checkLabelPosition: function (label, coord) {
    const that = this;
    const visibleArea = that._getVisibleArea();
    const labelBBox = label.getBoundingRect();
    const graphicBBox = that._getGraphicBBox(label.pointPosition);
    const fullGraphicBBox = that._getGraphicBBox();
    const isInside = label.getLayoutOptions().position === 'inside';
    const offset = LABEL_OFFSET;
    if (that._isPointInVisibleArea(visibleArea, fullGraphicBBox)) {
      if (!that._options.rotated) {
        if (visibleArea.minX > coord.x) {
          coord.x = visibleArea.minX;
        }
        if (visibleArea.maxX < coord.x + labelBBox.width) {
          coord.x = visibleArea.maxX - labelBBox.width;
        }
        if (visibleArea.minY > coord.y) {
          coord.y = isInside ? visibleArea.minY : graphicBBox.y + graphicBBox.height + offset;
        }
        if (visibleArea.maxY < coord.y + labelBBox.height) {
          coord.y = isInside ? visibleArea.maxY - labelBBox.height : graphicBBox.y - labelBBox.height - offset;
        }
      } else {
        if (visibleArea.minX > coord.x) {
          coord.x = isInside ? visibleArea.minX : graphicBBox.x + graphicBBox.width + offset;
        }
        if (visibleArea.maxX < coord.x + labelBBox.width) {
          coord.x = isInside ? visibleArea.maxX - labelBBox.width : graphicBBox.x - offset - labelBBox.width;
        }
        if (visibleArea.minY > coord.y) {
          coord.y = visibleArea.minY;
        }
        if (visibleArea.maxY < coord.y + labelBBox.height) {
          coord.y = visibleArea.maxY - labelBBox.height;
        }
      }
    }
    return coord;
  },
  _addLabelAlignmentAndOffset: function (label, coord) {
    const labelBBox = label.getBoundingRect();
    const labelOptions = label.getLayoutOptions();
    if (!this._options.rotated) {
      if (labelOptions.alignment === 'left') {
        coord.x += labelBBox.width / 2;
      } else if (labelOptions.alignment === 'right') {
        coord.x -= labelBBox.width / 2;
      }
    }
    coord.x += labelOptions.horizontalOffset;
    coord.y += labelOptions.verticalOffset;
    return coord;
  },
  _getLabelCoords: function (label) {
    return this._getLabelCoordOfPosition(label, this._getLabelPosition(label.pointPosition));
  },
  _getLabelCoordOfPosition: function (label, position) {
    const that = this;
    const labelBBox = label.getBoundingRect();
    const graphicBBox = that._getGraphicBBox(label.pointPosition);
    const offset = LABEL_OFFSET;
    const centerY = graphicBBox.height / 2 - labelBBox.height / 2;
    const centerX = graphicBBox.width / 2 - labelBBox.width / 2;
    let x = graphicBBox.x;
    let y = graphicBBox.y;
    switch (position) {
      case 'left':
        x -= labelBBox.width + offset;
        y += centerY;
        break;
      case 'right':
        x += graphicBBox.width + offset;
        y += centerY;
        break;
      case 'top':
        x += centerX;
        y -= labelBBox.height + offset;
        break;
      case 'bottom':
        x += centerX;
        y += graphicBBox.height + offset;
        break;
      case 'inside':
        x += centerX;
        y += centerY;
        break;
    }
    return {
      x: x,
      y: y
    };
  },
  _drawMarker: function (renderer, group, animationEnabled) {
    const that = this;
    const options = that._options;
    const translates = that._getTranslates(animationEnabled);
    const style = that._getStyle();
    that.graphic = that._createMarker(renderer, group, options.image, _extend({
      translateX: translates.x,
      translateY: translates.y,
      points: that._populatePointShape(options.symbol, style.r)
    }, style));
  },
  _getErrorBarSettings: function () {
    return {
      visibility: 'visible'
    };
  },
  _getErrorBarBaseEdgeLength() {
    return this.getPointRadius() * 2;
  },
  _drawErrorBar: function (renderer, group) {
    if (!this._options.errorBars) {
      return;
    }
    const that = this;
    const options = that._options;
    const errorBarOptions = options.errorBars;
    const points = [];
    let settings;
    const pos = that._errorBarPos;
    let high = that._highErrorCoord;
    let low = that._lowErrorCoord;
    const displayMode = (0, _utils.normalizeEnum)(errorBarOptions.displayMode);
    const isHighDisplayMode = displayMode === 'high';
    const isLowDisplayMode = displayMode === 'low';
    const highErrorOnly = (isHighDisplayMode || !(0, _type.isDefined)(low)) && (0, _type.isDefined)(high) && !isLowDisplayMode;
    const lowErrorOnly = (isLowDisplayMode || !(0, _type.isDefined)(high)) && (0, _type.isDefined)(low) && !isHighDisplayMode;
    let edgeLength = errorBarOptions.edgeLength;
    if (edgeLength <= 1 && edgeLength > 0) {
      edgeLength = this._getErrorBarBaseEdgeLength() * errorBarOptions.edgeLength;
    }
    edgeLength = _floor(parseInt(edgeLength) / 2);
    highErrorOnly && (low = that._baseErrorBarPos);
    lowErrorOnly && (high = that._baseErrorBarPos);
    if (displayMode !== 'none' && (0, _type.isDefined)(high) && (0, _type.isDefined)(low) && (0, _type.isDefined)(pos)) {
      !lowErrorOnly && points.push([pos - edgeLength, high, pos + edgeLength, high]);
      points.push([pos, high, pos, low]);
      !highErrorOnly && points.push([pos + edgeLength, low, pos - edgeLength, low]);
      options.rotated && (0, _iterator.each)(points, function (_, p) {
        p.reverse();
      });
      settings = that._getErrorBarSettings(errorBarOptions);
      if (!that._errorBar) {
        that._errorBar = renderer.path(points, 'line').attr(settings).append(group);
      } else {
        settings.points = points;
        that._errorBar.attr(settings);
      }
    } else {
      that._errorBar && that._errorBar.attr({
        visibility: 'hidden'
      });
    }
  },
  getTooltipParams: function () {
    const that = this;
    const graphic = that.graphic;
    return {
      x: that.x,
      y: that.y,
      offset: graphic ? graphic.getBBox().height / 2 : 0
    };
  },
  setPercentValue: function (absTotal, total, leftHoleTotal, rightHoleTotal) {
    const that = this;
    const valuePercent = that.value / absTotal || 0;
    const minValuePercent = that.minValue / absTotal || 0;
    const percent = valuePercent - minValuePercent;
    that._label.setDataField('percent', percent);
    that._label.setDataField('total', total);
    if (that.series.isFullStackedSeries() && that.hasValue()) {
      if (that.leftHole) {
        that.leftHole /= absTotal - leftHoleTotal;
        that.minLeftHole /= absTotal - leftHoleTotal;
      }
      if (that.rightHole) {
        that.rightHole /= absTotal - rightHoleTotal;
        that.minRightHole /= absTotal - rightHoleTotal;
      }
      that.value = that.properValue = valuePercent;
      that.minValue = !minValuePercent ? that.minValue : minValuePercent;
    }
  },
  _storeTrackerR: function () {
    const that = this;
    let navigator = window.navigator;
    const r = that._options.styles.normal.r;
    const minTrackerSize = (0, _window.hasProperty)('ontouchstart') || navigator.msPointerEnabled && navigator.msMaxTouchPoints || navigator.pointerEnabled && navigator.maxTouchPoints ? 20 : 6;
    that._options.trackerR = r < minTrackerSize ? minTrackerSize : r;
    return that._options.trackerR;
  },
  _translateErrorBars: function () {
    const that = this;
    const options = that._options;
    const rotated = options.rotated;
    const errorBars = options.errorBars;
    const translator = that._getValTranslator();
    if (!errorBars) {
      return;
    }
    (0, _type.isDefined)(that.lowError) && (that._lowErrorCoord = translator.translate(that.lowError));
    (0, _type.isDefined)(that.highError) && (that._highErrorCoord = translator.translate(that.highError));
    that._errorBarPos = _floor(rotated ? that.vy : that.vx);
    that._baseErrorBarPos = errorBars.type === 'stdDeviation' ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : rotated ? that.vx : that.vy;
  },
  _translate: function () {
    const that = this;
    const valTranslator = that._getValTranslator();
    const argTranslator = that._getArgTranslator();
    if (that._options.rotated) {
      that.vx = that.x = valTranslator.translate(that.value, undefined, true);
      that.vy = that.y = argTranslator.translate(that.argument, undefined, true);
      that.minX = valTranslator.translate(that.minValue, undefined, true);
      that.defaultX = valTranslator.translate(CANVAS_POSITION_DEFAULT);
    } else {
      that.vy = that.y = valTranslator.translate(that.value, undefined, true);
      that.vx = that.x = argTranslator.translate(that.argument, undefined, true);
      that.minY = valTranslator.translate(that.minValue, undefined, true);
      that.defaultY = valTranslator.translate(CANVAS_POSITION_DEFAULT);
    }
    that._translateErrorBars();
    that._calculateVisibility(that.x, that.y);
  },
  _updateData: function (data) {
    const that = this;
    that.value = that.properValue = that.initialValue = that.originalValue = data.value;
    that.minValue = that.initialMinValue = that.originalMinValue = (0, _type.isDefined)(data.minValue) ? data.minValue : CANVAS_POSITION_DEFAULT;
  },
  _getImageSettings: function (image) {
    return {
      href: image.url || image.toString(),
      width: image.width || DEFAULT_IMAGE_WIDTH,
      height: image.height || DEFAULT_IMAGE_HEIGHT
    };
  },
  getCrosshairData: function () {
    const that = this;
    const r = that._options.rotated;
    const value = that.properValue;
    const argument = that.argument;
    return {
      x: that.vx,
      y: that.vy,
      xValue: r ? value : argument,
      yValue: r ? argument : value,
      axis: that.series.axis
    };
  },
  getPointRadius: function () {
    const style = this._getStyle();
    const options = this._options;
    const r = style.r;
    let extraSpace;
    const symbol = options.symbol;
    const isSquare = symbol === 'square';
    const isTriangle = symbol === 'triangle' || symbol === 'triangleDown' || symbol === 'triangleUp';
    if (options.visible && !options.image && r) {
      extraSpace = style['stroke-width'] / 2;
      return (isSquare || isTriangle ? 1.4 * r : r) + extraSpace;
    }
    return 0;
  },
  _updateMarker: function (animationEnabled, style) {
    const that = this;
    const options = that._options;
    let settings;
    const image = options.image;
    const visibility = !that.isVisible() ? {
      visibility: 'hidden'
    } : {};
    if (that._checkImage(image)) {
      settings = _extend({}, {
        visibility: style.visibility
      }, visibility, that._getImageSettings(image));
    } else {
      settings = _extend({}, style, visibility, {
        points: that._populatePointShape(options.symbol, style.r)
      });
    }
    if (!animationEnabled) {
      settings.translateX = that.x;
      settings.translateY = that.y;
    }
    that.graphic.attr(settings).sharp();
  },
  _getLabelFormatObject: function () {
    const that = this;
    return {
      argument: that.initialArgument,
      value: that.initialValue,
      originalArgument: that.originalArgument,
      originalValue: that.originalValue,
      seriesName: that.series.name,
      lowErrorValue: that.lowError,
      highErrorValue: that.highError,
      point: that
    };
  },
  _getLabelPosition: function () {
    const rotated = this._options.rotated;
    if (this.initialValue > 0) {
      return rotated ? 'right' : 'top';
    } else {
      return rotated ? 'left' : 'bottom';
    }
  },
  _getFormatObject: function (tooltip) {
    const that = this;
    const labelFormatObject = that._label.getData();
    return _extend({}, labelFormatObject, {
      argumentText: tooltip.formatValue(that.initialArgument, 'argument'),
      valueText: tooltip.formatValue(that.initialValue)
    }, (0, _type.isDefined)(labelFormatObject.percent) ? {
      percentText: tooltip.formatValue(labelFormatObject.percent, 'percent')
    } : {}, (0, _type.isDefined)(labelFormatObject.total) ? {
      totalText: tooltip.formatValue(labelFormatObject.total)
    } : {});
  },
  getMarkerVisibility: function () {
    return this._options.visible;
  },
  coordsIn: function (x, y) {
    const trackerRadius = this._storeTrackerR();
    return x >= this.x - trackerRadius && x <= this.x + trackerRadius && y >= this.y - trackerRadius && y <= this.y + trackerRadius;
  },
  getMinValue: function (noErrorBar) {
    const errorBarOptions = this._options.errorBars;
    if (errorBarOptions && !noErrorBar) {
      const displayMode = errorBarOptions.displayMode;
      const lowValue = displayMode !== 'high' && (0, _type.isDefined)(this.lowError) ? this.lowError : this.value;
      const highValue = displayMode !== 'low' && (0, _type.isDefined)(this.highError) ? this.highError : this.value;
      return lowValue < highValue ? lowValue : highValue;
    } else {
      return this.value;
    }
  },
  getMaxValue: function (noErrorBar) {
    const errorBarOptions = this._options.errorBars;
    if (errorBarOptions && !noErrorBar) {
      const displayMode = errorBarOptions.displayMode;
      const lowValue = displayMode !== 'high' && (0, _type.isDefined)(this.lowError) ? this.lowError : this.value;
      const highValue = displayMode !== 'low' && (0, _type.isDefined)(this.highError) ? this.highError : this.value;
      return lowValue > highValue ? lowValue : highValue;
    } else {
      return this.value;
    }
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 57402:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.chart = void 0;
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
var _scatter_series = __webpack_require__(21667);
var _bar_series = __webpack_require__(58821);
var _area_series = __webpack_require__(90048);
// there are rangebar, rangearea

const _extend = _extend2.extend;
const barSeries = _bar_series.chart.bar;
const areaSeries = _area_series.chart.area;
const chart = exports.chart = {};
const baseRangeSeries = {
  areErrorBarsVisible: _common.noop,
  _createErrorBarGroup: _common.noop,
  _checkData: function (data, skippedFields) {
    const valueFields = this.getValueFields();
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      minValue: valueFields[0],
      value: valueFields[1]
    }) && data.minValue === data.minValue;
  },
  getValueRangeInitialValue: _scatter_series.chart.getValueRangeInitialValue,
  _getPointDataSelector: function (data) {
    const valueFields = this.getValueFields();
    const val1Field = valueFields[0];
    const val2Field = valueFields[1];
    const tagField = this.getTagField();
    const argumentField = this.getArgumentField();
    return data => {
      return {
        tag: data[tagField],
        minValue: this._processEmptyValue(data[val1Field]),
        value: this._processEmptyValue(data[val2Field]),
        argument: data[argumentField],
        data: data
      };
    };
  },
  _defaultAggregator: 'range',
  _aggregators: {
    range(_ref, series) {
      let {
        intervalStart,
        intervalEnd,
        data
      } = _ref;
      if (!data.length) {
        return;
      }
      const valueFields = series.getValueFields();
      const val1Field = valueFields[0];
      const val2Field = valueFields[1];
      const result = data.reduce((result, item) => {
        const val1 = item[val1Field];
        const val2 = item[val2Field];
        if (!(0, _type.isDefined)(val1) || !(0, _type.isDefined)(val2)) {
          return result;
        }
        result[val1Field] = Math.min(result[val1Field], Math.min(val1, val2));
        result[val2Field] = Math.max(result[val2Field], Math.max(val1, val2));
        return result;
      }, {
        [val1Field]: Infinity,
        [val2Field]: -Infinity,
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
      });
      if (!isFinite(result[val1Field]) || !isFinite(result[val2Field])) {
        if (data.filter(i => i[val1Field] === null && i[val2Field] === null).length === data.length) {
          result[val1Field] = result[val2Field] = null;
        } else {
          return;
        }
      }
      return result;
    }
  },
  getValueFields: function () {
    return [this._options.rangeValue1Field || 'val1', this._options.rangeValue2Field || 'val2'];
  },
  getSeriesPairCoord(coord, isArgument) {
    let oppositeCoord = null;
    const {
      rotated
    } = this._options;
    const isOpposite = !isArgument && !rotated || isArgument && rotated;
    const coordName = isOpposite ? 'vy' : 'vx';
    const minCoordName = rotated ? 'minX' : 'minY';
    const oppositeCoordName = isOpposite ? 'vx' : 'vy';
    const points = this.getPoints();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      let tmpCoord;
      if (isArgument) {
        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : undefined;
      } else {
        const coords = [Math.min(p[coordName], p[minCoordName]), Math.max(p[coordName], p[minCoordName])];
        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p[oppositeCoordName] : undefined;
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  }
};
chart['rangebar'] = _extend({}, barSeries, baseRangeSeries);
chart['rangearea'] = _extend({}, areaSeries, {
  _drawPoint: function (options) {
    const point = options.point;
    if (point.isInVisibleArea()) {
      point.clearVisibility();
      point.draw(this._renderer, options.groups);
      this._drawnPoints.push(point);
      if (!point.visibleTopMarker) {
        point.hideMarker('top');
      }
      if (!point.visibleBottomMarker) {
        point.hideMarker('bottom');
      }
    } else {
      point.setInvisibility();
    }
  },
  _prepareSegment: function (points, rotated) {
    const processedPoints = this._processSinglePointsAreaSegment(points, rotated);
    const processedMinPointsCoords = (0, _utils.map)(processedPoints, function (pt) {
      return pt.getCoords(true);
    });
    return {
      line: processedPoints,
      bottomLine: processedMinPointsCoords,
      area: (0, _utils.map)(processedPoints, function (pt) {
        return pt.getCoords();
      }).concat(processedMinPointsCoords.slice().reverse()),
      singlePointSegment: processedPoints !== points
    };
  },
  _getDefaultSegment: function (segment) {
    const defaultSegment = areaSeries._getDefaultSegment.call(this, segment);
    defaultSegment.bottomLine = defaultSegment.line;
    return defaultSegment;
  },
  _removeElement: function (element) {
    areaSeries._removeElement.call(this, element);
    element.bottomLine && element.bottomLine.remove();
  },
  _drawElement: function (segment, group) {
    const that = this;
    const drawnElement = areaSeries._drawElement.call(that, segment, group);
    drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, {
      'stroke-width': that._styles.normal.border['stroke-width']
    }).append(that._bordersGroup);
    return drawnElement;
  },
  _applyStyle: function (style) {
    const that = this;
    const elementsGroup = that._elementsGroup;
    const bordersGroup = that._bordersGroup;
    elementsGroup && elementsGroup.smartAttr(style.elements);
    bordersGroup && bordersGroup.attr(style.border);
    (that._graphics || []).forEach(function (graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.border['stroke-width']
      });
      graphic.bottomLine && graphic.bottomLine.attr({
        'stroke-width': style.border['stroke-width']
      });
    });
  },
  _updateElement: function (element, segment, animate, complete) {
    const bottomLineParams = {
      points: segment.bottomLine
    };
    const bottomBorderElement = element.bottomLine;
    areaSeries._updateElement.apply(this, arguments);
    if (bottomBorderElement) {
      animate ? bottomBorderElement.animate(bottomLineParams) : bottomBorderElement.attr(bottomLineParams);
    }
  }
}, baseRangeSeries);

/***/ }),

/***/ 21667:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _range_data_calculator = _interopRequireDefault(__webpack_require__(63407));
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const math = Math;
const _abs = math.abs;
const _sqrt = math.sqrt;
const _max = math.max;
const DEFAULT_TRACKER_WIDTH = 12;
const DEFAULT_DURATION = 400;
const HIGH_ERROR = 'highError';
const LOW_ERROR = 'lowError';
const VARIANCE = 'variance';
const STANDARD_DEVIATION = 'stddeviation';
const STANDARD_ERROR = 'stderror';
const PERCENT = 'percent';
const FIXED = 'fixed';
const UNDEFINED = 'undefined';
const DISCRETE = 'discrete';
const LOGARITHMIC = 'logarithmic';
const DATETIME = 'datetime';
let chart = exports.chart = {};
let polar = exports.polar = {};
function sum(array) {
  let result = 0;
  (0, _iterator.each)(array, function (_, value) {
    result += value;
  });
  return result;
}
function isErrorBarTypeCorrect(type) {
  // TODO why UNDEFINED is here
  // return inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR, UNDEFINED]) !== -1;
  return [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR].includes(type);
}
function variance(array, expectedValue) {
  return sum((0, _utils.map)(array, function (value) {
    return (value - expectedValue) * (value - expectedValue);
  })) / array.length;
}
function calculateAvgErrorBars(result, data, series) {
  const errorBarsOptions = series.getOptions().valueErrorBar;
  const valueField = series.getValueFields()[0];
  const lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
  const highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
  if (series.areErrorBarsVisible() && errorBarsOptions.type === undefined) {
    const fusionData = data.reduce(function (result, item) {
      if ((0, _type.isDefined)(item[lowValueField])) {
        result[0] += item[valueField] - item[lowValueField];
        result[1]++;
      }
      if ((0, _type.isDefined)(item[highValueField])) {
        result[2] += item[highValueField] - item[valueField];
        result[3]++;
      }
      return result;
    }, [0, 0, 0, 0]);
    if (fusionData[1]) {
      result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1];
    }
    if (fusionData[2]) {
      result[highValueField] = result[valueField] + fusionData[2] / fusionData[3];
    }
  }
  return result;
}
function calculateSumErrorBars(result, data, series) {
  const errorBarsOptions = series.getOptions().valueErrorBar;
  const lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
  const highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
  if (series.areErrorBarsVisible() && errorBarsOptions.type === undefined) {
    result[lowValueField] = 0;
    result[highValueField] = 0;
    result = data.reduce(function (result, item) {
      result[lowValueField] += item[lowValueField];
      result[highValueField] += item[highValueField];
      return result;
    }, result);
  }
  return result;
}
function getMinMaxAggregator(compare) {
  return (_ref, series) => {
    let {
      intervalStart,
      intervalEnd,
      data
    } = _ref;
    const valueField = series.getValueFields()[0];
    let targetData = data[0];
    targetData = data.reduce((result, item) => {
      const value = item[valueField];
      if (result[valueField] === null) {
        result = item;
      }
      if (value !== null && compare(value, result[valueField])) {
        return item;
      }
      return result;
    }, targetData);
    return (0, _extend2.extend)({}, targetData, {
      [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
    });
  };
}
function checkFields(data, fieldsToCheck, skippedFields) {
  let allFieldsIsValid = true;
  for (const field in fieldsToCheck) {
    const isArgument = field === 'argument';
    if (isArgument || field === 'size' ? !(0, _type.isDefined)(data[field]) : data[field] === undefined) {
      const selector = fieldsToCheck[field];
      if (!isArgument) {
        skippedFields[selector] = (skippedFields[selector] || 0) + 1;
      }
      allFieldsIsValid = false;
    }
  }
  return allFieldsIsValid;
}
const baseScatterMethods = {
  _defaultDuration: DEFAULT_DURATION,
  _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,
  _applyStyle: _common.noop,
  _updateOptions: _common.noop,
  _parseStyle: _common.noop,
  _prepareSegment: _common.noop,
  _drawSegment: _common.noop,
  _appendInGroup: function () {
    this._group.append(this._extGroups.seriesGroup);
  },
  _createLegendState: function (styleOptions, defaultColor) {
    return {
      fill: (0, _utils.extractColor)(styleOptions.color, true) || defaultColor,
      hatching: styleOptions.hatching ? (0, _extend2.extend)({}, styleOptions.hatching, {
        direction: 'right'
      }) : undefined
    };
  },
  _getColorId: _common.noop,
  _applyElementsClipRect: function (settings) {
    settings['clip-path'] = this._paneClipRectID;
  },
  _applyMarkerClipRect: function (settings) {
    settings['clip-path'] = this._forceClipping ? this._paneClipRectID : null;
  },
  _createGroup: function (groupName, parent, target, settings) {
    const group = parent[groupName] = parent[groupName] || this._renderer.g();
    target && group.append(target);
    settings && group.attr(settings);
  },
  _applyClearingSettings: function (settings) {
    settings.opacity = null;
    settings.scale = null;
    if (this._options.rotated) {
      settings.translateX = null;
    } else {
      settings.translateY = null;
    }
  },
  _createGroups: function () {
    const that = this;
    that._createGroup('_markersGroup', that, that._group);
    that._createGroup('_labelsGroup', that);
  },
  _setMarkerGroupSettings: function () {
    const that = this;
    const settings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
    settings['class'] = 'dxc-markers';
    settings.opacity = 1; // T172577
    that._applyMarkerClipRect(settings);
    that._markersGroup.attr(settings);
  },
  getVisibleArea: function () {
    return this._visibleArea;
  },
  areErrorBarsVisible: function () {
    const errorBarOptions = this._options.valueErrorBar;
    return errorBarOptions && this._errorBarsEnabled() && errorBarOptions.displayMode !== 'none' && (isErrorBarTypeCorrect((0, _utils.normalizeEnum)(errorBarOptions.type)) || (0, _type.isDefined)(errorBarOptions.lowValueField) || (0, _type.isDefined)(errorBarOptions.highValueField));
  },
  groupPointsByCoords(rotated) {
    const cat = [];
    (0, _iterator.each)(this.getVisiblePoints(), function (_, p) {
      const pointCoord = parseInt(rotated ? p.vy : p.vx);
      if (!cat[pointCoord]) {
        cat[pointCoord] = p;
      } else {
        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p];
      }
    });
    return cat;
  },
  _createErrorBarGroup: function (animationEnabled) {
    const that = this;
    const errorBarOptions = that._options.valueErrorBar;
    let settings;
    if (that.areErrorBarsVisible()) {
      settings = {
        'class': 'dxc-error-bars',
        stroke: errorBarOptions.color,
        'stroke-width': errorBarOptions.lineWidth,
        opacity: animationEnabled ? 0.001 : errorBarOptions.opacity || 1,
        'stroke-linecap': 'square',
        sharp: true,
        'clip-path': that._forceClipping ? that._paneClipRectID : that._widePaneClipRectID
      };
      that._createGroup('_errorBarGroup', that, that._group, settings);
    }
  },
  _setGroupsSettings: function (animationEnabled) {
    const that = this;
    that._setMarkerGroupSettings();
    that._setLabelGroupSettings(animationEnabled);
    that._createErrorBarGroup(animationEnabled);
  },
  _getCreatingPointOptions: function () {
    const that = this;
    let defaultPointOptions;
    let creatingPointOptions = that._predefinedPointOptions;
    let normalStyle;
    if (!creatingPointOptions) {
      defaultPointOptions = that._getPointOptions();
      that._predefinedPointOptions = creatingPointOptions = (0, _extend2.extend)(true, {
        styles: {}
      }, defaultPointOptions);
      normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};
      creatingPointOptions.styles = creatingPointOptions.styles || {};
      creatingPointOptions.styles.normal = {
        'stroke-width': normalStyle['stroke-width'],
        r: normalStyle.r,
        opacity: normalStyle.opacity
      };
    }
    return creatingPointOptions;
  },
  _getPointOptions: function () {
    return this._parsePointOptions(this._preparePointOptions(), this._options.label);
  },
  _getOptionsForPoint: function () {
    return this._options.point;
  },
  _parsePointStyle: function (style, defaultColor, defaultBorderColor, defaultSize) {
    const border = style.border || {};
    const sizeValue = style.size !== undefined ? style.size : defaultSize;
    return {
      fill: (0, _utils.extractColor)(style.color, true) || defaultColor,
      stroke: border.color || defaultBorderColor,
      'stroke-width': border.visible ? border.width : 0,
      r: sizeValue / 2 + (border.visible && sizeValue !== 0 ? ~~(border.width / 2) || 0 : 0)
    };
  },
  _createPointStyles: function (pointOptions) {
    const that = this;
    const mainPointColor = (0, _utils.extractColor)(pointOptions.color, true) || that._options.mainSeriesColor;
    const containerColor = that._options.containerBackgroundColor;
    const normalStyle = that._parsePointStyle(pointOptions, mainPointColor, mainPointColor);
    normalStyle.visibility = pointOptions.visible ? 'visible' : 'hidden';
    return {
      labelColor: mainPointColor,
      normal: normalStyle,
      hover: that._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),
      selection: that._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)
    };
  },
  _checkData: function (data, skippedFields, fieldsToCheck) {
    fieldsToCheck = fieldsToCheck || {
      value: this.getValueFields()[0]
    };
    fieldsToCheck.argument = this.getArgumentField();
    return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value;
  },
  getArgumentRangeInitialValue() {
    const points = this.getPoints();
    if (this.useAggregation() && points.length) {
      var _points$0$aggregation, _points$aggregationIn;
      return {
        min: (_points$0$aggregation = points[0].aggregationInfo) === null || _points$0$aggregation === void 0 ? void 0 : _points$0$aggregation.intervalStart,
        max: (_points$aggregationIn = points[points.length - 1].aggregationInfo) === null || _points$aggregationIn === void 0 ? void 0 : _points$aggregationIn.intervalEnd
      };
    }
    return undefined;
  },
  getValueRangeInitialValue: function () {
    return undefined;
  },
  _getRangeData: function () {
    return _range_data_calculator.default.getRangeData(this);
  },
  _getPointDataSelector: function () {
    const valueField = this.getValueFields()[0];
    const argumentField = this.getArgumentField();
    const tagField = this.getTagField();
    const areErrorBarsVisible = this.areErrorBarsVisible();
    let lowValueField;
    let highValueField;
    if (areErrorBarsVisible) {
      const errorBarOptions = this._options.valueErrorBar;
      lowValueField = errorBarOptions.lowValueField || LOW_ERROR;
      highValueField = errorBarOptions.highValueField || HIGH_ERROR;
    }
    return data => {
      const pointData = {
        value: this._processEmptyValue(data[valueField]),
        argument: data[argumentField],
        tag: data[tagField],
        data: data
      };
      if (areErrorBarsVisible) {
        pointData.lowError = data[lowValueField];
        pointData.highError = data[highValueField];
      }
      return pointData;
    };
  },
  _errorBarsEnabled: function () {
    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME;
  },
  _drawPoint: function (options) {
    const point = options.point;
    if (point.isInVisibleArea()) {
      point.clearVisibility();
      point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);
      this._drawnPoints.push(point);
    } else {
      point.setInvisibility();
    }
  },
  _animateComplete: function () {
    const that = this;
    const animationSettings = {
      duration: that._defaultDuration
    };
    that._labelsGroup && that._labelsGroup.animate({
      opacity: 1
    }, animationSettings);
    that._errorBarGroup && that._errorBarGroup.animate({
      opacity: that._options.valueErrorBar.opacity || 1
    }, animationSettings);
  },
  _animate: function () {
    const that = this;
    const lastPointIndex = that._drawnPoints.length - 1;
    (0, _iterator.each)(that._drawnPoints || [], function (i, p) {
      p.animate(i === lastPointIndex ? function () {
        that._animateComplete();
      } : undefined, {
        translateX: p.x,
        translateY: p.y
      });
    });
  },
  _getIntervalCenter(intervalStart, intervalEnd) {
    const argAxis = this.getArgumentAxis();
    const axisOptions = argAxis.getOptions();
    if (argAxis.aggregatedPointBetweenTicks()) {
      return intervalStart;
    }
    return axisOptions.type !== 'discrete' ? argAxis.getVisualRangeCenter({
      minVisible: intervalStart,
      maxVisible: intervalEnd
    }, true) : intervalStart;
  },
  _defaultAggregator: 'avg',
  _aggregators: {
    avg(_ref2, series) {
      let {
        data,
        intervalStart,
        intervalEnd
      } = _ref2;
      if (!data.length) {
        return;
      }
      const valueField = series.getValueFields()[0];
      const aggregationResult = data.reduce((result, item) => {
        const value = item[valueField];
        if ((0, _type.isDefined)(value)) {
          result[0] += value;
          result[1]++;
        } else if (value === null) {
          result[2]++;
        }
        return result;
      }, [0, 0, 0]);
      return calculateAvgErrorBars({
        [valueField]: aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1],
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
      }, data, series);
    },
    sum(_ref3, series) {
      let {
        intervalStart,
        intervalEnd,
        data
      } = _ref3;
      if (!data.length) {
        return;
      }
      const valueField = series.getValueFields()[0];
      const aggregationResult = data.reduce((result, item) => {
        const value = item[valueField];
        if (value !== undefined) {
          result[0] += value;
        }
        if (value === null) {
          result[1]++;
        } else if (value === undefined) {
          result[2]++;
        }
        return result;
      }, [0, 0, 0]);
      let value = aggregationResult[0];
      if (aggregationResult[1] === data.length) {
        value = null;
      }
      if (aggregationResult[2] === data.length) {
        return;
      }
      return calculateSumErrorBars({
        [valueField]: value,
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
      }, data, series);
    },
    count(_ref4, series) {
      let {
        data,
        intervalStart,
        intervalEnd
      } = _ref4;
      const valueField = series.getValueFields()[0];
      return {
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd),
        [valueField]: data.filter(i => i[valueField] !== undefined).length
      };
    },
    min: getMinMaxAggregator((a, b) => a < b),
    max: getMinMaxAggregator((a, b) => a > b)
  },
  _endUpdateData: function () {
    delete this._predefinedPointOptions;
  },
  getArgumentField: function () {
    return this._options.argumentField || 'arg';
  },
  getValueFields: function () {
    const options = this._options;
    const errorBarsOptions = options.valueErrorBar;
    const valueFields = [options.valueField || 'val'];
    let lowValueField;
    let highValueField;
    if (errorBarsOptions) {
      lowValueField = errorBarsOptions.lowValueField;
      highValueField = errorBarsOptions.highValueField;
      (0, _type.isString)(lowValueField) && valueFields.push(lowValueField);
      (0, _type.isString)(highValueField) && valueFields.push(highValueField);
    }
    return valueFields;
  },
  _calculateErrorBars: function (data) {
    if (!this.areErrorBarsVisible()) {
      return;
    }
    const that = this;
    const options = that._options;
    const errorBarsOptions = options.valueErrorBar;
    const errorBarType = (0, _utils.normalizeEnum)(errorBarsOptions.type);
    let floatErrorValue = parseFloat(errorBarsOptions.value);
    const valueField = that.getValueFields()[0];
    let value;
    const lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
    const highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
    let valueArray;
    let valueArrayLength;
    let meanValue;
    let processDataItem;
    const addSubError = function (_i, item) {
      value = item.value;
      item.lowError = value - floatErrorValue;
      item.highError = value + floatErrorValue;
    };
    switch (errorBarType) {
      case FIXED:
        processDataItem = addSubError;
        break;
      case PERCENT:
        processDataItem = function (_, item) {
          value = item.value;
          const error = value * floatErrorValue / 100;
          item.lowError = value - error;
          item.highError = value + error;
        };
        break;
      case UNDEFINED:
        // TODO: rework this
        processDataItem = function (_, item) {
          item.lowError = item.data[lowValueField];
          item.highError = item.data[highValueField];
        };
        break;
      default:
        valueArray = (0, _utils.map)(data, function (item) {
          return (0, _type.isDefined)(item.data[valueField]) ? item.data[valueField] : null;
        });
        valueArrayLength = valueArray.length;
        floatErrorValue = floatErrorValue || 1;
        switch (errorBarType) {
          case VARIANCE:
            floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;
            processDataItem = addSubError;
            break;
          case STANDARD_DEVIATION:
            meanValue = sum(valueArray) / valueArrayLength;
            floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;
            processDataItem = function (_, item) {
              item.lowError = meanValue - floatErrorValue;
              item.highError = meanValue + floatErrorValue;
            };
            break;
          case STANDARD_ERROR:
            floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;
            processDataItem = addSubError;
            break;
        }
    }
    processDataItem && (0, _iterator.each)(data, processDataItem);
  },
  _patchMarginOptions: function (options) {
    const pointOptions = this._getCreatingPointOptions();
    const styles = pointOptions.styles;
    const maxSize = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {
      return _max(max, style.r * 2 + style['stroke-width']);
    }, 0);
    options.size = pointOptions.visible ? maxSize : 0;
    options.sizePointNormalState = pointOptions.visible ? styles.normal.r * 2 + styles.normal['stroke-width'] : 2;
    return options;
  },
  usePointsToDefineAutoHiding() {
    return true;
  }
};
exports.chart = chart = (0, _extend2.extend)({}, baseScatterMethods, {
  drawTrackers: function () {
    const that = this;
    let trackers;
    let trackersGroup;
    const segments = that._segments || [];
    const rotated = that._options.rotated;
    if (!that.isVisible()) {
      return;
    }
    if (segments.length) {
      trackers = that._trackers = that._trackers || [];
      trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({
        fill: 'gray',
        opacity: 0.001,
        stroke: 'gray',
        'class': 'dxc-trackers'
      })).attr({
        'clip-path': this._paneClipRectID || null
      }).append(that._group);
      (0, _iterator.each)(segments, function (i, segment) {
        if (!trackers[i]) {
          trackers[i] = that._drawTrackerElement(segment).data({
            'chart-data-series': that
          }).append(trackersGroup);
        } else {
          that._updateTrackerElement(segment, trackers[i]);
        }
      });
    }
    that._trackersTranslator = that.groupPointsByCoords(rotated);
  },
  _checkAxisVisibleAreaCoord(isArgument, coord) {
    const axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();
    const visibleArea = axis.getVisibleArea();
    return (0, _type.isDefined)(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord;
  },
  checkSeriesViewportCoord(axis, coord) {
    return this.getPoints().length && this.isVisible();
  },
  getSeriesPairCoord(coord, isArgument) {
    let oppositeCoord = null;
    const isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;
    const coordName = !isOpposite ? 'vx' : 'vy';
    const oppositeCoordName = !isOpposite ? 'vy' : 'vx';
    const points = this.getVisiblePoints();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : undefined;
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  },
  _getNearestPoints(point, nextPoint) {
    return [point, nextPoint];
  },
  _getBezierPoints() {
    return [];
  },
  _getNearestPointsByCoord(coord, isArgument) {
    const that = this;
    const rotated = that.getOptions().rotated;
    const isOpposite = !isArgument && !rotated || isArgument && rotated;
    const coordName = isOpposite ? 'vy' : 'vx';
    const allPoints = that.getPoints();
    const bezierPoints = that._getBezierPoints();
    const nearestPoints = [];
    if (allPoints.length > 1) {
      allPoints.forEach((point, i) => {
        const nextPoint = allPoints[i + 1];
        if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {
          nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints));
        }
      });
    } else {
      nearestPoints.push([allPoints[0], allPoints[0]]);
    }
    return nearestPoints;
  },
  getNeighborPoint: function (x, y) {
    let pCoord = this._options.rotated ? y : x;
    let nCoord = pCoord;
    const cat = this._trackersTranslator;
    let point = null;
    let minDistance;
    const oppositeCoord = this._options.rotated ? x : y;
    const oppositeCoordName = this._options.rotated ? 'vx' : 'vy';
    if (this.isVisible() && cat) {
      point = cat[pCoord];
      do {
        point = cat[nCoord] || cat[pCoord];
        pCoord--;
        nCoord++;
      } while ((pCoord >= 0 || nCoord < cat.length) && !point);
      if (Array.isArray(point)) {
        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);
        (0, _iterator.each)(point, function (i, p) {
          const distance = _abs(p[oppositeCoordName] - oppositeCoord);
          if (minDistance >= distance) {
            minDistance = distance;
            point = p;
          }
        });
      }
    }
    return point;
  },
  _applyVisibleArea: function () {
    const that = this;
    const rotated = that._options.rotated;
    const visibleX = (rotated ? that.getValueAxis() : that.getArgumentAxis()).getVisibleArea();
    const visibleY = (rotated ? that.getArgumentAxis() : that.getValueAxis()).getVisibleArea();
    that._visibleArea = {
      minX: visibleX[0],
      maxX: visibleX[1],
      minY: visibleY[0],
      maxY: visibleY[1]
    };
  },
  getPointCenterByArg(arg) {
    const point = this.getPointsByArg(arg)[0];
    return point ? point.getCenterCoord() : undefined;
  }
});
exports.polar = polar = (0, _extend2.extend)({}, baseScatterMethods, {
  drawTrackers: function () {
    chart.drawTrackers.call(this);
    const cat = this._trackersTranslator;
    let index;
    if (!this.isVisible()) {
      return;
    }
    (0, _iterator.each)(cat, function (i, category) {
      if (category) {
        index = i;
        return false;
      }
    });
    cat[index + 360] = cat[index];
  },
  getNeighborPoint: function (x, y) {
    const pos = (0, _utils.convertXYToPolar)(this.getValueAxis().getCenter(), x, y);
    return chart.getNeighborPoint.call(this, pos.phi, pos.r);
  },
  _applyVisibleArea: function () {
    const that = this;
    const canvas = that.getValueAxis().getCanvas();
    that._visibleArea = {
      minX: canvas.left,
      maxX: canvas.width - canvas.right,
      minY: canvas.top,
      maxY: canvas.height - canvas.bottom
    };
  },
  getSeriesPairCoord(params, isArgument) {
    let coords = null;
    const paramName = isArgument ? 'argument' : 'radius';
    const points = this.getVisiblePoints();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const tmpPoint = (0, _type.isDefined)(p[paramName]) && (0, _type.isDefined)(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {
        x: p.x,
        y: p.y
      } : undefined;
      if ((0, _type.isDefined)(tmpPoint)) {
        coords = tmpPoint;
        break;
      }
    }
    return coords;
  }
});

/***/ }),

/***/ 92057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _area_series = __webpack_require__(90048);
var _bar_series = __webpack_require__(58821);
var _line_series = __webpack_require__(7222);
var _utils = __webpack_require__(19157);
var _object = __webpack_require__(48013);
// there stackedline, fullstackedline, stackedbar, fullstackedbar, stackedarea, fullstackedarea

const chartAreaSeries = _area_series.chart.area;
const chartBarSeries = _bar_series.chart.bar;
const baseStackedSeries = {
  _calculateErrorBars: _common.noop,
  _updateOptions: function (options) {
    this._stackName = 'axis_' + (options.axis || 'default');
  }
};
const chart = exports.chart = {};
const polar = exports.polar = {};
chart['stackedline'] = (0, _extend2.extend)({}, _line_series.chart.line, baseStackedSeries, {});
chart['stackedspline'] = (0, _extend2.extend)({}, _line_series.chart['spline'], baseStackedSeries, {});
chart['fullstackedline'] = (0, _extend2.extend)({}, _line_series.chart.line, baseStackedSeries, {
  getValueRangeInitialValue: _area_series.chart.area.getValueRangeInitialValue
});
chart['fullstackedspline'] = (0, _extend2.extend)({}, _line_series.chart['spline'], baseStackedSeries, {
  getValueRangeInitialValue: _area_series.chart.area.getValueRangeInitialValue
});
const stackedBar = chart['stackedbar'] = (0, _extend2.extend)({}, chartBarSeries, baseStackedSeries, {
  _updateOptions: function (options) {
    baseStackedSeries._updateOptions.call(this, options);
    this._stackName = this._stackName + '_stack_' + (options.stack || 'default');
  }
});
chart['fullstackedbar'] = (0, _extend2.extend)({}, chartBarSeries, baseStackedSeries, {
  _updateOptions: stackedBar._updateOptions
});
function clonePoint(point, value, minValue, position) {
  point = (0, _object.clone)(point);
  point.value = value;
  point.minValue = minValue;
  point.translate();
  point.argument = point.argument + position;
  return point;
}
function preparePointsForStackedAreaSegment(points) {
  let i = 0;
  let p;
  const result = [];
  let array;
  const len = points.length;
  while (i < len) {
    p = points[i];
    array = [p];
    if (p.leftHole) {
      array = [clonePoint(p, p.leftHole, p.minLeftHole, 'left'), p];
    }
    if (p.rightHole) {
      array.push(clonePoint(p, p.rightHole, p.minRightHole, 'right'));
    }
    result.push(array);
    i++;
  }
  return [].concat.apply([], result);
}
chart['stackedarea'] = (0, _extend2.extend)({}, chartAreaSeries, baseStackedSeries, {
  _prepareSegment: function (points, rotated) {
    return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points), rotated);
  },
  _appendInGroup: function () {
    this._group.append(this._extGroups.seriesGroup).toBackground();
  }
});
function getPointsByArgFromPrevSeries(prevSeries, argument) {
  let result;
  while (!result && prevSeries) {
    result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument]; // T357324
    prevSeries = prevSeries._prevSeries;
  }
  return result;
}
chart['stackedsplinearea'] = (0, _extend2.extend)({}, _area_series.chart['splinearea'], baseStackedSeries, {
  _prepareSegment: function (points, rotated) {
    const that = this;
    let areaSegment;
    points = preparePointsForStackedAreaSegment(points);
    if (!this._prevSeries || points.length === 1) {
      areaSegment = _area_series.chart['splinearea']._prepareSegment.call(this, points, rotated);
    } else {
      const forwardPoints = _line_series.chart.spline._calculateBezierPoints(points, rotated);
      let backwardPoints = (0, _utils.map)(points, function (p) {
        const point = p.getCoords(true);
        point.argument = p.argument;
        return point;
      });
      let prevSeriesForwardPoints = [];
      const pointByArg = {};
      let i = 0;
      const len = that._prevSeries._segments.length;
      while (i < len) {
        prevSeriesForwardPoints = prevSeriesForwardPoints.concat(that._prevSeries._segments[i].line);
        i++;
      }
      (0, _iterator.each)(prevSeriesForwardPoints, function (_, p) {
        if (p.argument !== null) {
          const argument = p.argument.valueOf();
          if (!pointByArg[argument]) {
            pointByArg[argument] = [p];
          } else {
            pointByArg[argument].push(p);
          }
        }
      });
      that._prevSeries._segmentByArg = pointByArg;
      backwardPoints = _line_series.chart.spline._calculateBezierPoints(backwardPoints, rotated);
      (0, _iterator.each)(backwardPoints, function (i, p) {
        const argument = p.argument.valueOf();
        let prevSeriesPoints;
        if (i % 3 === 0) {
          prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);
          if (prevSeriesPoints) {
            backwardPoints[i - 1] && prevSeriesPoints[0] && (backwardPoints[i - 1] = prevSeriesPoints[0]);
            backwardPoints[i + 1] && (backwardPoints[i + 1] = prevSeriesPoints[2] || p);
          }
        }
      });
      areaSegment = {
        line: forwardPoints,
        area: forwardPoints.concat(backwardPoints.reverse())
      };
      that._areaPointsToSplineAreaPoints(areaSegment.area);
    }
    return areaSegment;
  },
  _appendInGroup: chart['stackedarea']._appendInGroup
});
chart['fullstackedarea'] = (0, _extend2.extend)({}, chartAreaSeries, baseStackedSeries, {
  _prepareSegment: chart['stackedarea']._prepareSegment,
  _appendInGroup: chart['stackedarea']._appendInGroup
});
chart['fullstackedsplinearea'] = (0, _extend2.extend)({}, _area_series.chart['splinearea'], baseStackedSeries, {
  _prepareSegment: chart['stackedsplinearea']._prepareSegment,
  _appendInGroup: chart['stackedarea']._appendInGroup
});
polar['stackedbar'] = (0, _extend2.extend)({}, _bar_series.polar.bar, baseStackedSeries, {
  _updateOptions: function (options) {
    baseStackedSeries._updateOptions.call(this, options);
    this._stackName = this._stackName + '_stack_' + (options.stack || 'default');
  }
});

/***/ }),

/***/ 43759:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _sparkline = _interopRequireDefault(__webpack_require__(51876));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _sparkline.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 55628:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _extend2 = __webpack_require__(13306);
var _index = __webpack_require__(39611);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _utils = __webpack_require__(19157);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _translator2d = __webpack_require__(87276);
var _common = __webpack_require__(20576);
var _tooltip = __webpack_require__(14371);
var _export = __webpack_require__(82454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LINE_SPACING = 2;
const TOOLTIP_TABLE_BORDER_SPACING = 0;
const TOOLTIP_TABLE_KEY_VALUE_SPACE = 15;
const EVENT_NS = 'sparkline-tooltip';
const POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
const _extend = _extend2.extend;
const _floor = Math.floor;
function inCanvas(_ref, x, y) {
  let {
    width,
    height
  } = _ref;
  return (0, _utils.pointInCanvas)({
    left: 0,
    top: 0,
    right: width,
    bottom: height,
    width,
    height
  }, x, y);
}
function pointerHandler(_ref2) {
  let {
    data
  } = _ref2;
  const that = data.widget;
  that._enableOutHandler();
  that._showTooltip();
}
function getDefaultTemplate(_ref3, textAlign) {
  let {
    lineSpacing,
    size
  } = _ref3;
  const lineHeight = `${(lineSpacing ?? DEFAULT_LINE_SPACING) + size}px`;
  return function (_ref4, container) {
    let {
      valueText
    } = _ref4;
    const table = (0, _renderer.default)('<table>').css({
      borderSpacing: TOOLTIP_TABLE_BORDER_SPACING,
      lineHeight
    });
    for (let i = 0; i < valueText.length; i += 2) {
      const tr = (0, _renderer.default)('<tr>');
      (0, _renderer.default)('<td>').text(valueText[i]).appendTo(tr);
      (0, _renderer.default)('<td>').css({
        width: TOOLTIP_TABLE_KEY_VALUE_SPACE
      }).appendTo(tr);
      (0, _renderer.default)('<td>').css({
        textAlign
      }).text(valueText[i + 1]).appendTo(tr);
      table.append(tr);
    }
    container.append(table);
  };
}
function createAxis(isHorizontal) {
  const translator = new _translator2d.Translator2D({}, {}, {
    shiftZeroValue: !isHorizontal,
    isHorizontal: !!isHorizontal
  });
  return {
    getTranslator: function () {
      return translator;
    },
    update: function (range, canvas, options) {
      translator.update(range, canvas, options);
    },
    getVisibleArea() {
      const visibleArea = translator.getCanvasVisibleArea();
      return [visibleArea.min, visibleArea.max];
    },
    visualRange: _common.noop,
    calculateInterval: _common.noop,
    getMarginOptions() {
      return {};
    },
    aggregatedPointBetweenTicks() {
      return false;
    }
  };
}

/* eslint-disable-next-line */
let _initTooltip;
const BaseSparkline = _m_base_widget.default.inherit({
  _getLayoutItems: _common.noop,
  _useLinks: false,
  _themeDependentChanges: ['OPTIONS'],
  _initCore: function () {
    const that = this;
    that._tooltipTracker = that._renderer.root;
    that._tooltipTracker.attr({
      'pointer-events': 'visible'
    });
    that._createHtmlElements();
    that._initTooltipEvents();
    that._argumentAxis = createAxis(true);
    that._valueAxis = createAxis();
  },
  _getDefaultSize: function () {
    return this._defaultSize;
  },
  _disposeCore: function () {
    this._disposeWidgetElements();
    this._disposeTooltipEvents();
    this._ranges = null;
  },
  _optionChangesOrder: ['OPTIONS'],
  _change_OPTIONS: function () {
    this._prepareOptions();
    this._change(['UPDATE']);
  },
  _customChangesOrder: ['UPDATE'],
  _change_UPDATE: function () {
    this._update();
  },
  _update: function () {
    const that = this;
    if (that._tooltipShown) {
      that._tooltipShown = false;
      that._tooltip.hide();
    }
    that._cleanWidgetElements();
    that._updateWidgetElements();
    that._drawWidgetElements();
  },
  _updateWidgetElements: function () {
    const canvas = this._getCorrectCanvas();
    this._updateRange();
    this._argumentAxis.update(this._ranges.arg, canvas, this._getStick());
    this._valueAxis.update(this._ranges.val, canvas);
  },
  _getStick: function () {},
  _applySize: function (rect) {
    this._allOptions.size = {
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };
    this._change(['UPDATE']);
  },
  _setupResizeHandler: _common.noop,
  _prepareOptions: function () {
    return _extend(true, {}, this._themeManager.theme(), this.option());
  },
  _getTooltipCoords: function () {
    const canvas = this._canvas;
    const rootOffset = this._renderer.getRootOffset();
    return {
      x: canvas.width / 2 + rootOffset.left,
      y: canvas.height / 2 + rootOffset.top
    };
  },
  _initTooltipEvents() {
    const data = {
      widget: this
    };
    this._renderer.root.off('.' + EVENT_NS).on(POINTER_ACTION, data, pointerHandler);
  },
  _showTooltip() {
    const that = this;
    let tooltip;
    if (!that._tooltipShown) {
      that._tooltipShown = true;
      tooltip = that._getTooltip();
      tooltip.isEnabled() && that._tooltip.show(that._getTooltipData(), that._getTooltipCoords(), {});
    }
  },
  _hideTooltip() {
    if (this._tooltipShown) {
      this._tooltipShown = false;
      this._tooltip.hide();
    }
  },
  _stopCurrentHandling() {
    this._hideTooltip();
  },
  _enableOutHandler() {
    const that = this;
    if (that._outHandler) {
      return;
    }
    const handler = _ref5 => {
      let {
        pageX,
        pageY
      } = _ref5;
      const {
        left,
        top
      } = that._renderer.getRootOffset();
      const x = _floor(pageX - left);
      const y = _floor(pageY - top);
      if (!inCanvas(that._canvas, x, y)) {
        that._hideTooltip();
        that._disableOutHandler();
      }
    };
    _events_engine.default.on(_dom_adapter.default.getDocument(), POINTER_ACTION, handler);
    this._outHandler = handler;
  },
  _disableOutHandler() {
    this._outHandler && _events_engine.default.off(_dom_adapter.default.getDocument(), POINTER_ACTION, this._outHandler);
    this._outHandler = null;
  },
  _disposeTooltipEvents: function () {
    this._tooltipTracker.off();
    this._disableOutHandler();
    this._renderer.root.off('.' + EVENT_NS);
  },
  _getTooltip: function () {
    const that = this;
    if (!that._tooltip) {
      _initTooltip.apply(this, arguments);
      that._setTooltipRendererOptions(that._tooltipRendererOptions);
      that._tooltipRendererOptions = null;
      that._setTooltipOptions();
    }
    return that._tooltip;
  }
});
var _default = exports["default"] = BaseSparkline; // PLUGINS_SECTION
BaseSparkline.addPlugin(_tooltip.plugin);

// These are sparklines specifics on using tooltip - they cannot be omitted because of tooltip laziness.
_initTooltip = BaseSparkline.prototype._initTooltip;
BaseSparkline.prototype._initTooltip = _common.noop;
const _disposeTooltip = BaseSparkline.prototype._disposeTooltip;
BaseSparkline.prototype._disposeTooltip = function () {
  if (this._tooltip) {
    _disposeTooltip.apply(this, arguments);
  }
};
BaseSparkline.prototype._setTooltipRendererOptions = function () {
  const options = this._getRendererOptions();
  if (this._tooltip) {
    this._tooltip.setRendererOptions(options);
  } else {
    this._tooltipRendererOptions = options;
  }
};
BaseSparkline.prototype._setTooltipOptions = function () {
  if (this._tooltip) {
    const options = this._getOption('tooltip');
    const defaultContentTemplate = this._getDefaultTooltipTemplate(options);
    const contentTemplateOptions = defaultContentTemplate ? {
      contentTemplate: defaultContentTemplate
    } : {};
    const optionsToUpdate = _extend(contentTemplateOptions, options, {
      enabled: options.enabled && this._isTooltipEnabled()
    });
    this._tooltip.update(optionsToUpdate);
  }
};
BaseSparkline.prototype._getDefaultTooltipTemplate = function (options) {
  let defaultTemplateNeeded = true;
  const textAlign = this.option('rtlEnabled') ? 'left' : 'right';
  if ((0, _type.isFunction)(options.customizeTooltip)) {
    this._tooltip.update(options);
    const formatObject = this._getTooltipData();
    const customizeResult = options.customizeTooltip.call(formatObject, formatObject) ?? {};
    defaultTemplateNeeded = !('html' in customizeResult) && !('text' in customizeResult);
  }
  return defaultTemplateNeeded && getDefaultTemplate(options.font, textAlign);
};

// PLUGINS_SECTION
// T422022

const exportPlugin = (0, _extend2.extend)(true, {}, _export.plugin, {
  init: _common.noop,
  dispose: _common.noop,
  customize: null,
  members: {
    _getExportMenuOptions: null
  }
});
BaseSparkline.addPlugin(exportPlugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 59989:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _base_sparkline = _interopRequireDefault(__webpack_require__(55628));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TARGET_MIN_Y = 0.02;
const TARGET_MAX_Y = 0.98;
const BAR_VALUE_MIN_Y = 0.1;
const BAR_VALUE_MAX_Y = 0.9;
const DEFAULT_CANVAS_WIDTH = 300;
const DEFAULT_CANVAS_HEIGHT = 30;
const DEFAULT_HORIZONTAL_MARGIN = 1;
const DEFAULT_VERTICAL_MARGIN = 2;
const _Number = Number;
const _isFinite = isFinite;
const dxBullet = _base_sparkline.default.inherit({
  _rootClassPrefix: 'dxb',
  _rootClass: 'dxb-bullet',
  _themeSection: 'bullet',
  _defaultSize: {
    width: DEFAULT_CANVAS_WIDTH,
    height: DEFAULT_CANVAS_HEIGHT,
    left: DEFAULT_HORIZONTAL_MARGIN,
    right: DEFAULT_HORIZONTAL_MARGIN,
    top: DEFAULT_VERTICAL_MARGIN,
    bottom: DEFAULT_VERTICAL_MARGIN
  },
  _disposeWidgetElements: function () {
    delete this._zeroLevelPath;
    delete this._targetPath;
    delete this._barValuePath;
  },
  _cleanWidgetElements: function () {
    this._zeroLevelPath.remove();
    this._targetPath.remove();
    this._barValuePath.remove();
  },
  _drawWidgetElements: function () {
    this._drawBullet();
    this._drawn();
  },
  _createHtmlElements: function () {
    const renderer = this._renderer;
    this._zeroLevelPath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-zero-level',
      'stroke-linecap': 'square'
    });
    this._targetPath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-target',
      'stroke-linecap': 'square'
    });
    this._barValuePath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-bar-value',
      'stroke-linecap': 'square'
    });
  },
  _prepareOptions: function () {
    const that = this;
    let options;
    let startScaleValue;
    let endScaleValue;
    let level;
    let value;
    let target;
    that._allOptions = options = that.callBase();
    const isValueUndefined = that._allOptions.value === undefined;
    const isTargetUndefined = that._allOptions.target === undefined;
    that._tooltipEnabled = !(isValueUndefined && isTargetUndefined);
    if (isValueUndefined) {
      that._allOptions.value = 0;
    }
    if (isTargetUndefined) {
      that._allOptions.target = 0;
    }
    options.value = value = _Number(options.value);
    options.target = target = _Number(options.target);
    if (that._allOptions.startScaleValue === undefined) {
      that._allOptions.startScaleValue = target < value ? target : value;
      that._allOptions.startScaleValue = that._allOptions.startScaleValue < 0 ? that._allOptions.startScaleValue : 0;
    }
    if (that._allOptions.endScaleValue === undefined) {
      that._allOptions.endScaleValue = target > value ? target : value;
    }
    options.startScaleValue = startScaleValue = _Number(options.startScaleValue);
    options.endScaleValue = endScaleValue = _Number(options.endScaleValue);
    if (endScaleValue < startScaleValue) {
      level = endScaleValue;
      that._allOptions.endScaleValue = startScaleValue;
      that._allOptions.startScaleValue = level;
      that._allOptions.inverted = true;
    }
  },
  _updateRange: function () {
    const that = this;
    const options = that._allOptions;
    that._ranges = {
      arg: {
        invert: options.rtlEnabled ? !options.inverted : options.inverted,
        min: options.startScaleValue,
        max: options.endScaleValue,
        axisType: 'continuous',
        dataType: 'numeric'
      },
      val: {
        min: 0,
        max: 1,
        axisType: 'continuous',
        dataType: 'numeric'
      }
    };
  },
  _drawBullet: function () {
    const that = this;
    const options = that._allOptions;
    const isValidBounds = options.startScaleValue !== options.endScaleValue;
    const isValidMin = _isFinite(options.startScaleValue);
    const isValidMax = _isFinite(options.endScaleValue);
    const isValidValue = _isFinite(options.value);
    const isValidTarget = _isFinite(options.target);
    if (isValidBounds && isValidMax && isValidMin && isValidTarget && isValidValue) {
      this._drawBarValue();
      this._drawTarget();
      this._drawZeroLevel();
    }
  },
  _getTargetParams: function () {
    const that = this;
    const options = that._allOptions;
    const translatorY = that._valueAxis.getTranslator();
    const x = that._argumentAxis.getTranslator().translate(options.target);
    return {
      points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
      stroke: options.targetColor,
      'stroke-width': options.targetWidth
    };
  },
  _getBarValueParams: function () {
    const that = this;
    const options = that._allOptions;
    const translatorX = that._argumentAxis.getTranslator();
    const translatorY = that._valueAxis.getTranslator();
    const startLevel = options.startScaleValue;
    const endLevel = options.endScaleValue;
    const value = options.value;
    const y2 = translatorY.translate(BAR_VALUE_MIN_Y);
    const y1 = translatorY.translate(BAR_VALUE_MAX_Y);
    let x1;
    let x2;
    if (value > 0) {
      x1 = startLevel <= 0 ? 0 : startLevel;
      x2 = value >= endLevel ? endLevel : value < x1 ? x1 : value;
    } else {
      x1 = endLevel >= 0 ? 0 : endLevel;
      x2 = value < startLevel ? startLevel : value > x1 ? x1 : value;
    }
    x1 = translatorX.translate(x1);
    x2 = translatorX.translate(x2);
    return {
      points: [x1, y1, x2, y1, x2, y2, x1, y2],
      fill: options.color
    };
  },
  _getCorrectCanvas: function () {
    return this._canvas;
  },
  _getZeroLevelParams: function () {
    const that = this;
    const translatorY = that._valueAxis.getTranslator();
    const x = that._argumentAxis.getTranslator().translate(0);
    return {
      points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
      stroke: that._allOptions.targetColor,
      'stroke-width': 1
    };
  },
  _drawZeroLevel: function () {
    const that = this;
    const options = that._allOptions;
    if (0 > options.endScaleValue || 0 < options.startScaleValue || !options.showZeroLevel) {
      return;
    }
    that._zeroLevelPath.attr(that._getZeroLevelParams()).sharp().append(that._renderer.root);
  },
  _drawTarget: function () {
    const that = this;
    const options = that._allOptions;
    const target = options.target;
    if (target > options.endScaleValue || target < options.startScaleValue || !options.showTarget) {
      return;
    }
    that._targetPath.attr(that._getTargetParams()).sharp().append(that._renderer.root);
  },
  _drawBarValue: function () {
    this._barValuePath.attr(this._getBarValueParams()).append(this._renderer.root);
  },
  _getTooltipCoords: function () {
    const canvas = this._canvas;
    const rootOffset = this._renderer.getRootOffset();
    const bBox = this._barValuePath.getBBox();
    return {
      x: bBox.x + bBox.width / 2 + rootOffset.left,
      y: canvas.height / 2 + rootOffset.top
    };
  },
  _getTooltipData: function () {
    const that = this;
    const tooltip = that._tooltip;
    const options = that._allOptions;
    const value = options.value;
    const target = options.target;
    const valueText = tooltip.formatValue(value);
    const targetText = tooltip.formatValue(target);
    return {
      originalValue: value,
      originalTarget: target,
      value: valueText,
      target: targetText,
      valueText: ['Actual Value:', valueText, 'Target Value:', targetText]
    };
  },
  _isTooltipEnabled: function () {
    return this._tooltipEnabled;
  }
});
(0, _iterator.each)(['color', 'targetColor', 'targetWidth', 'showTarget', 'showZeroLevel', 'value', 'target', 'startScaleValue', 'endScaleValue'], function (_, name) {
  dxBullet.prototype._optionChangesMap[name] = 'OPTIONS';
});
(0, _component_registrator.default)('dxBullet', dxBullet);
var _default = exports["default"] = dxBullet;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 51876:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _base_sparkline = _interopRequireDefault(__webpack_require__(55628));
var _data_validator = __webpack_require__(45865);
var _base_series = __webpack_require__(54932);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const MIN_BAR_WIDTH = 1;
const MAX_BAR_WIDTH = 50;
const DEFAULT_BAR_INTERVAL = 4;
const DEFAULT_CANVAS_WIDTH = 250;
const DEFAULT_CANVAS_HEIGHT = 30;
const DEFAULT_POINT_BORDER = 2;
const ALLOWED_TYPES = {
  'line': true,
  'spline': true,
  'stepline': true,
  'area': true,
  'steparea': true,
  'splinearea': true,
  'bar': true,
  'winloss': true
};
const _math = Math;
const _abs = _math.abs;
const _round = _math.round;
const _max = _math.max;
const _min = _math.min;
const _isFinite = isFinite;
const _Number = Number;
const _String = String;
function findMinMax(data, valField) {
  const firstItem = data[0] || {};
  const firstValue = firstItem[valField] || 0;
  let min = firstValue;
  let max = firstValue;
  let minIndexes = [0];
  let maxIndexes = [0];
  const dataLength = data.length;
  let value;
  let i;
  for (i = 1; i < dataLength; i++) {
    value = data[i][valField];
    if (value < min) {
      min = value;
      minIndexes = [i];
    } else if (value === min) {
      minIndexes.push(i);
    }
    if (value > max) {
      max = value;
      maxIndexes = [i];
    } else if (value === max) {
      maxIndexes.push(i);
    }
  }
  if (max === min) {
    minIndexes = maxIndexes = [];
  }
  return {
    minIndexes,
    maxIndexes
  };
}
function parseNumericDataSource(data, argField, valField, ignoreEmptyPoints) {
  return (0, _utils.map)(data, function (dataItem, index) {
    let item = null;
    let isDataNumber;
    let value;
    if (dataItem !== undefined) {
      item = {};
      isDataNumber = _isFinite(dataItem);
      item[argField] = isDataNumber ? _String(index) : dataItem[argField];
      value = isDataNumber ? dataItem : dataItem[valField];
      item[valField] = value === null ? ignoreEmptyPoints ? undefined : value : _Number(value);
      item = item[argField] !== undefined && item[valField] !== undefined ? item : null;
    }
    return item;
  });
}
function parseWinlossDataSource(data, argField, valField, target) {
  const lowBarValue = -1;
  const zeroBarValue = 0;
  const highBarValue = 1;
  const delta = 0.0001;
  return (0, _utils.map)(data, function (dataItem) {
    const item = {};
    item[argField] = dataItem[argField];
    if (_abs(dataItem[valField] - target) < delta) {
      item[valField] = zeroBarValue;
    } else if (dataItem[valField] > target) {
      item[valField] = highBarValue;
    } else {
      item[valField] = lowBarValue;
    }
    return item;
  });
}
function selectPointColor(color, options, index, pointIndexes) {
  if (index === pointIndexes.first || index === pointIndexes.last) {
    color = options.firstLastColor;
  }
  if ((pointIndexes.min || []).indexOf(index) >= 0) {
    color = options.minColor;
  }
  if ((pointIndexes.max || []).indexOf(index) >= 0) {
    color = options.maxColor;
  }
  return color;
}
function createLineCustomizeFunction(pointIndexes, options) {
  return function () {
    const color = selectPointColor(undefined, options, this.index, pointIndexes);
    return color ? {
      visible: true,
      border: {
        color: color
      }
    } : {};
  };
}
function createBarCustomizeFunction(pointIndexes, options, winlossData) {
  return function () {
    const index = this.index;
    const isWinloss = options.type === 'winloss';
    const target = isWinloss ? options.winlossThreshold : 0;
    const value = isWinloss ? winlossData[index][options.valueField] : this.value;
    const positiveColor = isWinloss ? options.winColor : options.barPositiveColor;
    const negativeColor = isWinloss ? options.lossColor : options.barNegativeColor;
    return {
      color: selectPointColor(value >= target ? positiveColor : negativeColor, options, index, pointIndexes)
    };
  };
}
const dxSparkline = _base_sparkline.default.inherit({
  _rootClassPrefix: 'dxsl',
  _rootClass: 'dxsl-sparkline',
  _themeSection: 'sparkline',
  _defaultSize: {
    width: DEFAULT_CANVAS_WIDTH,
    height: DEFAULT_CANVAS_HEIGHT
  },
  _initCore: function () {
    this.callBase();
    this._createSeries();
  },
  _initialChanges: ['DATA_SOURCE'],
  _dataSourceChangedHandler: function () {
    this._requestChange(['UPDATE']);
  },
  _updateWidgetElements: function () {
    this._updateSeries();
    this.callBase();
  },
  _disposeWidgetElements: function () {
    const that = this;
    that._series && that._series.dispose();
    that._series = that._seriesGroup = that._seriesLabelGroup = null;
  },
  _cleanWidgetElements: function () {
    this._seriesGroup.remove();
    this._seriesLabelGroup.remove();
    this._seriesGroup.clear();
    this._seriesLabelGroup.clear();
    this._series.removeGraphicElements();
    this._series.removePointElements();
    this._series.removeBordersGroup();
  },
  _drawWidgetElements: function () {
    if (this._dataIsLoaded()) {
      this._drawSeries();
      this._drawn();
    }
  },
  _getCorrectCanvas: function () {
    const options = this._allOptions;
    const canvas = this._canvas;
    const halfPointSize = options.pointSize && Math.ceil(options.pointSize / 2) + DEFAULT_POINT_BORDER;
    const type = options.type;
    if (type !== 'bar' && type !== 'winloss' && (options.showFirstLast || options.showMinMax)) {
      return {
        width: canvas.width,
        height: canvas.height,
        left: canvas.left + halfPointSize,
        right: canvas.right + halfPointSize,
        top: canvas.top + halfPointSize,
        bottom: canvas.bottom + halfPointSize
      };
    }
    return canvas;
  },
  _prepareOptions: function () {
    const that = this;
    that._allOptions = that.callBase();
    that._allOptions.type = (0, _utils.normalizeEnum)(that._allOptions.type);
    if (!ALLOWED_TYPES[that._allOptions.type]) {
      that._allOptions.type = 'line';
    }
  },
  _createHtmlElements: function () {
    this._seriesGroup = this._renderer.g().attr({
      'class': 'dxsl-series'
    });
    this._seriesLabelGroup = this._renderer.g().attr({
      'class': 'dxsl-series-labels'
    });
  },
  _createSeries: function () {
    this._series = new _base_series.Series({
      renderer: this._renderer,
      seriesGroup: this._seriesGroup,
      labelsGroup: this._seriesLabelGroup,
      argumentAxis: this._argumentAxis,
      valueAxis: this._valueAxis,
      incidentOccurred: this._incidentOccurred
    }, {
      widgetType: 'chart',
      type: 'line'
    });
  },
  _updateSeries: function () {
    const that = this;
    const singleSeries = that._series;
    that._prepareDataSource();
    const seriesOptions = that._prepareSeriesOptions();
    singleSeries.updateOptions(seriesOptions);
    const groupsData = {
      groups: [{
        series: [singleSeries]
      }]
    };
    groupsData.argumentOptions = {
      type: seriesOptions.type === 'bar' ? 'discrete' : undefined
    };
    that._simpleDataSource = (0, _data_validator.validateData)(that._simpleDataSource, groupsData, that._incidentOccurred, {
      checkTypeForAllData: false,
      convertToAxisDataType: true,
      sortingMethod: true
    })[singleSeries.getArgumentField()];
    seriesOptions.customizePoint = that._getCustomizeFunction();
    singleSeries.updateData(that._simpleDataSource);
    singleSeries.createPoints();
    that._groupsDataCategories = groupsData.categories;
  },
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE'
  },
  _optionChangesOrder: ['DATA_SOURCE'],
  _change_DATA_SOURCE: function () {
    this._updateDataSource();
  },
  _prepareDataSource: function () {
    const that = this;
    const options = that._allOptions;
    const argField = options.argumentField;
    const valField = options.valueField;
    const dataSource = that._dataSourceItems() || [];
    const data = parseNumericDataSource(dataSource, argField, valField, that.option('ignoreEmptyPoints'));
    if (options.type === 'winloss') {
      that._winlossDataSource = data;
      that._simpleDataSource = parseWinlossDataSource(data, argField, valField, options.winlossThreshold);
    } else {
      that._simpleDataSource = data;
    }
  },
  _prepareSeriesOptions: function () {
    const that = this;
    const options = that._allOptions;
    const type = options.type === 'winloss' ? 'bar' : options.type;
    return {
      visible: true,
      argumentField: options.argumentField,
      valueField: options.valueField,
      color: options.lineColor,
      width: options.lineWidth,
      widgetType: 'chart',
      name: '',
      type: type,
      opacity: type.indexOf('area') !== -1 ? that._allOptions.areaOpacity : undefined,
      point: {
        size: options.pointSize,
        symbol: options.pointSymbol,
        border: {
          visible: true,
          width: DEFAULT_POINT_BORDER
        },
        color: options.pointColor,
        visible: false,
        hoverStyle: {
          border: {}
        },
        selectionStyle: {
          border: {}
        }
      },
      border: {
        color: options.lineColor,
        width: options.lineWidth,
        visible: type !== 'bar'
      }
    };
  },
  _getCustomizeFunction: function () {
    const that = this;
    const options = that._allOptions;
    const dataSource = that._winlossDataSource || that._simpleDataSource;
    const drawnPointIndexes = that._getExtremumPointsIndexes(dataSource);
    let customizeFunction;
    if (options.type === 'winloss' || options.type === 'bar') {
      customizeFunction = createBarCustomizeFunction(drawnPointIndexes, options, that._winlossDataSource);
    } else {
      customizeFunction = createLineCustomizeFunction(drawnPointIndexes, options);
    }
    return customizeFunction;
  },
  _getExtremumPointsIndexes: function (data) {
    const that = this;
    const options = that._allOptions;
    const lastIndex = data.length - 1;
    const indexes = {};
    that._minMaxIndexes = findMinMax(data, options.valueField);
    if (options.showFirstLast) {
      indexes.first = 0;
      indexes.last = lastIndex;
    }
    if (options.showMinMax) {
      indexes.min = that._minMaxIndexes.minIndexes;
      indexes.max = that._minMaxIndexes.maxIndexes;
    }
    return indexes;
  },
  _getStick: function () {
    return {
      stick: this._series.type !== 'bar'
    };
  },
  _updateRange: function () {
    const that = this;
    const series = that._series;
    const type = series.type;
    const isBarType = type === 'bar';
    const isWinlossType = type === 'winloss';
    const DEFAULT_VALUE_RANGE_MARGIN = 0.15;
    const DEFAULT_ARGUMENT_RANGE_MARGIN = 0.1;
    const WINLOSS_MAX_RANGE = 1;
    const WINLOSS_MIN_RANGE = -1;
    const rangeData = series.getRangeData();
    const minValue = that._allOptions.minValue;
    const hasMinY = (0, _type.isDefined)(minValue) && _isFinite(minValue);
    const maxValue = that._allOptions.maxValue;
    const hasMaxY = (0, _type.isDefined)(maxValue) && _isFinite(maxValue);
    let argCoef;
    const valCoef = (rangeData.val.max - rangeData.val.min) * DEFAULT_VALUE_RANGE_MARGIN;
    if (isBarType || isWinlossType || type === 'area') {
      if (rangeData.val.min !== 0) {
        rangeData.val.min -= valCoef;
      }
      if (rangeData.val.max !== 0) {
        rangeData.val.max += valCoef;
      }
    } else {
      rangeData.val.min -= valCoef;
      rangeData.val.max += valCoef;
    }
    if (hasMinY || hasMaxY) {
      if (hasMinY && hasMaxY) {
        rangeData.val.minVisible = _min(minValue, maxValue);
        rangeData.val.maxVisible = _max(minValue, maxValue);
      } else {
        rangeData.val.minVisible = hasMinY ? _Number(minValue) : undefined;
        rangeData.val.maxVisible = hasMaxY ? _Number(maxValue) : undefined;
      }
      if (isWinlossType) {
        rangeData.val.minVisible = hasMinY ? _max(rangeData.val.minVisible, WINLOSS_MIN_RANGE) : undefined;
        rangeData.val.maxVisible = hasMaxY ? _min(rangeData.val.maxVisible, WINLOSS_MAX_RANGE) : undefined;
      }
    }
    if (series.getPoints().length > 1) {
      if (isBarType) {
        argCoef = (rangeData.arg.max - rangeData.arg.min) * DEFAULT_ARGUMENT_RANGE_MARGIN;
        rangeData.arg.min = rangeData.arg.min - argCoef;
        rangeData.arg.max = rangeData.arg.max + argCoef;
      }
    }
    rangeData.arg.categories = that._groupsDataCategories;
    that._ranges = rangeData;
  },
  _getBarWidth: function (pointsCount) {
    const that = this;
    const canvas = that._canvas;
    const intervalWidth = pointsCount * DEFAULT_BAR_INTERVAL;
    const rangeWidth = canvas.width - canvas.left - canvas.right - intervalWidth;
    let width = _round(rangeWidth / pointsCount);
    if (width < MIN_BAR_WIDTH) {
      width = MIN_BAR_WIDTH;
    }
    if (width > MAX_BAR_WIDTH) {
      width = MAX_BAR_WIDTH;
    }
    return width;
  },
  _correctPoints: function () {
    const that = this;
    const seriesType = that._allOptions.type;
    const seriesPoints = that._series.getPoints();
    const pointsLength = seriesPoints.length;
    let barWidth;
    let i;
    if (seriesType === 'bar' || seriesType === 'winloss') {
      barWidth = that._getBarWidth(pointsLength);
      for (i = 0; i < pointsLength; i++) {
        seriesPoints[i].correctCoordinates({
          width: barWidth,
          offset: 0
        });
      }
    }
  },
  _drawSeries: function () {
    const that = this;
    if (that._simpleDataSource.length > 0) {
      that._correctPoints();
      that._series.draw();
      that._seriesGroup.append(that._renderer.root);
    }
  },
  _isTooltipEnabled: function () {
    return !!this._simpleDataSource.length;
  },
  _getTooltipData: function () {
    const that = this;
    const options = that._allOptions;
    const dataSource = that._winlossDataSource || that._simpleDataSource;
    const tooltip = that._tooltip;
    if (dataSource.length === 0) {
      return {};
    }
    const minMax = that._minMaxIndexes;
    const valueField = options.valueField;
    const first = dataSource[0][valueField];
    const last = dataSource[dataSource.length - 1][valueField];
    const min = (0, _type.isDefined)(minMax.minIndexes[0]) ? dataSource[minMax.minIndexes[0]][valueField] : first;
    const max = (0, _type.isDefined)(minMax.maxIndexes[0]) ? dataSource[minMax.maxIndexes[0]][valueField] : first;
    const formattedFirst = tooltip.formatValue(first);
    const formattedLast = tooltip.formatValue(last);
    const formattedMin = tooltip.formatValue(min);
    const formattedMax = tooltip.formatValue(max);
    const customizeObject = {
      firstValue: formattedFirst,
      lastValue: formattedLast,
      minValue: formattedMin,
      maxValue: formattedMax,
      originalFirstValue: first,
      originalLastValue: last,
      originalMinValue: min,
      originalMaxValue: max,
      valueText: ['Start:', formattedFirst, 'End:', formattedLast, 'Min:', formattedMin, 'Max:', formattedMax]
    };
    if (options.type === 'winloss') {
      customizeObject.originalThresholdValue = options.winlossThreshold;
      customizeObject.thresholdValue = tooltip.formatValue(options.winlossThreshold);
    }
    return customizeObject;
  }
});
(0, _utils.map)(['lossColor', 'lineColor', 'lineWidth', 'areaOpacity', 'minColor', 'maxColor', 'barPositiveColor', 'barNegativeColor', 'winColor', 'lessColor', 'firstLastColor', 'pointSymbol', 'pointColor', 'pointSize', 'type', 'argumentField', 'valueField', 'winlossThreshold', 'showFirstLast', 'showMinMax', 'ignoreEmptyPoints', 'minValue', 'maxValue'], function (name) {
  dxSparkline.prototype._optionChangesMap[name] = 'OPTIONS';
});
(0, _component_registrator.default)('dxSparkline', dxSparkline);
var _default = exports["default"] = dxSparkline; // PLUGINS_SECTION
dxSparkline.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 86231:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addCacheItem = addCacheItem;
exports.currentTheme = currentTheme;
exports.getTheme = getTheme;
exports.refreshTheme = refreshTheme;
exports.registerTheme = registerTheme;
exports.registerThemeSchemeAlias = registerThemeSchemeAlias;
exports.removeCacheItem = removeCacheItem;
var _extend2 = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _themes = __webpack_require__(75811);
var _type = __webpack_require__(35922);
var _index = _interopRequireDefault(__webpack_require__(13919));
var _carmine = _interopRequireDefault(__webpack_require__(85900));
var _dark = _interopRequireDefault(__webpack_require__(4691));
var _contrast = _interopRequireDefault(__webpack_require__(11269));
var _darkmoon = _interopRequireDefault(__webpack_require__(73932));
var _darkviolet = _interopRequireDefault(__webpack_require__(34893));
var _greenmist = _interopRequireDefault(__webpack_require__(50008));
var _softblue = _interopRequireDefault(__webpack_require__(93820));
var _index2 = _interopRequireDefault(__webpack_require__(88484));
var _index3 = _interopRequireDefault(__webpack_require__(32595));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const themes = {};
const themesMapping = {};
const themesSchemeMapping = {};
const _extend = _extend2.extend;
let currentThemeName = null;
let defaultTheme;
let nextCacheUid = 0;
const widgetsCache = {};
function getTheme(themeName) {
  const name = (0, _utils.normalizeEnum)(themeName);
  return themes[name] || themes[themesMapping[name] || currentTheme()];
}
function findThemeNameByName(name, scheme) {
  const fullThemeKey = `${name}.${scheme}`;
  return themesMapping[fullThemeKey] || themesSchemeMapping[fullThemeKey] || themesMapping[name];
}
function findThemeNameByPlatform(platform, version, scheme) {
  return findThemeNameByName(platform + version, scheme) || findThemeNameByName(platform, scheme);
}
function currentTheme(themeName, colorScheme) {
  if (!arguments.length) {
    return currentThemeName || findThemeNameByName((0, _themes.current)()) || defaultTheme;
  }
  const scheme = (0, _utils.normalizeEnum)(colorScheme);
  currentThemeName = (themeName !== null && themeName !== void 0 && themeName.platform ? findThemeNameByPlatform((0, _utils.normalizeEnum)(themeName.platform), themeName.version, scheme) : findThemeNameByName((0, _utils.normalizeEnum)(themeName), scheme)) || currentThemeName;
  // For chaining only
  return this;
}
function getThemeInfo(themeName, splitter) {
  const k = themeName.indexOf(splitter);
  return k > 0 ? {
    name: themeName.substring(0, k),
    scheme: themeName.substring(k + 1)
  } : null;
}
function registerThemeName(themeName, targetThemeName) {
  const themeInfo = getThemeInfo(themeName, '.') || {
    name: themeName
  };
  const name = themeInfo.name;
  const scheme = themeInfo.scheme;
  if (scheme) {
    const fullThemeKey = `${name}.${scheme}`;
    themesMapping[name] = themesMapping[name] || targetThemeName;
    themesMapping[fullThemeKey] = targetThemeName;
  } else {
    themesMapping[name] = targetThemeName;
  }
}
function registerTheme(theme, baseThemeName) {
  const themeName = (0, _utils.normalizeEnum)(theme && theme.name);
  if (themeName) {
    theme.isDefault && (defaultTheme = themeName);
    registerThemeName(themeName, themeName);
    themes[themeName] = _extend(true, {}, getTheme(baseThemeName), patchTheme(theme));
  }
}
function registerThemeSchemeAlias(from, to) {
  themesSchemeMapping[from] = to;
}
function mergeScalar(target, field, source, sourceValue) {
  const _value = (source === null || source === void 0 ? void 0 : source[field]) ?? sourceValue;
  if (_value !== undefined && target[field] === undefined) {
    target[field] = _value;
  }
}
function mergeObject(target, field, source, sourceValue) {
  const _value = (source === null || source === void 0 ? void 0 : source[field]) ?? sourceValue;
  if (_value !== undefined) {
    target[field] = _extend(true, {}, _value, target[field]);
  }
}

// TODO: Font initialization should be done here
function patchTheme(theme) {
  theme = _extend(true, {
    loadingIndicator: {
      font: {}
    },
    'export': {
      font: {}
    },
    legend: {
      font: {},
      border: {}
    },
    title: {
      font: {}
    },
    tooltip: {
      font: {}
    },
    'chart:common': {},
    'chart:common:axis': {
      grid: {},
      minorGrid: {},
      tick: {},
      minorTick: {},
      title: {
        font: {}
      },
      label: {
        font: {}
      }
    },
    'chart:common:annotation': {
      font: {},
      border: {}
    },
    chart: {
      commonSeriesSettings: {
        candlestick: {}
      }
    },
    pie: {},
    polar: {},
    gauge: {
      scale: {
        tick: {},
        minorTick: {},
        label: {
          font: {}
        }
      }
    },
    barGauge: {},
    funnel: {},
    sankey: {},
    map: {
      background: {}
    },
    treeMap: {
      tile: {
        selectionStyle: {
          border: {}
        }
      },
      group: {
        border: {},
        selectionStyle: {
          border: {}
        },
        label: {
          font: {}
        }
      }
    },
    rangeSelector: {
      scale: {
        tick: {},
        minorTick: {},
        label: {
          font: {}
        }
      },
      chart: {}
    },
    sparkline: {},
    bullet: {}
  }, theme);
  mergeScalar(theme.loadingIndicator, 'backgroundColor', theme);
  mergeScalar(theme.chart.commonSeriesSettings.candlestick, 'innerColor', null, theme.backgroundColor);
  mergeScalar(theme.map.background, 'color', null, theme.backgroundColor);
  mergeScalar(theme.title.font, 'color', null, theme.primaryTitleColor);
  mergeObject(theme.title, 'subtitle', null, theme.title);
  mergeScalar(theme.legend.font, 'color', null, theme.secondaryTitleColor);
  mergeScalar(theme.legend.border, 'color', null, theme.gridColor);
  patchAxes(theme);
  ['chart', 'pie', 'polar', 'gauge', 'barGauge', 'map', 'treeMap', 'funnel', 'rangeSelector', 'sparkline', 'bullet', 'sankey'].forEach(section => {
    mergeScalar(theme[section], 'redrawOnResize', theme);
    mergeScalar(theme[section], 'containerBackgroundColor', null, theme.backgroundColor);
    mergeObject(theme[section], 'tooltip', theme);
    mergeObject(theme[section], 'export', theme);
  });
  ['chart', 'pie', 'polar', 'gauge', 'barGauge', 'map', 'treeMap', 'funnel', 'rangeSelector', 'sankey'].forEach(section => {
    mergeObject(theme[section], 'loadingIndicator', theme);
    mergeObject(theme[section], 'legend', theme);
    mergeObject(theme[section], 'title', theme);
  });
  ['chart', 'pie', 'polar'].forEach(section => {
    mergeObject(theme, section, null, theme['chart:common']);
  });
  ['chart', 'polar'].forEach(section => {
    theme[section] = theme[section] || {};
    mergeObject(theme[section], 'commonAxisSettings', null, theme['chart:common:axis']);
  });
  ['chart', 'polar', 'map', 'pie'].forEach(section => {
    theme[section] = theme[section] || {};
    mergeObject(theme[section], 'commonAnnotationSettings', null, theme['chart:common:annotation']);
  });
  mergeObject(theme.rangeSelector.chart, 'commonSeriesSettings', theme.chart);
  mergeObject(theme.rangeSelector.chart, 'dataPrepareSettings', theme.chart);
  mergeScalar(theme.treeMap.group.border, 'color', null, theme.gridColor);
  mergeScalar(theme.treeMap.tile.selectionStyle.border, 'color', null, theme.primaryTitleColor);
  mergeScalar(theme.treeMap.group.selectionStyle.border, 'color', null, theme.primaryTitleColor);
  mergeScalar(theme.map.legend, 'backgroundColor', theme);
  patchMapLayers(theme);
  return theme;
}
function patchAxes(theme) {
  const commonAxisSettings = theme['chart:common:axis'];
  const colorFieldName = 'color';
  [commonAxisSettings.grid, commonAxisSettings.minorGrid].forEach(obj => {
    mergeScalar(obj, colorFieldName, null, theme.gridColor);
  });
  [commonAxisSettings, commonAxisSettings.tick, commonAxisSettings.minorTick, commonAxisSettings.label.font].forEach(obj => {
    mergeScalar(obj, colorFieldName, null, theme.axisColor);
  });
  mergeScalar(commonAxisSettings.title.font, colorFieldName, null, theme.secondaryTitleColor);
  mergeScalar(theme.gauge.scale.label.font, colorFieldName, null, theme.axisColor);
  mergeScalar(theme.gauge.scale.tick, colorFieldName, null, theme.backgroundColor);
  mergeScalar(theme.gauge.scale.minorTick, colorFieldName, null, theme.backgroundColor);
  mergeScalar(theme.rangeSelector.scale.label.font, colorFieldName, null, theme.axisColor);
}
function patchMapLayers(theme) {
  const map = theme.map;
  ['area', 'line', 'marker'].forEach(section => {
    mergeObject(map, 'layer:' + section, null, map.layer);
  });
  ['dot', 'bubble', 'pie', 'image'].forEach(section => {
    mergeObject(map, 'layer:marker:' + section, null, map['layer:marker']);
  });
}
function addCacheItem(target) {
  const cacheUid = ++nextCacheUid;
  target._cache = cacheUid;
  widgetsCache[cacheUid] = target;
}
function removeCacheItem(target) {
  delete widgetsCache[target._cache];
}
function refreshTheme() {
  Object.keys(widgetsCache).forEach(key => {
    widgetsCache[key].refresh();
  });
  // For chaining only
  return this;
}

// register themes
if ((0, _type.isEmptyObject)(themes) && (0, _type.isEmptyObject)(themesMapping) && !defaultTheme) {
  [].concat(_index.default, _carmine.default, _dark.default, _contrast.default, _darkmoon.default, _darkviolet.default, _greenmist.default, _softblue.default, _index2.default, _index3.default).forEach(t => {
    registerTheme(t.theme, t.baseThemeName);
  });
}

/***/ }),

/***/ 46163:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
const round = Math.round;
function getValue(value) {
  return value;
}
var _default = exports["default"] = {
  translate: function (category, directionOffset) {
    const that = this;
    const canvasOptions = that._canvasOptions;
    const categoryIndex = that._categoriesToPoints[category === null || category === void 0 ? void 0 : category.valueOf()];
    const specialValue = that.translateSpecialCase(category);
    const startPointIndex = canvasOptions.startPointIndex || 0;
    const stickInterval = that._options.stick ? 0 : 0.5;
    if ((0, _type.isDefined)(specialValue)) {
      return round(specialValue);
    }

    // Q522516
    if (!categoryIndex && categoryIndex !== 0) {
      return null;
    }
    directionOffset = directionOffset || 0;
    const stickDelta = categoryIndex + stickInterval - startPointIndex + directionOffset * 0.5;
    return round(that._calculateProjection(canvasOptions.interval * stickDelta));
  },
  getInterval: function () {
    return this._canvasOptions.interval;
  },
  getEventScale: function (zoomEvent) {
    const scale = zoomEvent.deltaScale || 1;
    return 1 - (1 - scale) / (0.75 + this.visibleCategories.length / this._categories.length);
  },
  zoom: function (translate, scale) {
    const that = this;
    const categories = that._categories;
    const canvasOptions = that._canvasOptions;
    const stick = that._options.stick;
    const invert = canvasOptions.invert;
    const interval = canvasOptions.interval * scale;
    const translateCategories = translate / interval;
    const visibleCount = (that.visibleCategories || []).length;
    let startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + 0.5);
    const categoriesLength = parseInt((0, _math.adjust)(canvasOptions.canvasLength / interval) + (stick ? 1 : 0)) || 1;
    let endCategoryIndex;
    if (invert) {
      startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + visibleCount - translateCategories + 0.5) - categoriesLength;
    }
    if (startCategoryIndex < 0) {
      startCategoryIndex = 0;
    }
    endCategoryIndex = startCategoryIndex + categoriesLength;
    if (endCategoryIndex > categories.length) {
      endCategoryIndex = categories.length;
      startCategoryIndex = endCategoryIndex - categoriesLength;
      if (startCategoryIndex < 0) {
        startCategoryIndex = 0;
      }
    }
    const newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));
    const newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);
    scale = newInterval / canvasOptions.interval;
    translate = that.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));
    return {
      min: newVisibleCategories[0],
      max: newVisibleCategories[newVisibleCategories.length - 1],
      translate: translate,
      scale: scale
    };
  },
  getMinScale: function (zoom) {
    const that = this;
    const canvasOptions = that._canvasOptions;
    let categoriesLength = (that.visibleCategories || that._categories).length;
    categoriesLength += (parseInt(categoriesLength * 0.1) || 1) * (zoom ? -2 : 2);
    return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval);
  },
  getScale: function (min, max) {
    const that = this;
    const canvasOptions = that._canvasOptions;
    const visibleArea = that.getCanvasVisibleArea();
    const stickOffset = !that._options.stick && 1;
    let minPoint = (0, _type.isDefined)(min) ? that.translate(min, -stickOffset) : null;
    let maxPoint = (0, _type.isDefined)(max) ? that.translate(max, +stickOffset) : null;
    if (minPoint === null) {
      minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min;
    }
    if (maxPoint === null) {
      maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max;
    }
    return that.canvasLength / Math.abs(maxPoint - minPoint);
  },
  // dxRangeSelector

  isValid: function (value) {
    return (0, _type.isDefined)(value) ? this._categoriesToPoints[value.valueOf()] >= 0 : false;
  },
  getCorrectValue: getValue,
  to: function (value, direction) {
    const canvasOptions = this._canvasOptions;
    const categoryIndex = this._categoriesToPoints[value === null || value === void 0 ? void 0 : value.valueOf()];
    const startPointIndex = canvasOptions.startPointIndex || 0;
    const stickDelta = categoryIndex + (this._options.stick ? 0 : 0.5) - startPointIndex + (this._businessRange.invert ? -1 : +1) * direction * 0.5;
    return round(this._calculateProjection(canvasOptions.interval * stickDelta));
  },
  from: function (position) {
    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const canvasOptions = this._canvasOptions;
    const startPoint = canvasOptions.startPoint;
    const categories = this.visibleCategories || this._categories;
    const categoriesLength = categories.length;
    const stickInterval = this._options.stick ? 0.5 : 0;
    // It is strange - while "businessRange.invert" check is required in "to" here it is not.
    // Check that translator.from(translator.to(x, -1), -1) equals x.
    // And check that translator.untranslate(translator.translate(x, -1), -1) does not equal x - is it really supposed to be so?
    let result = round((position - startPoint) / canvasOptions.interval + stickInterval - 0.5 - /* (businessRange.invert ? -1 : +1) * */direction * 0.5);
    if (result >= categoriesLength) {
      result = categoriesLength - 1;
    }
    if (result < 0) {
      result = 0;
    }
    if (canvasOptions.invert) {
      result = categoriesLength - result - 1;
    }
    return categories[result];
  },
  _add: function () {
    return NaN;
  },
  toValue: getValue,
  isValueProlonged: true,
  getRangeByMinZoomValue(minZoom, visualRange) {
    const categories = this._categories;
    const minVisibleIndex = categories.indexOf(visualRange.minVisible);
    const maxVisibleIndex = categories.indexOf(visualRange.maxVisible);
    const startIndex = minVisibleIndex + minZoom - 1;
    const endIndex = maxVisibleIndex - minZoom + 1;
    if (categories[startIndex]) {
      return [visualRange.minVisible, categories[startIndex]];
    } else {
      return [categories[endIndex], visualRange.maxVisible];
    }
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 75480:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function parse(value) {
  return value !== null ? new Date(value) : value;
}
var _default = exports["default"] = {
  fromValue: parse,
  toValue: parse,
  _add: _date.default.addDateInterval,
  convert: _date.default.dateToMilliseconds
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 93175:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _math = __webpack_require__(60810);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const floor = Math.floor;
var _default = exports["default"] = {
  _intervalize: function (value, interval) {
    if (!(0, _type.isDefined)(value)) {
      return undefined;
    }
    if (this._businessRange.dataType === 'datetime') {
      if ((0, _type.isNumeric)(value)) {
        value = new Date(value);
      } else {
        value = new Date(value.getTime());
      }
      value = _date.default.correctDateWithUnitBeginning(value, interval, null, this._options.firstDayOfWeek);
    } else {
      value = (0, _math.adjust)(floor((0, _math.adjust)(value / interval)) * interval, interval);
    }
    return value;
  },
  translate: function (bp, direction, skipRound, interval) {
    const that = this;
    const specialValue = that.translateSpecialCase(bp);
    if ((0, _type.isDefined)(specialValue)) {
      return Math.round(specialValue);
    }
    interval = interval || that._options.interval;

    // TODO B253861
    if (!that.isValid(bp, interval)) {
      return null;
    }
    return that.to(bp, direction, skipRound, interval);
  },
  getInterval: function () {
    return Math.round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)));
  },
  zoom: function () {},
  getMinScale: function () {},
  getScale: function () {},
  _parse: function (value) {
    return this._businessRange.dataType === 'datetime' ? new Date(value) : Number(value);
  },
  fromValue: function (value) {
    return this._parse(value);
  },
  toValue: function (value) {
    return this._parse(value);
  },
  isValid: function (value, interval) {
    const that = this;
    const co = that._canvasOptions;
    let rangeMin = co.rangeMin;
    let rangeMax = co.rangeMax;
    interval = interval || that._options.interval;
    if (value === null || isNaN(value)) {
      return false;
    }
    value = that._businessRange.dataType === 'datetime' && (0, _type.isNumeric)(value) ? new Date(value) : value;
    if (interval !== that._options.interval) {
      rangeMin = that._intervalize(rangeMin, interval);
      rangeMax = that._intervalize(rangeMax, interval);
    }
    if (value.valueOf() < rangeMin || value.valueOf() >= _date.default.addInterval(rangeMax, interval)) {
      return false;
    }
    return true;
  },
  to: function (bp, direction, skipRound, interval) {
    const that = this;
    interval = interval || that._options.interval;
    const v1 = that._intervalize(bp, interval);
    const v2 = _date.default.addInterval(v1, interval);
    let res = that._to(v1, skipRound);
    const p2 = that._to(v2, skipRound);
    if (!direction) {
      res = floor((res + p2) / 2);
    } else if (direction > 0) {
      res = p2;
    }
    return res;
  },
  _to: function (value, skipRound) {
    const co = this._canvasOptions;
    const rMin = co.rangeMinVisible;
    const rMax = co.rangeMaxVisible;
    let offset = value - rMin;
    if (value < rMin) {
      offset = 0;
    } else if (value > rMax) {
      offset = _date.default.addInterval(rMax, this._options.interval) - rMin;
    }
    const projectedValue = this._calculateProjection(offset * this._canvasOptions.ratioOfCanvasRange);
    return this._conversionValue(projectedValue, skipRound);
  },
  from: function (position, direction) {
    const that = this;
    const origInterval = that._options.interval;
    let interval = origInterval;
    const co = that._canvasOptions;
    const rMin = co.rangeMinVisible;
    const rMax = co.rangeMaxVisible;
    let value;
    if (that._businessRange.dataType === 'datetime') {
      interval = _date.default.dateToMilliseconds(origInterval);
    }
    value = that._calculateUnProjection((position - that._canvasOptions.startPoint) / that._canvasOptions.ratioOfCanvasRange);
    value = that._intervalize(_date.default.addInterval(value, interval / 2, direction > 0), origInterval);
    if (value < rMin) {
      value = rMin;
    } else if (value > rMax) {
      value = rMax;
    }
    return value;
  },
  _add: function () {
    return NaN;
  },
  isValueProlonged: true
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 1804:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _default = exports["default"] = {
  fromValue: function (value) {
    return value !== null ? (0, _utils.getLogExt)(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value;
  },
  toValue: function (value) {
    return value !== null ? (0, _utils.raiseToExt)(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value;
  },
  getMinBarSize: function (minBarSize) {
    const visibleArea = this.getCanvasVisibleArea();
    const minValue = this.from(visibleArea.min + minBarSize);
    const canvasOptions = this._canvasOptions;
    const startValue = this.fromValue(this.from(visibleArea.min));
    const endValue = this.fromValue(minValue ?? this.from(visibleArea.max));
    const value = Math.abs(startValue - endValue);
    return Math.pow(canvasOptions.base, value);
  },
  checkMinBarSize: function (initialValue, minShownValue, stackValue) {
    const canvasOptions = this._canvasOptions;
    const prevValue = stackValue ? stackValue - initialValue : 0;
    const baseMethod = this.constructor.prototype.checkMinBarSize;
    let minBarSize;
    let updateValue;
    if ((0, _type.isDefined)(minShownValue) && prevValue > 0) {
      minBarSize = baseMethod(this.fromValue(stackValue / prevValue), this.fromValue(minShownValue) - canvasOptions.rangeMinVisible);
      updateValue = Math.pow(canvasOptions.base, this.fromValue(prevValue) + minBarSize) - prevValue;
    } else {
      updateValue = baseMethod(initialValue, minShownValue);
    }
    return updateValue;
  }
};
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 21177:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Range = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
const _isDefined = _type.isDefined;
const _isDate = _type.isDate;
const _isFunction = _type.isFunction;
const minSelector = 'min';
const maxSelector = 'max';
const minVisibleSelector = 'minVisible';
const maxVisibleSelector = 'maxVisible';
const baseSelector = 'base';
const axisTypeSelector = 'axisType';
function otherLessThan(thisValue, otherValue) {
  return otherValue < thisValue;
}
function otherGreaterThan(thisValue, otherValue) {
  return otherValue > thisValue;
}
function compareAndReplace(thisValue, otherValue, setValue, compare) {
  const otherValueDefined = _isDefined(otherValue);
  if (_isDefined(thisValue)) {
    if (otherValueDefined && compare(thisValue, otherValue)) {
      setValue(otherValue);
    }
  } else if (otherValueDefined) {
    setValue(otherValue);
  }
}
const Range = function (range) {
  range && (0, _extend.extend)(this, range);
};
exports.Range = Range;
const _Range = Range;
_Range.prototype = {
  constructor: _Range,
  addRange: function (otherRange) {
    const that = this;
    const categories = that.categories;
    const otherCategories = otherRange.categories;
    const isDiscrete = that[axisTypeSelector] === 'discrete';
    const compareAndReplaceByField = function (field, compare) {
      compareAndReplace(that[field], otherRange[field], function (value) {
        that[field] = value;
      }, compare);
    };
    const controlValuesByVisibleBounds = function (valueField, visibleValueField, compare) {
      compareAndReplace(that[valueField], that[visibleValueField], function (value) {
        _isDefined(that[valueField]) && (that[valueField] = value);
      }, compare);
    };
    const checkField = function (field) {
      that[field] = that[field] || otherRange[field];
    };
    checkField('invert');
    checkField('containsConstantLine');
    checkField(axisTypeSelector);
    checkField('dataType');
    checkField('isSpacedMargin');
    if (that[axisTypeSelector] === 'logarithmic') {
      checkField(baseSelector);
    } else {
      that[baseSelector] = undefined;
    }
    compareAndReplaceByField(minSelector, otherLessThan);
    compareAndReplaceByField(maxSelector, otherGreaterThan);
    if (isDiscrete) {
      checkField(minVisibleSelector);
      checkField(maxVisibleSelector);
    } else {
      compareAndReplaceByField(minVisibleSelector, otherLessThan);
      compareAndReplaceByField(maxVisibleSelector, otherGreaterThan);
    }
    compareAndReplaceByField('interval', otherLessThan);
    if (!isDiscrete) {
      controlValuesByVisibleBounds(minSelector, minVisibleSelector, otherLessThan);
      controlValuesByVisibleBounds(minSelector, maxVisibleSelector, otherLessThan);
      controlValuesByVisibleBounds(maxSelector, maxVisibleSelector, otherGreaterThan);
      controlValuesByVisibleBounds(maxSelector, minVisibleSelector, otherGreaterThan);
    }
    if (categories === undefined) {
      that.categories = otherCategories;
    } else {
      that.categories = otherCategories ? (0, _utils.unique)(categories.concat(otherCategories)) : categories;
    }
    if (that[axisTypeSelector] === 'logarithmic') {
      checkField('allowNegatives');
      compareAndReplaceByField('linearThreshold', otherLessThan);
    }
    return that;
  },
  isEmpty: function () {
    return (!_isDefined(this[minSelector]) || !_isDefined(this[maxSelector])) && (!this.categories || this.categories.length === 0);
  },
  correctValueZeroLevel: function () {
    const that = this;
    if (_isDate(that[maxSelector]) || _isDate(that[minSelector])) {
      return that;
    }
    function setZeroLevel(min, max) {
      that[min] < 0 && that[max] < 0 && (that[max] = 0);
      that[min] > 0 && that[max] > 0 && (that[min] = 0);
    }
    setZeroLevel(minSelector, maxSelector);
    setZeroLevel(minVisibleSelector, maxVisibleSelector);
    return that;
  },
  sortCategories(sort) {
    if (sort === false || !this.categories) {
      return;
    }
    if (Array.isArray(sort)) {
      const sortValues = sort.map(item => item.valueOf());
      const filteredSeriesCategories = this.categories.filter(item => sortValues.indexOf(item.valueOf()) === -1);
      this.categories = sort.concat(filteredSeriesCategories);
    } else {
      const notAFunction = !_isFunction(sort);
      if (notAFunction && this.dataType !== 'string') {
        sort = (a, b) => a.valueOf() - b.valueOf();
      } else if (notAFunction) {
        sort = false;
      }
      sort && this.categories.sort(sort);
    }
  }
};

/***/ }),

/***/ 17953:
/***/ (function(__unused_webpack_module, exports) {



exports.Translator1D = Translator1D;
const _Number = Number;
function Translator1D() {
  this.setDomain(arguments[0], arguments[1]).setCodomain(arguments[2], arguments[3]).setInverted(false);
}
Translator1D.prototype = {
  constructor: Translator1D,
  setDomain: function (domain1, domain2) {
    const that = this;
    that._domain1 = _Number(domain1);
    that._domain2 = _Number(domain2);
    that._domainDelta = that._domain2 - that._domain1;
    return that;
  },
  setCodomain: function (codomain1, codomain2) {
    const that = this;
    that._codomain1 = _Number(codomain1);
    that._codomain2 = _Number(codomain2);
    that._codomainDelta = that._codomain2 - that._codomain1;
    return that;
  },
  setInverted(state) {
    this.inverted = state;
  },
  getDomain: function () {
    return [this._domain1, this._domain2];
  },
  getCodomain: function () {
    return [this._codomain1, this._codomain2];
  },
  getDomainStart: function () {
    return this._domain1;
  },
  getDomainEnd: function () {
    return this._domain2;
  },
  getCodomainStart: function () {
    return this._codomain1;
  },
  getCodomainEnd: function () {
    return this._codomain2;
  },
  getDomainRange: function () {
    return this._domainDelta;
  },
  getCodomainRange: function () {
    return this._codomainDelta;
  },
  translate: function (value) {
    let ratio = (_Number(value) - this._domain1) / this._domainDelta;
    this.inverted && (ratio = 1 - ratio);
    return 0 <= ratio && ratio <= 1 ? this._codomain1 + ratio * this._codomainDelta : NaN;
  },
  adjust: function (value) {
    const ratio = (_Number(value) - this._domain1) / this._domainDelta;
    let result = NaN;
    if (ratio < 0) {
      result = this._domain1;
    } else if (ratio > 1) {
      result = this._domain2;
    } else if (0 <= ratio && ratio <= 1) {
      result = _Number(value);
    }
    return result;
  }
};

/***/ }),

/***/ 87276:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Translator2D = void 0;
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _range = __webpack_require__(21177);
var _category_translator = _interopRequireDefault(__webpack_require__(46163));
var _interval_translator = _interopRequireDefault(__webpack_require__(93175));
var _datetime_translator = _interopRequireDefault(__webpack_require__(75480));
var _logarithmic_translator = _interopRequireDefault(__webpack_require__(1804));
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _abs = Math.abs;
const CANVAS_PROP = ['width', 'height', 'left', 'top', 'bottom', 'right'];
const dummyTranslator = {
  to(value) {
    const coord = this._canvasOptions.startPoint + (this._options.conversionValue ? value : Math.round(value));
    return coord > this._canvasOptions.endPoint ? this._canvasOptions.endPoint : coord;
  },
  from(value) {
    return value - this._canvasOptions.startPoint;
  }
};
const validateCanvas = function (canvas) {
  (0, _iterator.each)(CANVAS_PROP, function (_, prop) {
    canvas[prop] = parseInt(canvas[prop]) || 0;
  });
  return canvas;
};
const makeCategoriesToPoints = function (categories) {
  const categoriesToPoints = {};
  categories.forEach(function (item, i) {
    categoriesToPoints[item.valueOf()] = i;
  });
  return categoriesToPoints;
};
const validateBusinessRange = function (businessRange) {
  if (!(businessRange instanceof _range.Range)) {
    businessRange = new _range.Range(businessRange);
  }
  function validate(valueSelector, baseValueSelector) {
    if (!(0, _type.isDefined)(businessRange[valueSelector]) && (0, _type.isDefined)(businessRange[baseValueSelector])) {
      businessRange[valueSelector] = businessRange[baseValueSelector];
    }
  }
  validate('minVisible', 'min');
  validate('maxVisible', 'max');
  return businessRange;
};
function prepareBreaks(breaks, range) {
  const transform = range.axisType === 'logarithmic' ? function (value) {
    return (0, _utils.getLogExt)(value, range.base);
  } : function (value) {
    return value;
  };
  const array = [];
  let br;
  let transformFrom;
  let transformTo;
  let i;
  const length = breaks.length;
  let sum = 0;
  for (i = 0; i < length; i++) {
    br = breaks[i];
    transformFrom = transform(br.from);
    transformTo = transform(br.to);
    sum += transformTo - transformFrom;
    array.push({
      trFrom: transformFrom,
      trTo: transformTo,
      from: br.from,
      to: br.to,
      length: sum,
      cumulativeWidth: br.cumulativeWidth
    });
  }
  return array;
}
function getCanvasBounds(range) {
  let min = range.min;
  let max = range.max;
  let minVisible = range.minVisible;
  let maxVisible = range.maxVisible;
  const isLogarithmic = range.axisType === 'logarithmic';
  if (isLogarithmic) {
    maxVisible = (0, _utils.getLogExt)(maxVisible, range.base, range.allowNegatives, range.linearThreshold);
    minVisible = (0, _utils.getLogExt)(minVisible, range.base, range.allowNegatives, range.linearThreshold);
    min = (0, _utils.getLogExt)(min, range.base, range.allowNegatives, range.linearThreshold);
    max = (0, _utils.getLogExt)(max, range.base, range.allowNegatives, range.linearThreshold);
  }
  return {
    base: range.base,
    rangeMin: min,
    rangeMax: max,
    rangeMinVisible: minVisible,
    rangeMaxVisible: maxVisible
  };
}
function getCheckingMethodsAboutBreaks(inverted) {
  return {
    isStartSide: !inverted ? function (pos, breaks, start, end) {
      return pos < breaks[0][start];
    } : function (pos, breaks, start, end) {
      return pos <= breaks[breaks.length - 1][end];
    },
    isEndSide: !inverted ? function (pos, breaks, start, end) {
      return pos >= breaks[breaks.length - 1][end];
    } : function (pos, breaks, start, end) {
      return pos > breaks[0][start];
    },
    isInBreak: !inverted ? function (pos, br, start, end) {
      return pos >= br[start] && pos < br[end];
    } : function (pos, br, start, end) {
      return pos > br[end] && pos <= br[start];
    },
    isBetweenBreaks: !inverted ? function (pos, br, prevBreak, start, end) {
      return pos < br[start] && pos >= prevBreak[end];
    } : function (pos, br, prevBreak, start, end) {
      return pos >= br[end] && pos < prevBreak[start];
    },
    getLength: !inverted ? function (br) {
      return br.length;
    } : function (br, lastBreak) {
      return lastBreak.length - br.length;
    },
    getBreaksSize: !inverted ? function (br) {
      return br.cumulativeWidth;
    } : function (br, lastBreak) {
      return lastBreak.cumulativeWidth - br.cumulativeWidth;
    }
  };
}
const _Translator2d = function (businessRange, canvas, options) {
  this.update(businessRange, canvas, options);
};
exports.Translator2D = _Translator2d;
_Translator2d.prototype = {
  constructor: _Translator2d,
  reinit: function () {
    // TODO: parseInt canvas
    const that = this;
    const options = that._options;
    const range = that._businessRange;
    const categories = range.categories || [];
    let script = {};
    const canvasOptions = that._prepareCanvasOptions();
    const visibleCategories = (0, _utils.getCategoriesInfo)(categories, range.minVisible, range.maxVisible).categories;
    const categoriesLength = visibleCategories.length;
    const conditionalRound = (value, skipRound) => skipRound ? value : Math.round(value);
    if (range.isEmpty()) {
      script = dummyTranslator;
    } else {
      switch (range.axisType) {
        case 'logarithmic':
          script = _logarithmic_translator.default;
          break;
        case 'semidiscrete':
          script = _interval_translator.default;
          canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (_date.default.addInterval(canvasOptions.rangeMaxVisible, options.interval) - canvasOptions.rangeMinVisible);
          break;
        case 'discrete':
          script = _category_translator.default;
          that._categories = categories;
          canvasOptions.interval = that._getDiscreteInterval(options.addSpiderCategory ? categoriesLength + 1 : categoriesLength, canvasOptions);
          that._categoriesToPoints = makeCategoriesToPoints(categories);
          if (categoriesLength) {
            canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[0].valueOf()];
            that.visibleCategories = visibleCategories;
          }
          break;
        default:
          if (range.dataType === 'datetime') {
            script = _datetime_translator.default;
          }
      }
    }
    (that._oldMethods || []).forEach(function (methodName) {
      delete that[methodName];
    });
    that._oldMethods = Object.keys(script);
    (0, _extend.extend)(that, script);
    that._conversionValue = options.conversionValue ? value => value : conditionalRound;
    that.sc = {};
    that._checkingMethodsAboutBreaks = [getCheckingMethodsAboutBreaks(false), getCheckingMethodsAboutBreaks(that.isInverted())];
    that._translateBreaks();
    that._calculateSpecialValues();
  },
  _translateBreaks: function () {
    const breaks = this._breaks;
    const size = this._options.breaksSize;
    let i;
    let b;
    let end;
    let length;
    if (breaks === undefined) {
      return;
    }
    for (i = 0, length = breaks.length; i < length; i++) {
      b = breaks[i];
      end = this.translate(b.to);
      b.end = end;
      b.start = !b.gapSize ? !this.isInverted() ? end - size : end + size : end;
    }
  },
  _checkValueAboutBreaks: function (breaks, pos, start, end, methods) {
    let i;
    let length;
    let prop = {
      length: 0,
      breaksSize: undefined,
      inBreak: false
    };
    let br;
    let prevBreak;
    const lastBreak = breaks[breaks.length - 1];
    if (methods.isStartSide(pos, breaks, start, end)) {
      return prop;
    } else if (methods.isEndSide(pos, breaks, start, end)) {
      return {
        length: lastBreak.length,
        breaksSize: lastBreak.cumulativeWidth,
        inBreak: false
      };
    }
    for (i = 0, length = breaks.length; i < length; i++) {
      br = breaks[i];
      prevBreak = breaks[i - 1];
      if (methods.isInBreak(pos, br, start, end)) {
        prop.inBreak = true;
        prop.break = br;
        break;
      }
      if (prevBreak && methods.isBetweenBreaks(pos, br, prevBreak, start, end)) {
        prop = {
          length: methods.getLength(prevBreak, lastBreak),
          breaksSize: methods.getBreaksSize(prevBreak, lastBreak),
          inBreak: false
        };
        break;
      }
    }
    return prop;
  },
  isInverted: function () {
    return !(this._options.isHorizontal ^ this._businessRange.invert);
  },
  _getDiscreteInterval: function (categoriesLength, canvasOptions) {
    const correctedCategoriesCount = categoriesLength - (this._options.stick ? 1 : 0);
    return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength;
  },
  _prepareCanvasOptions() {
    const that = this;
    const businessRange = that._businessRange;
    const canvasOptions = that._canvasOptions = getCanvasBounds(businessRange);
    const canvas = that._canvas;
    const breaks = that._breaks;
    let length;
    canvasOptions.startPadding = canvas.startPadding || 0;
    canvasOptions.endPadding = canvas.endPadding || 0;
    if (that._options.isHorizontal) {
      canvasOptions.startPoint = canvas.left + canvasOptions.startPadding;
      length = canvas.width;
      canvasOptions.endPoint = canvas.width - canvas.right - canvasOptions.endPadding;
      canvasOptions.invert = businessRange.invert;
    } else {
      canvasOptions.startPoint = canvas.top + canvasOptions.startPadding;
      length = canvas.height;
      canvasOptions.endPoint = canvas.height - canvas.bottom - canvasOptions.endPadding;
      canvasOptions.invert = !businessRange.invert; // axis inverted because display drawn to bottom
    }
    that.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;
    canvasOptions.rangeDoubleError = Math.pow(10, (0, _utils.getPower)(canvasOptions.rangeMax - canvasOptions.rangeMin) - (0, _utils.getPower)(length) - 2); // B253861
    canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);
    if (breaks !== undefined) {
      const visibleRangeLength = canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible - breaks[breaks.length - 1].length;
      if (visibleRangeLength !== 0) {
        canvasOptions.ratioOfCanvasRange = (canvasOptions.canvasLength - breaks[breaks.length - 1].cumulativeWidth) / visibleRangeLength;
      }
    }
    return canvasOptions;
  },
  updateCanvas: function (canvas) {
    this._canvas = validateCanvas(canvas);
    this.reinit();
  },
  updateBusinessRange: function (businessRange) {
    const that = this;
    const breaks = businessRange.breaks || [];
    that._userBreaks = businessRange.userBreaks || [];
    that._businessRange = validateBusinessRange(businessRange);
    that._breaks = breaks.length ? prepareBreaks(breaks, that._businessRange) : undefined;
    that.reinit();
  },
  update: function (businessRange, canvas, options) {
    const that = this;
    that._options = (0, _extend.extend)(that._options || {}, options);
    that._canvas = validateCanvas(canvas);
    that.updateBusinessRange(businessRange);
  },
  getBusinessRange: function () {
    return this._businessRange;
  },
  getEventScale: function (zoomEvent) {
    return zoomEvent.deltaScale || 1;
  },
  getCanvasVisibleArea: function () {
    return {
      min: this._canvasOptions.startPoint,
      max: this._canvasOptions.endPoint
    };
  },
  _calculateSpecialValues: function () {
    const that = this;
    const canvasOptions = that._canvasOptions;
    const startPoint = canvasOptions.startPoint - canvasOptions.startPadding;
    const endPoint = canvasOptions.endPoint + canvasOptions.endPadding;
    const range = that._businessRange;
    const minVisible = range.minVisible;
    const maxVisible = range.maxVisible;
    const canvas_position_center_middle = startPoint + canvasOptions.canvasLength / 2;
    let canvas_position_default;
    if (minVisible < 0 && maxVisible > 0 && minVisible !== maxVisible) {
      canvas_position_default = that.translate(0, 1);
    }
    if (!(0, _type.isDefined)(canvas_position_default)) {
      const invert = range.invert ^ (minVisible < 0 && maxVisible <= 0);
      if (that._options.isHorizontal) {
        canvas_position_default = invert ? endPoint : startPoint;
      } else {
        canvas_position_default = invert ? startPoint : endPoint;
      }
    }
    that.sc = {
      'canvas_position_default': canvas_position_default,
      'canvas_position_left': startPoint,
      'canvas_position_top': startPoint,
      'canvas_position_center': canvas_position_center_middle,
      'canvas_position_middle': canvas_position_center_middle,
      'canvas_position_right': endPoint,
      'canvas_position_bottom': endPoint,
      'canvas_position_start': canvasOptions.invert ? endPoint : startPoint,
      'canvas_position_end': canvasOptions.invert ? startPoint : endPoint
    };
  },
  translateSpecialCase(value) {
    return this.sc[value];
  },
  _calculateProjection: function (distance) {
    const canvasOptions = this._canvasOptions;
    return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance;
  },
  _calculateUnProjection: function (distance) {
    const canvasOptions = this._canvasOptions;
    this._businessRange.dataType === 'datetime' && (distance = Math.round(distance));
    return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance;
  },
  getMinBarSize: function (minBarSize) {
    const visibleArea = this.getCanvasVisibleArea();
    const minValue = this.from(visibleArea.min + minBarSize);
    return _abs(this.from(visibleArea.min) - (!(0, _type.isDefined)(minValue) ? this.from(visibleArea.max) : minValue));
  },
  checkMinBarSize: function (value, minShownValue) {
    return _abs(value) < minShownValue ? value >= 0 ? minShownValue : -minShownValue : value;
  },
  translate(bp, direction, skipRound) {
    const specialValue = this.translateSpecialCase(bp);
    if ((0, _type.isDefined)(specialValue)) {
      return Math.round(specialValue);
    }
    if (isNaN(bp)) {
      return null;
    }
    return this.to(bp, direction, skipRound);
  },
  getInterval: function (interval) {
    const canvasOptions = this._canvasOptions;
    interval = interval ?? this._businessRange.interval;
    if (interval) {
      return Math.round(canvasOptions.ratioOfCanvasRange * interval);
    }
    return Math.round(canvasOptions.endPoint - canvasOptions.startPoint);
  },
  zoom(translate, scale, wholeRange) {
    const canvasOptions = this._canvasOptions;
    if (canvasOptions.rangeMinVisible.valueOf() === canvasOptions.rangeMaxVisible.valueOf() && translate !== 0) {
      return this.zoomZeroLengthRange(translate, scale);
    }
    const startPoint = canvasOptions.startPoint;
    const endPoint = canvasOptions.endPoint;
    const isInverted = this.isInverted();
    let newStart = (startPoint + translate) / scale;
    let newEnd = (endPoint + translate) / scale;
    wholeRange = wholeRange || {};
    const minPoint = this.to(isInverted ? wholeRange.endValue : wholeRange.startValue);
    const maxPoint = this.to(isInverted ? wholeRange.startValue : wholeRange.endValue);
    let min;
    let max;
    if (minPoint > newStart) {
      newEnd -= newStart - minPoint;
      newStart = minPoint;
      min = isInverted ? wholeRange.endValue : wholeRange.startValue;
    }
    if (maxPoint < newEnd) {
      newStart -= newEnd - maxPoint;
      newEnd = maxPoint;
      max = isInverted ? wholeRange.startValue : wholeRange.endValue;
    }
    if (maxPoint - minPoint < newEnd - newStart) {
      newStart = minPoint;
      newEnd = maxPoint;
    }
    translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;
    scale = (startPoint + translate) / newStart || 1;
    min = (0, _type.isDefined)(min) ? min : (0, _math.adjust)(this.from(newStart, 1));
    max = (0, _type.isDefined)(max) ? max : (0, _math.adjust)(this.from(newEnd, -1));
    if (scale <= 1) {
      min = this._correctValueAboutBreaks(min, scale === 1 ? translate : -1);
      max = this._correctValueAboutBreaks(max, scale === 1 ? translate : 1);
    }
    if (min > max) {
      min = min > wholeRange.endValue ? wholeRange.endValue : min;
      max = max < wholeRange.startValue ? wholeRange.startValue : max;
    } else {
      min = min < wholeRange.startValue ? wholeRange.startValue : min;
      max = max > wholeRange.endValue ? wholeRange.endValue : max;
    }
    return {
      min,
      max,
      translate: (0, _math.adjust)(translate),
      scale: (0, _math.adjust)(scale)
    };
  },
  _correctValueAboutBreaks(value, direction) {
    const br = this._userBreaks.filter(br => {
      return value >= br.from && value <= br.to;
    });
    if (br.length) {
      return direction > 0 ? br[0].to : br[0].from;
    } else {
      return value;
    }
  },
  zoomZeroLengthRange(translate, scale) {
    const canvasOptions = this._canvasOptions;
    const min = canvasOptions.rangeMin;
    const max = canvasOptions.rangeMax;
    const correction = (max.valueOf() !== min.valueOf() ? max.valueOf() - min.valueOf() : _abs(canvasOptions.rangeMinVisible.valueOf() - min.valueOf())) / canvasOptions.canvasLength;
    const isDateTime = (0, _type.isDate)(max) || (0, _type.isDate)(min);
    const isLogarithmic = this._businessRange.axisType === 'logarithmic';
    let newMin = canvasOptions.rangeMinVisible.valueOf() - correction;
    let newMax = canvasOptions.rangeMaxVisible.valueOf() + correction;
    newMin = isLogarithmic ? (0, _math.adjust)((0, _utils.raiseToExt)(newMin, canvasOptions.base)) : isDateTime ? new Date(newMin) : newMin;
    newMax = isLogarithmic ? (0, _math.adjust)((0, _utils.raiseToExt)(newMax, canvasOptions.base)) : isDateTime ? new Date(newMax) : newMax;
    return {
      min: newMin,
      max: newMax,
      translate: translate,
      scale: scale
    };
  },
  getMinScale: function (zoom) {
    const {
      dataType,
      interval
    } = this._businessRange;
    if (dataType === 'datetime' && interval === 1) {
      return this.getDateTimeMinScale(zoom);
    }
    return zoom ? 1.1 : 0.9;
  },
  getDateTimeMinScale(zoom) {
    const canvasOptions = this._canvasOptions;
    let length = canvasOptions.canvasLength / canvasOptions.ratioOfCanvasRange;
    length += (parseInt(length * 0.1) || 1) * (zoom ? -2 : 2);
    return canvasOptions.canvasLength / (Math.max(length, 1) * canvasOptions.ratioOfCanvasRange);
  },
  getScale: function (val1, val2) {
    const canvasOptions = this._canvasOptions;
    if (canvasOptions.rangeMax === canvasOptions.rangeMin) {
      return 1;
    }
    val1 = (0, _type.isDefined)(val1) ? this.fromValue(val1) : canvasOptions.rangeMin;
    val2 = (0, _type.isDefined)(val2) ? this.fromValue(val2) : canvasOptions.rangeMax;
    return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2);
  },
  // dxRangeSelector
  isValid: function (value) {
    const co = this._canvasOptions;
    value = this.fromValue(value);
    return value !== null && !isNaN(value) && value.valueOf() + co.rangeDoubleError >= co.rangeMin && value.valueOf() - co.rangeDoubleError <= co.rangeMax;
  },
  getCorrectValue: function (value, direction) {
    const that = this;
    const breaks = that._breaks;
    let prop;
    value = that.fromValue(value);
    if (that._breaks) {
      prop = that._checkValueAboutBreaks(breaks, value, 'trFrom', 'trTo', that._checkingMethodsAboutBreaks[0]);
      if (prop.inBreak === true) {
        return that.toValue(direction > 0 ? prop.break.trTo : prop.break.trFrom);
      }
    }
    return that.toValue(value);
  },
  to: function (bp, direction, skipRound) {
    const range = this.getBusinessRange();
    if ((0, _type.isDefined)(range.maxVisible) && (0, _type.isDefined)(range.minVisible) && range.maxVisible.valueOf() === range.minVisible.valueOf()) {
      if (!(0, _type.isDefined)(bp) || range.maxVisible.valueOf() !== bp.valueOf()) {
        return null;
      }
      return this.translateSpecialCase(bp === 0 && this._options.shiftZeroValue ? 'canvas_position_default' : 'canvas_position_middle');
    }
    bp = this.fromValue(bp);
    const that = this;
    const canvasOptions = that._canvasOptions;
    const breaks = that._breaks;
    let prop = {
      length: 0
    };
    let commonBreakSize = 0;
    if (breaks !== undefined) {
      prop = that._checkValueAboutBreaks(breaks, bp, 'trFrom', 'trTo', that._checkingMethodsAboutBreaks[0]);
      commonBreakSize = (0, _type.isDefined)(prop.breaksSize) ? prop.breaksSize : 0;
    }
    if (prop.inBreak === true) {
      if (direction > 0) {
        return prop.break.start;
      } else if (direction < 0) {
        return prop.break.end;
      } else {
        return null;
      }
    }
    return that._conversionValue(that._calculateProjection((bp - canvasOptions.rangeMinVisible - prop.length) * canvasOptions.ratioOfCanvasRange + commonBreakSize), skipRound);
  },
  from: function (pos, direction) {
    const that = this;
    const breaks = that._breaks;
    let prop = {
      length: 0
    };
    const canvasOptions = that._canvasOptions;
    const startPoint = canvasOptions.startPoint;
    let commonBreakSize = 0;
    if (breaks !== undefined) {
      prop = that._checkValueAboutBreaks(breaks, pos, 'start', 'end', that._checkingMethodsAboutBreaks[1]);
      commonBreakSize = (0, _type.isDefined)(prop.breaksSize) ? prop.breaksSize : 0;
    }
    if (prop.inBreak === true) {
      if (direction > 0) {
        return that.toValue(prop.break.trTo);
      } else if (direction < 0) {
        return that.toValue(prop.break.trFrom);
      } else {
        return null;
      }
    }
    return that.toValue(that._calculateUnProjection((pos - startPoint - commonBreakSize) / canvasOptions.ratioOfCanvasRange + prop.length));
  },
  isValueProlonged: false,
  // dxRangeSelector specific

  // TODO: Rename to getValueRange
  getRange: function () {
    return [this.toValue(this._canvasOptions.rangeMin), this.toValue(this._canvasOptions.rangeMax)];
  },
  getScreenRange: function () {
    return [this._canvasOptions.startPoint, this._canvasOptions.endPoint];
  },
  add: function (value, diff, dir) {
    return this._add(value, diff, (this._businessRange.invert ? -1 : +1) * dir);
  },
  _add: function (value, diff, coeff) {
    return this.toValue(this.fromValue(value) + diff * coeff);
  },
  fromValue: function (value) {
    return value !== null ? Number(value) : null;
  },
  toValue: function (value) {
    return value !== null ? Number(value) : null;
  },
  ratioOfCanvasRange() {
    return this._canvasOptions.ratioOfCanvasRange;
  },
  convert(value) {
    return value;
  },
  getRangeByMinZoomValue(minZoom, visualRange) {
    if (visualRange.minVisible + minZoom <= this._businessRange.max) {
      return [visualRange.minVisible, visualRange.minVisible + minZoom];
    } else {
      return [visualRange.maxVisible - minZoom, visualRange.maxVisible];
    }
  }
};

/***/ }),

/***/ 15584:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tree_map = _interopRequireDefault(__webpack_require__(4080));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _tree_map.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 4815:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _node = _interopRequireDefault(__webpack_require__(21168));
var _extend2 = __webpack_require__(13306);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const proto = _tree_map.default.prototype;
const nodeProto = _node.default.prototype;
proto._eventsMap.onNodesInitialized = {
  name: 'nodesInitialized'
};
proto._eventsMap.onNodesRendering = {
  name: 'nodesRendering'
};
proto._createProxyType = function () {
  const that = this;
  let nodes;
  Proxy.prototype = {
    constructor: Proxy,
    getParent: function () {
      return nodes[this._id].parent.proxy || null;
    },
    getChild: function (index) {
      const _nodes = nodes[this._id].nodes;
      return _nodes ? _nodes[index].proxy : null;
    },
    getChildrenCount: function () {
      const _nodes = nodes[this._id].nodes;
      return _nodes ? _nodes.length : 0;
    },
    getAllChildren: function () {
      const _nodes = nodes[this._id].nodes;
      let i;
      const ii = _nodes && _nodes.length;
      const list = [];
      for (i = 0; i < ii; ++i) {
        list.push(_nodes[i].proxy);
      }
      return list;
    },
    getAllNodes: function () {
      const list = [];
      collectNodes(nodes[this._id], list);
      return list;
    },
    isLeaf: function () {
      return !nodes[this._id].isNode();
    },
    isActive: function () {
      return nodes[this._id].isActive();
    },
    value: function (arg) {
      const node = nodes[this._id];
      let result;
      if (arg !== undefined) {
        updateValue(node, arg > 0 ? Number(arg) : 0);
        change(node, ['TILING']);
        result = this;
      } else {
        result = node.value;
      }
      return result;
    },
    label: function (arg) {
      const node = nodes[this._id];
      let result;
      if (arg !== undefined) {
        node.customLabel = arg ? String(arg) : null;
        change(node, ['LABELS']);
        result = this;
      } else {
        result = node.customLabel || node.label;
      }
      return result;
    },
    customize: function (settings) {
      const node = nodes[this._id];
      if (settings) {
        node._custom = node._custom || {};
        (0, _extend2.extend)(true, node._custom, settings);
        node._partialState = node._partialLabelState = null;
      }
      change(node, ['TILES', 'LABELS']);
      return this;
    },
    resetCustomization: function () {
      const node = nodes[this._id];
      node._custom = node._partialState = node._partialLabelState = null;
      change(node, ['TILES', 'LABELS']);
      return this;
    }
  };
  that._extendProxyType(Proxy.prototype);
  function Proxy(node) {
    const that = this;
    node.proxy = that;
    that._id = node._id;
    that.level = node.level;
    that.index = node.index;
    that.data = node.data;
  }

  // TODO: Find a way to make the following methods exist one per module rather then one per instance
  that._handlers.beginBuildNodes = function () {
    nodes = that._nodes;
    new Proxy(that._root);
  };
  that._handlers.buildNode = function (node) {
    new Proxy(node);
  };
  that._handlers.endBuildNodes = function () {
    that._eventTrigger('nodesInitialized', {
      root: that._root.proxy
    });
  };
};
function change(node, codes) {
  const ctx = node.ctx;
  ctx.suspend();
  ctx.change(codes);
  ctx.resume();
}
function collectNodes(node, list) {
  const nodes = node.nodes;
  let i;
  const ii = nodes && nodes.length;
  for (i = 0; i < ii; ++i) {
    list.push(nodes[i].proxy);
    collectNodes(nodes[i], list);
  }
}
function updateValue(node, value) {
  const delta = value - node.value;
  while (node) {
    node.value += delta;
    node = node.parent;
  }
}
proto._extendProxyType = _common.noop;
const _resetNodes = proto._resetNodes;
proto._resetNodes = function () {
  _resetNodes.call(this);
  this._eventTrigger('nodesRendering', {
    node: this._topNode.proxy
  });
};
const _updateStyles = nodeProto.updateStyles;
nodeProto.updateStyles = function () {
  const that = this;
  _updateStyles.call(that);
  if (that._custom) {
    that._partialState = !that.ctx.forceReset && that._partialState || that.ctx.calculateState(that._custom);
    (0, _extend2.extend)(true, that.state, that._partialState);
  }
};
const _updateLabelStyle = nodeProto.updateLabelStyle;
nodeProto.updateLabelStyle = function () {
  const that = this;
  const custom = that._custom;
  _updateLabelStyle.call(that);
  if (custom && custom.label) {
    that._partialLabelState = !that.ctx.forceReset && that._partialLabelState || calculatePartialLabelState(that, custom.label);
    that.labelState = (0, _extend2.extend)(true, {}, that.labelState, that._partialLabelState);
  }
};
function calculatePartialLabelState(node, settings) {
  const state = node.ctx.calculateLabelState(settings);
  if ('visible' in settings) {
    state.visible = !!settings.visible;
  }
  return state;
}
proto.getRootNode = function () {
  return this._root.proxy;
};
proto.resetNodes = function () {
  const context = this._context;
  context.suspend();
  context.change(['NODES_CREATE']);
  context.resume();
  return this;
};

/***/ }),

/***/ 66831:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _colorizing = __webpack_require__(19910);
function discreteColorizer(options, themeManager, root) {
  const palette = themeManager.createPalette(options.palette, {
    useHighlight: true,
    extensionMode: options.paletteExtensionMode,
    count: options.colorizeGroups ? getNodesCount(root) : getLeafsCount(root)
  });
  return (options.colorizeGroups ? discreteGroupColorizer : discreteLeafColorizer)(palette, root);
}
function getLeafsCount(root) {
  const allNodes = root.nodes.slice();
  let i;
  const ii = allNodes.length;
  let count = 0;
  let node;
  for (i = 0; i < ii; ++i) {
    node = allNodes[i];
    if (node.isNode()) {
      count = Math.max(count, getLeafsCount(node));
    } else {
      count += 1;
    }
  }
  return count;
}
function discreteLeafColorizer(palette) {
  const colors = palette.generateColors();
  return function (node) {
    return colors[node.index];
  };
}
function getNodesCount(root) {
  const allNodes = root.nodes.slice();
  let i;
  const ii = allNodes.length;
  let count = 0;
  let node;
  for (i = 0; i < ii; ++i) {
    node = allNodes[i];
    if (node.isNode()) {
      count += getNodesCount(node) + 1;
    }
  }
  return count;
}
function prepareDiscreteGroupColors(palette, root) {
  const colors = {};
  let allNodes = root.nodes.slice();
  let i;
  let ii = allNodes.length;
  let node;
  for (i = 0; i < ii; ++i) {
    node = allNodes[i];
    if (node.isNode()) {
      allNodes = allNodes.concat(node.nodes);
      ii = allNodes.length;
    } else if (!colors[node.parent._id]) {
      colors[node.parent._id] = palette.getNextColor();
    }
  }
  return colors;
}
function discreteGroupColorizer(palette, root) {
  const colors = prepareDiscreteGroupColors(palette, root);
  return function (node) {
    return colors[node._id];
  };
}
(0, _colorizing.addColorizer)('discrete', discreteColorizer);
var _default = exports["default"] = discreteColorizer;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 13652:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _colorizing = __webpack_require__(19910);
const _min = Math.min;
const _max = Math.max;
function createSimpleColorizer(getColor, range) {
  return function (node) {
    return getColor(node, range);
  };
}
function getRangeData(range) {
  return [Number(range[0]) || 0, range[1] - range[0] || 1];
}
function calculateRange(nodes, getValue) {
  let i;
  const ii = nodes.length;
  const codes = [];
  let code;
  for (i = 0; i < ii; ++i) {
    code = getValue(nodes[i]);
    if (isFinite(code)) {
      codes.push(code);
    }
  }
  return getRangeData([_min.apply(null, codes), _max.apply(null, codes)]);
}
function createGuessingColorizer(getColor, getValue) {
  const ranges = {};
  return function (node) {
    const parent = node.parent;
    return getColor(node, ranges[parent._id] || (ranges[parent._id] = calculateRange(parent.nodes, getValue)));
  };
}
function gradientColorizer(options, themeManager) {
  const palette = themeManager.createGradientPalette(options.palette);
  const getValue = (0, _colorizing.createColorCodeGetter)(options);
  return 'range' in options ? createSimpleColorizer(getColor, getRangeData(options.range || [])) : createGuessingColorizer(getColor, getValue);
  function getColor(node, arg) {
    return palette.getColor((getValue(node) - arg[0]) / arg[1]);
  }
}
(0, _colorizing.addColorizer)('gradient', gradientColorizer);
var _default = exports["default"] = gradientColorizer;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 19910:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addColorizer = addColorizer;
exports.createColorCodeGetter = createColorCodeGetter;
exports.getColorizer = getColorizer;
exports.setDefaultColorizer = setDefaultColorizer;
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
const colorizers = {};
let defaultColorizerName;
function wrapLeafColorGetter(getter) {
  return function (node) {
    return !node.isNode() ? getter(node) : undefined;
  };
}
function wrapGroupColorGetter(getter) {
  return function (node) {
    const parent = !node.isNode() && node.parent;
    return parent ? parent._groupColor = parent._groupColor || getter(parent) : undefined;
  };
}
function getColorizer(options, themeManager, root) {
  const type = (0, _utils.normalizeEnum)(options.type || defaultColorizerName);
  const colorizer = colorizers[type] && colorizers[type](options, themeManager, root);
  return colorizer ? (options.colorizeGroups ? wrapGroupColorGetter : wrapLeafColorGetter)(colorizer) : _common.noop;
}
function addColorizer(name, colorizer) {
  colorizers[name] = colorizer;
}
function setDefaultColorizer(name) {
  defaultColorizerName = name;
}
function getValueAsColorCode(node) {
  return node.value;
}
function createColorCode(colorCodeField) {
  return function (node) {
    return Number(node.data[colorCodeField]);
  };
}
function createColorCodeGetter(options) {
  return options.colorCodeField ? createColorCode(options.colorCodeField) : getValueAsColorCode;
}

/***/ }),

/***/ 73675:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _colorizing = __webpack_require__(19910);
function getPaletteIndex(value, items) {
  let start = 0;
  let end = items.length - 1;
  let index = -1;
  let middle;
  if (items[start] <= value && value <= items[end]) {
    if (value === items[end]) {
      index = end - 1;
    } else {
      while (end - start > 1) {
        middle = start + end >> 1;
        if (value < items[middle]) {
          end = middle;
        } else {
          start = middle;
        }
      }
      index = start;
    }
  }
  return index;
}
function rangeColorizer(options, themeManager) {
  const range = options.range || [];
  const palette = themeManager.createDiscretePalette(options.palette, range.length - 1);
  const getValue = (0, _colorizing.createColorCodeGetter)(options);
  return function (node) {
    return palette.getColor(getPaletteIndex(getValue(node), range));
  };
}
(0, _colorizing.addColorizer)('range', rangeColorizer);
var _default = exports["default"] = rangeColorizer;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 77707:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.buildRectAppearance = buildRectAppearance;
exports.buildTextAppearance = buildTextAppearance;
var _utils = __webpack_require__(19157);
function buildRectAppearance(option) {
  const border = option.border || {};
  return {
    fill: option.color,
    opacity: option.opacity,
    'stroke': border.color,
    'stroke-width': border.width,
    'stroke-opacity': border.opacity,
    hatching: option.hatching
  };
}
function buildTextAppearance(options, filter) {
  return {
    attr: {
      filter
    },
    css: (0, _utils.patchFontOptions)(options.font)
  };
}

/***/ }),

/***/ 61104:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _helpers = __webpack_require__(3603);
__webpack_require__(4815);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const proto = _tree_map.default.prototype;
proto._eventsMap.onDrill = {
  name: 'drill'
};
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  const that = this;
  proto.drillDown = function () {
    that._drillToNode(this._id);
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._drilldownIndex = -1;
});
proto._drillToNode = function (index) {
  const that = this;
  let node;
  if (that._drilldownIndex !== index) {
    node = that._nodes[index] || that._root;
    if (node.nodes) {
      that._drilldownIndex = index;
      that._topNode = node;
      that._context.suspend();
      that._context.change(['MAX_DEPTH', 'NODES_RESET']);
      that._context.resume();
      that._eventTrigger('drill', {
        node: node.proxy
      });
    }
  }
};
proto.resetDrillDown = function () {
  this._drillToNode(-1);
  return this;
};
proto.drillUp = function () {
  this._drillToNode(this._topNode.parent._id || -1);
  return this;
};
proto.getCurrentNode = function () {
  return this._topNode.proxy;
};

/***/ }),

/***/ 9888:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _node = _interopRequireDefault(__webpack_require__(21168));
var _helpers = __webpack_require__(3603);
var _common = __webpack_require__(77707);
var _utils = __webpack_require__(19157);
__webpack_require__(4815);
__webpack_require__(83469);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const proto = _tree_map.default.prototype;
const nodeProto = _node.default.prototype;
const STATE_CODE = 1;
proto._eventsMap.onHoverChanged = {
  name: 'hoverChanged'
};
(0, _helpers.expand)(proto._handlers, 'calculateAdditionalStates', function (states, options) {
  states[1] = options.hoverStyle ? (0, _common.buildRectAppearance)(options.hoverStyle) : {};
});
_tree_map.default.addChange({
  code: 'HOVER_ENABLED',
  handler: function () {
    const hoverEnabled = (0, _utils.parseScalar)(this._getOption('hoverEnabled', true), true);
    if (!hoverEnabled) {
      this.clearHover();
    }
    this._hoverEnabled = hoverEnabled;
  },
  isThemeDependent: true,
  isOptionChange: true,
  option: 'hoverEnabled'
});
nodeProto.statesMap[1] = 1;
nodeProto.additionalStates.push(1);
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  const that = this;
  proto.setHover = function () {
    that._hoverNode(this._id);
  };
  proto.isHovered = function () {
    return that._hoverIndex === this._id;
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._hoverIndex = -1;
});
(0, _helpers.expand)(proto, '_changeGroupSettings', function () {
  const that = this;
  that._groupHoverEnabled = (0, _utils.parseScalar)(that._getOption('group').hoverEnabled, true);
  if (!that._groupHoverEnabled) {
    that.clearHover();
  }
});
proto._applyHoverState = function (index, state) {
  setNodeStateRecursive(this._nodes[index], STATE_CODE, state);
  this._eventTrigger('hoverChanged', {
    node: this._nodes[index].proxy
  });
};
function setNodeStateRecursive(node, code, state) {
  const nodes = node.isNode() && node.nodes;
  let i;
  const ii = nodes && nodes.length;
  node.setState(code, state);
  for (i = 0; i < ii; ++i) {
    setNodeStateRecursive(nodes[i], code, state);
  }
}
proto._hoverNode = function (index) {
  const that = this;
  const currentIndex = that._hoverIndex;
  if (that._hoverEnabled && currentIndex !== index) {
    if (!that._groupHoverEnabled && index >= 0 && that._nodes[index].isNode()) {
      that.clearHover();
      return;
    }
    that._context.suspend();
    that._hoverIndex = -1;
    if (currentIndex >= 0) {
      that._applyHoverState(currentIndex, false);
    }
    that._hoverIndex = index;
    if (index >= 0) {
      that._applyHoverState(index, true);
    }
    that._context.resume();
  }
};
proto.clearHover = function () {
  this._hoverNode(-1);
};

/***/ }),

/***/ 21168:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
function Node() {}
const updateTile = [updateLeaf, updateGroup];
(0, _extend2.extend)(Node.prototype, {
  value: 0,
  isNode: function () {
    return !!(this.nodes && this.level < this.ctx.maxLevel);
  },
  isActive: function () {
    const ctx = this.ctx;
    return this.level >= ctx.minLevel && this.level <= ctx.maxLevel;
  },
  updateStyles: function () {
    const that = this;
    const isNode = Number(that.isNode());
    that.state = that._buildState(that.ctx.settings[isNode].state, !isNode && that.color && {
      fill: that.color
    });
  },
  _buildState: function (state, extra) {
    const base = (0, _extend2.extend)({}, state);
    return extra ? (0, _extend2.extend)(base, extra) : base;
  },
  updateLabelStyle: function () {
    const settings = this.ctx.settings[Number(this.isNode())];
    this.labelState = settings.labelState;
    this.labelParams = settings.labelParams;
  },
  _getState: function () {
    return this.state;
  },
  applyState: function () {
    updateTile[Number(this.isNode())](this.tile, this._getState());
  }
});
function updateLeaf(content, attrs) {
  content.smartAttr(attrs);
}
function updateGroup(content, attrs) {
  content.outer.attr({
    stroke: attrs.stroke,
    'stroke-width': attrs['stroke-width'],
    'stroke-opacity': attrs['stroke-opacity']
  });
  content.inner.smartAttr({
    fill: attrs.fill,
    opacity: attrs.opacity,
    hatching: attrs.hatching
  });
}
var _default = exports["default"] = Node;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 74958:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const proto = _tree_map.default.prototype;
proto._optionChangesMap.idField = proto._optionChangesMap.parentField = 'NODES_CREATE';
proto._processDataSourceItems = function (items) {
  let i;
  const struct = {};
  let currentItem;
  const idField = this._getOption('idField', true);
  const parentField = this._getOption('parentField', true);
  let parentId;
  const rootNodes = [];
  let tmpItems;
  let item;
  if (!idField || !parentField || items.length === 0) {
    return {
      items: items,
      isPlain: false
    };
  }
  for (i = 0; i < items.length; i++) {
    currentItem = items[i];
    parentId = currentItem[parentField];
    if (parentId) {
      struct[parentId] = struct[parentId] || {
        items: []
      };
      tmpItems = struct[parentId].items;
    } else {
      tmpItems = rootNodes;
    }
    tmpItems.push(currentItem);
  }
  treeFiller({
    struct: struct,
    idField: idField
  }, rootNodes);
  for (item in struct) {
    struct[item] && rootNodes.push(struct[item]);
  }
  return {
    items: rootNodes,
    isPlain: true
  };
};
function treeFiller(context, items) {
  let currentItem;
  let i;
  const struct = context.struct;
  let id;
  for (i = 0; i < items.length; i++) {
    currentItem = items[i];
    id = currentItem[context.idField];
    if (struct[id]) {
      currentItem.items = struct[id].items;
      struct[id] = null;
      treeFiller(context, currentItem.items);
    }
  }
}

/***/ }),

/***/ 13099:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _node = _interopRequireDefault(__webpack_require__(21168));
var _helpers = __webpack_require__(3603);
var _common = __webpack_require__(77707);
var _utils = __webpack_require__(19157);
__webpack_require__(4815);
__webpack_require__(83469);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const proto = _tree_map.default.prototype;
const nodeProto = _node.default.prototype;
const MODE_NONE = 0;
const MODE_SINGLE = 1;
const MODE_MULTIPLE = 2;
const STATE_CODE = 2;
proto._eventsMap.onSelectionChanged = {
  name: 'selectionChanged'
};
(0, _helpers.expand)(proto._handlers, 'calculateAdditionalStates', function (states, options) {
  states[2] = options.selectionStyle ? (0, _common.buildRectAppearance)(options.selectionStyle) : {};
});
nodeProto.statesMap[2] = nodeProto.statesMap[3] = STATE_CODE;
nodeProto.additionalStates.push(2);
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._selectionList.length = 0;
});
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  const that = this;
  proto.select = function (state) {
    that._selectNode(this._id, !!state);
  };
  proto.isSelected = function () {
    return that._selectionList.includes(this._id);
  };
  that._selectionList = [];
});
_tree_map.default.addChange({
  code: 'SELECTION_MODE',
  handler: function () {
    const that = this;
    const option = (0, _utils.normalizeEnum)(that._getOption('selectionMode', true));
    const selectionList = that._selectionList;
    let tmp;
    const mode = option === 'none' ? MODE_NONE : option === 'multiple' ? MODE_MULTIPLE : MODE_SINGLE;
    if (mode === MODE_SINGLE && selectionList.length > 1) {
      tmp = selectionList.pop();
      that.clearSelection();
      selectionList.push(tmp);
    } else if (mode === MODE_NONE) {
      that.clearSelection();
    }
    that._selectionMode = mode;
  },
  isThemeDependent: true,
  isOptionChange: true,
  option: 'selectionMode'
});
(0, _helpers.expand)(proto, '_applyTilesAppearance', function () {
  if (this._selectionList.length) {
    bringSelectedTilesToForeground(this._nodes, this._selectionList);
  }
});
const tileToFront = [leafToFront, groupToFront];
function bringSelectedTilesToForeground(nodes, selectionList) {
  let i;
  const ii = selectionList.length;
  let node;
  for (i = 0; i < ii; ++i) {
    node = nodes[selectionList[i]];
    tileToFront[Number(node.isNode())](node.tile);
  }
}
function leafToFront(content) {
  content.toForeground();
}
function groupToFront(content) {
  content.outer.toForeground();
  content.inner.toForeground();
}
proto._applySelectionState = function (index, state) {
  const node = this._nodes[index];
  node.setState(STATE_CODE, state);
  this._eventTrigger('selectionChanged', {
    node: node.proxy
  });
};
proto._selectNode = function (index, state) {
  const that = this;
  let selectionList;
  let k;
  let tmp;
  if (that._selectionMode !== MODE_NONE) {
    that._context.suspend();
    selectionList = that._selectionList;
    k = selectionList.indexOf(index);
    if (state && k === -1) {
      if (that._selectionMode === MODE_SINGLE) {
        if (selectionList.length) {
          tmp = selectionList.pop();
          that._applySelectionState(tmp, false);
        }
      }
      selectionList.push(index);
      that._applySelectionState(index, true);
    } else if (!state && k >= 0) {
      selectionList.splice(k, 1);
      that._applySelectionState(index, false);
    }
    that._context.resume();
  }
};
proto.clearSelection = function () {
  const that = this;
  const selectionList = that._selectionList;
  let i;
  const ii = selectionList.length;
  if (that._selectionMode !== MODE_NONE) {
    that._context.suspend();
    for (i = 0; i < ii; ++i) {
      that._applySelectionState(selectionList[i], false);
    }
    selectionList.length = 0;
    that._context.resume();
  }
};

/***/ }),

/***/ 83469:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _node = _interopRequireDefault(__webpack_require__(21168));
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const proto = _tree_map.default.prototype;
const nodeProto = _node.default.prototype;
const handlers = proto._handlers;
const _calculateState = handlers.calculateState;
const _buildState = nodeProto._buildState;
handlers.calculateState = function (options) {
  const states = {
    0: _calculateState(options)
  };
  handlers.calculateAdditionalStates(states, options);
  return states;
};
handlers.calculateAdditionalStates = _common.noop;
nodeProto.code = 0;
nodeProto.statesMap = {
  0: 0
};
nodeProto.additionalStates = [];
nodeProto._buildState = function (state, extra) {
  const states = {
    0: _buildState(state[0], extra)
  };
  if (this.additionalStates.length) {
    buildAdditionalStates(states, states[0], state, this.additionalStates);
  }
  return states;
};
nodeProto._getState = function () {
  return this.state[this.statesMap[this.code]];
};
nodeProto.setState = function (code, state) {
  if (state) {
    this.code |= code;
  } else {
    this.code &= ~code;
  }
  this.ctx.change(['TILES']);
};
function buildAdditionalStates(states, base, source, list) {
  let i;
  const ii = list.length;
  for (i = 0; i < ii; ++i) {
    states[list[i]] = (0, _extend2.extend)({}, base, source[list[i]]);
  }
}

/***/ }),

/***/ 60642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addAlgorithm = addAlgorithm;
exports.buildSidesData = buildSidesData;
exports.calculateRectangles = calculateRectangles;
exports.getAlgorithm = getAlgorithm;
exports.getStaticSideIndex = void 0;
exports.setDefaultAlgorithm = setDefaultAlgorithm;
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
const _round = Math.round;
const algorithms = {};
let defaultAlgorithm;
function getAlgorithm(value) {
  return algorithms[(0, _utils.normalizeEnum)(value)] || (0, _type.isFunction)(value) && value || defaultAlgorithm;
}
function addAlgorithm(name, callback) {
  algorithms[name] = callback;
}
function setDefaultAlgorithm(name) {
  defaultAlgorithm = algorithms[name];
}
const directionToIndexOffsets = {};
directionToIndexOffsets[-1] = [2, 0];
directionToIndexOffsets[+1] = [0, 2];
const getStaticSideIndex = function (rect) {
  return rect[2] - rect[0] < rect[3] - rect[1] ? 0 : 1;
};
exports.getStaticSideIndex = getStaticSideIndex;
function buildSidesData(rect, directions, _staticSideIndex) {
  const staticSideIndex = _staticSideIndex !== undefined ? _staticSideIndex : getStaticSideIndex(rect);
  const variedSideIndex = 1 - staticSideIndex;
  const staticSideDirection = directions[staticSideIndex];
  const variedSideDirection = directions[variedSideIndex];
  const staticSideIndexOffsets = directionToIndexOffsets[staticSideDirection];
  const variedSideIndexOffsets = directionToIndexOffsets[variedSideDirection];
  return {
    staticSide: rect[2 + staticSideIndex] - rect[staticSideIndex],
    variedSide: rect[2 + variedSideIndex] - rect[variedSideIndex],
    static1: staticSideIndex + staticSideIndexOffsets[0],
    static2: staticSideIndex + staticSideIndexOffsets[1],
    varied1: variedSideIndex + variedSideIndexOffsets[0],
    varied2: variedSideIndex + variedSideIndexOffsets[1],
    staticDir: staticSideDirection,
    variedDir: variedSideDirection
  };
}
function calculateRectangles(nodes, head, totalRect, sidesData, rowData) {
  let i;
  let ii;
  const variedSidePart = [0, 0, 0, 0];
  const static1 = sidesData.static1;
  const static2 = sidesData.static2;
  let position = totalRect[static1];
  const dir = sidesData.staticDir;
  let side = sidesData.staticSide;
  let sum = rowData.sum;
  let rect;
  let delta;
  variedSidePart[sidesData.varied1] = totalRect[sidesData.varied1];
  variedSidePart[sidesData.varied2] = totalRect[sidesData.varied1] + sidesData.variedDir * rowData.side;
  for (i = head, ii = head + rowData.count; i < ii; ++i) {
    rect = variedSidePart.slice();
    rect[static1] = position;
    delta = _round(side * nodes[i].value / sum) || 0;
    sum -= nodes[i].value;
    side -= delta;
    position += dir * delta;
    rect[static2] = position;
    nodes[i].rect = rect;
  }
  totalRect[sidesData.varied1] = variedSidePart[sidesData.varied2];
}

/***/ }),

/***/ 36061:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tiling = __webpack_require__(60642);
const sliceAndDiceAlgorithm = (0, _tiling.getAlgorithm)('sliceanddice');
function rotatedSliceAndDice(data) {
  data.isRotated = !data.isRotated;
  return sliceAndDiceAlgorithm.call(this, data);
}
(0, _tiling.addAlgorithm)('rotatedsliceanddice', rotatedSliceAndDice);

/***/ }),

/***/ 56369:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tiling = __webpack_require__(60642);
function sliceAndDice(data) {
  const items = data.items;
  const sidesData = (0, _tiling.buildSidesData)(data.rect, data.directions, data.isRotated ? 1 : 0);
  (0, _tiling.calculateRectangles)(items, 0, data.rect, sidesData, {
    sum: data.sum,
    count: items.length,
    side: sidesData.variedSide
  });
}
(0, _tiling.addAlgorithm)('sliceanddice', sliceAndDice);
var _default = exports["default"] = sliceAndDice;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 57200:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _tiling = __webpack_require__(60642);
const _max = Math.max;
const _round = Math.round;
function compare(a, b) {
  return b.value - a.value;
}
function getAspectRatio(value) {
  return _max(value, 1 / value);
}
function findAppropriateCollection(nodes, head, context) {
  let bestAspectRatio = Infinity;
  let nextAspectRatio;
  let sum = 0;
  let nextSum;
  let i;
  let j;
  const ii = nodes.length;
  const coeff = context.areaToValue / context.staticSide;
  let totalAspectRatio;
  for (i = head; i < ii;) {
    nextSum = sum + nodes[i].value;
    totalAspectRatio = context.staticSide / coeff / nextSum;
    nextAspectRatio = 0;
    for (j = head; j <= i; ++j) {
      nextAspectRatio = context.accumulate(nextAspectRatio, getAspectRatio(totalAspectRatio * nodes[j].value / nextSum), j - head + 1);
    }
    if (nextAspectRatio < bestAspectRatio) {
      bestAspectRatio = nextAspectRatio;
      sum = nextSum;
      ++i;
    } else {
      break;
    }
  }
  return {
    sum: sum,
    count: i - head,
    side: _round(coeff * sum)
  };
}
function getArea(rect) {
  return (rect[2] - rect[0]) * (rect[3] - rect[1]);
}
function doStep(nodes, head, context) {
  const sidesData = (0, _tiling.buildSidesData)(context.rect, context.directions, context.staticSideIndex);
  const area = getArea(context.rect);
  const rowData = area > 0 ? findAppropriateCollection(nodes, head, {
    areaToValue: area / context.sum,
    accumulate: context.accumulate,
    staticSide: sidesData.staticSide
  }) : {
    sum: 1,
    side: sidesData.variedSide,
    count: nodes.length - head
  };
  (0, _tiling.calculateRectangles)(nodes, head, context.rect, sidesData, rowData);
  context.sum -= rowData.sum;
  return head + rowData.count;
}
function _default(data, accumulate, isFixedStaticSide) {
  const items = data.items;
  const ii = items.length;
  let i;
  const context = {
    sum: data.sum,
    rect: data.rect,
    directions: data.directions,
    accumulate: accumulate
  };
  if (isFixedStaticSide) {
    context.staticSideIndex = (0, _tiling.getStaticSideIndex)(context.rect);
  }
  items.sort(compare);
  for (i = 0; i < ii;) {
    i = doStep(items, i, context);
  }
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 46576:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tilingSquarified = _interopRequireDefault(__webpack_require__(57200));
var _tiling = __webpack_require__(60642);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _max = Math.max;
function accumulate(total, current) {
  return _max(total, current);
}
function squarified(data) {
  return (0, _tilingSquarified.default)(data, accumulate, false);
}
(0, _tiling.addAlgorithm)('squarified', squarified);
var _default = exports["default"] = squarified;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 20957:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tilingSquarified = _interopRequireDefault(__webpack_require__(57200));
var _tiling = __webpack_require__(60642);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function accumulate(total, current, count) {
  return ((count - 1) * total + current) / count;
}
function strip(data) {
  return (0, _tilingSquarified.default)(data, accumulate, true);
}
(0, _tiling.addAlgorithm)('strip', strip);
var _default = exports["default"] = strip;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 2322:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _helpers = __webpack_require__(3603);
var _tree_map = _interopRequireDefault(__webpack_require__(49983));
__webpack_require__(4815);
var _tooltip = __webpack_require__(14371);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const proto = _tree_map.default.prototype;
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  const that = this;
  proto.showTooltip = function (coords) {
    that._showTooltip(this._id, coords);
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  if (this._tooltipIndex >= 0) {
    this._tooltip.hide();
  }
  this._tooltipIndex = -1;
});
(0, _helpers.expand)(proto, '_onTilingPerformed', function () {
  if (this._tooltipIndex >= 0) {
    this._moveTooltip(this._nodes[this._tooltipIndex]);
  }
});
function getCoords(coords, rect, renderer) {
  const offset = renderer.getRootOffset();
  return coords || rect && [(rect[0] + rect[2]) / 2 + offset.left, (rect[1] + rect[3]) / 2 + offset.top] || [-1000, -1000];
}
proto._showTooltip = function (index, coords) {
  const that = this;
  const tooltip = that._tooltip;
  const node = that._nodes[index];
  if (that._tooltipIndex === index) {
    that._moveTooltip(node, coords);
    return;
  }
  const callback = result => {
    if (result === undefined) {
      return;
    }
    if (!result) {
      tooltip.hide();
    }
    that._tooltipIndex = result ? index : -1;
  };
  const xy = getCoords(coords, node.rect, this._renderer);
  callback(tooltip.show({
    value: node.value,
    valueText: tooltip.formatValue(node.value),
    node: node.proxy
  }, {
    x: xy[0],
    y: xy[1],
    offset: 0
  }, {
    node: node.proxy
  }, undefined, callback));
};
proto._moveTooltip = function (node, coords) {
  const xy = getCoords(coords, node.rect, this._renderer);
  this._tooltip.move(xy[0], xy[1], 0);
};
proto.hideTooltip = function () {
  if (this._tooltipIndex >= 0) {
    this._tooltipIndex = -1;
    this._tooltip.hide();
  }
};

// PLUGINS_SECTION\

_tree_map.default.addPlugin(_tooltip.plugin);

/***/ }),

/***/ 66681:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _tracker = __webpack_require__(88997);
var _helpers = __webpack_require__(3603);
var _utils = __webpack_require__(19157);
__webpack_require__(4815);
__webpack_require__(9888);
__webpack_require__(2322);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DATA_KEY_BASE = '__treemap_data_';
let dataKeyModifier = 0;
const proto = _tree_map.default.prototype;
proto._eventsMap.onClick = {
  name: 'click'
};
const getDataKey = function () {
  const dataKey = DATA_KEY_BASE + dataKeyModifier++;
  return dataKey;
};
(0, _helpers.expand)(proto, '_initCore', function () {
  const that = this;
  const dataKey = getDataKey();
  const getProxy = function (index) {
    return that._nodes[index].proxy;
  };
  that._tracker = new _tracker.Tracker({
    widget: that,
    root: that._renderer.root,
    getNode: function (id) {
      const proxy = getProxy(id);
      const interactWithGroup = (0, _utils.parseScalar)(that._getOption('interactWithGroup', true));
      return interactWithGroup && proxy.isLeaf() && proxy.getParent().isActive() ? proxy.getParent() : proxy;
    },
    getData: function (e) {
      const target = e.target;
      return (target.tagName === 'tspan' ? target.parentNode : target)[dataKey];
    },
    getProxy: getProxy,
    click: function (e) {
      that._eventTrigger('click', e);
    }
  });
  that._handlers.setTrackerData = function (node, element) {
    element.data(dataKey, node._id);
  };
});
(0, _helpers.expand)(proto, '_disposeCore', function () {
  this._tracker.dispose();
});

/***/ }),

/***/ 49983:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(77707);
var _node = _interopRequireDefault(__webpack_require__(21168));
var _tiling = __webpack_require__(60642);
var _colorizing = __webpack_require__(19910);
var _utils = __webpack_require__(19157);
var _common2 = __webpack_require__(20576);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
__webpack_require__(46576);
__webpack_require__(66831);
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _max = Math.max;
const directions = {
  'lefttoprightbottom': [+1, +1],
  'leftbottomrighttop': [+1, -1],
  'righttopleftbottom': [-1, +1],
  'rightbottomlefttop': [-1, -1]
};

// At least one algorithm is required.

(0, _tiling.setDefaultAlgorithm)('squarified');

// By design discrete colorizing is used by default.

(0, _colorizing.setDefaultColorizer)('discrete');
function pickPositiveInteger(val) {
  return val > 0 ? Math.round(val) : 0;
}
const dxTreeMap = _m_base_widget.default.inherit({
  _handlers: {
    beginBuildNodes: _common2.noop,
    buildNode: _common2.noop,
    endBuildNodes: _common2.noop,
    setTrackerData: _common2.noop,
    calculateState: function (options) {
      return (0, _common.buildRectAppearance)(options);
    }
  },
  _rootClass: 'dxtm-tree-map',
  _rootClassPrefix: 'dxtm',
  _getDefaultSize: function () {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'treeMap',
  _fontFields: ['tile.label.font', 'group.label.font'],
  _init: function () {
    const that = this;
    that._rectOffsets = {};
    that._handlers = Object.create(that._handlers);
    that._context = {
      suspend: function () {
        if (!that._applyingChanges) {
          that._suspendChanges();
        }
      },
      resume: function () {
        if (!that._applyingChanges) {
          that._resumeChanges();
        }
      },
      change: function (codes) {
        that._change(codes);
      },
      settings: [{}, {}],
      calculateState: that._handlers.calculateState,
      calculateLabelState: _common.buildTextAppearance
    };
    that._root = that._topNode = {
      nodes: []
    };
    that.callBase.apply(that, arguments);
  },
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function () {
    const that = this;
    const renderer = that._renderer;
    that._createProxyType();
    that._tilesGroup = renderer.g().linkOn(renderer.root, 'tiles').linkAppend();
    that._labelsGroup = renderer.g().linkOn(renderer.root, 'labels').linkAppend();
  },
  _createProxyType: _common2.noop,
  _disposeCore: function () {
    const that = this;
    that._filter && that._filter.dispose();
    that._labelsGroup.linkOff();
    that._tilesGroup.linkOff();
  },
  _applySize: function (rect) {
    this._tilingRect = rect.slice();
    this._change(['TILING']);
  },
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    valueField: 'NODES_CREATE',
    childrenField: 'NODES_CREATE',
    colorField: 'TILES',
    colorizer: 'TILES',
    labelField: 'LABELS',
    tile: 'TILE_SETTINGS',
    group: 'GROUP_SETTINGS',
    maxDepth: 'MAX_DEPTH',
    layoutAlgorithm: 'TILING',
    layoutDirection: 'TILING'
  },
  _themeDependentChanges: ['TILE_SETTINGS', 'GROUP_SETTINGS', 'MAX_DEPTH'],
  _changeDataSource: function () {
    const that = this;
    that._isDataExpected = that._isSyncData = true;
    that._updateDataSource();
    that._isSyncData = false;
    if (that._isDataExpected) {
      that._suspendChanges();
    }
  },
  _dataSourceChangedHandler: function () {
    const that = this;
    if (that._isDataExpected) {
      that._isDataExpected = false;
      that._change(['NODES_CREATE']);
      if (!that._isSyncData) {
        that._resumeChanges();
      }
    } else {
      that._requestChange(['NODES_CREATE']);
    }
  },
  _optionChangesOrder: ['DATA_SOURCE', 'TILE_SETTINGS', 'GROUP_SETTINGS', 'MAX_DEPTH'],
  _change_DATA_SOURCE: function () {
    this._changeDataSource();
  },
  _change_TILE_SETTINGS: function () {
    this._changeTileSettings();
  },
  _change_GROUP_SETTINGS: function () {
    this._changeGroupSettings();
  },
  _change_MAX_DEPTH: function () {
    this._changeMaxDepth();
  },
  _customChangesOrder: ['NODES_CREATE', 'NODES_RESET', 'TILES', 'LABELS', 'TILING', 'LABELS_LAYOUT'],
  _change_NODES_CREATE: function () {
    this._buildNodes();
  },
  _change_NODES_RESET: function () {
    this._resetNodes();
  },
  _change_TILES: function () {
    this._applyTilesAppearance();
  },
  _change_LABELS: function () {
    this._applyLabelsAppearance();
  },
  _change_TILING: function () {
    this._performTiling();
  },
  _change_LABELS_LAYOUT: function () {
    this._performLabelsLayout();
  },
  _applyChanges: function () {
    const that = this;
    that.callBase.apply(that, arguments);
    // This looks dirty.
    if (!that._isDataExpected) {
      that._drawn();
    }
    // Looks dirty but let it stay so until there is only one such case.
    that._context.forceReset = false;
  },
  _buildNodes: function () {
    const that = this;
    const root = that._root = that._topNode = new _node.default();
    root._id = 0;
    root.parent = {};
    root.data = {};
    root.level = root.index = -1;
    root.ctx = that._context;
    root.label = null;
    that._nodes = [root];
    that._handlers.beginBuildNodes();
    const processedData = that._processDataSourceItems(that._dataSourceItems() || []);
    traverseDataItems(root, processedData.items, 0, {
      itemsField: !processedData.isPlain && that._getOption('childrenField', true) || 'items',
      valueField: that._getOption('valueField', true) || 'value',
      buildNode: that._handlers.buildNode,
      ctx: that._context,
      nodes: that._nodes
    });
    that._onNodesCreated();
    that._handlers.endBuildNodes();
    that._change(['NODES_RESET']);
  },
  _onNodesCreated: _common2.noop,
  _processDataSourceItems: function (items) {
    return {
      items: items,
      isPlain: false
    };
  },
  _changeTileSettings: function () {
    const that = this;
    const options = that._getOption('tile');
    const offsets = that._rectOffsets;
    const borderWidth = pickPositiveInteger(options.border.width);
    const edgeOffset = borderWidth / 2;
    const innerOffset = borderWidth & 1 ? 0.5 : 0;
    const labelOptions = options.label;
    const settings = that._context.settings[0];
    that._change(['TILES', 'LABELS']);
    settings.state = that._handlers.calculateState(options);
    // TODO: There should be some way (option) to prevent filter creation
    that._filter = that._filter || that._renderer.shadowFilter('-50%', '-50%', '200%', '200%');
    that._filter.attr(labelOptions.shadow);
    that._calculateLabelSettings(settings, labelOptions, that._filter.id);
    if (offsets.tileEdge !== edgeOffset || offsets.tileInner !== innerOffset) {
      offsets.tileEdge = edgeOffset;
      offsets.tileInner = innerOffset;
      that._change(['TILING']);
    }
  },
  _changeGroupSettings: function () {
    const that = this;
    const options = that._getOption('group');
    const labelOptions = options.label;
    const offsets = that._rectOffsets;
    const borderWidth = pickPositiveInteger(options.border.width);
    const edgeOffset = borderWidth / 2;
    const innerOffset = borderWidth & 1 ? 0.5 : 0;
    let headerHeight = 0;
    const groupPadding = pickPositiveInteger(options.padding);
    const settings = that._context.settings[1];
    that._change(['TILES', 'LABELS']);
    settings.state = that._handlers.calculateState(options);
    that._calculateLabelSettings(settings, labelOptions);
    if (options.headerHeight >= 0) {
      headerHeight = pickPositiveInteger(options.headerHeight);
    } else {
      headerHeight = settings.labelParams.height + 2 * pickPositiveInteger(labelOptions.paddingTopBottom);
    }
    if (that._headerHeight !== headerHeight) {
      that._headerHeight = headerHeight;
      that._change(['TILING']);
    }
    if (that._groupPadding !== groupPadding) {
      that._groupPadding = groupPadding;
      that._change(['TILING']);
    }
    if (offsets.headerEdge !== edgeOffset || offsets.headerInner !== innerOffset) {
      offsets.headerEdge = edgeOffset;
      offsets.headerInner = innerOffset;
      that._change(['TILING']);
    }
  },
  _calculateLabelSettings: function (settings, options, filter) {
    const bBox = this._getTextBBox(options.font);
    const paddingLeftRight = pickPositiveInteger(options.paddingLeftRight);
    const paddingTopBottom = pickPositiveInteger(options.paddingTopBottom);
    const tileLabelOptions = this._getOption('tile.label');
    const groupLabelOptions = this._getOption('group.label');
    settings.labelState = (0, _common.buildTextAppearance)(options, filter);
    settings.labelState.visible = !('visible' in options) || !!options.visible;
    settings.labelParams = {
      height: bBox.height,
      rtlEnabled: this._getOption('rtlEnabled', true),
      paddingTopBottom: paddingTopBottom,
      paddingLeftRight: paddingLeftRight,
      tileLabelWordWrap: tileLabelOptions.wordWrap,
      tileLabelOverflow: tileLabelOptions.textOverflow,
      groupLabelOverflow: groupLabelOptions.textOverflow
    };
  },
  _changeMaxDepth: function () {
    let maxDepth = this._getOption('maxDepth', true);
    maxDepth = maxDepth >= 1 ? Math.round(maxDepth) : Infinity;
    if (this._maxDepth !== maxDepth) {
      this._maxDepth = maxDepth;
      this._change(['NODES_RESET']);
    }
  },
  _resetNodes: function () {
    const that = this;
    that._tilesGroup.clear();
    that._renderer.initDefsElements();
    that._context.forceReset = true;
    that._context.minLevel = that._topNode.level + 1;
    that._context.maxLevel = that._context.minLevel + that._maxDepth - 1;
    that._change(['TILES', 'LABELS', 'TILING']);
  },
  _processNodes: function (context, process) {
    processNodes(context, this._topNode, process);
  },
  _applyTilesAppearance: function () {
    const that = this;
    // Passing *themeManager* looks dirty but is excused by necessity of palettes (and default palette specifically).
    // Passing *topNode* looks awfully dirty and is performed only because of discrete group colorizing.
    // Aforementioned colorizing requires breadth-first tree traversal and nodes processing is performed in a depth-first order.
    // TODO: Find a way to stop passing *topNode*
    const colorizer = (0, _colorizing.getColorizer)(that._getOption('colorizer'), that._themeManager, that._topNode);
    that._processNodes({
      renderer: that._renderer,
      group: that._tilesGroup,
      setTrackerData: that._handlers.setTrackerData,
      colorField: that._getOption('colorField', true) || 'color',
      getColor: colorizer
    }, processTileAppearance);
  },
  _applyLabelsAppearance: function () {
    const that = this;
    that._labelsGroup.clear();
    that._processNodes({
      renderer: that._renderer,
      group: that._labelsGroup,
      setTrackerData: that._handlers.setTrackerData,
      labelField: that._getOption('labelField', true) || 'name'
    }, processLabelAppearance);
    // Actually that is strange - for example if just "font.color" is changed then there is no need to layout labels.
    // But for <text> element can change its size because of rather many reasons - so for simplicity layout is always performed.
    that._change(['LABELS_LAYOUT']);
  },
  _performTiling: function () {
    const that = this;
    const context = {
      algorithm: (0, _tiling.getAlgorithm)(that._getOption('layoutAlgorithm', true)),
      directions: directions[String(that._getOption('layoutDirection', true)).toLowerCase()] || directions['lefttoprightbottom'],
      headerHeight: that._headerHeight,
      groupPadding: that._groupPadding,
      rectOffsets: that._rectOffsets
    };
    that._topNode.innerRect = that._tilingRect;
    calculateRects(context, that._topNode);
    that._processNodes(context, processTiling);
    that._change(['LABELS_LAYOUT']);
    that._onTilingPerformed();
  },
  _onTilingPerformed: _common2.noop,
  _performLabelsLayout: function () {
    this._processNodes(null, processLabelsLayout);
  },
  _getTextBBox: function (fontOptions) {
    const renderer = this._renderer;
    const text = this._textForCalculations || renderer.text('0', 0, 0);
    this._textForCalculations = text;
    text.css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);
    const bBox = text.getBBox();
    text.remove();
    return bBox;
  }
});
function traverseDataItems(root, dataItems, level, params) {
  const nodes = [];
  const allNodes = params.nodes;
  let node;
  let i;
  const ii = dataItems.length;
  let dataItem;
  let totalValue = 0;
  let items;
  for (i = 0; i < ii; ++i) {
    var _items;
    dataItem = dataItems[i];
    node = new _node.default();
    node._id = allNodes.length;
    node.ctx = params.ctx;
    node.parent = root;
    node.level = level;
    node.index = nodes.length;
    node.data = dataItem;
    params.buildNode(node);
    allNodes.push(node);
    nodes.push(node);
    items = dataItem[params.itemsField];
    if ((_items = items) !== null && _items !== void 0 && _items.length) {
      traverseDataItems(node, items, level + 1, params);
    }
    if (dataItem[params.valueField] > 0) {
      node.value = Number(dataItem[params.valueField]);
    }
    totalValue += node.value;
  }
  root.nodes = nodes;
  root.value = totalValue;
}
function processNodes(context, root, process) {
  const nodes = root.nodes;
  let node;
  let i;
  const ii = nodes.length;
  for (i = 0; i < ii; ++i) {
    node = nodes[i];
    process(context, node);
    if (node.isNode()) {
      processNodes(context, node, process);
    }
  }
}
const createTile = [createLeaf, createGroup];
function processTileAppearance(context, node) {
  node.color = node.data[context.colorField] || context.getColor(node) || node.parent.color;
  node.updateStyles();
  node.tile = !node.ctx.forceReset && node.tile || createTile[Number(node.isNode())](context, node);
  node.applyState();
}
function createLeaf(context, node) {
  const tile = context.renderer.simpleRect().append(context.group);
  context.setTrackerData(node, tile);
  return tile;
}
function createGroup(context, node) {
  const outer = context.renderer.simpleRect().append(context.group);
  const inner = context.renderer.simpleRect().append(context.group);
  context.setTrackerData(node, inner);
  return {
    outer: outer,
    inner: inner
  };
}
function processLabelAppearance(context, node) {
  node.updateLabelStyle();
  if (node.labelState.visible) {
    createLabel(context, node, node.labelState, node.labelParams);
  }
}
function createLabel(context, currentNode, settings, params) {
  let textData = currentNode.data[context.labelField];
  currentNode.label = textData ? String(textData) : null;
  textData = currentNode.customLabel || currentNode.label;
  if (textData) {
    currentNode.text = context.renderer.text(textData).attr(settings.attr).css(settings.css).append(context.group);
    context.setTrackerData(currentNode, currentNode.text);
  }
}
const emptyRect = [0, 0, 0, 0];
function calculateRects(context, root) {
  const nodes = root.nodes;
  const items = [];
  const rects = [];
  let sum = 0;
  let i;
  const ii = items.length = rects.length = nodes.length;
  for (i = 0; i < ii; ++i) {
    sum += nodes[i].value;
    items[i] = {
      value: nodes[i].value,
      i: i
    };
  }
  if (sum > 0) {
    context.algorithm({
      items: items.slice(),
      sum: sum,
      rect: root.innerRect.slice(),
      isRotated: nodes[0].level & 1,
      directions: context.directions
    });
  }
  for (i = 0; i < ii; ++i) {
    rects[i] = items[i].rect || emptyRect;
  }
  root.rects = rects;
}
function processTiling(context, node) {
  let rect = node.parent.rects[node.index];
  const rectOffsets = context.rectOffsets;
  let headerHeight;
  if (node.isNode()) {
    setRectAttrs(node.tile.outer, buildTileRect(rect, node.parent.innerRect, rectOffsets.headerEdge, rectOffsets.headerInner));
    rect = marginateRect(rect, context.groupPadding);
    headerHeight = Math.min(context.headerHeight, rect[3] - rect[1]);
    node.rect = [rect[0], rect[1], rect[2], rect[1] + headerHeight];
    setRectAttrs(node.tile.inner, marginateRect(node.rect, rectOffsets.headerEdge));
    rect[1] += headerHeight;
    node.innerRect = rect;
    calculateRects(context, node);
  } else {
    node.rect = rect;
    setRectAttrs(node.tile, buildTileRect(rect, node.parent.innerRect, rectOffsets.tileEdge, rectOffsets.tileInner));
  }
}
function marginateRect(rect, margin) {
  return [rect[0] + margin, rect[1] + margin, rect[2] - margin, rect[3] - margin];
}
function buildTileRect(rect, outer, edgeOffset, innerOffset) {
  return [rect[0] + (rect[0] === outer[0] ? edgeOffset : +innerOffset), rect[1] + (rect[1] === outer[1] ? edgeOffset : +innerOffset), rect[2] - (rect[2] === outer[2] ? edgeOffset : -innerOffset), rect[3] - (rect[3] === outer[3] ? edgeOffset : -innerOffset)];
}
function setRectAttrs(element, rect) {
  element.attr({
    x: rect[0],
    y: rect[1],
    width: _max(rect[2] - rect[0], 0),
    height: _max(rect[3] - rect[1], 0)
  });
}
function processLabelsLayout(context, node) {
  if (node.text && node.labelState.visible) {
    layoutTextNode(node, node.labelParams);
  }
}
function layoutTextNode(node, params) {
  const rect = node.rect;
  const text = node.text;
  const bBox = text.getBBox();
  const paddingLeftRight = params.paddingLeftRight;
  const paddingTopBottom = params.paddingTopBottom;
  const effectiveWidth = rect[2] - rect[0] - 2 * paddingLeftRight;
  text.setMaxSize(effectiveWidth, rect[3] - rect[1] - paddingTopBottom, node.isNode() ? {
    textOverflow: params.groupLabelOverflow,
    wordWrap: 'none'
  } : {
    textOverflow: params.tileLabelOverflow,
    wordWrap: params.tileLabelWordWrap,
    hideOverflowEllipsis: true
  });
  text.move(params.rtlEnabled ? rect[2] - paddingLeftRight - bBox.x - bBox.width : rect[0] + paddingLeftRight - bBox.x, rect[1] + paddingTopBottom - bBox.y);
}
(0, _component_registrator.default)('dxTreeMap', dxTreeMap);
var _default = exports["default"] = dxTreeMap; // PLUGINS_SECTION
dxTreeMap.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 4080:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tree_map = _interopRequireDefault(__webpack_require__(49983));
__webpack_require__(46576);
__webpack_require__(20957);
__webpack_require__(56369);
__webpack_require__(36061);
__webpack_require__(66831);
__webpack_require__(13652);
__webpack_require__(73675);
__webpack_require__(4815);
__webpack_require__(9888);
__webpack_require__(13099);
__webpack_require__(2322);
__webpack_require__(66681);
__webpack_require__(61104);
__webpack_require__(74958);
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _loading_indicator = __webpack_require__(64758);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _tree_map.default; // PLUGINS_SECTION
_tree_map.default.addPlugin(_export.plugin);
_tree_map.default.addPlugin(_title.plugin);
_tree_map.default.addPlugin(_loading_indicator.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 34434:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.prepareSegmentRectPoints = exports.floorCanvasDimensions = exports.areCanvasesDifferent = void 0;
Object.defineProperty(exports, "refreshPaths", ({
  enumerable: true,
  get: function () {
    return _renderer.refreshPaths;
  }
}));
var _renderer = __webpack_require__(56453);
var _iterator = __webpack_require__(95479);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const {
  floor
} = Math;
let prepareSegmentRectPoints = function (left, top, width, height, borderOptions) {
  const maxSW = ~~((width < height ? width : height) / 2);
  const sw = borderOptions.width || 0;
  const newSW = sw < maxSW ? sw : maxSW;
  left = left + newSW / 2;
  top = top + newSW / 2;
  width = width - newSW;
  height = height - newSW;
  const right = left + width;
  const bottom = top + height;
  let points = [];
  let segments = [];
  let segmentSequence;
  let visiblyOpt = 0;
  let prevSegmentVisibility = 0;
  const allSegment = {
    top: [[left, top], [right, top]],
    right: [[right, top], [right, bottom]],
    bottom: [[right, bottom], [left, bottom]],
    left: [[left, bottom], [left, top]]
  };
  (0, _iterator.each)(allSegment, function (seg) {
    const visibility = !!borderOptions[seg];
    visiblyOpt = visiblyOpt * 2 + ~~visibility;
  });
  switch (visiblyOpt) {
    case 13:
    case 9:
      segmentSequence = ['left', 'top', 'right', 'bottom'];
      break;
    case 11:
      segmentSequence = ['bottom', 'left', 'top', 'right'];
      break;
    default:
      segmentSequence = ['top', 'right', 'bottom', 'left'];
  }
  (0, _iterator.each)(segmentSequence, function (_, seg) {
    const segmentVisibility = !!borderOptions[seg];
    if (!prevSegmentVisibility && segments.length) {
      points.push(segments);
      segments = [];
    }
    if (segmentVisibility) {
      (0, _iterator.each)(allSegment[seg].slice(prevSegmentVisibility), function (_, segment) {
        segments = segments.concat(segment);
      });
    }
    prevSegmentVisibility = ~~segmentVisibility;
  });
  segments.length && points.push(segments);
  points.length === 1 && (points = points[0]);
  return {
    points: points,
    pathType: visiblyOpt === 15 ? 'area' : 'line'
  };
};
exports.prepareSegmentRectPoints = prepareSegmentRectPoints;
const areCanvasesDifferent = function (canvas1, canvas2) {
  const sizeChangingThreshold = 1;
  const sizeLessThreshold = ['width', 'height'].every(key => Math.abs(canvas1[key] - canvas2[key]) < sizeChangingThreshold);
  const canvasCoordsIsEqual = ['left', 'right', 'top', 'bottom'].every(key => canvas1[key] === canvas2[key]);
  return !(sizeLessThreshold && canvasCoordsIsEqual);
};
exports.areCanvasesDifferent = areCanvasesDifferent;
const floorCanvasDimensions = function (canvas) {
  return _extends({}, canvas, {
    height: floor(canvas.height),
    width: floor(canvas.width)
  });
};
exports.floorCanvasDimensions = floorCanvasDimensions;

/***/ }),

/***/ 81849:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _vector_map = _interopRequireDefault(__webpack_require__(13711));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports["default"] = _vector_map.default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 17323:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ControlBar = ControlBar;
var _utils = __webpack_require__(19157);
var _utils2 = __webpack_require__(77891);
const _math = Math;
const _min = _math.min;
const _max = _math.max;
const _round = _math.round;
const _floor = _math.floor;
const _sqrt = _math.sqrt;
const parseHorizontalAlignment = (0, _utils.enumParser)(['left', 'center', 'right']);
const parseVerticalAlignment = (0, _utils.enumParser)(['top', 'bottom']);
const COMMAND_RESET = 'command-reset';
const COMMAND_MOVE_UP = 'command-move-up';
const COMMAND_MOVE_RIGHT = 'command-move-right';
const COMMAND_MOVE_DOWN = 'command-move-down';
const COMMAND_MOVE_LEFT = 'command-move-left';
const COMMAND_ZOOM_IN = 'command-zoom-in';
const COMMAND_ZOOM_OUT = 'command-zoom-out';
const COMMAND_ZOOM_DRAG_LINE = 'command-zoom-drag-line';
const COMMAND_ZOOM_DRAG = 'command-zoom-drag';
const EVENT_TARGET_TYPE = 'control-bar';
const FLAG_CENTERING = 1;
const FLAG_ZOOMING = 2;

// TODO: This should be specified in options - seems like everything can be calculated from "buttonSize" and "zoomSliderLength"
const SIZE_OPTIONS = {
  bigCircleSize: 58,
  smallCircleSize: 28,
  buttonSize: 10,
  arrowButtonOffset: 20,
  incDecButtonSize: 11,
  incButtonOffset: 66,
  decButtonOffset: 227,
  sliderLineStartOffset: 88.5,
  sliderLineEndOffset: 205.5,
  sliderLength: 20,
  sliderWidth: 8,
  trackerGap: 4
};
const OFFSET_X = 30.5;
const OFFSET_Y = 30.5;
const TOTAL_WIDTH = 61;
const TOTAL_HEIGHT = 274;
let COMMAND_TO_TYPE_MAP = {};
COMMAND_TO_TYPE_MAP[COMMAND_RESET] = ResetCommand;
COMMAND_TO_TYPE_MAP[COMMAND_MOVE_UP] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_RIGHT] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_DOWN] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_LEFT] = MoveCommand;
COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_IN] = COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_OUT] = ZoomCommand;
COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_DRAG] = ZoomDragCommand;
function ControlBar(parameters) {
  const that = this;
  that._params = parameters;
  that._createElements(parameters.renderer, parameters.container, parameters.dataKey);
  parameters.layoutControl.addItem(that);
  that._subscribeToProjection(parameters.projection);
  that._subscribeToTracker(parameters.tracker);
  that._createCallbacks(parameters.projection);
}
ControlBar.prototype = {
  constructor: ControlBar,
  _flags: 0,
  dispose: function () {
    const that = this;
    that._params.layoutControl.removeItem(that);
    that._root.linkRemove().linkOff();
    that._offProjection();
    that._offTracker();
    that._params = that._root = that._offProjection = that._offTracker = that._callbacks = null;
  },
  _subscribeToProjection: function (projection) {
    const that = this;
    that._offProjection = projection.on({
      'engine': function () {
        that._update();
      },
      'zoom': updateZoom,
      'max-zoom': function () {
        that._zoomPartition = projection.getZoomScalePartition();
        that._sliderUnitLength = that._sliderLineLength / that._zoomPartition;
        updateZoom();
      }
    });
    function updateZoom() {
      that._adjustZoom(projection.getScaledZoom());
    }
  },
  _subscribeToTracker: function (tracker) {
    const that = this;
    let isActive = false;
    that._offTracker = tracker.on({
      'start': function (arg) {
        isActive = arg.data.name === EVENT_TARGET_TYPE;
        if (isActive) {
          that._processStart(arg.data.index, arg);
        }
      },
      'move': function (arg) {
        if (isActive) {
          that._processMove(arg.data.index, arg);
        }
      },
      'end': function () {
        if (isActive) {
          that._processEnd();
          isActive = false;
        }
      }
    });
  },
  _createCallbacks: function (projection) {
    const that = this;
    that._callbacks = {
      reset: function (isCenter, isZoom) {
        if (isCenter) {
          projection.setCenter(null);
        }
        if (isZoom) {
          projection.setZoom(null);
        }
      },
      beginMove: function () {
        projection.beginMoveCenter();
      },
      endMove: function () {
        projection.endMoveCenter();
      },
      move: function (shift) {
        projection.moveCenter(shift);
      },
      zoom: function (zoom) {
        projection.setScaledZoom(zoom);
      }
    };
  },
  _createElements: function (renderer, container, dataKey) {
    const that = this;
    that._root = renderer.g().attr({
      'class': 'dxm-control-bar'
    }).linkOn(container, 'control-bar');
    const panControl = that._panControl = (0, _utils2.createVisibilityGroup)(renderer, that._root, 'dxm-pan-control');
    const zoomBar = that._zoomBar = (0, _utils2.createVisibilityGroup)(renderer, that._root, 'dxm-zoom-bar');
    const trackersPan = that._trackersPan = (0, _utils2.createTracker)(renderer, that._root);
    const trackersZoom = that._trackersZoom = (0, _utils2.createTracker)(renderer, that._root);
    that._createTrackersPan(renderer, dataKey, trackersPan);
    that._createTrackersZoom(renderer, dataKey, trackersZoom);
    that._createPanControl(renderer, dataKey, panControl);
    that._createZoomBar(renderer, dataKey, zoomBar);
  },
  _createPanControl: function (renderer, dataKey, group) {
    const options = SIZE_OPTIONS;
    const size = options.buttonSize / 2;
    const offset1 = options.arrowButtonOffset - size;
    const offset2 = options.arrowButtonOffset;
    const directionOptions = {
      'stroke-linecap': 'square',
      fill: 'none'
    };
    const line = 'line';
    renderer.circle(0, 0, options.bigCircleSize / 2).append(group);
    renderer.circle(0, 0, size).attr({
      fill: 'none'
    }).append(group);
    renderer.path([-size, -offset1, 0, -offset2, size, -offset1], line).attr(directionOptions).append(group);
    renderer.path([offset1, -size, offset2, 0, offset1, size], line).attr(directionOptions).append(group);
    renderer.path([size, offset1, 0, offset2, -size, offset1], line).attr(directionOptions).append(group);
    renderer.path([-offset1, size, -offset2, 0, -offset1, -size], line).attr(directionOptions).append(group);
  },
  _createZoomBar: function (renderer, dataKey, group) {
    const that = this;
    const options = SIZE_OPTIONS;
    const incDecButtonSize = options.incDecButtonSize / 2;
    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).append(group);
    renderer.path([[-incDecButtonSize, options.incButtonOffset, incDecButtonSize, options.incButtonOffset], [0, options.incButtonOffset - incDecButtonSize, 0, options.incButtonOffset + incDecButtonSize]], 'area').append(group);
    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).append(group);
    renderer.path([-incDecButtonSize, options.decButtonOffset, incDecButtonSize, options.decButtonOffset], 'area').append(group);
    that._zoomLine = renderer.path([], 'line').append(group);
    that._zoomDrag = renderer.rect(_floor(-options.sliderLength / 2), _floor(options.sliderLineEndOffset - options.sliderWidth / 2), options.sliderLength, options.sliderWidth).append(group);
    that._sliderLineLength = options.sliderLineEndOffset - options.sliderLineStartOffset;
  },
  _createTrackersPan: function (renderer, dataKey, group) {
    const options = SIZE_OPTIONS;
    const size = _round((options.arrowButtonOffset - options.trackerGap) / 2);
    const offset1 = options.arrowButtonOffset - size;
    const offset2 = _round(_sqrt(options.bigCircleSize * options.bigCircleSize / 4 - size * size));
    const size2 = offset2 - offset1;
    renderer.rect(-size, -size, size * 2, size * 2).data(dataKey, {
      index: COMMAND_RESET,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-size, -offset2, size * 2, size2).data(dataKey, {
      index: COMMAND_MOVE_UP,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(offset1, -size, size2, size * 2).data(dataKey, {
      index: COMMAND_MOVE_RIGHT,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-size, offset1, size * 2, size2).data(dataKey, {
      index: COMMAND_MOVE_DOWN,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-offset2, -size, size2, size * 2).data(dataKey, {
      index: COMMAND_MOVE_LEFT,
      name: EVENT_TARGET_TYPE
    }).append(group);
  },
  _createTrackersZoom: function (renderer, dataKey, group) {
    const options = SIZE_OPTIONS;
    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).data(dataKey, {
      index: COMMAND_ZOOM_IN,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).data(dataKey, {
      index: COMMAND_ZOOM_OUT,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-2, options.sliderLineStartOffset - 2, 4, options.sliderLineEndOffset - options.sliderLineStartOffset + 4).css({
      cursor: 'default'
    }).data(dataKey, {
      index: COMMAND_ZOOM_DRAG_LINE,
      name: EVENT_TARGET_TYPE
    }).append(group);
    this._zoomDragTracker = renderer.rect(-options.sliderLength / 2, options.sliderLineEndOffset - options.sliderWidth / 2, options.sliderLength, options.sliderWidth).data(dataKey, {
      index: COMMAND_ZOOM_DRAG,
      name: EVENT_TARGET_TYPE
    }).append(group);
  },
  // BEGIN: Implementation of LayoutTarget interface
  resize: function (size) {
    if (this._isActive) {
      this._root.attr({
        visibility: size !== null ? null : 'hidden'
      });
    }
  },
  getLayoutOptions: function () {
    return this._isActive ? this._layoutOptions : null;
  },
  locate: function (x, y) {
    this._root.attr({
      translateX: x + this._margin + OFFSET_X,
      translateY: y + this._margin + OFFSET_Y
    });
  },
  // END: Implementation of LayoutTarget interface

  _update: function () {
    const that = this;
    that._isActive = that._isEnabled && that._flags && that._params.projection.isInvertible();
    const groupPan = [that._panControl, that._trackersPan];
    const groupZoom = [that._zoomBar, that._trackersZoom];
    if (that._isActive) {
      that._root.linkAppend();
      (0, _utils2.toggleDisplay)(groupPan, that._isPanVisible);
      (0, _utils2.toggleDisplay)(groupZoom, that._isZoomVisible);
    } else {
      that._root.linkRemove();
    }
    that._processEnd();
    that.updateLayout();
  },
  setInteraction: function (interaction) {
    const that = this;
    if ((0, _utils.parseScalar)(interaction.centeringEnabled, true)) {
      that._flags |= FLAG_CENTERING;
    } else {
      that._flags &= ~FLAG_CENTERING;
    }
    if ((0, _utils.parseScalar)(interaction.zoomingEnabled, true)) {
      that._flags |= FLAG_ZOOMING;
    } else {
      that._flags &= ~FLAG_ZOOMING;
    }
    that._update();
  },
  setOptions: function (options) {
    const that = this;
    const styleSvg = {
      'stroke-width': options.borderWidth,
      stroke: options.borderColor,
      fill: options.color,
      'fill-opacity': options.opacity
    };
    that._isEnabled = !!(0, _utils.parseScalar)(options.enabled, true);
    that._margin = options.margin || 0;
    that._layoutOptions = {
      width: 2 * that._margin + TOTAL_WIDTH,
      height: 2 * that._margin + TOTAL_HEIGHT,
      horizontalAlignment: parseHorizontalAlignment(options.horizontalAlignment, 'left'),
      verticalAlignment: parseVerticalAlignment(options.verticalAlignment, 'top')
    };
    that._isPanVisible = !!(0, _utils.parseScalar)(options.panVisible, true);
    that._isZoomVisible = !!(0, _utils.parseScalar)(options.zoomVisible, true);
    that._panControl.attr(styleSvg);
    that._zoomBar.attr(styleSvg);
    that._update();
  },
  _adjustZoom: function (zoom) {
    const that = this;
    const start = SIZE_OPTIONS.sliderLineStartOffset;
    const end = SIZE_OPTIONS.sliderLineEndOffset;
    const h = SIZE_OPTIONS.sliderWidth;
    that._zoomFactor = _max(_min(_round(zoom), that._zoomPartition), 0);
    const transform = {
      translateY: -_round(that._zoomFactor * that._sliderUnitLength)
    };
    const y = end - h / 2 + transform.translateY;
    that._zoomLine.attr({
      points: [[0, start, 0, _max(start, y)], [0, _min(end, y + h), 0, end]]
    });
    that._zoomDrag.attr(transform);
    that._zoomDragTracker.attr(transform);
  },
  _applyZoom: function () {
    this._callbacks.zoom(this._zoomFactor);
  },
  _processStart: function (command, arg) {
    let commandType;
    if (this._isActive) {
      commandType = COMMAND_TO_TYPE_MAP[command];
      this._command = commandType && commandType.flags & this._flags ? new commandType(this, command, arg) : null;
    }
  },
  _processMove: function (command, arg) {
    this._command && this._command.update(command, arg);
  },
  _processEnd: function () {
    this._command && this._command.finish();
    this._command = null;
  }
};
function disposeCommand(command) {
  delete command._owner;
  command.update = function () {};
  command.finish = function () {};
}
function ResetCommand(owner, command) {
  this._owner = owner;
  this._command = command;
}
ResetCommand.flags = FLAG_CENTERING | FLAG_ZOOMING;
ResetCommand.prototype.update = function (command) {
  command !== this._command && disposeCommand(this);
};
ResetCommand.prototype.finish = function () {
  const flags = this._owner._flags;
  this._owner._callbacks.reset(!!(flags & FLAG_CENTERING), !!(flags & FLAG_ZOOMING));
  disposeCommand(this);
};
function MoveCommand(owner, command, arg) {
  this._command = command;
  let timeout = null;
  const interval = 100;
  let dx = 0;
  let dy = 0;
  switch (this._command) {
    case COMMAND_MOVE_UP:
      dy = -10;
      break;
    case COMMAND_MOVE_RIGHT:
      dx = 10;
      break;
    case COMMAND_MOVE_DOWN:
      dy = 10;
      break;
    case COMMAND_MOVE_LEFT:
      dx = -10;
      break;
  }
  function callback() {
    owner._callbacks.move([dx, dy]);
    timeout = setTimeout(callback, interval);
  }
  this._stop = function () {
    clearTimeout(timeout);
    owner._callbacks.endMove();
    this._stop = owner = null;
    return this;
  };
  arg = null;
  owner._callbacks.beginMove();
  callback();
}
MoveCommand.flags = FLAG_CENTERING;
MoveCommand.prototype.update = function (command) {
  this._command !== command && this.finish();
};
MoveCommand.prototype.finish = function () {
  disposeCommand(this._stop());
};
function ZoomCommand(owner, command) {
  this._owner = owner;
  this._command = command;
  let timeout = null;
  const interval = 150;
  const dZoom = this._command === COMMAND_ZOOM_IN ? 1 : -1;
  function callback() {
    owner._adjustZoom(owner._zoomFactor + dZoom);
    timeout = setTimeout(callback, interval);
  }
  this._stop = function () {
    clearTimeout(timeout);
    this._stop = owner = null;
    return this;
  };
  callback();
}
ZoomCommand.flags = FLAG_ZOOMING;
ZoomCommand.prototype.update = function (command) {
  this._command !== command && this.finish();
};
ZoomCommand.prototype.finish = function () {
  this._owner._applyZoom();
  disposeCommand(this._stop());
};
function ZoomDragCommand(owner, command, arg) {
  this._owner = owner;
  this._zoomFactor = owner._zoomFactor;
  this._pos = arg.y;
}
ZoomDragCommand.flags = FLAG_ZOOMING;
ZoomDragCommand.prototype.update = function (command, arg) {
  const owner = this._owner;
  owner._adjustZoom(this._zoomFactor + owner._zoomPartition * (this._pos - arg.y) / owner._sliderLineLength);
};
ZoomDragCommand.prototype.finish = function () {
  this._owner._applyZoom();
  disposeCommand(this);
};

/***/ }),

/***/ 77891:
/***/ (function(__unused_webpack_module, exports) {



exports.toggleDisplay = exports.createVisibilityGroup = exports.createTracker = void 0;
const createTracker = (renderer, root) => renderer.g().attr({
  stroke: 'none',
  'stroke-width': 0,
  fill: '#000000',
  opacity: 0.0001
}).css({
  cursor: 'pointer'
}).append(root);
exports.createTracker = createTracker;
const createVisibilityGroup = function (renderer, root) {
  let className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return renderer.g().attr({
    'class': className
  }).append(root);
};
exports.createVisibilityGroup = createVisibilityGroup;
const toggleDisplay = (blocks, isVisible) => {
  const cssDisplayBlock = {
    display: 'block'
  };
  const cssDisplayNone = {
    display: 'none'
  };
  const style = isVisible ? cssDisplayBlock : cssDisplayNone;
  blocks.map(item => item.css(style));
};
exports.toggleDisplay = toggleDisplay;

/***/ }),

/***/ 93699:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.DataExchanger = DataExchanger;
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function DataExchanger() {
  this._store = {};
}
DataExchanger.prototype = {
  constructor: DataExchanger,
  dispose: function () {
    this._store = null;
    return this;
  },
  _get: function (category, name) {
    const store = this._store[category] || (this._store[category] = {});
    return store[name] || (store[name] = {
      callbacks: (0, _callbacks.default)()
    });
  },
  set: function (category, name, data) {
    const item = this._get(category, name);
    item.data = data;
    item.callbacks.fire(data);
    return this;
  },
  bind: function (category, name, callback) {
    const item = this._get(category, name);
    item.callbacks.add(callback);
    item.data && callback(item.data);
    return this;
  },
  unbind: function (category, name, callback) {
    const item = this._get(category, name);
    item.callbacks.remove(callback);
    return this;
  }
};

/***/ }),

/***/ 63832:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.makeEventEmitter = makeEventEmitter;
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const eventEmitterMethods = {
  _initEvents: function () {
    const names = this._eventNames;
    let i;
    const ii = names.length;
    const events = this._events = {};
    for (i = 0; i < ii; ++i) {
      events[names[i]] = (0, _callbacks.default)();
    }
  },
  _disposeEvents: function () {
    const events = this._events;
    let name;
    for (name in events) {
      events[name].empty();
    }
    this._events = null;
  },
  on: function (handlers) {
    const events = this._events;
    let name;
    for (name in handlers) {
      events[name].add(handlers[name]);
    }
    return dispose;
    function dispose() {
      for (name in handlers) {
        events[name].remove(handlers[name]);
      }
    }
  },
  _fire: function (name, arg) {
    this._events[name].fire(arg);
  }
};
function makeEventEmitter(target) {
  const proto = target.prototype;
  let name;
  for (name in eventEmitterMethods) {
    proto[name] = eventEmitterMethods[name];
  }
}

/***/ }),

/***/ 3797:
/***/ (function(__unused_webpack_module, exports) {



exports.GestureHandler = GestureHandler;
const _ln = Math.log;
const _LN2 = Math.LN2;
function GestureHandler(params) {
  const that = this;
  that._projection = params.projection;
  that._renderer = params.renderer;
  that._x = that._y = 0;
  that._subscribeToTracker(params.tracker);
}
GestureHandler.prototype = {
  constructor: GestureHandler,
  dispose: function () {
    this._offTracker();
    this._offTracker = null;
  },
  _subscribeToTracker: function (tracker) {
    const that = this;
    let isActive = false;
    that._offTracker = tracker.on({
      'start': function (arg) {
        // TODO: This is an implicit dependency on the ControlBar which must be removed
        isActive = arg.data.name !== 'control-bar';
        if (isActive) {
          that._processStart(arg);
        }
      },
      'move': function (arg) {
        if (isActive) {
          that._processMove(arg);
        }
      },
      'end': function () {
        if (isActive) {
          that._processEnd();
        }
      },
      'zoom': function (arg) {
        that._processZoom(arg);
      }
    });
  },
  setInteraction: function (options) {
    this._processEnd();
    this._centeringEnabled = options.centeringEnabled;
    this._zoomingEnabled = options.zoomingEnabled;
  },
  _processStart: function (arg) {
    if (this._centeringEnabled) {
      this._x = arg.x;
      this._y = arg.y;
      this._projection.beginMoveCenter();
    }
  },
  _processMove: function (arg) {
    const that = this;
    if (that._centeringEnabled) {
      that._renderer.root.attr({
        cursor: 'move'
      });
      that._projection.moveCenter([that._x - arg.x, that._y - arg.y]);
      that._x = arg.x;
      that._y = arg.y;
    }
  },
  _processEnd: function () {
    if (this._centeringEnabled) {
      this._renderer.root.attr({
        cursor: 'default'
      });
      this._projection.endMoveCenter();
    }
  },
  _processZoom: function (arg) {
    const that = this;
    let delta;
    let screenPosition;
    let coords;
    if (that._zoomingEnabled) {
      if (arg.delta) {
        delta = arg.delta;
      } else if (arg.ratio) {
        delta = _ln(arg.ratio) / _LN2;
      }
      if (that._centeringEnabled) {
        screenPosition = that._renderer.getRootOffset();
        screenPosition = [arg.x - screenPosition.left, arg.y - screenPosition.top];
        coords = that._projection.fromScreenPoint(screenPosition);
      }
      that._projection.changeScaledZoom(delta);
      if (that._centeringEnabled) {
        that._projection.setCenterByPoint(coords, screenPosition);
      }
    }
  }
};

/***/ }),

/***/ 39378:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.LayoutControl = LayoutControl;
var _iterator = __webpack_require__(95479);
const _round = Math.round;
const _min = Math.min;
const _max = Math.max;
const _each = _iterator.each;
const horizontalAlignmentMap = {
  'left': 0,
  'center': 1,
  'right': 2
};
const verticalAlignmentMap = {
  'top': 0,
  'bottom': 1
};
function getCellIndex(options) {
  return verticalAlignmentMap[options.verticalAlignment] * 3 + horizontalAlignmentMap[options.horizontalAlignment];
}
function createCells(canvas, items) {
  const hStep = (canvas.right - canvas.left) / 3;
  const vStep = (canvas.bottom - canvas.top) / 2;
  const h1 = canvas.left;
  const h2 = _round(h1 + hStep);
  const h3 = _round(h1 + hStep + hStep);
  const h4 = canvas.right;
  const v1 = canvas.top;
  const v2 = _round(v1 + vStep);
  const v3 = canvas.bottom;
  const cells = [{
    rect: [h1, v1, h2, v2]
  }, {
    rect: [h2, v1, h3, v2],
    center: true
  }, {
    rect: [h3, v1, h4, v2],
    horInversion: true
  }, {
    rect: [h1, v2, h2, v3],
    verInversion: true
  }, {
    rect: [h2, v2, h3, v3],
    center: true,
    verInversion: true
  }, {
    rect: [h3, v2, h4, v3],
    horInversion: true,
    verInversion: true
  }];
  const itemsList = [[], [], [], [], [], []];
  _each(items, function (_, item) {
    const options = item.getLayoutOptions();
    if (options) {
      itemsList[getCellIndex(options)].push({
        item: item,
        width: options.width,
        height: options.height
      });
    }
  });
  _each(cells, function (i, cell) {
    if (itemsList[i].length) {
      cell.items = itemsList[i];
    } else {
      if (cell.center) {
        cell.rect[0] = cell.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;
      } else {
        cell.rect[cell.horInversion ? 0 : 2] = cell.rect[cell.horInversion ? 2 : 0];
      }
      cell.rect[cell.verInversion ? 1 : 3] = cell.rect[cell.verInversion ? 3 : 1];
    }
  });
  return cells;
}
function adjustCellSizes(cells) {
  _each([0, 1, 2, 3, 4, 5], function (_, index) {
    const cell = cells[index];
    const otherCell = cells[(index + 3) % 6];
    if (cell.items) {
      if (!otherCell.items) {
        cell.rect[1] = _min(cell.rect[1], otherCell.rect[3]);
        cell.rect[3] = _max(cell.rect[3], otherCell.rect[1]);
      }
    }
  });
  _each([1, 4], function (_, index) {
    const cell = cells[index];
    const otherCell1 = cells[index - 1];
    const otherCell2 = cells[index + 1];
    let size1;
    let size2;
    if (cell.items) {
      if (!otherCell1.items && !otherCell2.items) {
        size1 = cell.rect[0] - otherCell1.rect[2];
        size2 = otherCell2.rect[0] - cell.rect[2];
        if (size1 > size2) {
          if (size1 / size2 >= 2) {
            cell.rect[0] -= size1;
            cell.right = true;
          } else {
            cell.rect[0] -= size2;
            cell.rect[2] += size2;
          }
        } else {
          if (size2 / size1 >= 2) {
            cell.rect[2] += size2;
            cell.center = null;
          } else {
            cell.rect[0] -= size1;
            cell.rect[2] += size1;
          }
        }
      }
    } else {
      if (otherCell1.items) {
        otherCell1.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;
      }
      if (otherCell2.items) {
        otherCell2.rect[0] = (cell.rect[0] + cell.rect[2]) / 2;
      }
    }
  });
}
function adjustCellsAndApplyLayout(cells, forceMode) {
  let hasHiddenItems = false;
  adjustCellSizes(cells);
  _each(cells, function (_, cell) {
    if (cell.items) {
      hasHiddenItems = applyCellLayout(cell, forceMode) || hasHiddenItems;
    }
  });
  return hasHiddenItems;
}
function applyCellLayout(cell, forceMode) {
  const cellRect = cell.rect;
  const cellWidth = cellRect[2] - cellRect[0];
  const cellHeight = cellRect[3] - cellRect[1];
  let xOffset = 0;
  let yOffset = 0;
  let currentHeight = 0;
  let totalL = cellRect[2];
  let totalT = cellRect[3];
  let totalR = cellRect[0];
  let totalB = cellRect[1];
  const moves = [];
  let hasHiddenItems = false;
  _each(cell.items, function (_, item) {
    if (item.width > cellWidth || item.height > cellHeight) {
      moves.push(null);
      hasHiddenItems = true;
      return forceMode || false;
    }
    if (xOffset + item.width > cellWidth) {
      yOffset += currentHeight;
      xOffset = currentHeight = 0;
    }
    if (yOffset + item.height > cellHeight) {
      moves.push(null);
      hasHiddenItems = true;
      return forceMode || false;
    }
    currentHeight = _max(currentHeight, item.height);
    const dx = cell.horInversion ? cellRect[2] - item.width - xOffset : cellRect[0] + xOffset;
    const dy = cell.verInversion ? cellRect[3] - item.height - yOffset : cellRect[1] + yOffset;
    xOffset += item.width;
    totalL = _min(totalL, dx);
    totalT = _min(totalT, dy);
    totalR = _max(totalR, dx + item.width);
    totalB = _max(totalB, dy + item.height);
    moves.push([dx, dy]);
  });
  if (forceMode || !hasHiddenItems) {
    xOffset = 0;
    if (cell.right) {
      xOffset = cellRect[2] - cellRect[0] - totalR + totalL;
    } else if (cell.center) {
      xOffset = _round((cellRect[2] - cellRect[0] - totalR + totalL) / 2);
    }
    _each(cell.items, function (i, item) {
      const move = moves[i];
      if (move) {
        item.item.locate(move[0] + xOffset, move[1]);
      } else {
        item.item.resize(null);
      }
    });
    cell.rect = [totalL, totalT, totalR, totalB];
    cell.items = null;
  }
  return hasHiddenItems;
}
function applyLayout(canvas, items) {
  const cells = createCells(canvas, items);
  if (adjustCellsAndApplyLayout(cells)) {
    adjustCellsAndApplyLayout(cells, true);
  }
}
function LayoutControl(widget) {
  const that = this;
  that._items = [];
  that._suspended = 0;
  that._widget = widget;
  that._updateLayout = function () {
    that._update();
  };
}
LayoutControl.prototype = {
  constructor: LayoutControl,
  dispose: function () {
    this._items = this._updateLayout = null;
  },
  setSize: function (canvas) {
    this._canvas = canvas;
    this._update();
  },
  suspend: function () {
    ++this._suspended;
  },
  resume: function () {
    if (--this._suspended === 0) {
      this._update();
    }
  },
  // It should return callback (update trigger) instead of injecting the argument
  addItem: function (item) {
    this._items.push(item);
    item.updateLayout = this._updateLayout;
  },
  removeItem: function (item) {
    const index = this._items.indexOf(item);
    this._items.splice(index, 1);
    item.updateLayout = null;
  },
  _update: function () {
    let canvas;
    if (this._suspended === 0) {
      canvas = this._canvas;
      _each(this._items, function (_, item) {
        item.resize(canvas);
      });
      this._widget.resolveItemsDeferred(this._items.filter(el => el.getTemplatesGroups && el.getTemplatesDef));
      applyLayout({
        left: canvas.left,
        top: canvas.top,
        right: canvas.width + canvas.left,
        bottom: canvas.height + canvas.top
      }, this._items);
    }
  }
};

/***/ }),

/***/ 7291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.LegendsControl = LegendsControl;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _object = __webpack_require__(48013);
var _legend = __webpack_require__(16342);
const _extend = _extend2.extend;
const _each = _iterator.each;
const unknownSource = {
  category: 'UNKNOWN',
  name: 'UNKNOWN'
};
function buildData(partition, values, field) {
  let i;
  const ii = values.length;
  const list = [];
  let item;
  for (i = 0; i < ii; ++i) {
    list[i] = item = {
      start: partition[i],
      end: partition[i + 1],
      index: i
    };
    item[field] = values[i];
    item.states = {
      normal: {
        fill: item.color
      }
    };
    item.visible = true;
  }
  return list;
}

// 'var' because JSHint throws W021 error
let Legend = function (parameters) {
  const that = this;
  that._params = parameters;
  that._root = parameters.renderer.g().attr({
    'class': 'dxm-legend'
  }).linkOn(parameters.container, {
    name: 'legend',
    after: 'legend-base'
  }).enableLinks().linkAppend();
  parameters.layoutControl.addItem(that);
  _legend.Legend.call(that, {
    renderer: parameters.renderer,
    widget: parameters.widget,
    group: that._root,
    backgroundClass: null,
    itemsGroupClass: null,
    textField: 'text',
    getFormatObject: function (data) {
      return data;
    }
  });
  that._onDataChanged = function (data) {
    that._updateData(data);
  };
};
Legend.prototype = _extend((0, _object.clone)(_legend.Legend.prototype), {
  constructor: Legend,
  dispose: function () {
    const that = this;
    that._params.layoutControl.removeItem(that);
    that._unbindData();
    that._root.linkRemove().linkOff();
    that._params = that._root = that._onDataChanged = null;
    return _legend.Legend.prototype.dispose.apply(that, arguments);
  },
  // This method is called only by the layout
  resize: function (size) {
    this._params.notifyDirty();
    if (size === null) {
      this.erase();
    } else {
      this.draw(size.width, size.height);
    }
    this._params.notifyReady();
  },
  locate: _legend.Legend.prototype.shift,
  _updateData: function (data) {
    this._options.defaultColor = data && data.defaultColor;
    this.update(data ? buildData(data.partition, data.values, this._dataName) : [], this._options, this._params.themeManager.theme('legend').title);
    this.updateLayout();
  },
  _unbindData: function () {
    if (this._dataCategory) {
      this._params.dataExchanger.unbind(this._dataCategory, this._dataName, this._onDataChanged);
    }
  },
  _bindData: function (arg) {
    this._params.dataExchanger.bind(this._dataCategory = arg.category, this._dataName = arg.name, this._onDataChanged);
  },
  // The `_root` should be appended or removed here but there is no way to check if core.Legend is actually enabled or not
  setOptions: function (options) {
    const that = this;
    that.update(that._data, options, this._params.themeManager.theme('legend').title);
    that._unbindData();
    const source = options.source;
    that._bindData(source ? {
      category: source.layer,
      name: source.grouping
    } : unknownSource);
    that.updateLayout();
    return that;
  }
});
function LegendsControl(parameters) {
  this._params = parameters;
  this._items = [];
  parameters.container.virtualLink('legend-base');
}
LegendsControl.prototype = {
  constructor: LegendsControl,
  dispose: function () {
    _each(this._items, function (_, item) {
      item.dispose();
    });
    this._params = this._items = null;
  },
  setOptions: function (options) {
    const optionList = options && options.length ? options : [];
    const items = this._items;
    let i;
    const ii = optionList.length;
    const params = this._params;
    const theme = params.themeManager.theme('legend');
    for (i = items.length; i < ii; ++i) {
      items[i] = new Legend(params);
    }
    for (i = items.length - 1; i >= ii; --i) {
      items[i].dispose();
      items.splice(i, 1);
    }
    params.layoutControl.suspend();
    for (i = 0; i < ii; ++i) {
      items[i].setOptions(_extend(true, {}, theme, optionList[i]));
    }
    params.layoutControl.resume();
  }
};

/***/ }),

/***/ 15151:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.MapLayerCollection = MapLayerCollection;
exports.getMaxBound = getMaxBound;
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _data_helper = _interopRequireDefault(__webpack_require__(53305));
var _type = __webpack_require__(35922);
var _deferred = __webpack_require__(62754);
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _noop = _common.noop;
const _extend = _extend2.extend;
const _each = _iterator.each;
const _concat = Array.prototype.concat;
const TYPE_AREA = 'area';
const TYPE_LINE = 'line';
const TYPE_MARKER = 'marker';
const STATE_DEFAULT = 0;
const STATE_HOVERED = 1;
const STATE_SELECTED = 2;
const STATE_TO_INDEX = [0, 1, 2, 2];
const TOLERANCE = 1;
const SELECTIONS = {
  'none': null,
  'single': -1,
  'multiple': NaN
};
const _isArray = Array.isArray;
const _Number = Number;
const _String = String;
const _abs = Math.abs;
const _round = Math.round;
const _min = Math.min;
const _max = Math.max;
const _sqrt = Math.sqrt;
function getMaxBound(arr) {
  return arr.reduce((a, c) => {
    return c ? [_min(a[0], c[0]), _min(a[1], c[1]), _max(a[2], c[2]), _max(a[3], c[3])] : a;
  }, arr[0]);
}
function getSelection(selectionMode) {
  let selection = (0, _utils.normalizeEnum)(selectionMode);
  selection = selection in SELECTIONS ? SELECTIONS[selection] : SELECTIONS.single;
  if (selection !== null) {
    selection = {
      state: {},
      single: selection
    };
  }
  return selection;
}
function getName(opt, index) {
  return (opt[index] || {}).name;
}
function EmptySource() {}
EmptySource.prototype.count = function () {
  return 0;
};
function ArraySource(raw) {
  this.raw = raw;
}
ArraySource.prototype = {
  constructor: ArraySource,
  count: function () {
    return this.raw.length;
  },
  item: function (index) {
    return this.raw[index];
  },
  geometry: function (item) {
    return {
      coordinates: item.coordinates
    };
  },
  attributes: function (item) {
    return item.attributes;
  },
  getBBox: function (index) {
    return arguments.length === 0 ? undefined : this.raw[index]['bbox'];
  }
};
function GeoJsonSource(raw) {
  this.raw = raw;
}
GeoJsonSource.prototype = {
  constructor: GeoJsonSource,
  count: function () {
    return this.raw.features.length;
  },
  item: function (index) {
    return this.raw.features[index];
  },
  geometry: function (item) {
    return item.geometry;
  },
  attributes: function (item) {
    return item.properties;
  },
  getBBox: function (index) {
    return arguments.length === 0 ? this.raw['bbox'] : this.raw.features[index]['bbox'];
  }
};
function isGeoJsonObject(obj) {
  return _isArray(obj.features);
}

// The problem is that when remote source returns an object (not an array) the data.DataSource internally wraps it into array (of one element)
// So specific `if` clause is required to recognize GeoJson object in the returned `items`
function unwrapFromDataSource(source) {
  let sourceType;
  if (source) {
    if (isGeoJsonObject(source)) {
      sourceType = GeoJsonSource;
    } else if (source.length === 1 && source[0] && isGeoJsonObject(source[0])) {
      sourceType = GeoJsonSource;
      source = source[0];
    } else if (_isArray(source)) {
      sourceType = ArraySource;
    }
  }
  sourceType = sourceType || EmptySource;
  return new sourceType(source);
}

// The first problem is that when our DataSource is updated with an object (not an array) it considers such object a bunch of options.
// So single object has to be wrapped into array in order to be passed to the data.DataSource as is.
// The second problem is that when our DataSource is updated with `null` or `undefined` it does nothing - callback is not triggered (it is because of charts).
// So `null` or `undefined` is changed to empty array.
function wrapToDataSource(option) {
  return option ? isGeoJsonObject(option) ? [option] : option : [];
}
function customizeHandles(proxies, callback, widget) {
  callback.call(widget, proxies);
}

// TODO: Consider moving it inside a strategy
function setAreaLabelVisibility(label) {
  label.text.attr({
    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE && label.size[1] / label.spaceSize[1] < TOLERANCE ? null : 'hidden'
  });
}

// TODO: Consider moving it inside a strategy
function setLineLabelVisibility(label) {
  label.text.attr({
    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE || label.size[1] / label.spaceSize[1] < TOLERANCE ? null : 'hidden'
  });
}
function getDataValue(proxy, dataField) {
  return proxy.attribute(dataField);
}
const TYPE_TO_TYPE_MAP = {
  Point: TYPE_MARKER,
  MultiPoint: TYPE_LINE,
  LineString: TYPE_LINE,
  MultiLineString: TYPE_LINE,
  Polygon: TYPE_AREA,
  MultiPolygon: TYPE_AREA
};
function pick(a, b) {
  return a !== undefined ? a : b;
}
function guessTypeByData(sample) {
  let type = TYPE_TO_TYPE_MAP[sample.type];
  const coordinates = sample.coordinates;
  if (!type) {
    if (typeof coordinates[0] === 'number') {
      type = TYPE_MARKER;
    } else if (typeof coordinates[0][0] === 'number') {
      type = TYPE_LINE;
    } else {
      type = TYPE_AREA;
    }
  }
  return type;
}
const emptyStrategy = {
  setup: _noop,
  reset: _noop,
  arrange: _noop,
  updateGrouping: _noop,
  getDefaultColor: _noop
};
const strategiesByType = {};
const strategiesByGeometry = {};
const strategiesByElementType = {};
let groupByColor;
let groupBySize;
let selectStrategy = function (options, data) {
  let type = (0, _utils.normalizeEnum)(options.type);
  let elementType = (0, _utils.normalizeEnum)(options.elementType);
  let sample;
  const strategy = _extend({}, emptyStrategy);
  if (data.count() > 0) {
    sample = data.geometry(data.item(0));
    type = strategiesByType[type] ? type : guessTypeByData(sample);
    _extend(strategy, strategiesByType[type]);
    strategy.fullType = strategy.type = type;
    if (strategiesByGeometry[type]) {
      _extend(strategy, strategiesByGeometry[type](sample));
    }
    if (strategiesByElementType[type]) {
      elementType = strategiesByElementType[type][elementType] ? elementType : strategiesByElementType[type]._default;
      _extend(strategy, strategiesByElementType[type][elementType]);
      strategy.elementType = elementType;
      strategy.fullType += ':' + elementType;
    }
  }
  return strategy;
};
function applyElementState(figure, styles, state, field) {
  figure[field].attr(styles[field][state]);
}
strategiesByType[TYPE_AREA] = {
  projectLabel: projectAreaLabel,
  transform: transformPointList,
  transformLabel: transformAreaLabel,
  draw: function (context, figure, data) {
    figure.root = context.renderer.path([], 'area').data(context.dataKey, data);
  },
  refresh: _noop,
  getLabelOffset: function (label) {
    setAreaLabelVisibility(label);
    return [0, 0];
  },
  getStyles: function (settings) {
    const color = settings.color || null;
    const borderColor = settings.borderColor || null;
    const borderWidth = pick(settings.borderWidth, null);
    const opacity = pick(settings.opacity, null);
    return {
      root: [{
        'class': 'dxm-area',
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        'class': 'dxm-area dxm-area-hovered',
        stroke: settings.hoveredBorderColor || borderColor,
        'stroke-width': pick(settings.hoveredBorderWidth, borderWidth),
        fill: settings.hoveredColor || color,
        opacity: pick(settings.hoveredOpacity, opacity)
      }, {
        'class': 'dxm-area dxm-area-selected',
        stroke: settings.selectedBorderColor || borderColor,
        'stroke-width': pick(settings.selectedBorderWidth, borderWidth),
        fill: settings.selectedColor || color,
        opacity: pick(settings.selectedOpacity, opacity)
      }]
    };
  },
  setState: function (figure, styles, state) {
    applyElementState(figure, styles, state, 'root');
  },
  hasLabelsGroup: true,
  updateGrouping: function (context) {
    groupByColor(context);
  },
  getDefaultColor: _noop
};
strategiesByType[TYPE_LINE] = {
  projectLabel: projectLineLabel,
  transform: transformPointList,
  transformLabel: transformLineLabel,
  draw: function (context, figure, data) {
    figure.root = context.renderer.path([], 'line').data(context.dataKey, data);
  },
  refresh: _noop,
  getLabelOffset: function (label) {
    setLineLabelVisibility(label);
    return [0, 0];
  },
  getStyles: function (settings) {
    const color = settings.color || settings.borderColor || null;
    const width = pick(settings.borderWidth, null);
    const opacity = pick(settings.opacity, null);
    return {
      root: [{
        'class': 'dxm-line',
        stroke: color,
        'stroke-width': width,
        opacity: opacity
      }, {
        'class': 'dxm-line dxm-line-hovered',
        stroke: settings.hoveredColor || settings.hoveredBorderColor || color,
        'stroke-width': pick(settings.hoveredBorderWidth, width),
        opacity: pick(settings.hoveredOpacity, opacity)
      }, {
        'class': 'dxm-line dxm-line-selected',
        stroke: settings.selectedColor || settings.selectedBorderColor || color,
        'stroke-width': pick(settings.selectedBorderWidth, width),
        opacity: pick(settings.selectedOpacity, opacity)
      }]
    };
  },
  setState: function (figure, styles, state) {
    applyElementState(figure, styles, state, 'root');
  },
  hasLabelsGroup: true,
  updateGrouping: function (context) {
    groupByColor(context);
  },
  getDefaultColor: _noop
};
strategiesByType[TYPE_MARKER] = {
  project: projectPoint,
  transform: transformPoint,
  draw: function (context, figure, data) {
    figure.root = context.renderer.g();
    this._draw(context, figure, data);
  },
  refresh: _noop,
  hasLabelsGroup: false,
  getLabelOffset: function (label, settings) {
    return [_round((label.size[0] + _max(settings.size || 0, 0)) / 2) + 2, 0];
  },
  getStyles: function (settings) {
    const styles = {
      root: [{
        'class': 'dxm-marker'
      }, {
        'class': 'dxm-marker dxm-marker-hovered'
      }, {
        'class': 'dxm-marker dxm-marker-selected'
      }]
    };
    this._getStyles(styles, settings);
    return styles;
  },
  setState: function (figure, styles, state) {
    applyElementState(figure, styles, state, 'root');
    this._setState(figure, styles, state);
  },
  updateGrouping: function (context) {
    groupByColor(context);
    groupBySize(context);
  },
  getDefaultColor: function (ctx, palette) {
    return ctx.params.themeManager.getAccentColor(palette);
  }
};
strategiesByGeometry[TYPE_AREA] = function (sample) {
  return {
    project(projection, coordinates) {
      return coordinates[0] && coordinates[0][0] && coordinates[0][0][0] && typeof coordinates[0][0][0][0] === 'number' ? projectMultiPolygon(projection, coordinates) : projectPolygon(projection, coordinates);
    }
  };
};
strategiesByGeometry[TYPE_LINE] = function (sample) {
  const coordinates = sample.coordinates;
  return {
    project: coordinates[0] && coordinates[0][0] && typeof coordinates[0][0][0] === 'number' ? projectPolygon : projectLineString
  };
};
strategiesByElementType[TYPE_MARKER] = {
  _default: 'dot',
  dot: {
    setup: function (context) {
      context.filter = context.renderer.shadowFilter('-40%', '-40%', '180%', '200%', 0, 1, 1, '#000000', 0.2);
    },
    reset: function (context) {
      context.filter.dispose();
      context.filter = null;
    },
    _draw: function (ctx, figure, data) {
      figure.back = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
      figure.dot = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function (ctx, figure, data, proxy, settings) {
      figure.dot.attr({
        filter: settings.shadow ? ctx.filter.id : null
      });
    },
    _getStyles: function (styles, style) {
      const size = style.size > 0 ? _Number(style.size) : 0;
      const hoveredSize = size;
      const selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
      const hoveredBackSize = hoveredSize + (style.backStep > 0 ? _Number(style.backStep) : 0);
      const selectedBackSize = selectedSize + (style.backStep > 0 ? _Number(style.backStep) : 0);
      const color = style.color || null;
      const borderColor = style.borderColor || null;
      const borderWidth = pick(style.borderWidth, null);
      const opacity = pick(style.opacity, null);
      const backColor = style.backColor || null;
      const backOpacity = pick(style.backOpacity, null);
      styles.dot = [{
        r: size / 2,
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        r: hoveredSize / 2,
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth),
        fill: style.hoveredColor || color,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        r: selectedSize / 2,
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth),
        fill: style.selectedColor || color,
        opacity: pick(style.selectedOpacity, opacity)
      }];
      styles.back = [{
        r: size / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }, {
        r: hoveredBackSize / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }, {
        r: selectedBackSize / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }];
    },
    _setState: function (figure, styles, state) {
      applyElementState(figure, styles, state, 'dot');
      applyElementState(figure, styles, state, 'back');
    }
  },
  bubble: {
    _draw: function (ctx, figure, data) {
      figure.bubble = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function (ctx, figure, data, proxy, settings) {
      figure.bubble.attr({
        r: settings.size / 2
      });
    },
    _getStyles: function (styles, style) {
      const color = style.color || null;
      const borderColor = style.borderColor || null;
      const borderWidth = pick(style.borderWidth, null);
      const opacity = pick(style.opacity, null);
      styles.bubble = [{
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth),
        fill: style.hoveredColor || style.color,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth),
        fill: style.selectedColor || style.color,
        opacity: pick(style.selectedOpacity, opacity)
      }];
    },
    _setState: function (figure, styles, state) {
      applyElementState(figure, styles, state, 'bubble');
    },
    arrange: function (context, handles) {
      const values = [];
      let i;
      const ii = values.length = handles.length;
      const settings = context.settings;
      const dataField = settings.dataField;
      const minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;
      const maxSize = settings.maxSize > minSize ? _Number(settings.maxSize) : minSize;
      if (settings.sizeGroups) {
        return;
      }
      for (i = 0; i < ii; ++i) {
        values[i] = _max(getDataValue(handles[i].proxy, dataField) || 0, 0);
      }
      const minValue = _min.apply(null, values);
      const maxValue = _max.apply(null, values);
      const deltaValue = maxValue - minValue || 1;
      const deltaSize = maxSize - minSize;
      for (i = 0; i < ii; ++i) {
        handles[i]._settings.size = minSize + deltaSize * (values[i] - minValue) / deltaValue;
      }
    },
    updateGrouping: function (context) {
      const dataField = context.settings.dataField;
      strategiesByType[TYPE_MARKER].updateGrouping(context);
      groupBySize(context, function (proxy) {
        return getDataValue(proxy, dataField);
      });
    }
  },
  pie: {
    _draw: function (ctx, figure, data) {
      figure.pie = ctx.renderer.g().append(figure.root);
      figure.border = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function (ctx, figure, data, proxy, settings) {
      const values = getDataValue(proxy, ctx.settings.dataField) || [];
      const colors = settings._colors;
      let sum = 0;
      const pie = figure.pie;
      const renderer = ctx.renderer;
      const dataKey = ctx.dataKey;
      const r = (settings.size > 0 ? _Number(settings.size) : 0) / 2;
      let start = 90;
      let end = start;
      let zeroSum = false;
      sum = values.reduce(function (total, item) {
        return total + (item || 0);
      }, 0);
      if (sum === 0) {
        zeroSum = true;
        sum = 360 / values.length;
      }
      values.forEach(function (item, i) {
        start = end;
        end += zeroSum ? sum : (item || 0) / sum * 360;
        renderer.arc(0, 0, 0, r, start, end).attr({
          'stroke-linejoin': 'round',
          fill: colors[i]
        }).data(dataKey, data).append(pie);
      });
      figure.border.attr({
        r: r
      });
    },
    _getStyles: function (styles, style) {
      const opacity = pick(style.opacity, null);
      const borderColor = style.borderColor || null;
      const borderWidth = pick(style.borderWidth, null);
      styles.pie = [{
        opacity: opacity
      }, {
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        opacity: pick(style.selectedOpacity, opacity)
      }];
      styles.border = [{
        stroke: borderColor,
        'stroke-width': borderWidth
      }, {
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth)
      }, {
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth)
      }];
    },
    _setState: function (figure, styles, state) {
      applyElementState(figure, styles, state, 'pie');
      applyElementState(figure, styles, state, 'border');
    },
    arrange: function (context, handles) {
      let i;
      const ii = handles.length;
      const dataField = context.settings.dataField;
      let values;
      let count = 0;
      let palette;
      for (i = 0; i < ii; ++i) {
        values = getDataValue(handles[i].proxy, dataField);
        if (values && values.length > count) {
          count = values.length;
        }
      }
      if (count > 0) {
        palette = context.params.themeManager.createPalette(context.settings.palette, {
          useHighlight: true,
          extensionMode: 'alternate'
        });
        values = palette.generateColors(count);
        context.settings._colors = values;
        context.grouping.color = {
          callback: _noop,
          field: '',
          partition: [],
          values: []
        };
        context.params.dataExchanger.set(context.name, 'color', {
          partition: [],
          values: values
        });
      }
    }
  },
  image: {
    _draw: function (ctx, figure, data) {
      figure.image = ctx.renderer.image(null, null, null, null, null, 'center').attr({
        'pointer-events': 'visible'
      }) // T567545
      .data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function (ctx, figure, data, proxy) {
      figure.image.attr({
        href: getDataValue(proxy, ctx.settings.dataField)
      });
    },
    _getStyles: function (styles, style) {
      const size = style.size > 0 ? _Number(style.size) : 0;
      const hoveredSize = size + (style.hoveredStep > 0 ? _Number(style.hoveredStep) : 0);
      const selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
      const opacity = pick(style.opacity, null);
      styles.image = [{
        x: -size / 2,
        y: -size / 2,
        width: size,
        height: size,
        opacity: opacity
      }, {
        x: -hoveredSize / 2,
        y: -hoveredSize / 2,
        width: hoveredSize,
        height: hoveredSize,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        x: -selectedSize / 2,
        y: -selectedSize / 2,
        width: selectedSize,
        height: selectedSize,
        opacity: pick(style.selectedOpacity, opacity)
      }];
    },
    _setState: function (figure, styles, state) {
      applyElementState(figure, styles, state, 'image');
    }
  }
};
function projectPoint(projection, coordinates) {
  return projection.project(coordinates);
}
function projectPointList(projection, coordinates) {
  const output = [];
  let i;
  const ii = output.length = coordinates.length;
  for (i = 0; i < ii; ++i) {
    output[i] = projection.project(coordinates[i]);
  }
  return output;
}
function projectLineString(projection, coordinates) {
  return [projectPointList(projection, coordinates)];
}
function projectPolygon(projection, coordinates) {
  const output = [];
  let i;
  const ii = output.length = coordinates.length;
  for (i = 0; i < ii; ++i) {
    output[i] = projectPointList(projection, coordinates[i]);
  }
  return output;
}
function projectMultiPolygon(projection, coordinates) {
  const output = [];
  let i;
  const ii = output.length = coordinates.length;
  for (i = 0; i < ii; ++i) {
    output[i] = projectPolygon(projection, coordinates[i]);
  }
  return _concat.apply([], output);
}
function transformPoint(content, projection, coordinates) {
  const data = projection.transform(coordinates);
  content.root.attr({
    translateX: data[0],
    translateY: data[1]
  });
}
function transformList(projection, coordinates) {
  const output = [];
  let i;
  const ii = coordinates.length;
  let item;
  let k = 0;
  output.length = 2 * ii;
  for (i = 0; i < ii; ++i) {
    item = projection.transform(coordinates[i]);
    output[k++] = item[0];
    output[k++] = item[1];
  }
  return output;
}
function transformPointList(content, projection, coordinates) {
  const output = [];
  let i;
  const ii = output.length = coordinates.length;
  for (i = 0; i < ii; ++i) {
    output[i] = transformList(projection, coordinates[i]);
  }
  content.root.attr({
    points: output
  });
}
function transformAreaLabel(label, projection, coordinates) {
  const data = projection.transform(coordinates[0]);
  label.spaceSize = projection.getSquareSize(coordinates[1]);
  label.text.attr({
    translateX: data[0],
    translateY: data[1]
  });
  setAreaLabelVisibility(label);
}
function transformLineLabel(label, projection, coordinates) {
  const data = projection.transform(coordinates[0]);
  label.spaceSize = projection.getSquareSize(coordinates[1]);
  label.text.attr({
    translateX: data[0],
    translateY: data[1]
  });
  setLineLabelVisibility(label);
}
function getItemSettings(context, proxy, settings) {
  const result = combineSettings(context.settings, settings);
  applyGrouping(context.grouping, proxy, result);
  if (settings.color === undefined && settings.paletteIndex >= 0) {
    result.color = result._colors[settings.paletteIndex];
  }
  return result;
}
function applyGrouping(grouping, proxy, settings) {
  _each(grouping, function (name, data) {
    const index = findGroupingIndex(data.callback(proxy, data.field), data.partition);
    if (index >= 0) {
      settings[name] = data.values[index];
    }
  });
}
function findGroupingIndex(value, partition) {
  let start = 0;
  let end = partition.length - 1;
  let index = -1;
  let middle;
  if (partition[start] <= value && value <= partition[end]) {
    if (value === partition[end]) {
      index = end - 1;
    } else {
      while (end - start > 1) {
        middle = start + end >> 1;
        if (value < partition[middle]) {
          end = middle;
        } else {
          start = middle;
        }
      }
      index = start;
    }
  }
  return index;
}
function raiseChanged(context, handle, state, name) {
  context.params.eventTrigger(name, {
    target: handle.proxy,
    state: state
  });
}

// This is required because `$.extend` cannot be used - because of the `options.data` which is commonly a very large array
// TODO: Try to use our simple `extend` instead of `$.extend`
function combineSettings(common, partial) {
  const obj = _extend({}, common, partial);
  obj.label = _extend({}, common.label, obj.label);
  obj.label.font = _extend({}, common.label.font, obj.label.font);
  return obj;
}
function processCommonSettings(context, options) {
  const themeManager = context.params.themeManager;
  const strategy = context.str;
  const settings = combineSettings(_extend({
    label: {},
    color: strategy.getDefaultColor(context, options.palette)
  }, themeManager.theme('layer:' + strategy.fullType)), options);
  let colors;
  let i;
  let palette;
  if (settings.paletteSize > 0) {
    palette = themeManager.createDiscretePalette(settings.palette, settings.paletteSize);
    for (i = 0, colors = []; i < settings.paletteSize; ++i) {
      colors.push(palette.getColor(i));
    }
    settings._colors = colors;
  }
  return settings;
}
function valueCallback(proxy, dataField) {
  return proxy.attribute(dataField);
}
let performGrouping = function (context, partition, settingField, dataField, valuesCallback) {
  let values;
  if (dataField && partition && partition.length > 1) {
    values = valuesCallback(partition.length - 1);
    context.grouping[settingField] = {
      callback: (0, _type.isFunction)(dataField) ? dataField : valueCallback,
      field: dataField,
      partition: partition,
      values: values
    };
    context.params.dataExchanger.set(context.name, settingField, {
      partition: partition,
      values: values,
      defaultColor: context.settings.color
    });
  }
};
function dropGrouping(context) {
  const name = context.name;
  const dataExchanger = context.params.dataExchanger;
  _each(context.grouping, function (field) {
    dataExchanger.set(name, field, null);
  });
  context.grouping = {};
}
groupByColor = function (context) {
  performGrouping(context, context.settings.colorGroups, 'color', context.settings.colorGroupingField, function (count) {
    const _palette = context.params.themeManager.createDiscretePalette(context.settings.palette, count);
    let i;
    const list = [];
    for (i = 0; i < count; ++i) {
      list.push(_palette.getColor(i));
    }
    return list;
  });
};
groupBySize = function (context, valueCallback) {
  const settings = context.settings;
  performGrouping(context, settings.sizeGroups, 'size', valueCallback || settings.sizeGroupingField, function (count) {
    const minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;
    const maxSize = settings.maxSize >= minSize ? _Number(settings.maxSize) : 0;
    let i = 0;
    const sizes = [];
    if (count > 1) {
      for (i = 0; i < count; ++i) {
        sizes.push((minSize * (count - i - 1) + maxSize * i) / (count - 1));
      }
    } else if (count === 1) {
      sizes.push((minSize + maxSize) / 2);
    }
    return sizes;
  });
};
function setFlag(flags, flag, state) {
  if (state) {
    flags |= flag;
  } else {
    flags &= ~flag;
  }
  return flags;
}
function hasFlag(flags, flag) {
  return !!(flags & flag);
}
function createLayerProxy(layer, name, index) {
  const proxy = {
    index: index,
    name: name,
    getElements: function () {
      return layer.getProxies();
    },
    clearSelection: function (_noEvent) {
      layer.clearSelection(_noEvent);
      return proxy;
    },
    getDataSource: function () {
      return layer.getDataSource();
    },
    getBounds() {
      return layer.getBounds();
    }
  };
  return proxy;
}
let MapLayerElement;
let MapLayer = function (params, container, name, index) {
  const that = this;
  that._params = params;
  that._onProjection();
  that.proxy = createLayerProxy(that, name, index);
  that._context = {
    name: name,
    layer: that.proxy,
    renderer: params.renderer,
    projection: params.projection,
    params: params,
    dataKey: params.dataKey,
    str: emptyStrategy,
    hover: false,
    selection: null,
    grouping: {},
    // TODO: Link name should be built upon layer index rather than name
    root: params.renderer.g().attr({
      'class': 'dxm-layer'
    }).linkOn(container, name).linkAppend()
  };
  that._container = container;
  that._options = {};
  // Though the `_handles` field is set in the `_createHandles` it is required here because projection events are fired before data is set
  that._handles = [];
  // The `_data` field may be accessed in the `setOptions` when data is not set
  that._data = new EmptySource();
  that._dataSourceLoaded = null;
};
MapLayer.prototype = _extend({
  constructor: MapLayer,
  getDataReadyCallback() {
    return this._dataSourceLoaded;
  },
  _onProjection: function () {
    const that = this;
    that._removeHandlers = that._params.projection.on({
      'engine': function () {
        that._project();
      },
      'screen': function () {
        that._transform();
      },
      'center': function () {
        that._transformCore();
      },
      'zoom': function () {
        that._transform();
      }
    });
  },
  getData() {
    return this._data;
  },
  _dataSourceLoadErrorHandler: function () {
    this._dataSourceChangedHandler();
  },
  _dataSourceChangedHandler: function () {
    const that = this;
    that._data = unwrapFromDataSource(that._dataSource && that._dataSource.items());
    that._update(true);
  },
  _dataSourceOptions: function () {
    return {
      paginate: false
    };
  },
  _getSpecificDataSourceOption: function () {
    return this._specificDataSourceOption;
  },
  _normalizeDataSource: function (dataSource) {
    const store = dataSource.store();
    if (store._loadMode === 'raw') {
      store._loadMode = undefined;
    }
    return dataSource;
  },
  _offProjection: function () {
    this._removeHandlers();
    this._removeHandlers = null;
  },
  dispose: function () {
    const that = this;
    that._disposeDataSource();
    that._destroyHandles();
    dropGrouping(that._context);
    that._context.root.linkRemove().linkOff();
    that._context.labelRoot && that._context.labelRoot.linkRemove().linkOff();
    that._context.str.reset(that._context);
    that._offProjection();
    that._params = that._container = that._context = that.proxy = null;
    return that;
  },
  setOptions: function (options) {
    const that = this;
    options = that._options = options || {};
    that._dataSourceLoaded = new _deferred.Deferred();
    if ('dataSource' in options && options.dataSource !== that._options_dataSource) {
      that._options_dataSource = options.dataSource;
      that._params.notifyDirty();
      that._specificDataSourceOption = wrapToDataSource(options.dataSource);
      that._refreshDataSource();
    } else if (that._data.count() > 0) {
      that._params.notifyDirty();
      that._update(options.type !== undefined && options.type !== that._context.str.type || options.elementType !== undefined && options.elementType !== that._context.str.elementType);
    }
    that._transformCore();
  },
  _update: function (isContextChanged) {
    const that = this;
    const context = that._context;
    if (isContextChanged) {
      context.str.reset(context);
      context.root.clear();
      context.labelRoot && context.labelRoot.clear();
      that._params.tracker.reset(); // T173037; TODO: There is no need to reset the entire tracker - only its memory about items
      that._destroyHandles();
      context.str = selectStrategy(that._options, that._data);
      context.str.setup(context);
      that.proxy.type = context.str.type;
      that.proxy.elementType = context.str.elementType;
    }
    context.settings = processCommonSettings(context, that._options);
    context.hasSeparateLabel = !!(context.settings.label.enabled && context.str.hasLabelsGroup);
    context.hover = !!(0, _utils.parseScalar)(context.settings.hoverEnabled, true);
    // There is intentionally no attempt to preserve previous selection (or part of it)
    // Otherwise it would require some stack-like structure to keep selected items
    // Let's not complicate
    if (context.selection) {
      _each(context.selection.state, function (_, handle) {
        handle && handle.resetSelected();
      });
    }
    context.selection = getSelection(context.settings.selectionMode);
    if (context.hasSeparateLabel) {
      if (!context.labelRoot) {
        // TODO: Link name should be built upon layer index rather than name
        context.labelRoot = context.renderer.g().attr({
          'class': 'dxm-layer-labels'
        }).linkOn(that._container, {
          name: context.name + '-labels',
          after: context.name
        }).linkAppend();
        that._transformCore();
      }
    } else {
      if (context.labelRoot) {
        context.labelRoot.linkRemove().linkOff();
        context.labelRoot = null;
      }
    }
    if (isContextChanged) {
      that._createHandles();
    }
    dropGrouping(context);
    context.str.arrange(context, that._handles);
    context.str.updateGrouping(context);
    that._updateHandles();
    that._params.notifyReady();
    if (that._dataSourceLoaded) {
      // T890687
      that._dataSourceLoaded.resolve();
      that._dataSourceLoaded = null;
    } else {
      that._params.dataReady();
    }
  },
  getBounds() {
    return getMaxBound(this._handles.map(_ref => {
      let {
        proxy
      } = _ref;
      return proxy.coordinates().map(coords => {
        if (!_isArray(coords)) {
          return;
        }
        const coordsToBoundsSearch = _isArray(coords[0][0]) ? coords.reduce((ac, val) => ac.concat(val), []) : coords;
        const initValue = coordsToBoundsSearch[0];
        return coordsToBoundsSearch.reduce((min, c) => {
          return [_min(min[0], c[0]), _min(min[1], c[1]), _max(min[2], c[0]), _max(min[3], c[1])];
        }, [initValue[0], initValue[1], initValue[0], initValue[1]]);
      });
    }).map(getMaxBound));
  },
  _destroyHandles() {
    this._handles.forEach(h => h.dispose());
    if (this._context.selection) {
      this._context.selection.state = {};
    }
    this._handles = [];
  },
  _createHandles: function () {
    const that = this;
    const handles = that._handles = [];
    const data = that._data;
    let i;
    const ii = handles.length = data.count();
    const context = that._context;
    const geometry = data.geometry;
    const attributes = data.attributes;
    let handle;
    let dataItem;
    for (i = 0; i < ii; ++i) {
      dataItem = data.item(i);
      handles[i] = new MapLayerElement(context, i, geometry(dataItem), attributes(dataItem));
    }
    // Customization must be performed before anything else happens to element (that is the idea of customization)
    (0, _type.isFunction)(that._options.customize) && customizeHandles(that.getProxies(), that._options.customize, that._params.widget);
    for (i = 0; i < ii; ++i) {
      handle = handles[i];
      handle.project();
      handle.draw();
      handle.transform();
    }
    if (context.selection) {
      _each(context.selection.state, function (_, handle) {
        handle && handle.restoreSelected();
      });
    }
  },
  _updateHandles: function () {
    const handles = this._handles;
    let i;
    const ii = handles.length;
    for (i = 0; i < ii; ++i) {
      handles[i].refresh();
    }
    if (this._context.settings.label.enabled) {
      for (i = 0; i < ii; ++i) {
        handles[i].measureLabel();
      }
      for (i = 0; i < ii; ++i) {
        handles[i].adjustLabel();
      }
    }
  },
  _transformCore: function () {
    const transform = this._params.projection.getTransform();
    this._context.root.attr(transform);
    this._context.labelRoot && this._context.labelRoot.attr(transform);
  },
  _project: function () {
    const handles = this._handles;
    let i;
    const ii = handles.length;
    for (i = 0; i < ii; ++i) {
      handles[i].project();
    }
  },
  _transform: function () {
    const handles = this._handles;
    let i;
    const ii = handles.length;
    this._transformCore();
    for (i = 0; i < ii; ++i) {
      handles[i].transform();
    }
  },
  getProxies() {
    return this._handles.map(p => p.proxy);
  },
  getProxy: function (index) {
    return this._handles[index].proxy;
  },
  raiseClick: function (i, dxEvent) {
    this._params.eventTrigger('click', {
      target: this._handles[i].proxy,
      event: dxEvent
    });
  },
  hoverItem: function (i, state) {
    this._handles[i].setHovered(state);
  },
  selectItem: function (i, state, _noEvent) {
    this._handles[i].setSelected(state, _noEvent);
  },
  clearSelection: function () {
    const selection = this._context.selection;
    if (selection) {
      _each(selection.state, function (_, handle) {
        handle && handle.setSelected(false);
      });
      selection.state = {};
    }
  }
}, _data_helper.default);
function createProxy(handle, coords, attrs) {
  const proxy = {
    coordinates: function () {
      return coords;
    },
    attribute: function (name, value) {
      if (arguments.length > 1) {
        attrs[name] = value;
        return proxy;
      } else {
        return arguments.length > 0 ? attrs[name] : attrs;
      }
    },
    selected: function (state, _noEvent) {
      if (arguments.length > 0) {
        handle.setSelected(state, _noEvent);
        return proxy;
      } else {
        return handle.isSelected();
      }
    },
    applySettings: function (settings) {
      handle.update(settings);
      return proxy;
    }
  };
  return proxy;
}
MapLayerElement = function (context, index, geometry, attributes) {
  const that = this;
  const proxy = that.proxy = createProxy(that, geometry.coordinates, _extend({}, attributes));
  that._ctx = context;
  that._index = index;
  that._fig = that._label = null;
  that._state = STATE_DEFAULT;
  that._coordinates = geometry.coordinates;
  that._settings = {
    label: {}
  };
  proxy.index = index;
  proxy.layer = context.layer;
  // TODO: Replace "name" field with one referencing layer index and use layer index (instead of name) as layer id
  // as it is more suitable, simple and consistent
  that._data = {
    name: context.name,
    index: index
  };
};
MapLayerElement.prototype = {
  constructor: MapLayerElement,
  dispose: function () {
    const that = this;
    that._ctx = that.proxy = that._settings = that._fig = that._label = that.data = null;
    return that;
  },
  project: function () {
    const context = this._ctx;
    this._projection = context.str.project(context.projection, this._coordinates);
    if (context.hasSeparateLabel && this._label) {
      this._projectLabel();
    }
  },
  _projectLabel: function () {
    this._labelProjection = this._ctx.str.projectLabel(this._projection);
  },
  draw: function () {
    const that = this;
    const context = this._ctx;
    context.str.draw(context, that._fig = {}, that._data);
    that._fig.root.append(context.root);
  },
  transform: function () {
    const that = this;
    const context = that._ctx;
    context.str.transform(that._fig, context.projection, that._projection);
    if (context.hasSeparateLabel && that._label) {
      that._transformLabel();
    }
  },
  _transformLabel: function () {
    this._ctx.str.transformLabel(this._label, this._ctx.projection, this._labelProjection);
  },
  refresh: function () {
    const that = this;
    const strategy = that._ctx.str;
    const settings = getItemSettings(that._ctx, that.proxy, that._settings);
    that._styles = strategy.getStyles(settings);
    strategy.refresh(that._ctx, that._fig, that._data, that.proxy, settings);
    that._refreshLabel(settings);
    that._setState();
  },
  _refreshLabel: function (settings) {
    const that = this;
    const context = that._ctx;
    const labelSettings = settings.label;
    let label = that._label;
    if (context.settings.label.enabled) {
      if (!label) {
        label = that._label = {
          root: context.labelRoot || that._fig.root,
          text: context.renderer.text().attr({
            'class': 'dxm-label'
          }),
          size: [0, 0]
        };
        if (context.hasSeparateLabel) {
          that._projectLabel();
          that._transformLabel();
        }
      }
      label.value = _String(that.proxy.text || that.proxy.attribute(labelSettings.dataField) || '');
      if (label.value) {
        // The data should be set when the element is created but it requires changes in the Renderer
        label.text.attr({
          text: label.value,
          x: 0,
          y: 0
        }).css((0, _utils.patchFontOptions)(labelSettings.font)).attr({
          align: 'center',
          stroke: labelSettings.stroke,
          'stroke-width': labelSettings['stroke-width'],
          'stroke-opacity': labelSettings['stroke-opacity']
        }).data(context.dataKey, that._data).append(label.root);
        label.settings = settings;
      }
    } else {
      if (label) {
        label.text.remove();
        that._label = null;
      }
    }
  },
  measureLabel: function () {
    const label = this._label;
    let bBox;
    if (label.value) {
      bBox = label.text.getBBox();
      label.size = [bBox.width, bBox.height, -bBox.y - bBox.height / 2];
    }
  },
  adjustLabel: function () {
    const label = this._label;
    let offset;
    if (label.value) {
      offset = this._ctx.str.getLabelOffset(label, label.settings);
      label.settings = null;
      label.text.attr({
        x: offset[0],
        y: offset[1] + label.size[2]
      });
    }
  },
  update: function (settings) {
    const that = this;
    that._settings = combineSettings(that._settings, settings);
    // This check is required because the method can be called during the customization stage when DOM content neither is created nor should be changed
    if (that._fig) {
      that.refresh();
      if (that._label && that._label.value) {
        that.measureLabel();
        that.adjustLabel();
      }
    }
  },
  _setState: function () {
    this._ctx.str.setState(this._fig, this._styles, STATE_TO_INDEX[this._state]);
  },
  _setForeground: function () {
    const root = this._fig.root;
    this._state ? root.toForeground() : root.toBackground();
  },
  setHovered: function (state) {
    const that = this;
    const currentState = hasFlag(that._state, STATE_HOVERED);
    const newState = !!state;
    if (that._ctx.hover && currentState !== newState) {
      that._state = setFlag(that._state, STATE_HOVERED, newState);
      that._setState();
      that._setForeground();
      raiseChanged(that._ctx, that, newState, 'hoverChanged');
    }
    return that;
  },
  setSelected: function (state, _noEvent) {
    const that = this;
    const currentState = hasFlag(that._state, STATE_SELECTED);
    const newState = !!state;
    const selection = that._ctx.selection;
    let tmp;
    if (selection && currentState !== newState) {
      that._state = setFlag(that._state, STATE_SELECTED, newState);
      tmp = selection.state[selection.single];
      selection.state[selection.single] = null; // This is to prevent stack overflow
      if (tmp) {
        tmp.setSelected(false);
      }
      selection.state[selection.single || that._index] = state ? that : null;
      // This check is required because the method can be called during the customization stage when DOM content neither is created nor should be changed
      if (that._fig) {
        that._setState();
        that._setForeground();
        if (!_noEvent) {
          raiseChanged(that._ctx, that, newState, 'selectionChanged');
        }
      }
    }
  },
  isSelected: function () {
    return hasFlag(this._state, STATE_SELECTED);
  },
  resetSelected: function () {
    this._state = setFlag(this._state, STATE_SELECTED, false);
  },
  restoreSelected: function () {
    this._fig.root.toForeground();
  }
};

// http://en.wikipedia.org/wiki/Centroid
function calculatePolygonCentroid(coordinates) {
  let i;
  const length = coordinates.length;
  let v1;
  let v2 = coordinates[length - 1];
  let cross;
  let cx = 0;
  let cy = 0;
  let area = 0;
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (i = 0; i < length; ++i) {
    v1 = v2;
    v2 = coordinates[i];
    cross = v1[0] * v2[1] - v2[0] * v1[1];
    area += cross;
    cx += (v1[0] + v2[0]) * cross;
    cy += (v1[1] + v2[1]) * cross;
    minX = _min(minX, v2[0]);
    maxX = _max(maxX, v2[0]);
    minY = _min(minY, v2[1]);
    maxY = _max(maxY, v2[1]);
  }
  // from centroid coords we need subtract the center of bbox coords to get a good geometrical center (T312029)
  return {
    area: _abs(area) / 2,
    center: [2 * cx / 3 / area - (minX + maxX) / 2, 2 * cy / 3 / area - (minY + maxY) / 2]
  };
}
function calculateLineStringData(coordinates) {
  let i;
  const ii = coordinates.length;
  let v1;
  let v2 = coordinates[0] || [];
  let totalLength = 0;
  const items = [0];
  let min0 = v2[0];
  let max0 = v2[0];
  let min1 = v2[1];
  let max1 = v2[1];
  for (i = 1; i < ii; ++i) {
    v1 = v2;
    v2 = coordinates[i];
    totalLength += _sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
    items[i] = totalLength;
    min0 = _min(min0, v2[0]);
    max0 = _max(max0, v2[0]);
    min1 = _min(min1, v2[1]);
    max1 = _max(max1, v2[1]);
  }
  i = findGroupingIndex(totalLength / 2, items);
  v1 = coordinates[i];
  v2 = coordinates[i + 1];
  const t = (totalLength / 2 - items[i]) / (items[i + 1] - items[i]);
  return ii ? [[v1[0] * (1 - t) + v2[0] * t, v1[1] * (1 - t) + v2[1] * t], [max0 - min0, max1 - min1], totalLength] : [];
}

// TODO: Optimize!
// There are redundant iterations in the following cycle - interior holes of a polygon should not be taken into account
// So there is only centroid to be calculated for each "Polygon"
function projectAreaLabel(coordinates) {
  let i;
  const ii = coordinates.length;
  let centroid;
  let resultCentroid;
  let maxArea = 0;
  for (i = 0; i < ii; ++i) {
    centroid = calculatePolygonCentroid(coordinates[i]);
    if (centroid.area > maxArea) {
      maxArea = centroid.area;
      resultCentroid = centroid;
    }
  }
  // TODO: Move "_sqrt" to the "calculatePolygonCentroid"
  return resultCentroid ? [resultCentroid.center, [_sqrt(resultCentroid.area), _sqrt(resultCentroid.area)]] : [[], []];
}
function projectLineLabel(coordinates) {
  let i;
  const ii = coordinates.length;
  let maxLength = 0;
  let data;
  let resultData;
  for (i = 0; i < ii; ++i) {
    data = calculateLineStringData(coordinates[i]);
    if (data[2] > maxLength) {
      maxLength = data[2];
      resultData = data;
    }
  }
  return resultData || [[], []];
}
function MapLayerCollection(params) {
  const that = this;
  const renderer = params.renderer;
  that._params = params;
  that._layers = [];
  // TODO: Use Set instance instead of plain object
  that._layerByName = {};
  that._rect = [0, 0, 0, 0];
  that._clip = renderer.clipRect();
  that._background = renderer.rect().attr({
    'class': 'dxm-background'
  }).data(params.dataKey, {
    name: 'background'
  }).append(renderer.root);
  that._container = renderer.g().attr({
    'class': 'dxm-layers',
    'clip-path': that._clip.id
  }).append(renderer.root).enableLinks();
  that._subscribeToTracker(params.tracker, renderer, params.eventTrigger);
  that._dataReady = params.dataReady;
}
MapLayerCollection.prototype = {
  constructor: MapLayerCollection,
  dispose: function () {
    const that = this;
    that._clip.dispose();
    that._layers.forEach(l => l.dispose());
    that._offTracker();
    that._params = that._offTracker = that._layers = that._layerByName = that._clip = that._background = that._container = null;
  },
  _subscribeToTracker: function (tracker, renderer, eventTrigger) {
    const that = this;
    that._offTracker = tracker.on({
      'click': function (arg) {
        // TODO: Adjust `x` and `y` inside the Tracker
        const offset = renderer.getRootOffset();
        const layer = that.byName(arg.data.name);
        arg.$event.x = arg.x - offset.left;
        arg.$event.y = arg.y - offset.top;
        // TODO: Remove the "raiseClick" method
        if (layer) {
          layer.raiseClick(arg.data.index, arg.$event);
        } else if (arg.data.name === 'background') {
          eventTrigger('click', {
            event: arg.$event
          });
        }
      },
      'hover-on': function (arg) {
        const layer = that.byName(arg.data.name);
        if (layer) {
          layer.hoverItem(arg.data.index, true);
        }
      },
      'hover-off': function (arg) {
        const layer = that.byName(arg.data.name);
        if (layer) {
          layer.hoverItem(arg.data.index, false);
        }
      }
    });
  },
  setOptions(options) {
    const that = this;
    const optionList = options ? _isArray(options) ? options : [options] : [];
    let layers = that._layers;
    let readyCallbacks = [];
    const needToCreateLayers = optionList.length !== layers.length || layers.some((l, i) => {
      const name = getName(optionList, i);
      return (0, _type.isDefined)(name) && name !== l.proxy.name;
    });
    if (needToCreateLayers) {
      that._params.tracker.reset();
      that._layers.forEach(l => l.dispose());
      const layerByName = that._layerByName = {};
      that._layers = layers = [];
      for (let i = 0, ii = optionList.length; i < ii; ++i) {
        const name = getName(optionList, i) || 'map-layer-' + i;
        const layer = layers[i] = new MapLayer(that._params, that._container, name, i);
        layerByName[name] = layer;
      }
    }
    layers.forEach((l, i) => {
      l.setOptions(optionList[i]);
    });
    readyCallbacks = layers.map(l => {
      return l.getDataReadyCallback();
    });
    readyCallbacks.length && _deferred.when.apply(undefined, readyCallbacks).done(that._dataReady);
  },
  _updateClip: function () {
    const rect = this._rect;
    const bw = this._borderWidth;
    this._clip.attr({
      x: rect[0] + bw,
      y: rect[1] + bw,
      width: _max(rect[2] - bw * 2, 0),
      height: _max(rect[3] - bw * 2, 0)
    });
  },
  setBackgroundOptions: function (options) {
    this._background.attr({
      stroke: options.borderColor,
      'stroke-width': options.borderWidth,
      fill: options.color
    });
    this._borderWidth = _max(options.borderWidth, 0);
    this._updateClip();
  },
  setRect: function (rect) {
    this._rect = rect;
    this._background.attr({
      x: rect[0],
      y: rect[1],
      width: rect[2],
      height: rect[3]
    });
    this._updateClip();
  },
  byIndex: function (index) {
    return this._layers[index];
  },
  byName: function (name) {
    return this._layerByName[name];
  },
  items: function () {
    return this._layers;
  }
};

/***/ }),

/***/ 102:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "projection", ({
  enumerable: true,
  get: function () {
    return _projection.projection;
  }
}));
var _projection = __webpack_require__(14316);
const _min = Math.min;
const _max = Math.max;
const _sin = Math.sin;
const _asin = Math.asin;
const _tan = Math.tan;
const _atan = Math.atan;
const _exp = Math.exp;
const _log = Math.log;
const PI = Math.PI;
const PI_DIV_4 = PI / 4;
const GEO_LON_BOUND = 180;
const GEO_LAT_BOUND = 90;
const RADIANS = PI / 180;
const MERCATOR_LAT_BOUND = (2 * _atan(_exp(PI)) - PI / 2) / RADIANS;
const MILLER_LAT_BOUND = (2.5 * _atan(_exp(0.8 * PI)) - 0.625 * PI) / RADIANS;
function clamp(value, threshold) {
  return _max(_min(value, +threshold), -threshold);
}

// https://en.wikipedia.org/wiki/Mercator_projection
_projection.projection.add('mercator', (0, _projection.projection)({
  aspectRatio: 1,
  to: function (coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, _log(_tan(PI_DIV_4 + clamp(coordinates[1], MERCATOR_LAT_BOUND) * RADIANS / 2)) / PI];
  },
  from: function (coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, (2 * _atan(_exp(coordinates[1] * PI)) - PI / 2) / RADIANS];
  }
}));

// https://en.wikipedia.org/wiki/Equirectangular_projection
_projection.projection.add('equirectangular', (0, _projection.projection)({
  aspectRatio: 2,
  to: function (coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, coordinates[1] / GEO_LAT_BOUND];
  },
  from: function (coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, coordinates[1] * GEO_LAT_BOUND];
  }
}));

// https://en.wikipedia.org/wiki/Lambert_cylindrical_equal-area_projection
_projection.projection.add('lambert', (0, _projection.projection)({
  aspectRatio: 2,
  to: function (coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, _sin(clamp(coordinates[1], GEO_LAT_BOUND) * RADIANS)];
  },
  from: function (coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, _asin(clamp(coordinates[1], 1)) / RADIANS];
  }
}));

// https://en.wikipedia.org/wiki/Miller_cylindrical_projection
_projection.projection.add('miller', (0, _projection.projection)({
  aspectRatio: 1,
  to: function (coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, 1.25 * _log(_tan(PI_DIV_4 + clamp(coordinates[1], MILLER_LAT_BOUND) * RADIANS * 0.4)) / PI];
  },
  from: function (coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, (2.5 * _atan(_exp(0.8 * coordinates[1] * PI)) - 0.625 * PI) / RADIANS];
  }
}));

/***/ }),

/***/ 14316:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.projection = exports.Projection = void 0;
var _extend = __webpack_require__(13306);
var _event_emitter = __webpack_require__(63832);
const _Number = Number;
const _min = Math.min;
const _max = Math.max;
const _abs = Math.abs;
const _round = Math.round;
const _ln = Math.log;
const _pow = Math.pow;
const TWO_TO_LN2 = 2 / Math.LN2;

// T224204
// The value is selected so that bounds range of 1 angular second can be defined
// 1 angular second is (1 / 3600) degrees or (1 / 3600 / 180) after projection
// The value 10 times less than projected 1 angular second is chosen
const MIN_BOUNDS_RANGE = 1 / 3600 / 180 / 10;
const DEFAULT_MIN_ZOOM = 1;
const DEFAULT_MAX_ZOOM = 1 << 8;
const DEFAULT_CENTER = [NaN, NaN];
const DEFAULT_ENGINE_NAME = 'mercator';
function floatsEqual(f1, f2) {
  return _abs(f1 - f2) < 1E-8;
}
function arraysEqual(a1, a2) {
  return floatsEqual(a1[0], a2[0]) && floatsEqual(a1[1], a2[1]);
}
function parseAndClamp(value, minValue, maxValue, defaultValue) {
  const val = _Number(value);
  return isFinite(val) ? _min(_max(val, minValue), maxValue) : defaultValue;
}
function parseAndClampArray(value, minValue, maxValue, defaultValue) {
  return [parseAndClamp(value[0], minValue[0], maxValue[0], defaultValue[0]), parseAndClamp(value[1], minValue[1], maxValue[1], defaultValue[1])];
}
function getEngine(engine) {
  return engine instanceof Engine && engine || projection.get(engine) || projection(engine) || projection.get(DEFAULT_ENGINE_NAME);
}
const Projection = function (parameters) {
  const that = this;
  that._initEvents();
  that._params = parameters;
  that._engine = getEngine();
  that._center = that._engine.center();
  that._adjustCenter();
};
exports.Projection = Projection;
Projection.prototype = {
  constructor: Projection,
  _minZoom: DEFAULT_MIN_ZOOM,
  _maxZoom: DEFAULT_MAX_ZOOM,
  _zoom: DEFAULT_MIN_ZOOM,
  _center: DEFAULT_CENTER,
  _canvas: {},
  _scale: [],
  dispose: function () {
    this._disposeEvents();
  },
  setEngine: function (value) {
    const that = this;
    const engine = getEngine(value);
    if (that._engine !== engine) {
      that._engine = engine;
      that._fire('engine');
      if (that._changeCenter(engine.center())) {
        that._triggerCenterChanged();
      }
      if (that._changeZoom(that._minZoom)) {
        that._triggerZoomChanged();
      }
      that._adjustCenter();
      that._setupScreen();
    }
  },
  setBounds: function (bounds) {
    if (bounds !== undefined) {
      this.setEngine(this._engine.original().bounds(bounds));
    }
  },
  _setupScreen: function () {
    const that = this;
    const canvas = that._canvas;
    const width = canvas.width;
    const height = canvas.height;
    const engine = that._engine;
    const aspectRatio = engine.ar();
    that._x0 = canvas.left + width / 2;
    that._y0 = canvas.top + height / 2;
    const min = [that.project([engine.min()[0], 0])[0], that.project([0, engine.min()[1]])[1]];
    const max = [that.project([engine.max()[0], 0])[0], that.project([0, engine.max()[1]])[1]];
    const screenAR = width / height;
    const boundsAR = _abs(max[0] - min[0]) / _abs(max[1] - min[1]);
    let correction;
    if (isNaN(boundsAR) || boundsAR === 0 || _min(screenAR, aspectRatio) <= aspectRatio * boundsAR && aspectRatio * boundsAR <= _max(screenAR, aspectRatio)) {
      correction = 1;
    } else {
      correction = boundsAR > 1 ? boundsAR : 1 / boundsAR;
    }
    if (aspectRatio * boundsAR >= screenAR) {
      that._xRadius = width / 2 / correction;
      that._yRadius = width / 2 / (aspectRatio * correction);
    } else {
      that._xRadius = height / 2 * (aspectRatio / correction);
      that._yRadius = height / 2 / correction;
    }
    that._fire('screen');
  },
  setSize: function (canvas) {
    this._canvas = canvas;
    this._setupScreen();
  },
  getCanvas: function () {
    return this._canvas;
  },
  _toScreen: function (coordinates) {
    return [this._x0 + this._xRadius * coordinates[0], this._y0 + this._yRadius * coordinates[1]];
  },
  _fromScreen: function (coordinates) {
    return [(coordinates[0] - this._x0) / this._xRadius, (coordinates[1] - this._y0) / this._yRadius];
  },
  _toTransformed: function (coordinates) {
    return [coordinates[0] * this._zoom + this._xCenter, coordinates[1] * this._zoom + this._yCenter];
  },
  _toTransformedFast: function (coordinates) {
    return [coordinates[0] * this._zoom, coordinates[1] * this._zoom];
  },
  _fromTransformed: function (coordinates) {
    return [(coordinates[0] - this._xCenter) / this._zoom, (coordinates[1] - this._yCenter) / this._zoom];
  },
  _adjustCenter: function () {
    const that = this;
    const center = that._engine.project(that._center);
    that._xCenter = -center[0] * that._zoom || 0;
    that._yCenter = -center[1] * that._zoom || 0;
  },
  project: function (coordinates) {
    return this._engine.project(coordinates);
  },
  transform: function (coordinates) {
    return this._toScreen(this._toTransformedFast(coordinates));
  },
  isInvertible: function () {
    return this._engine.isInvertible();
  },
  getSquareSize: function (size) {
    return [size[0] * this._zoom * this._xRadius, size[1] * this._zoom * this._yRadius];
  },
  getZoom: function () {
    return this._zoom;
  },
  _changeZoom: function (value) {
    const that = this;
    const oldZoom = that._zoom;
    const newZoom = that._zoom = parseAndClamp(value, that._minZoom, that._maxZoom, that._minZoom);
    const isChanged = !floatsEqual(oldZoom, newZoom);
    if (isChanged) {
      that._adjustCenter();
      that._fire('zoom');
    }
    return isChanged;
  },
  setZoom: function (value) {
    if (this._engine.isInvertible() && this._changeZoom(value)) {
      this._triggerZoomChanged();
    }
  },
  getScaledZoom: function () {
    return _round((this._scale.length - 1) * _ln(this._zoom) / _ln(this._maxZoom));
  },
  setScaledZoom: function (scaledZoom) {
    this.setZoom(this._scale[_round(scaledZoom)]);
  },
  changeScaledZoom: function (deltaZoom) {
    this.setZoom(this._scale[_max(_min(_round(this.getScaledZoom() + deltaZoom), this._scale.length - 1), 0)]);
  },
  getZoomScalePartition: function () {
    return this._scale.length - 1;
  },
  _setupScaling: function () {
    const that = this;
    const k = _max(_round(TWO_TO_LN2 * _ln(that._maxZoom)), 4);
    const step = _pow(that._maxZoom, 1 / k);
    let zoom = that._minZoom;
    that._scale = [zoom];
    for (let i = 1; i <= k; ++i) {
      that._scale.push(zoom *= step);
    }
  },
  setMaxZoom: function (maxZoom) {
    const that = this;
    that._minZoom = DEFAULT_MIN_ZOOM;
    that._maxZoom = parseAndClamp(maxZoom, that._minZoom, _Number.MAX_VALUE, DEFAULT_MAX_ZOOM);
    that._setupScaling();
    if (that._zoom > that._maxZoom) {
      that.setZoom(that._maxZoom);
    }
    that._fire('max-zoom');
  },
  getCenter: function () {
    return this._center.slice();
  },
  setCenter: function (value) {
    if (this._engine.isInvertible() && this._changeCenter(value || [])) {
      this._triggerCenterChanged();
    }
  },
  _changeCenter: function (value) {
    const that = this;
    const engine = that._engine;
    const oldCenter = that._center;
    const newCenter = that._center = parseAndClampArray(value, engine.min(), engine.max(), engine.center());
    const isChanged = !arraysEqual(oldCenter, newCenter);
    if (isChanged) {
      that._adjustCenter();
      that._fire('center');
    }
    return isChanged;
  },
  _triggerCenterChanged: function () {
    this._params.centerChanged(this.getCenter());
  },
  _triggerZoomChanged: function () {
    this._params.zoomChanged(this.getZoom());
  },
  setCenterByPoint: function (coordinates, screenPosition) {
    const that = this;
    const p = that._engine.project(coordinates);
    const q = that._fromScreen(screenPosition);
    that.setCenter(that._engine.unproject([-q[0] / that._zoom + p[0], -q[1] / that._zoom + p[1]]));
  },
  beginMoveCenter: function () {
    if (this._engine.isInvertible()) {
      this._moveCenter = this._center;
    }
  },
  endMoveCenter: function () {
    const that = this;
    if (that._moveCenter) {
      if (!arraysEqual(that._moveCenter, that._center)) {
        that._triggerCenterChanged();
      }
      that._moveCenter = null;
    }
  },
  moveCenter: function (shift) {
    const that = this;
    if (that._moveCenter) {
      const current = that.toScreenPoint(that._center);
      that._changeCenter(that.fromScreenPoint([current[0] + shift[0], current[1] + shift[1]]));
    }
  },
  getViewport: function () {
    const that = this;
    const unproject = that._engine.unproject;
    const lt = unproject(that._fromTransformed([-1, -1]));
    const lb = unproject(that._fromTransformed([-1, +1]));
    const rt = unproject(that._fromTransformed([+1, -1]));
    const rb = unproject(that._fromTransformed([+1, +1]));
    const minMax = findMinMax([selectFarthestPoint(lt[0], lb[0], rt[0], rb[0]), selectFarthestPoint(lt[1], rt[1], lb[1], rb[1])], [selectFarthestPoint(rt[0], rb[0], lt[0], lb[0]), selectFarthestPoint(lb[1], rb[1], lt[1], rt[1])]);
    return [].concat(minMax.min[0], minMax.max[1], minMax.max[0], minMax.min[1]);
  },
  // T254127
  // There should be no expectation that if viewport is got with `getViewport` and set with `setViewport`
  // then center and zoom will be retained - in general case they will be not.
  // Such retaining requires invertibility of projection which is generally not available
  // Invertibility means that `project(unproject([x, y])) === [x, y]` and `unproject(project([x, y])) === [x, y]` for any reasonable `(x, y)`
  // For example:
  // the "mercator" is non invertible - longitude is invertible, latitude is not (because of tan and log)
  // the "equirectangular" is invertible (it uses simple linear transformations)
  setViewport: function (viewport) {
    const engine = this._engine;
    const data = viewport ? getZoomAndCenterFromViewport(engine.project, engine.unproject, viewport) : [this._minZoom, engine.center()];
    this.setZoom(data[0]);
    this.setCenter(data[1]);
  },
  getTransform: function () {
    return {
      translateX: this._xCenter * this._xRadius,
      translateY: this._yCenter * this._yRadius
    };
  },
  fromScreenPoint: function (coordinates) {
    return this._engine.unproject(this._fromTransformed(this._fromScreen(coordinates)));
  },
  toScreenPoint: function (coordinates) {
    return this._toScreen(this._toTransformed(this._engine.project(coordinates)));
  },
  _eventNames: ['engine', 'screen', 'center', 'zoom', 'max-zoom']
};
(0, _event_emitter.makeEventEmitter)(Projection);
function selectFarthestPoint(point1, point2, basePoint1, basePoint2) {
  const basePoint = (basePoint1 + basePoint2) / 2;
  return _abs(point1 - basePoint) > _abs(point2 - basePoint) ? point1 : point2;
}
function selectClosestPoint(point1, point2, basePoint1, basePoint2) {
  const basePoint = (basePoint1 + basePoint2) / 2;
  return _abs(point1 - basePoint) < _abs(point2 - basePoint) ? point1 : point2;
}
function getZoomAndCenterFromViewport(project, unproject, viewport) {
  const lt = project([viewport[0], viewport[3]]);
  const lb = project([viewport[0], viewport[1]]);
  const rt = project([viewport[2], viewport[3]]);
  const rb = project([viewport[2], viewport[1]]);
  const l = selectClosestPoint(lt[0], lb[0], rt[0], rb[0]);
  const r = selectClosestPoint(rt[0], rb[0], lt[0], lb[0]);
  const t = selectClosestPoint(lt[1], rt[1], lb[1], rb[1]);
  const b = selectClosestPoint(lb[1], rb[1], lt[1], rt[1]);
  return [2 / _max(_abs(l - r), _abs(t - b)), unproject([(l + r) / 2, (t + b) / 2])];
}
function setMinMax(engine, p1, p2) {
  const {
    min,
    max
  } = findMinMax(p1, p2);
  engine.min = returnArray(min);
  engine.max = returnArray(max);
}
const Engine = class {
  constructor(parameters) {
    const that = this;
    const project = createProjectMethod(parameters.to);
    const unproject = parameters.from ? createUnprojectMethod(parameters.from) : returnValue(DEFAULT_CENTER);
    that.project = project;
    that.unproject = unproject;
    that.original = returnValue(that);
    that.source = function () {
      return (0, _extend.extend)({}, parameters);
    };
    that.isInvertible = returnValue(!!parameters.from);
    that.ar = returnValue(parameters.aspectRatio > 0 ? _Number(parameters.aspectRatio) : 1);
    that.center = returnArray(unproject([0, 0]));
    setMinMax(that, [unproject([-1, 0])[0], unproject([0, +1])[1]], [unproject([+1, 0])[0], unproject([0, -1])[1]]);
  }
  aspectRatio(aspectRatio) {
    const engine = new Engine((0, _extend.extend)(this.source(), {
      aspectRatio: aspectRatio
    }));
    engine.original = this.original;
    engine.min = this.min;
    engine.max = this.max;
    return engine;
  }
  bounds(bounds) {
    bounds = bounds || [];
    const parameters = this.source();
    const min = this.min();
    const max = this.max();
    const b1 = parseAndClampArray([bounds[0], bounds[1]], min, max, min);
    const b2 = parseAndClampArray([bounds[2], bounds[3]], min, max, max);
    const p1 = parameters.to(b1);
    const p2 = parameters.to(b2);
    const delta = _min(_abs(p2[0] - p1[0]) > MIN_BOUNDS_RANGE ? _abs(p2[0] - p1[0]) : 2, _abs(p2[1] - p1[1]) > MIN_BOUNDS_RANGE ? _abs(p2[1] - p1[1]) : 2);
    if (delta < 2) {
      (0, _extend.extend)(parameters, createProjectUnprojectMethods(parameters.to, parameters.from, p1, p2, delta));
    }
    const engine = new Engine(parameters);
    engine.original = this.original;
    setMinMax(engine, b1, b2);
    return engine;
  }
};
function invertVerticalAxis(pair) {
  return [pair[0], -pair[1]];
}
function createProjectMethod(method) {
  return arg => invertVerticalAxis(method(arg));
}
function createUnprojectMethod(method) {
  return arg => method(invertVerticalAxis(arg));
}
function returnValue(value) {
  return () => value;
}
function returnArray(value) {
  return () => value.slice();
}
function findMinMax(p1, p2) {
  return {
    min: [_min(p1[0], p2[0]), _min(p1[1], p2[1])],
    max: [_max(p1[0], p2[0]), _max(p1[1], p2[1])]
  };
}
const projection = function (parameters) {
  return parameters && parameters.to ? new Engine(parameters) : null;
};
exports.projection = projection;
const projectionsCache = {};
projection.get = function (name) {
  return projectionsCache[name] || null;
};
projection.add = function (name, engine) {
  engine = engine instanceof Engine && engine || projection(engine);
  if (!projectionsCache[name] && engine) {
    projectionsCache[name] = engine;
  }
  return projection; // For chaining
};
function createProjectUnprojectMethods(project, unproject, p1, p2, delta) {
  const x0 = (p1[0] + p2[0]) / 2 - delta / 2;
  const y0 = (p1[1] + p2[1]) / 2 - delta / 2;
  const k = 2 / delta;
  return {
    to: function (coordinates) {
      const [p0, p1] = project(coordinates);
      return [-1 + (p0 - x0) * k, -1 + (p1 - y0) * k];
    },
    from: function (coordinates) {
      return unproject([x0 + (coordinates[0] + 1) / k, y0 + (coordinates[1] + 1) / k]);
    }
  };
}

/***/ }),

/***/ 8068:
/***/ (function(__unused_webpack_module, exports) {



exports.TooltipViewer = TooltipViewer;
const TOOLTIP_OFFSET = 12;

// TODO: Somehow it should be merged with the core.Tooltip
function TooltipViewer(params) {
  this._subscribeToTracker(params.tracker, params.tooltip, params.layerCollection);
}
TooltipViewer.prototype = {
  constructor: TooltipViewer,
  dispose: function () {
    this._offTracker();
    this._offTracker = null;
  },
  _subscribeToTracker: function (tracker, tooltip, layerCollection) {
    this._offTracker = tracker.on({
      'focus-on': function (arg) {
        let layer;
        let proxy;
        if (tooltip.isEnabled()) {
          layer = layerCollection.byName(arg.data.name);
          proxy = layer && layer.getProxy(arg.data.index);
          const callback = result => {
            result && arg.done(result);
          };
          proxy && callback(tooltip.show(proxy, {
            x: arg.x,
            y: arg.y,
            offset: TOOLTIP_OFFSET
          }, {
            target: proxy
          }, undefined, callback));
        }
      },
      // There are no checks for `tooltip.isEnabled()` in the following two handlers because they are called only if the previous one has finished with `true`
      'focus-move': function (arg) {
        tooltip.move(arg.x, arg.y, TOOLTIP_OFFSET);
      },
      'focus-off': function () {
        tooltip.hide();
      }
    });
  }
};

/***/ }),

/***/ 49497:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Tracker = Tracker;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _event_emitter = __webpack_require__(63832);
var _index = __webpack_require__(39611);
var _wheel = __webpack_require__(765);
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const navigator = (0, _window.getNavigator)();
const _math = Math;
const _abs = _math.abs;
const _sqrt = _math.sqrt;
const _round = _math.round;
const _addNamespace = _index.addNamespace;
const _NAME = 'dxVectorMap';
const EVENT_START = 'start';
const EVENT_MOVE = 'move';
const EVENT_END = 'end';
const EVENT_ZOOM = 'zoom';
const EVENT_HOVER_ON = 'hover-on';
const EVENT_HOVER_OFF = 'hover-off';
const EVENT_CLICK = 'click';
const EVENT_FOCUS_ON = 'focus-on';
const EVENT_FOCUS_MOVE = 'focus-move';
const EVENT_FOCUS_OFF = 'focus-off';
const CLICK_TIME_THRESHOLD = 500;
const CLICK_COORD_THRESHOLD_MOUSE = 5;
const CLICK_COORD_THRESHOLD_TOUCH = 20;
const DRAG_COORD_THRESHOLD_MOUSE = 5;
const DRAG_COORD_THRESHOLD_TOUCH = 10;
const WHEEL_COOLDOWN = 50;
const WHEEL_DIRECTION_COOLDOWN = 300;
let EVENTS;
let Focus;
setupEvents();
function Tracker(parameters) {
  const that = this;
  that._root = parameters.root;
  that._createEventHandlers(parameters.dataKey);
  that._createProjectionHandlers(parameters.projection);
  that._initEvents();
  that._focus = new Focus(function (name, arg) {
    that._fire(name, arg);
  });
  that._attachHandlers();
}
Tracker.prototype = {
  constructor: Tracker,
  dispose: function () {
    const that = this;
    that._detachHandlers();
    that._disposeEvents();
    that._focus.dispose();
    that._root = that._focus = that._docHandlers = that._rootHandlers = null;
  },
  _eventNames: [EVENT_START, EVENT_MOVE, EVENT_END, EVENT_ZOOM, EVENT_CLICK, EVENT_HOVER_ON, EVENT_HOVER_OFF, EVENT_FOCUS_ON, EVENT_FOCUS_OFF, EVENT_FOCUS_MOVE],
  _startClick: function (event, data) {
    if (!data) {
      return;
    }
    const coords = getEventCoords(event);
    this._clickState = {
      x: coords.x,
      y: coords.y,
      threshold: isTouchEvent(event) ? CLICK_COORD_THRESHOLD_TOUCH : CLICK_COORD_THRESHOLD_MOUSE,
      time: Date.now()
    };
  },
  _endClick: function (event, data) {
    const state = this._clickState;
    let threshold;
    let coords;
    if (!state) {
      return;
    }
    if (data && Date.now() - state.time <= CLICK_TIME_THRESHOLD) {
      threshold = state.threshold;
      coords = getEventCoords(event);
      if (_abs(coords.x - state.x) <= threshold && _abs(coords.y - state.y) <= threshold) {
        this._fire(EVENT_CLICK, {
          data: data,
          x: coords.x,
          y: coords.y,
          $event: event
        });
      }
    }
    this._clickState = null;
  },
  _startDrag: function (event, data) {
    if (!data) {
      return;
    }
    const coords = getEventCoords(event);
    const state = this._dragState = {
      x: coords.x,
      y: coords.y,
      data: data
    };
    this._fire(EVENT_START, {
      x: state.x,
      y: state.y,
      data: state.data
    });
  },
  _moveDrag: function (event, data) {
    const state = this._dragState;
    if (!state) {
      return;
    }
    const coords = getEventCoords(event);
    const threshold = isTouchEvent(event) ? DRAG_COORD_THRESHOLD_TOUCH : DRAG_COORD_THRESHOLD_MOUSE;
    if (state.active || _abs(coords.x - state.x) > threshold || _abs(coords.y - state.y) > threshold) {
      state.x = coords.x;
      state.y = coords.y;
      state.active = true;
      state.data = data || {};
      this._fire(EVENT_MOVE, {
        x: state.x,
        y: state.y,
        data: state.data
      });
    }
  },
  _endDrag: function () {
    const state = this._dragState;
    if (!state) {
      return;
    }
    this._dragState = null;
    this._fire(EVENT_END, {
      x: state.x,
      y: state.y,
      data: state.data
    });
  },
  _wheelZoom: function (event, data) {
    if (!data) {
      return;
    }
    const that = this;
    const lock = that._wheelLock;
    const time = Date.now();
    if (time - lock.time <= WHEEL_COOLDOWN) {
      return;
    }
    // T136650
    if (time - lock.dirTime > WHEEL_DIRECTION_COOLDOWN) {
      lock.dir = 0;
    }
    // T107589, T136650
    const delta = adjustWheelDelta(event.delta / 120 || 0, lock);
    if (delta === 0) {
      return;
    }
    const coords = getEventCoords(event);
    that._fire(EVENT_ZOOM, {
      delta: delta,
      x: coords.x,
      y: coords.y
    });
    lock.time = lock.dirTime = time;
  },
  _startZoom: function (event, data) {
    if (!isTouchEvent(event) || !data) {
      return;
    }
    const state = this._zoomState = this._zoomState || {};
    let coords;
    let pointer2;
    if (state.pointer1 && state.pointer2) {
      return;
    }
    if (state.pointer1 === undefined) {
      state.pointer1 = getPointerId(event) || 0;
      coords = getMultitouchEventCoords(event, state.pointer1);
      state.x1 = state.x1_0 = coords.x;
      state.y1 = state.y1_0 = coords.y;
    }
    if (state.pointer2 === undefined) {
      pointer2 = getPointerId(event) || 1;
      if (pointer2 !== state.pointer1) {
        coords = getMultitouchEventCoords(event, pointer2);
        if (coords) {
          state.x2 = state.x2_0 = coords.x;
          state.y2 = state.y2_0 = coords.y;
          state.pointer2 = pointer2;
          state.ready = true;
          this._endDrag();
        }
      }
    }
  },
  _moveZoom: function (event) {
    const state = this._zoomState;
    let coords;
    if (!state || !isTouchEvent(event)) {
      return;
    }
    if (state.pointer1 !== undefined) {
      coords = getMultitouchEventCoords(event, state.pointer1);
      if (coords) {
        state.x1 = coords.x;
        state.y1 = coords.y;
      }
    }
    if (state.pointer2 !== undefined) {
      coords = getMultitouchEventCoords(event, state.pointer2);
      if (coords) {
        state.x2 = coords.x;
        state.y2 = coords.y;
      }
    }
  },
  _endZoom: function (event) {
    const state = this._zoomState;
    let startDistance;
    let currentDistance;
    if (!state || !isTouchEvent(event)) {
      return;
    }
    if (state.ready) {
      startDistance = getDistance(state.x1_0, state.y1_0, state.x2_0, state.y2_0);
      currentDistance = getDistance(state.x1, state.y1, state.x2, state.y2);
      this._fire(EVENT_ZOOM, {
        ratio: currentDistance / startDistance,
        x: (state.x1_0 + state.x2_0) / 2,
        y: (state.y1_0 + state.y2_0) / 2
      });
    }
    this._zoomState = null;
  },
  _startHover: function (event, data) {
    this._doHover(event, data, true);
  },
  _moveHover: function (event, data) {
    this._doHover(event, data, false);
  },
  _doHover: function (event, data, isTouch) {
    const that = this;
    if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
      that._cancelHover();
      return;
    }
    if (isTouchEvent(event) !== isTouch || that._hoverTarget === event.target || that._hoverState && that._hoverState.data === data) {
      return;
    }
    that._cancelHover();
    if (data) {
      that._hoverState = {
        data: data
      };
      that._fire(EVENT_HOVER_ON, {
        data: data
      });
    }
    that._hoverTarget = event.target;
  },
  _cancelHover: function () {
    const state = this._hoverState;
    this._hoverState = this._hoverTarget = null;
    if (state) {
      this._fire(EVENT_HOVER_OFF, {
        data: state.data
      });
    }
  },
  _startFocus: function (event, data) {
    this._doFocus(event, data, true);
  },
  _moveFocus: function (event, data) {
    this._doFocus(event, data, false);
  },
  _doFocus: function (event, data, isTouch) {
    const that = this;
    if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
      that._cancelFocus();
      return;
    }
    if (isTouchEvent(event) !== isTouch) {
      return;
    }
    that._focus.turnOff();
    data && that._focus.turnOn(data, getEventCoords(event));
  },
  _cancelFocus: function () {
    this._focus.cancel();
  },
  _createEventHandlers: function (DATA_KEY) {
    const that = this;
    that._docHandlers = {};
    that._rootHandlers = {};
    that._docHandlers[EVENTS.start] = function (event) {
      const isTouch = isTouchEvent(event);
      const data = getData(event);
      if (isTouch && !that._isTouchEnabled) {
        return;
      }
      if (data) {
        event.preventDefault();
      }
      that._startClick(event, data);
      that._startDrag(event, data);
      that._startZoom(event, data);
      that._startHover(event, data);
      that._startFocus(event, data);
    };
    that._docHandlers[EVENTS.move] = function (event) {
      const isTouch = isTouchEvent(event);
      const data = getData(event);
      if (isTouch && !that._isTouchEnabled) {
        return;
      }
      that._moveDrag(event, data);
      that._moveZoom(event, data);
      that._moveHover(event, data);
      that._moveFocus(event, data);
    };
    that._docHandlers[EVENTS.end] = function (event) {
      const isTouch = isTouchEvent(event);
      const data = getData(event);
      if (isTouch && !that._isTouchEnabled) {
        return;
      }
      that._endClick(event, data);
      that._endDrag(event, data);
      that._endZoom(event, data);
    };
    that._rootHandlers[EVENTS.wheel] = function (event) {
      that._cancelFocus();
      if (!that._isWheelEnabled) {
        return;
      }
      const data = getData(event);
      if (data) {
        event.preventDefault();
        event.stopPropagation(); // T249548
        that._wheelZoom(event, data);
      }
    };
    that._wheelLock = {
      dir: 0
    };

    // Actually it is responsibility of the text element wrapper to handle "data" to its span elements (if there are any).
    // Now to avoid not so necessary complication of renderer text-span issue is handled on the side of the tracker.
    function getData(event) {
      const target = event.target;
      return (target.tagName === 'tspan' ? target.parentNode : target)[DATA_KEY];
    }
  },
  _createProjectionHandlers: function (projection) {
    const that = this;
    projection.on({
      'center': handler,
      'zoom': handler
    }); // T247841
    function handler() {
      // `_cancelHover` probably should also be called here but for now let it not be so
      that._cancelFocus();
    }
  },
  reset: function () {
    const that = this;
    that._clickState = null;
    that._endDrag();
    that._cancelHover();
    that._cancelFocus();
  },
  setOptions: function (options) {
    const that = this;
    that.reset();
    that._detachHandlers();
    that._isTouchEnabled = !!(0, _utils.parseScalar)(options.touchEnabled, true);
    that._isWheelEnabled = !!(0, _utils.parseScalar)(options.wheelEnabled, true);
    that._attachHandlers();
  },
  _detachHandlers: function () {
    const that = this;
    if (that._isTouchEnabled) {
      that._root.css({
        'touch-action': '',
        '-webkit-user-select': ''
      }).off(_addNamespace('MSHoldVisual', _NAME)).off(_addNamespace('contextmenu', _NAME));
    }
    _events_engine.default.off(_dom_adapter.default.getDocument(), that._docHandlers);
    that._root.off(that._rootHandlers);
  },
  _attachHandlers: function () {
    const that = this;
    if (that._isTouchEnabled) {
      that._root.css({
        'touch-action': 'none',
        '-webkit-user-select': 'none'
      }).on(_addNamespace('MSHoldVisual', _NAME), function (event) {
        event.preventDefault();
      }).on(_addNamespace('contextmenu', _NAME), function (event) {
        isTouchEvent(event) && event.preventDefault();
      });
    }
    _events_engine.default.on(_dom_adapter.default.getDocument(), that._docHandlers);
    that._root.on(that._rootHandlers);
  }
};
Focus = function (fire) {
  let that = this;
  let _activeData = null;
  let _data = null;
  let _disabled = false;
  let _x;
  let _y;
  that.dispose = function () {
    that.turnOn = that.turnOff = that.cancel = that.dispose = that = fire = _activeData = _data = null;
  };
  that.turnOn = function (data, coords) {
    if (data === _data && _disabled) {
      return;
    }
    _disabled = false;
    _data = data;
    if (_activeData) {
      _x = coords.x;
      _y = coords.y;
      if (_data === _activeData) {
        fire(EVENT_FOCUS_MOVE, {
          data: _data,
          x: _x,
          y: _y
        });
        onCheck(true);
      } else {
        fire(EVENT_FOCUS_ON, {
          data: _data,
          x: _x,
          y: _y,
          done: onCheck
        });
      }
    } else {
      _x = coords.x;
      _y = coords.y;
      fire(EVENT_FOCUS_ON, {
        data: _data,
        x: _x,
        y: _y,
        done: onCheck
      });
    }
    function onCheck(result) {
      _disabled = !result;
      if (result) {
        _activeData = _data;
      }
    }
  };
  that.turnOff = function () {
    _data = null;
    if (_activeData && !_disabled) {
      fire(EVENT_FOCUS_OFF, {
        data: _activeData
      });
      _activeData = null;
    }
  };
  that.cancel = function () {
    if (_activeData) {
      fire(EVENT_FOCUS_OFF, {
        data: _activeData
      });
    }
    _activeData = _data = null;
  };
};
(0, _event_emitter.makeEventEmitter)(Tracker);
function getDistance(x1, y1, x2, y2) {
  return _sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
function isTouchEvent(event) {
  const type = event.originalEvent.type;
  const pointerType = event.originalEvent.pointerType;
  return /^touch/.test(type) || /^MSPointer/.test(type) && pointerType !== 4 || /^pointer/.test(type) && pointerType !== 'mouse';
}
function selectItem(flags, items) {
  let i = 0;
  const ii = flags.length;
  let item;
  for (; i < ii; ++i) {
    if (flags[i]) {
      item = items[i];
      break;
    }
  }
  return _addNamespace(item || items[i], _NAME);
}
function setupEvents() {
  let flags = [navigator.pointerEnabled, navigator.msPointerEnabled, (0, _window.hasProperty)('ontouchstart')];
  EVENTS = {
    start: selectItem(flags, ['pointerdown', 'MSPointerDown', 'touchstart mousedown', 'mousedown']),
    move: selectItem(flags, ['pointermove', 'MSPointerMove', 'touchmove mousemove', 'mousemove']),
    end: selectItem(flags, ['pointerup', 'MSPointerUp', 'touchend mouseup', 'mouseup']),
    wheel: _addNamespace(_wheel.name, _NAME)
  };
}
function getEventCoords(event) {
  const originalEvent = event.originalEvent;
  const touch = originalEvent.touches && originalEvent.touches[0] || {};
  return {
    x: touch.pageX || originalEvent.pageX || event.pageX,
    y: touch.pageY || originalEvent.pageY || event.pageY
  };
}
function getPointerId(event) {
  return event.originalEvent.pointerId;
}
function getMultitouchEventCoords(event, pointerId) {
  let originalEvent = event.originalEvent;
  if (originalEvent.pointerId !== undefined) {
    originalEvent = originalEvent.pointerId === pointerId ? originalEvent : null;
  } else {
    originalEvent = originalEvent.touches[pointerId];
  }
  return originalEvent ? {
    x: originalEvent.pageX || event.pageX,
    y: originalEvent.pageY || event.pageY
  } : null;
}
function adjustWheelDelta(delta, lock) {
  if (delta === 0) {
    return 0;
  }
  let _delta = _abs(delta);
  const sign = _round(delta / _delta);
  if (lock.dir && sign !== lock.dir) {
    return 0;
  }
  lock.dir = sign;
  if (_delta < 0.1) {
    _delta = 0;
  } else if (_delta < 1) {
    _delta = 1;
  } else if (_delta > 4) {
    _delta = 4;
  } else {
    _delta = _round(_delta);
  }
  return sign * _delta;
}

/***/ }),

/***/ 13711:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _projection = __webpack_require__(14316);
var _control_bar = __webpack_require__(17323);
var _gesture_handler = __webpack_require__(3797);
var _tracker = __webpack_require__(49497);
var _data_exchanger = __webpack_require__(93699);
var _legend = __webpack_require__(7291);
var _layout = __webpack_require__(39378);
var _map_layer = __webpack_require__(15151);
var _tooltip_viewer = __webpack_require__(8068);
var _vector_map = __webpack_require__(56145);
__webpack_require__(102);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _tooltip = __webpack_require__(14371);
var _loading_indicator = __webpack_require__(64758);
var _annotations = __webpack_require__(77129);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_WIDTH = 800;
const DEFAULT_HEIGHT = 400;
const RE_STARTS_LAYERS = /^layers/;
const RE_ENDS_DATA_SOURCE = /\.dataSource$/;
function mergeBounds(sumBounds, dataBounds) {
  return dataBounds ? [Math.min(dataBounds[0], dataBounds[2], sumBounds[0]), Math.min(dataBounds[1], dataBounds[3], sumBounds[3]), Math.max(dataBounds[0], dataBounds[2], sumBounds[2]), Math.max(dataBounds[1], dataBounds[3], sumBounds[1])] : sumBounds;
}
const dxVectorMap = _m_base_widget.default.inherit({
  _eventsMap: {
    'onClick': {
      name: 'click'
    },
    'onCenterChanged': {
      name: 'centerChanged'
    },
    'onZoomFactorChanged': {
      name: 'zoomFactorChanged'
    },
    'onHoverChanged': {
      name: 'hoverChanged'
    },
    'onSelectionChanged': {
      name: 'selectionChanged'
    }
  },
  _rootClassPrefix: 'dxm',
  _rootClass: 'dxm-vector-map',
  _themeSection: 'map',
  _fontFields: ['layer:area.label.font', 'layer:marker:dot.label.font', 'layer:marker:bubble.label.font', 'layer:marker:pie.label.font', 'layer:marker:image.label.font', 'legend.font', 'legend.title.font', 'legend.title.subtitle.font'],
  _initLayerCollection: function (dataKey) {
    const that = this;
    that._layerCollection = new _map_layer.MapLayerCollection({
      renderer: that._renderer,
      projection: that._projection,
      themeManager: that._themeManager,
      tracker: that._tracker,
      dataKey: dataKey,
      eventTrigger: that._eventTrigger,
      dataExchanger: that._dataExchanger,
      tooltip: that._tooltip,
      notifyDirty: that._notifyDirty,
      notifyReady: that._notifyReady,
      dataReady() {
        let bounds;
        if (that.option('getBoundsFromData') && !that.option('bounds')) {
          that._preventProjectionEvents();
          bounds = that._getBoundsFromData();
          that._projection.setBounds(bounds);
          that._allowProjectionEvents();
        }
        if (!that.option('projection')) {
          bounds = bounds || that._getBoundsFromData();
          if (Math.ceil(bounds[0]) < -180 || Math.ceil(bounds[3]) < -90 || Math.floor(bounds[2]) > 180 || Math.floor(bounds[1]) > 90) {
            const longitudeLength = bounds[2] - bounds[0];
            const latitudeLength = bounds[1] - bounds[3];
            that._projection.setEngine({
              to(coordinates) {
                return [(coordinates[0] - bounds[0]) * 2 / longitudeLength - 1, (coordinates[1] - bounds[3]) * 2 / latitudeLength - 1];
              },
              from(coordinates) {
                return [(coordinates[0] + 1) * longitudeLength / 2 + bounds[0], (coordinates[1] + 1) * latitudeLength / 2 + bounds[3]];
              }
            });
          }
        }
      }
    });
  },
  _getBoundsFromData() {
    let bounds = this._getBoundingBoxFromDataSource();
    if (!bounds) {
      const layersBounds = this.getLayers().map(l => l.getBounds()).filter(x => x !== undefined);
      const boundsByData = (0, _map_layer.getMaxBound)(layersBounds);
      if (boundsByData) {
        bounds = boundsByData;
      }
    }
    bounds = bounds || [];
    bounds = [bounds[0], bounds[3], bounds[2], bounds[1]];
    return bounds;
  },
  _initLegendsControl: function () {
    const that = this;
    that._legendsControl = new _legend.LegendsControl({
      renderer: that._renderer,
      container: that._root,
      widget: that,
      layoutControl: that._layoutControl,
      themeManager: that._themeManager,
      dataExchanger: that._dataExchanger,
      notifyDirty: that._notifyDirty,
      notifyReady: that._notifyReady
    });
  },
  _initControlBar: function (dataKey) {
    const that = this;
    that._controlBar = new _control_bar.ControlBar({
      renderer: that._renderer,
      container: that._root,
      layoutControl: that._layoutControl,
      projection: that._projection,
      tracker: that._tracker,
      dataKey: dataKey
    });
  },
  _initElements: function () {
    const that = this;
    const dataKey = (0, _vector_map.generateDataKey)();
    let notifyCounter = 0;
    let preventProjectionEvents;
    that._preventProjectionEvents = function () {
      preventProjectionEvents = true;
    };
    that._allowProjectionEvents = function () {
      preventProjectionEvents = false;
    };
    that._notifyDirty = function () {
      that._resetIsReady();
      ++notifyCounter;
    };
    that._notifyReady = function () {
      that._allowProjectionEvents();
      if (--notifyCounter === 0) {
        that._drawn();
      }
    };
    that._preventProjectionEvents();
    that._dataExchanger = new _data_exchanger.DataExchanger();

    // The `{ eventTrigger: that._eventTrigger }` object cannot be passed to the Projection because later backward option updating is going to be added.
    that._projection = new _projection.Projection({
      centerChanged: function (value) {
        if (!preventProjectionEvents) {
          that._eventTrigger('centerChanged', {
            center: value
          });
        }
      },
      zoomChanged: function (value) {
        if (!preventProjectionEvents) {
          that._eventTrigger('zoomFactorChanged', {
            zoomFactor: value
          });
        }
      }
    });
    that._tracker = new _tracker.Tracker({
      root: that._root,
      projection: that._projection,
      dataKey: dataKey
    });
    that._gestureHandler = new _gesture_handler.GestureHandler({
      projection: that._projection,
      renderer: that._renderer,
      tracker: that._tracker
    });
    that._layoutControl = new _layout.LayoutControl(that);
    that._layoutControl.suspend();
    that._initLayerCollection(dataKey);
    that._createHtmlStructure();
    that._initControlBar(dataKey);
    that._initLegendsControl();
    that._prepareExtraElements();
    that._tooltipViewer = new _tooltip_viewer.TooltipViewer({
      tracker: that._tracker,
      tooltip: that._tooltip,
      layerCollection: that._layerCollection
    });
  },
  _change_RESUME_LAYOUT: function () {
    this._layoutControl.resume();
  },
  _initialChanges: ['PROJECTION', 'RESUME_LAYOUT', 'LAYOUT_INIT', 'BOUNDS', 'MAX_ZOOM_FACTOR', 'ZOOM_FACTOR', 'CENTER'],
  _layoutChangesOrder: ['RESUME_LAYOUT', 'LAYERS'],
  _customChangesOrder: ['EXTRA_ELEMENTS'],
  _initCore: function () {
    this._root = this._renderer.root.attr({
      align: 'center',
      cursor: 'default'
    });
    this._initElements();
  },
  _disposeCore: function () {
    const that = this;
    that._controlBar.dispose();
    that._gestureHandler.dispose();
    that._tracker.dispose();
    that._legendsControl.dispose();
    that._layerCollection.dispose();
    that._layoutControl.dispose();
    that._tooltipViewer.dispose();
    that._dataExchanger.dispose();
    that._projection.dispose();
    that._dataExchanger = that._gestureHandler = that._projection = that._tracker = that._layoutControl = that._root = that._layerCollection = that._controlBar = that._legendsControl = null;
  },
  _setupInteraction: function () {
    const options = {
      centeringEnabled: !!(0, _utils.parseScalar)(this._getOption('panningEnabled', true), true),
      zoomingEnabled: !!(0, _utils.parseScalar)(this._getOption('zoomingEnabled', true), true)
    };
    this._gestureHandler.setInteraction(options);
    this._controlBar.setInteraction(options);
  },
  _getDefaultSize: function () {
    return {
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT
    };
  },
  _applySize: function (rect) {
    const layout = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1],
      right: 0,
      bottom: 0
    };
    this._projection.setSize(layout);
    this._layoutControl.setSize(layout);
    this._layerCollection.setRect([layout.left, layout.top, layout.width, layout.height]);
    this._requestChange(['EXTRA_ELEMENTS']);
  },
  // The "layers_data", "mapData", "markers" options must never be merged (because of their meaning)
  // For "layers_data" there are special cases: "layers", "layers.data", "layers[i]", "layers[i].data"
  // Because of the cases (1) and (3) "option by reference" mechanism cannot be used -
  // so separate (for dxVectorMap only by now) mechanism is introduced - it handles all cases (including "option by reference")
  // T318992
  // Previously mechanism used the "_optionValuesEqual" method but after T318992 usage of "_optionValuesEqual" was stopped
  // and new (more meaningful) method was added - "_optionChanging"
  _optionChanging: function (name, currentValue, nextValue) {
    if (currentValue && nextValue) {
      if (RE_STARTS_LAYERS.test(name)) {
        if (currentValue.dataSource && nextValue.dataSource && currentValue !== nextValue) {
          currentValue.dataSource = null;
        } else if (RE_ENDS_DATA_SOURCE.test(name)) {
          this.option(name, null);
        }
      }
    }
  },
  _applyChanges: function () {
    this._notifyDirty();
    this.callBase.apply(this, arguments);
    this._notifyReady();
  },
  _optionChangesMap: {
    background: 'BACKGROUND',
    layers: 'LAYERS',
    extraElements: 'EXTRA_ELEMENTS',
    controlBar: 'CONTROL_BAR',
    legends: 'LEGENDS',
    touchEnabled: 'TRACKER',
    wheelEnabled: 'TRACKER',
    panningEnabled: 'INTERACTION',
    zoomingEnabled: 'INTERACTION',
    projection: 'PROJECTION',
    bounds: 'BOUNDS',
    maxZoomFactor: 'MAX_ZOOM_FACTOR',
    zoomFactor: 'ZOOM_FACTOR',
    center: 'CENTER'
  },
  _optionChangesOrder: ['PROJECTION', 'BOUNDS', 'MAX_ZOOM_FACTOR', 'ZOOM_FACTOR', 'CENTER', 'BACKGROUND', 'CONTROL_BAR', 'LEGENDS', 'TRACKER', 'INTERACTION'],
  _change_PROJECTION: function () {
    this._setProjection();
  },
  _change_BOUNDS: function () {
    this._setBounds();
  },
  _change_MAX_ZOOM_FACTOR: function () {
    this._setMaxZoom();
  },
  _change_ZOOM_FACTOR: function () {
    this._setZoom();
  },
  _change_CENTER: function () {
    this._setCenter();
  },
  _change_BACKGROUND: function () {
    this._setBackgroundOptions();
  },
  _change_LAYERS: function () {
    this._setLayerCollectionOptions();
  },
  _change_CONTROL_BAR: function () {
    this._setControlBarOptions();
  },
  _change_EXTRA_ELEMENTS: function () {
    this._renderExtraElements();
  },
  _change_LEGENDS: function () {
    this._setLegendsOptions();
  },
  _change_TRACKER: function () {
    this._setTrackerOptions();
  },
  _change_INTERACTION: function () {
    this._setupInteraction();
  },
  _themeDependentChanges: ['BACKGROUND', 'LAYERS', 'CONTROL_BAR', 'LEGENDS', 'TRACKER', 'INTERACTION'],
  _setProjection: function () {
    this._projection.setEngine(this.option('projection'));
  },
  _setBounds: function () {
    this._projection.setBounds(this.option('bounds'));
  },
  _setMaxZoom: function () {
    this._projection.setMaxZoom(this.option('maxZoomFactor'));
  },
  _setZoom: function () {
    this._projection.setZoom(this.option('zoomFactor'));
  },
  _setCenter: function () {
    this._projection.setCenter(this.option('center'));
  },
  _setBackgroundOptions: function () {
    this._layerCollection.setBackgroundOptions(this._getOption('background'));
  },
  _setLayerCollectionOptions: function () {
    this._layerCollection.setOptions(this.option('layers'));
  },
  _getBoundingBoxFromDataSource() {
    const that = this;
    const layers = that._layerCollection.items();
    const infinityBounds = [Infinity, -Infinity, -Infinity, Infinity];
    const resultBBox = layers && layers.length ? layers.reduce((sumBBox, l) => {
      const layerData = l.getData();
      const itemCount = layerData.count();
      if (itemCount > 0) {
        const rootBBox = layerData.getBBox();
        if (rootBBox) {
          sumBBox = mergeBounds(sumBBox, rootBBox);
        } else {
          for (let i = 0; i < itemCount; i++) {
            sumBBox = mergeBounds(sumBBox, layerData.getBBox(i));
          }
        }
      }
      return sumBBox;
    }, infinityBounds) : undefined;
    return resultBBox === infinityBounds ? undefined : resultBBox;
  },
  _setControlBarOptions: function () {
    this._controlBar.setOptions(this._getOption('controlBar'));
  },
  _setLegendsOptions: function () {
    this._legendsControl.setOptions(this.option('legends'));
  },
  _setTrackerOptions: function () {
    this._tracker.setOptions({
      touchEnabled: this._getOption('touchEnabled', true),
      wheelEnabled: this._getOption('wheelEnabled', true)
    });
  },
  getLayers() {
    return this._layerCollection.items().map(l => l.proxy);
  },
  getLayerByIndex: function (index) {
    const layer = this._layerCollection.byIndex(index);
    return layer ? layer.proxy : null;
  },
  getLayerByName: function (name) {
    const layer = this._layerCollection.byName(name);
    return layer ? layer.proxy : null;
  },
  clearSelection: function (_noEvent) {
    const layers = this._layerCollection.items();
    let i;
    const ii = layers.length;
    for (i = 0; i < ii; ++i) {
      layers[i].clearSelection(_noEvent);
    }
    return this;
  },
  center: function (value) {
    const that = this;
    if (value === undefined) {
      return that._projection.getCenter();
    } else {
      that._projection.setCenter(value);
      return that;
    }
  },
  zoomFactor: function (value) {
    const that = this;
    if (value === undefined) {
      return that._projection.getZoom();
    } else {
      that._projection.setZoom(value);
      return that;
    }
  },
  viewport: function (value) {
    const that = this;
    if (value === undefined) {
      return that._projection.getViewport();
    } else {
      that._projection.setViewport(value);
      return that;
    }
  },
  convertCoordinates: function (coordinates) {
    coordinates = coordinates && coordinates.length ? coordinates : [arguments[0], arguments[1]];
    return this.convertToGeo(coordinates[0], coordinates[1]);
  },
  convertToGeo: function (x, y) {
    return this._projection.fromScreenPoint([x, y]);
  },
  convertToXY: function (longitude, latitude) {
    return this._projection.toScreenPoint([longitude, latitude]);
  }
});
(0, _component_registrator.default)('dxVectorMap', dxVectorMap);
var _default = exports["default"] = dxVectorMap; // PLUGINS_SECTION
dxVectorMap.addPlugin(_export.plugin);
dxVectorMap.addPlugin(_title.plugin);
dxVectorMap.addPlugin(_tooltip.plugin);
dxVectorMap.addPlugin(_loading_indicator.plugin);
dxVectorMap.addPlugin(_annotations.plugins.core);
dxVectorMap.addPlugin(_annotations.plugins.vectorMap);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 56145:
/***/ (function(__unused_webpack_module, exports) {



exports.generateDataKey = generateDataKey;
let nextDataKey = 1;
function generateDataKey() {
  return 'vectormap-data-' + nextDataKey++;
}

/***/ }),

/***/ 71272:
/***/ (function(module) {

module.exports = window.Globalize;

/***/ }),

/***/ 96073:
/***/ (function(module) {

module.exports = window.jQuery;

/***/ }),

/***/ 76130:
/***/ (function(module) {

module.exports = window.ko;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {


__webpack_require__(66312);
}();
/******/ })()
;
